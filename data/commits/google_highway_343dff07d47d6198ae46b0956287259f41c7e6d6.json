{
  "metadata": {
    "collection_date": "2026-02-03T20:01:27.722739",
    "repository": "https://github.com/google/highway",
    "repository_name": "google/highway"
  },
  "commit_info": {
    "old_sha": "7a906ec139625de5ea3866603269cde82bdc761e",
    "new_sha": "343dff07d47d6198ae46b0956287259f41c7e6d6",
    "commit_message": [
      "use SVE2 bsl in IfVecThenElse and Min128\n\nPiperOrigin-RevId: 455559741"
    ],
    "commit_date": "2022-06-17T08:19:32+00:00",
    "patch": [
      "--- hwy/ops/arm_sve-inl.h\n@@ -873,12 +873,35 @@ HWY_API VFromD<D> VecFromMask(const D d, svbool_t mask) {\n \n // ------------------------------ IfVecThenElse (MaskFromVec, IfThenElse)\n \n+#if HWY_TARGET == HWY_SVE2\n+\n+#define HWY_SVE_IF_VEC(BASE, CHAR, BITS, HALF, NAME, OP)          \\\n+  HWY_API HWY_SVE_V(BASE, BITS)                                   \\\n+      NAME(HWY_SVE_V(BASE, BITS) mask, HWY_SVE_V(BASE, BITS) yes, \\\n+           HWY_SVE_V(BASE, BITS) no) {                            \\\n+    return sv##OP##_##CHAR##BITS(yes, no, mask);                  \\\n+  }\n+\n+HWY_SVE_FOREACH_UI(HWY_SVE_IF_VEC, IfVecThenElse, bsl)\n+#undef HWY_SVE_IF_VEC\n+\n+template <class V, HWY_IF_FLOAT_V(V)>\n+HWY_API V IfVecThenElse(const V mask, const V yes, const V no) {\n+  const DFromV<V> d;\n+  const RebindToUnsigned<decltype(d)> du;\n+  return BitCast(\n+      d, IfVecThenElse(BitCast(du, mask), BitCast(du, yes), BitCast(du, no)));\n+}\n+\n+#else\n+\n template <class V>\n HWY_API V IfVecThenElse(const V mask, const V yes, const V no) {\n-  // TODO(janwas): use svbsl for SVE2\n-  return IfThenElse(MaskFromVec(mask), yes, no);\n+  return Or(And(mask, yes), AndNot(mask, no));\n }\n \n+#endif  // HWY_TARGET == HWY_SVE2\n+\n // ------------------------------ Floating-point classification (Ne)\n \n template <class V>\n@@ -1538,9 +1561,9 @@ svbool_t MaskLowerHalf(D d) {\n template <class D>\n svbool_t MaskUpperHalf(D d) {\n   // TODO(janwas): WHILEGE on pow2 SVE2\n- if( HWY_SVE_IS_POW2 && IsFull(d)){\n-  return Not(MaskLowerHalf(d));\n- }\n+  if (HWY_SVE_IS_POW2 && IsFull(d)) {\n+    return Not(MaskLowerHalf(d));\n+  }\n \n   // For Splice to work as intended, make sure bits above Lanes(d) are zero.\n   return AndNot(MaskLowerHalf(d), detail::MakeMask(d));\n@@ -2600,29 +2623,39 @@ HWY_API svuint64_t CLMulUpper(const svuint64_t a, const svuint64_t b) {\n #endif  // __ARM_FEATURE_SVE2_AES\n \n // ------------------------------ Lt128\n+\n+namespace detail {\n+\n template <class D>\n-HWY_INLINE svbool_t Lt128(D d, const svuint64_t a, const svuint64_t b) {\n+HWY_INLINE svuint64_t Lt128Vec(D d, const svuint64_t a, const svuint64_t b) {\n   static_assert(!IsSigned<TFromD<D>>() && sizeof(TFromD<D>) == 8, \"Use u64\");\n   const svbool_t eqHx = Eq(a, b);  // only odd lanes used\n   // Convert to vector: more pipelines can TRN* for vectors than predicates.\n   const svuint64_t ltHL = VecFromMask(d, Lt(a, b));\n   // Move into upper lane: ltL if the upper half is equal, otherwise ltH.\n   // Requires an extra IfThenElse because INSR, EXT, TRN2 are unpredicated.\n   const svuint64_t ltHx = IfThenElse(eqHx, DupEven(ltHL), ltHL);\n-  // Duplicate upper lane into lower and convert back to predicate.\n-  return MaskFromVec(DupOdd(ltHx));\n+  // Duplicate upper lane into lower.\n+  return DupOdd(ltHx);\n+}\n+\n+}  // namespace detail\n+\n+template <class D>\n+HWY_INLINE svbool_t Lt128(D d, const svuint64_t a, const svuint64_t b) {\n+  return MaskFromVec(detail::Lt128Vec(d, a, b));\n }\n \n // ------------------------------ Min128, Max128 (Lt128)\n \n template <class D>\n HWY_INLINE svuint64_t Min128(D d, const svuint64_t a, const svuint64_t b) {\n-  return IfThenElse(Lt128(d, a, b), a, b);\n+  return IfVecThenElse(detail::Lt128Vec(d, a, b), a, b);\n }\n \n template <class D>\n HWY_INLINE svuint64_t Max128(D d, const svuint64_t a, const svuint64_t b) {\n-  return IfThenElse(Lt128(d, a, b), b, a);\n+  return IfVecThenElse(detail::Lt128Vec(d, a, b), b, a);\n }\n \n // ================================================== END MACROS"
    ],
    "files_changed": [
      {
        "filename": "hwy/ops/arm_sve-inl.h",
        "status": "modified",
        "additions": 43,
        "deletions": 10,
        "changes": 53,
        "patch": "@@ -873,12 +873,35 @@ HWY_API VFromD<D> VecFromMask(const D d, svbool_t mask) {\n \n // ------------------------------ IfVecThenElse (MaskFromVec, IfThenElse)\n \n+#if HWY_TARGET == HWY_SVE2\n+\n+#define HWY_SVE_IF_VEC(BASE, CHAR, BITS, HALF, NAME, OP)          \\\n+  HWY_API HWY_SVE_V(BASE, BITS)                                   \\\n+      NAME(HWY_SVE_V(BASE, BITS) mask, HWY_SVE_V(BASE, BITS) yes, \\\n+           HWY_SVE_V(BASE, BITS) no) {                            \\\n+    return sv##OP##_##CHAR##BITS(yes, no, mask);                  \\\n+  }\n+\n+HWY_SVE_FOREACH_UI(HWY_SVE_IF_VEC, IfVecThenElse, bsl)\n+#undef HWY_SVE_IF_VEC\n+\n+template <class V, HWY_IF_FLOAT_V(V)>\n+HWY_API V IfVecThenElse(const V mask, const V yes, const V no) {\n+  const DFromV<V> d;\n+  const RebindToUnsigned<decltype(d)> du;\n+  return BitCast(\n+      d, IfVecThenElse(BitCast(du, mask), BitCast(du, yes), BitCast(du, no)));\n+}\n+\n+#else\n+\n template <class V>\n HWY_API V IfVecThenElse(const V mask, const V yes, const V no) {\n-  // TODO(janwas): use svbsl for SVE2\n-  return IfThenElse(MaskFromVec(mask), yes, no);\n+  return Or(And(mask, yes), AndNot(mask, no));\n }\n \n+#endif  // HWY_TARGET == HWY_SVE2\n+\n // ------------------------------ Floating-point classification (Ne)\n \n template <class V>\n@@ -1538,9 +1561,9 @@ svbool_t MaskLowerHalf(D d) {\n template <class D>\n svbool_t MaskUpperHalf(D d) {\n   // TODO(janwas): WHILEGE on pow2 SVE2\n- if( HWY_SVE_IS_POW2 && IsFull(d)){\n-  return Not(MaskLowerHalf(d));\n- }\n+  if (HWY_SVE_IS_POW2 && IsFull(d)) {\n+    return Not(MaskLowerHalf(d));\n+  }\n \n   // For Splice to work as intended, make sure bits above Lanes(d) are zero.\n   return AndNot(MaskLowerHalf(d), detail::MakeMask(d));\n@@ -2600,29 +2623,39 @@ HWY_API svuint64_t CLMulUpper(const svuint64_t a, const svuint64_t b) {\n #endif  // __ARM_FEATURE_SVE2_AES\n \n // ------------------------------ Lt128\n+\n+namespace detail {\n+\n template <class D>\n-HWY_INLINE svbool_t Lt128(D d, const svuint64_t a, const svuint64_t b) {\n+HWY_INLINE svuint64_t Lt128Vec(D d, const svuint64_t a, const svuint64_t b) {\n   static_assert(!IsSigned<TFromD<D>>() && sizeof(TFromD<D>) == 8, \"Use u64\");\n   const svbool_t eqHx = Eq(a, b);  // only odd lanes used\n   // Convert to vector: more pipelines can TRN* for vectors than predicates.\n   const svuint64_t ltHL = VecFromMask(d, Lt(a, b));\n   // Move into upper lane: ltL if the upper half is equal, otherwise ltH.\n   // Requires an extra IfThenElse because INSR, EXT, TRN2 are unpredicated.\n   const svuint64_t ltHx = IfThenElse(eqHx, DupEven(ltHL), ltHL);\n-  // Duplicate upper lane into lower and convert back to predicate.\n-  return MaskFromVec(DupOdd(ltHx));\n+  // Duplicate upper lane into lower.\n+  return DupOdd(ltHx);\n+}\n+\n+}  // namespace detail\n+\n+template <class D>\n+HWY_INLINE svbool_t Lt128(D d, const svuint64_t a, const svuint64_t b) {\n+  return MaskFromVec(detail::Lt128Vec(d, a, b));\n }\n \n // ------------------------------ Min128, Max128 (Lt128)\n \n template <class D>\n HWY_INLINE svuint64_t Min128(D d, const svuint64_t a, const svuint64_t b) {\n-  return IfThenElse(Lt128(d, a, b), a, b);\n+  return IfVecThenElse(detail::Lt128Vec(d, a, b), a, b);\n }\n \n template <class D>\n HWY_INLINE svuint64_t Max128(D d, const svuint64_t a, const svuint64_t b) {\n-  return IfThenElse(Lt128(d, a, b), b, a);\n+  return IfVecThenElse(detail::Lt128Vec(d, a, b), b, a);\n }\n \n // ================================================== END MACROS"
      }
    ],
    "lines_added": 43,
    "lines_removed": 10
  },
  "issues": [],
  "pull_requests": [],
  "build_info": {
    "old_build_script": [
      "apt-get update",
      "cmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON",
      "cmake --build /test_workspace/workspace/old/build -- -j 1"
    ],
    "new_build_script": [
      "apt-get update",
      "cmake -S /test_workspace/workspace/new -B /test_workspace/workspace/new/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON",
      "cmake --build /test_workspace/workspace/new/build -- -j 1"
    ],
    "old_test_script": [
      "cd /test_workspace/workspace/old/build",
      "ctest --output-on-failure"
    ],
    "new_test_script": [
      "cd /test_workspace/workspace/new/build",
      "ctest --output-on-failure"
    ],
    "build_system": "cmake"
  },
  "performance_analysis": {
    "is_significant": false,
    "p_value": 0.9999999999997383,
    "is_pair_significant": false,
    "pair_p_value": 0.9999999999998861,
    "is_binom_significant": false,
    "binom_p_value": 0.9999999990686774,
    "is_wilcoxon_significant": false,
    "wilcoxon_p_value": 0.999999040737457,
    "is_mannwhitney_significant": false,
    "mannwhitney_p_value": 0.41510208493705775,
    "relative_improvement": 0.00031703257509710326,
    "absolute_improvement_ms": 3.9999999999960067,
    "old_mean_ms": 12617.0,
    "new_mean_ms": 12613.000000000004,
    "old_std_ms": 275.31987665760465,
    "new_std_ms": 263.6239484699685,
    "effect_size_cohens_d": 0.01484035340853127,
    "old_ci95_ms": [
      12514.193868484566,
      12719.806131515432
    ],
    "new_ci95_ms": [
      12514.561199844917,
      12711.43880015509
    ],
    "old_ci99_ms": [
      12478.44667284182,
      12755.553327158179
    ],
    "new_ci99_ms": [
      12480.332589195823,
      12745.667410804183
    ],
    "new_times_s": [
      12.68,
      12.72,
      12.99,
      12.37,
      12.77,
      12.88,
      12.73,
      12.83,
      12.47,
      12.99,
      13.07,
      13.15,
      12.6,
      12.95,
      13.03,
      12.5,
      12.35,
      12.39,
      12.41,
      12.36,
      12.7,
      12.52,
      12.27,
      12.45,
      12.37,
      12.35,
      12.49,
      12.35,
      12.41,
      12.44,
      12.48
    ],
    "old_times_s": [
      12.47,
      12.71,
      12.51,
      12.77,
      12.51,
      13.05,
      12.32,
      12.74,
      12.65,
      12.84,
      12.76,
      12.65,
      13.18,
      13.06,
      13.25,
      12.46,
      12.41,
      12.44,
      12.43,
      12.57,
      12.38,
      12.5,
      12.34,
      12.49,
      12.37,
      12.43,
      12.4,
      12.45,
      12.25,
      13.11,
      12.48
    ]
  },
  "tests": {
    "total_tests": 1,
    "significant_improvements": 0,
    "significant_improvements_tests": [],
    "significant_regressions": 0,
    "significant_regressions_tests": [],
    "significant_pair_improvements": 0,
    "significant_pair_improvements_tests": [],
    "significant_pair_regressions": 0,
    "significant_pair_regressions_tests": [],
    "significant_binom_improvements": 0,
    "significant_binom_improvements_tests": [],
    "significant_binom_regressions": 0,
    "significant_binom_regressions_tests": [],
    "significant_wilcoxon_improvements": 0,
    "significant_wilcoxon_improvements_tests": [],
    "significant_wilcoxon_regressions": 0,
    "significant_wilcoxon_regressions_tests": [],
    "significant_mannwhitney_improvements": 0,
    "significant_mannwhitney_improvements_tests": [],
    "significant_mannwhitney_regressions": 0,
    "significant_mannwhitney_regressions_tests": [],
    "tests": [
      {
        "test_name": "NanobenchmarkTest.RunAll",
        "is_significant": false,
        "p_value": 0.4794643885449762,
        "is_pair_significant": false,
        "pair_p_value": 0.480302781640229,
        "is_binom_significant": false,
        "binom_p_value": 0.4252770096063614,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.3161048916004684,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.10592062086019421,
        "relative_improvement": 0.05191256830601095,
        "absolute_improvement_ms": 20.357142857142907,
        "old_mean_ms": 392.14285714285717,
        "new_mean_ms": 371.7857142857143,
        "old_std_ms": 55.200452417438996,
        "new_std_ms": 55.97972989154341,
        "effect_size_cohens_d": 0.36619193096264535,
        "old_ci95_ms": [
          370.73835621339435,
          413.54735807232004
        ],
        "new_ci95_ms": [
          350.0790410969982,
          393.4923874744303
        ],
        "old_ci99_ms": [
          363.2393558767341,
          421.04635840898027
        ],
        "new_ci99_ms": [
          342.47417564900763,
          401.0972529224209
        ],
        "new_times": [
          0.35,
          0.36,
          0.3,
          0.36,
          0.42,
          0.38,
          0.23,
          0.34,
          0.43,
          0.35,
          0.41,
          0.39,
          0.43,
          0.37,
          0.37,
          0.41,
          0.36,
          0.53,
          0.4,
          0.44,
          0.36,
          0.3,
          0.31,
          0.4,
          0.34,
          0.32,
          0.39,
          0.36
        ],
        "old_times": [
          0.46,
          0.42,
          0.49,
          0.33,
          0.32,
          0.33,
          0.39,
          0.34,
          0.46,
          0.4,
          0.42,
          0.48,
          0.42,
          0.38,
          0.35,
          0.36,
          0.42,
          0.3,
          0.44,
          0.45,
          0.42,
          0.36,
          0.34,
          0.46,
          0.41,
          0.3,
          0.35,
          0.38
        ]
      }
    ]
  },
  "logs": {
    "full_log_path": "/logs/full.log",
    "config_log_path": "/logs/config.log",
    "build_log_path": "/logs/build.log",
    "test_log_path": "/logs/test.log",
    "build_success": true,
    "test_success": true
  },
  "raw_timing_data": {
    "warmup_runs": 1,
    "measurement_runs": 30,
    "min_exec_time_improvement": 0.05,
    "min_p_value": 0.05
  }
}