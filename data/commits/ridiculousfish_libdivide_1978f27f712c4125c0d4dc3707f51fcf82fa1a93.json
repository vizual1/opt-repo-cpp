{
  "metadata": {
    "collection_date": "2026-02-03T20:05:09.975766",
    "repository": "https://github.com/ridiculousfish/libdivide",
    "repository_name": "ridiculousfish/libdivide"
  },
  "commit_info": {
    "old_sha": "eee14df7eb7688050cb9f30eff8bf09b26b69222",
    "new_sha": "1978f27f712c4125c0d4dc3707f51fcf82fa1a93",
    "commit_message": [
      "Implement 16-bit SSE2 & AVX2 vector division (#94)\n\n* Full implementation of 16-bit vec256\r\n\r\n* Full implementation of 16-bit vec128"
    ],
    "commit_date": "2022-02-12T14:21:18+00:00",
    "patch": [
      "--- libdivide.h\n@@ -2372,11 +2372,24 @@ static LIBDIVIDE_INLINE __m256i libdivide_mullhi_s64_vec256(__m256i x, __m256i y\n ////////// UINT16\n \n __m256i libdivide_u16_do_vec256(__m256i numers, const struct libdivide_u16_t *denom) {\n-    SIMPLE_VECTOR_DIVISION(uint16_t, __m256i, u16)\n+    uint8_t more = denom->more;\n+    if (!denom->magic) {\n+        return _mm256_srli_epi16(numers, more);\n+    } else {\n+        __m256i q = _mm256_mulhi_epu16(numers, _mm256_set1_epi16(denom->magic));\n+        if (more & LIBDIVIDE_ADD_MARKER) {\n+            __m256i t = _mm256_adds_epu16(_mm256_srli_epi16(_mm256_subs_epu16(numers, q), 1), q);\n+            return _mm256_srli_epi16(t, (more & LIBDIVIDE_16_SHIFT_MASK));\n+        } else {\n+            return _mm256_srli_epi16(q, more);\n+        }\n+    }    \n }\n \n __m256i libdivide_u16_branchfree_do_vec256(__m256i numers, const struct libdivide_u16_branchfree_t *denom) {\n-    SIMPLE_VECTOR_DIVISION(uint16_t, __m256i, u16_branchfree)\n+    __m256i q = _mm256_mulhi_epu16(numers, _mm256_set1_epi16(denom->magic));\n+    __m256i t = _mm256_adds_epu16(_mm256_srli_epi16(_mm256_subs_epu16(numers, q), 1), q);\n+    return _mm256_srli_epi16(t, denom->more);    \n }\n \n ////////// UINT32\n@@ -2436,11 +2449,53 @@ __m256i libdivide_u64_branchfree_do_vec256(\n ////////// SINT16\n \n __m256i libdivide_s16_do_vec256(__m256i numers, const struct libdivide_s16_t *denom) {\n-    SIMPLE_VECTOR_DIVISION(int16_t, __m256i, s16)\n+    uint8_t more = denom->more;\n+    if (!denom->magic) {\n+        uint16_t shift = more & LIBDIVIDE_16_SHIFT_MASK;\n+        uint16_t mask = ((uint16_t)1 << shift) - 1;\n+        __m256i roundToZeroTweak = _mm256_set1_epi16(mask);\n+        // q = numer + ((numer >> 15) & roundToZeroTweak);\n+        __m256i q = _mm256_add_epi16(\n+            numers, _mm256_and_si256(_mm256_srai_epi16(numers, 15), roundToZeroTweak));\n+        q = _mm256_srai_epi16(q, shift);\n+        __m256i sign = _mm256_set1_epi16((int8_t)more >> 7);\n+        // q = (q ^ sign) - sign;\n+        q = _mm256_sub_epi16(_mm256_xor_si256(q, sign), sign);\n+        return q;\n+    } else {\n+        __m256i q = _mm256_mulhi_epi16(numers, _mm256_set1_epi16(denom->magic));\n+        if (more & LIBDIVIDE_ADD_MARKER) {\n+            // must be arithmetic shift\n+            __m256i sign = _mm256_set1_epi16((int8_t)more >> 7);\n+            // q += ((numer ^ sign) - sign);\n+            q = _mm256_add_epi16(q, _mm256_sub_epi16(_mm256_xor_si256(numers, sign), sign));\n+        }\n+        // q >>= shift\n+        q = _mm256_srai_epi16(q, more & LIBDIVIDE_16_SHIFT_MASK);\n+        q = _mm256_add_epi16(q, _mm256_srli_epi16(q, 15));  // q += (q < 0)\n+        return q;\n+    }\n }\n \n __m256i libdivide_s16_branchfree_do_vec256(__m256i numers, const struct libdivide_s16_branchfree_t *denom) {\n-    SIMPLE_VECTOR_DIVISION(int16_t, __m256i, s16_branchfree)\n+    int16_t magic = denom->magic;\n+    uint8_t more = denom->more;\n+    uint8_t shift = more & LIBDIVIDE_16_SHIFT_MASK;\n+    // must be arithmetic shift\n+    __m256i sign = _mm256_set1_epi16((int8_t)more >> 7);\n+    __m256i q = _mm256_mulhi_epi16(numers, _mm256_set1_epi16(magic));\n+    q = _mm256_add_epi16(q, numers);  // q += numers\n+\n+    // If q is non-negative, we have nothing to do\n+    // If q is negative, we want to add either (2**shift)-1 if d is\n+    // a power of 2, or (2**shift) if it is not a power of 2\n+    uint16_t is_power_of_2 = (magic == 0);\n+    __m256i q_sign = _mm256_srai_epi16(q, 15);  // q_sign = q >> 15\n+    __m256i mask = _mm256_set1_epi16(((uint16_t)1 << shift) - is_power_of_2);\n+    q = _mm256_add_epi16(q, _mm256_and_si256(q_sign, mask));  // q = q + (q_sign & mask)\n+    q = _mm256_srai_epi16(q, shift);                          // q >>= shift\n+    q = _mm256_sub_epi16(_mm256_xor_si256(q, sign), sign);    // q = (q ^ sign) - sign\n+    return q;\n }\n \n ////////// SINT32\n@@ -2668,11 +2723,24 @@ static LIBDIVIDE_INLINE __m128i libdivide_mullhi_s64_vec128(__m128i x, __m128i y\n ////////// UINT26\n \n __m128i libdivide_u16_do_vec128(__m128i numers, const struct libdivide_u16_t *denom) {\n-    SIMPLE_VECTOR_DIVISION(uint16_t, __m128i, u16)\n+    uint8_t more = denom->more;\n+    if (!denom->magic) {\n+        return _mm_srli_epi16(numers, more);\n+    } else {\n+        __m128i q = _mm_mulhi_epu16(numers, _mm_set1_epi16(denom->magic));\n+        if (more & LIBDIVIDE_ADD_MARKER) {\n+            __m128i t = _mm_adds_epu16(_mm_srli_epi16(_mm_subs_epu16(numers, q), 1), q);\n+            return _mm_srli_epi16(t, (more & LIBDIVIDE_16_SHIFT_MASK));\n+        } else {\n+            return _mm_srli_epi16(q, more);\n+        }\n+    } \n }\n \n __m128i libdivide_u16_branchfree_do_vec128(__m128i numers, const struct libdivide_u16_branchfree_t *denom) {\n-    SIMPLE_VECTOR_DIVISION(uint16_t, __m128i, u16_branchfree)\n+    __m128i q = _mm_mulhi_epu16(numers, _mm_set1_epi16(denom->magic));\n+    __m128i t = _mm_adds_epu16(_mm_srli_epi16(_mm_subs_epu16(numers, q), 1), q);\n+    return _mm_srli_epi16(t, denom->more);\n }\n \n ////////// UINT32\n@@ -2732,11 +2800,53 @@ __m128i libdivide_u64_branchfree_do_vec128(\n ////////// SINT16\n \n __m128i libdivide_s16_do_vec128(__m128i numers, const struct libdivide_s16_t *denom) {\n-    SIMPLE_VECTOR_DIVISION(int16_t, __m128i, s16)\n+    uint8_t more = denom->more;\n+    if (!denom->magic) {\n+        uint16_t shift = more & LIBDIVIDE_16_SHIFT_MASK;\n+        uint16_t mask = ((uint16_t)1 << shift) - 1;\n+        __m128i roundToZeroTweak = _mm_set1_epi16(mask);\n+        // q = numer + ((numer >> 15) & roundToZeroTweak);\n+        __m128i q = _mm_add_epi16(\n+            numers, _mm_and_si128(_mm_srai_epi16(numers, 15), roundToZeroTweak));\n+        q = _mm_srai_epi16(q, shift);\n+        __m128i sign = _mm_set1_epi16((int8_t)more >> 7);\n+        // q = (q ^ sign) - sign;\n+        q = _mm_sub_epi16(_mm_xor_si128(q, sign), sign);\n+        return q;\n+    } else {\n+        __m128i q = _mm_mulhi_epi16(numers, _mm_set1_epi16(denom->magic));\n+        if (more & LIBDIVIDE_ADD_MARKER) {\n+            // must be arithmetic shift\n+            __m128i sign = _mm_set1_epi16((int8_t)more >> 7);\n+            // q += ((numer ^ sign) - sign);\n+            q = _mm_add_epi16(q, _mm_sub_epi16(_mm_xor_si128(numers, sign), sign));\n+        }\n+        // q >>= shift\n+        q = _mm_srai_epi16(q, more & LIBDIVIDE_16_SHIFT_MASK);\n+        q = _mm_add_epi16(q, _mm_srli_epi16(q, 15));  // q += (q < 0)\n+        return q;\n+    }\n }\n \n __m128i libdivide_s16_branchfree_do_vec128(__m128i numers, const struct libdivide_s16_branchfree_t *denom) {\n-    SIMPLE_VECTOR_DIVISION(int16_t, __m128i, s16_branchfree)\n+    int16_t magic = denom->magic;\n+    uint8_t more = denom->more;\n+    uint8_t shift = more & LIBDIVIDE_16_SHIFT_MASK;\n+    // must be arithmetic shift\n+    __m128i sign = _mm_set1_epi16((int8_t)more >> 7);\n+    __m128i q = _mm_mulhi_epi16(numers, _mm_set1_epi16(magic));\n+    q = _mm_add_epi16(q, numers);  // q += numers\n+\n+    // If q is non-negative, we have nothing to do\n+    // If q is negative, we want to add either (2**shift)-1 if d is\n+    // a power of 2, or (2**shift) if it is not a power of 2\n+    uint16_t is_power_of_2 = (magic == 0);\n+    __m128i q_sign = _mm_srai_epi16(q, 15);  // q_sign = q >> 15\n+    __m128i mask = _mm_set1_epi16(((uint16_t)1 << shift) - is_power_of_2);\n+    q = _mm_add_epi16(q, _mm_and_si128(q_sign, mask));  // q = q + (q_sign & mask)\n+    q = _mm_srai_epi16(q, shift);                          // q >>= shift\n+    q = _mm_sub_epi16(_mm_xor_si128(q, sign), sign);    // q = (q ^ sign) - sign\n+    return q;\n }\n \n ////////// SINT32"
    ],
    "files_changed": [
      {
        "filename": "libdivide.h",
        "status": "modified",
        "additions": 118,
        "deletions": 8,
        "changes": 126,
        "patch": "@@ -2372,11 +2372,24 @@ static LIBDIVIDE_INLINE __m256i libdivide_mullhi_s64_vec256(__m256i x, __m256i y\n ////////// UINT16\n \n __m256i libdivide_u16_do_vec256(__m256i numers, const struct libdivide_u16_t *denom) {\n-    SIMPLE_VECTOR_DIVISION(uint16_t, __m256i, u16)\n+    uint8_t more = denom->more;\n+    if (!denom->magic) {\n+        return _mm256_srli_epi16(numers, more);\n+    } else {\n+        __m256i q = _mm256_mulhi_epu16(numers, _mm256_set1_epi16(denom->magic));\n+        if (more & LIBDIVIDE_ADD_MARKER) {\n+            __m256i t = _mm256_adds_epu16(_mm256_srli_epi16(_mm256_subs_epu16(numers, q), 1), q);\n+            return _mm256_srli_epi16(t, (more & LIBDIVIDE_16_SHIFT_MASK));\n+        } else {\n+            return _mm256_srli_epi16(q, more);\n+        }\n+    }    \n }\n \n __m256i libdivide_u16_branchfree_do_vec256(__m256i numers, const struct libdivide_u16_branchfree_t *denom) {\n-    SIMPLE_VECTOR_DIVISION(uint16_t, __m256i, u16_branchfree)\n+    __m256i q = _mm256_mulhi_epu16(numers, _mm256_set1_epi16(denom->magic));\n+    __m256i t = _mm256_adds_epu16(_mm256_srli_epi16(_mm256_subs_epu16(numers, q), 1), q);\n+    return _mm256_srli_epi16(t, denom->more);    \n }\n \n ////////// UINT32\n@@ -2436,11 +2449,53 @@ __m256i libdivide_u64_branchfree_do_vec256(\n ////////// SINT16\n \n __m256i libdivide_s16_do_vec256(__m256i numers, const struct libdivide_s16_t *denom) {\n-    SIMPLE_VECTOR_DIVISION(int16_t, __m256i, s16)\n+    uint8_t more = denom->more;\n+    if (!denom->magic) {\n+        uint16_t shift = more & LIBDIVIDE_16_SHIFT_MASK;\n+        uint16_t mask = ((uint16_t)1 << shift) - 1;\n+        __m256i roundToZeroTweak = _mm256_set1_epi16(mask);\n+        // q = numer + ((numer >> 15) & roundToZeroTweak);\n+        __m256i q = _mm256_add_epi16(\n+            numers, _mm256_and_si256(_mm256_srai_epi16(numers, 15), roundToZeroTweak));\n+        q = _mm256_srai_epi16(q, shift);\n+        __m256i sign = _mm256_set1_epi16((int8_t)more >> 7);\n+        // q = (q ^ sign) - sign;\n+        q = _mm256_sub_epi16(_mm256_xor_si256(q, sign), sign);\n+        return q;\n+    } else {\n+        __m256i q = _mm256_mulhi_epi16(numers, _mm256_set1_epi16(denom->magic));\n+        if (more & LIBDIVIDE_ADD_MARKER) {\n+            // must be arithmetic shift\n+            __m256i sign = _mm256_set1_epi16((int8_t)more >> 7);\n+            // q += ((numer ^ sign) - sign);\n+            q = _mm256_add_epi16(q, _mm256_sub_epi16(_mm256_xor_si256(numers, sign), sign));\n+        }\n+        // q >>= shift\n+        q = _mm256_srai_epi16(q, more & LIBDIVIDE_16_SHIFT_MASK);\n+        q = _mm256_add_epi16(q, _mm256_srli_epi16(q, 15));  // q += (q < 0)\n+        return q;\n+    }\n }\n \n __m256i libdivide_s16_branchfree_do_vec256(__m256i numers, const struct libdivide_s16_branchfree_t *denom) {\n-    SIMPLE_VECTOR_DIVISION(int16_t, __m256i, s16_branchfree)\n+    int16_t magic = denom->magic;\n+    uint8_t more = denom->more;\n+    uint8_t shift = more & LIBDIVIDE_16_SHIFT_MASK;\n+    // must be arithmetic shift\n+    __m256i sign = _mm256_set1_epi16((int8_t)more >> 7);\n+    __m256i q = _mm256_mulhi_epi16(numers, _mm256_set1_epi16(magic));\n+    q = _mm256_add_epi16(q, numers);  // q += numers\n+\n+    // If q is non-negative, we have nothing to do\n+    // If q is negative, we want to add either (2**shift)-1 if d is\n+    // a power of 2, or (2**shift) if it is not a power of 2\n+    uint16_t is_power_of_2 = (magic == 0);\n+    __m256i q_sign = _mm256_srai_epi16(q, 15);  // q_sign = q >> 15\n+    __m256i mask = _mm256_set1_epi16(((uint16_t)1 << shift) - is_power_of_2);\n+    q = _mm256_add_epi16(q, _mm256_and_si256(q_sign, mask));  // q = q + (q_sign & mask)\n+    q = _mm256_srai_epi16(q, shift);                          // q >>= shift\n+    q = _mm256_sub_epi16(_mm256_xor_si256(q, sign), sign);    // q = (q ^ sign) - sign\n+    return q;\n }\n \n ////////// SINT32\n@@ -2668,11 +2723,24 @@ static LIBDIVIDE_INLINE __m128i libdivide_mullhi_s64_vec128(__m128i x, __m128i y\n ////////// UINT26\n \n __m128i libdivide_u16_do_vec128(__m128i numers, const struct libdivide_u16_t *denom) {\n-    SIMPLE_VECTOR_DIVISION(uint16_t, __m128i, u16)\n+    uint8_t more = denom->more;\n+    if (!denom->magic) {\n+        return _mm_srli_epi16(numers, more);\n+    } else {\n+        __m128i q = _mm_mulhi_epu16(numers, _mm_set1_epi16(denom->magic));\n+        if (more & LIBDIVIDE_ADD_MARKER) {\n+            __m128i t = _mm_adds_epu16(_mm_srli_epi16(_mm_subs_epu16(numers, q), 1), q);\n+            return _mm_srli_epi16(t, (more & LIBDIVIDE_16_SHIFT_MASK));\n+        } else {\n+            return _mm_srli_epi16(q, more);\n+        }\n+    } \n }\n \n __m128i libdivide_u16_branchfree_do_vec128(__m128i numers, const struct libdivide_u16_branchfree_t *denom) {\n-    SIMPLE_VECTOR_DIVISION(uint16_t, __m128i, u16_branchfree)\n+    __m128i q = _mm_mulhi_epu16(numers, _mm_set1_epi16(denom->magic));\n+    __m128i t = _mm_adds_epu16(_mm_srli_epi16(_mm_subs_epu16(numers, q), 1), q);\n+    return _mm_srli_epi16(t, denom->more);\n }\n \n ////////// UINT32\n@@ -2732,11 +2800,53 @@ __m128i libdivide_u64_branchfree_do_vec128(\n ////////// SINT16\n \n __m128i libdivide_s16_do_vec128(__m128i numers, const struct libdivide_s16_t *denom) {\n-    SIMPLE_VECTOR_DIVISION(int16_t, __m128i, s16)\n+    uint8_t more = denom->more;\n+    if (!denom->magic) {\n+        uint16_t shift = more & LIBDIVIDE_16_SHIFT_MASK;\n+        uint16_t mask = ((uint16_t)1 << shift) - 1;\n+        __m128i roundToZeroTweak = _mm_set1_epi16(mask);\n+        // q = numer + ((numer >> 15) & roundToZeroTweak);\n+        __m128i q = _mm_add_epi16(\n+            numers, _mm_and_si128(_mm_srai_epi16(numers, 15), roundToZeroTweak));\n+        q = _mm_srai_epi16(q, shift);\n+        __m128i sign = _mm_set1_epi16((int8_t)more >> 7);\n+        // q = (q ^ sign) - sign;\n+        q = _mm_sub_epi16(_mm_xor_si128(q, sign), sign);\n+        return q;\n+    } else {\n+        __m128i q = _mm_mulhi_epi16(numers, _mm_set1_epi16(denom->magic));\n+        if (more & LIBDIVIDE_ADD_MARKER) {\n+            // must be arithmetic shift\n+            __m128i sign = _mm_set1_epi16((int8_t)more >> 7);\n+            // q += ((numer ^ sign) - sign);\n+            q = _mm_add_epi16(q, _mm_sub_epi16(_mm_xor_si128(numers, sign), sign));\n+        }\n+        // q >>= shift\n+        q = _mm_srai_epi16(q, more & LIBDIVIDE_16_SHIFT_MASK);\n+        q = _mm_add_epi16(q, _mm_srli_epi16(q, 15));  // q += (q < 0)\n+        return q;\n+    }\n }\n \n __m128i libdivide_s16_branchfree_do_vec128(__m128i numers, const struct libdivide_s16_branchfree_t *denom) {\n-    SIMPLE_VECTOR_DIVISION(int16_t, __m128i, s16_branchfree)\n+    int16_t magic = denom->magic;\n+    uint8_t more = denom->more;\n+    uint8_t shift = more & LIBDIVIDE_16_SHIFT_MASK;\n+    // must be arithmetic shift\n+    __m128i sign = _mm_set1_epi16((int8_t)more >> 7);\n+    __m128i q = _mm_mulhi_epi16(numers, _mm_set1_epi16(magic));\n+    q = _mm_add_epi16(q, numers);  // q += numers\n+\n+    // If q is non-negative, we have nothing to do\n+    // If q is negative, we want to add either (2**shift)-1 if d is\n+    // a power of 2, or (2**shift) if it is not a power of 2\n+    uint16_t is_power_of_2 = (magic == 0);\n+    __m128i q_sign = _mm_srai_epi16(q, 15);  // q_sign = q >> 15\n+    __m128i mask = _mm_set1_epi16(((uint16_t)1 << shift) - is_power_of_2);\n+    q = _mm_add_epi16(q, _mm_and_si128(q_sign, mask));  // q = q + (q_sign & mask)\n+    q = _mm_srai_epi16(q, shift);                          // q >>= shift\n+    q = _mm_sub_epi16(_mm_xor_si128(q, sign), sign);    // q = (q ^ sign) - sign\n+    return q;\n }\n \n ////////// SINT32"
      }
    ],
    "lines_added": 118,
    "lines_removed": 8
  },
  "issues": [],
  "pull_requests": [],
  "build_info": {
    "old_build_script": [
      "apt-get update",
      "cmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTS=ON",
      "cmake --build /test_workspace/workspace/old/build -- -j 1"
    ],
    "new_build_script": [
      "apt-get update",
      "cmake -S /test_workspace/workspace/new -B /test_workspace/workspace/new/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTS=ON",
      "cmake --build /test_workspace/workspace/new/build -- -j 1"
    ],
    "old_test_script": [
      "cd /test_workspace/workspace/old/build",
      "ctest --output-on-failure"
    ],
    "new_test_script": [
      "cd /test_workspace/workspace/new/build",
      "ctest --output-on-failure"
    ],
    "build_system": "cmake"
  },
  "performance_analysis": {
    "is_significant": false,
    "p_value": 0.999999928804791,
    "is_pair_significant": false,
    "pair_p_value": 0.9999989762736091,
    "is_binom_significant": false,
    "binom_p_value": 0.9999995660036802,
    "is_wilcoxon_significant": false,
    "wilcoxon_p_value": 0.9999997140839696,
    "is_mannwhitney_significant": false,
    "mannwhitney_p_value": 1.5089833992452233e-11,
    "relative_improvement": 0.037858218782269366,
    "absolute_improvement_ms": 13320.666666666568,
    "old_mean_ms": 351856.66666666657,
    "new_mean_ms": 338536.0,
    "old_std_ms": 2812.3193684013013,
    "new_std_ms": 2848.37715441497,
    "effect_size_cohens_d": 4.706274706045227,
    "old_ci95_ms": [
      350806.52935598185,
      352906.8039773513
    ],
    "new_ci95_ms": [
      337472.39849073987,
      339599.60150926013
    ],
    "old_ci99_ms": [
      350441.38125300943,
      353271.9520803237
    ],
    "new_ci99_ms": [
      337102.56868898595,
      339969.43131101405
    ],
    "new_times_s": [
      338.1,
      340.19,
      337.35,
      332.79,
      339.3,
      337.79,
      345.6,
      338.95,
      336.31,
      340.4,
      336.5,
      340.0,
      337.27,
      338.83,
      333.17,
      335.53,
      333.82,
      344.66,
      337.58,
      337.55,
      338.35,
      341.11,
      337.61,
      340.31,
      338.88,
      339.26,
      342.8,
      338.93,
      337.86,
      338.02,
      339.36
    ],
    "old_times_s": [
      351.21,
      350.42,
      356.43,
      349.02,
      353.93,
      353.69,
      351.55,
      356.43,
      352.74,
      347.8,
      350.68,
      357.8,
      353.13,
      349.52,
      349.09,
      349.15,
      352.88,
      353.49,
      348.4,
      350.5,
      355.44,
      347.03,
      353.7,
      351.19,
      351.95,
      349.9,
      348.06,
      351.47,
      351.98,
      356.05,
      352.28
    ]
  },
  "tests": {
    "total_tests": 4,
    "significant_improvements": 1,
    "significant_improvements_tests": [
      "tester"
    ],
    "significant_regressions": 0,
    "significant_regressions_tests": [],
    "significant_pair_improvements": 1,
    "significant_pair_improvements_tests": [
      "tester"
    ],
    "significant_pair_regressions": 0,
    "significant_pair_regressions_tests": [],
    "significant_binom_improvements": 1,
    "significant_binom_improvements_tests": [
      "tester"
    ],
    "significant_binom_regressions": 0,
    "significant_binom_regressions_tests": [],
    "significant_wilcoxon_improvements": 1,
    "significant_wilcoxon_improvements_tests": [
      "tester"
    ],
    "significant_wilcoxon_regressions": 0,
    "significant_wilcoxon_regressions_tests": [],
    "significant_mannwhitney_improvements": 1,
    "significant_mannwhitney_improvements_tests": [
      "tester"
    ],
    "significant_mannwhitney_regressions": 1,
    "significant_mannwhitney_regressions_tests": [
      "benchmark_branchfree"
    ],
    "tests": [
      {
        "test_name": "build_tester",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999638108507,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 1.0,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 70.0,
        "new_mean_ms": 70.0,
        "old_std_ms": 0.0,
        "new_std_ms": 0.0,
        "effect_size_cohens_d": "NaN",
        "old_ci95_ms": [
          70.0,
          70.0
        ],
        "new_ci95_ms": [
          70.0,
          70.0
        ],
        "old_ci99_ms": [
          70.0,
          70.0
        ],
        "new_ci99_ms": [
          70.0,
          70.0
        ],
        "new_times": [
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07
        ],
        "old_times": [
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07
        ]
      },
      {
        "test_name": "build_benchmark_branchfree",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999638108507,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 1.0,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 70.0,
        "new_mean_ms": 70.0,
        "old_std_ms": 0.0,
        "new_std_ms": 0.0,
        "effect_size_cohens_d": "NaN",
        "old_ci95_ms": [
          70.0,
          70.0
        ],
        "new_ci95_ms": [
          70.0,
          70.0
        ],
        "old_ci99_ms": [
          70.0,
          70.0
        ],
        "new_ci99_ms": [
          70.0,
          70.0
        ],
        "new_times": [
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07
        ],
        "old_times": [
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07
        ]
      },
      {
        "test_name": "tester",
        "is_significant": true,
        "p_value": 9.529746159179342e-54,
        "is_pair_significant": true,
        "pair_p_value": 4.128546828830158e-34,
        "is_binom_significant": true,
        "binom_p_value": 1.862645149230957e-09,
        "is_wilcoxon_significant": true,
        "wilcoxon_p_value": 1.2789548180602085e-06,
        "is_mannwhitney_significant": true,
        "mannwhitney_p_value": 3.243836357140264e-11,
        "relative_improvement": 0.16262543081099215,
        "absolute_improvement_ms": 14708.965517241368,
        "old_mean_ms": 90446.89655172412,
        "new_mean_ms": 75737.93103448275,
        "old_std_ms": 403.29095707579717,
        "new_std_ms": 571.841507202481,
        "effect_size_cohens_d": 29.727328801360745,
        "old_ci95_ms": [
          90293.49287583272,
          90600.30022761553
        ],
        "new_ci95_ms": [
          75520.41415816049,
          75955.44791080501
        ],
        "old_ci99_ms": [
          90239.95789706343,
          90653.83520638481
        ],
        "new_ci99_ms": [
          75444.50488618114,
          76031.35718278437
        ],
        "new_times": [
          74.86,
          75.35,
          74.96,
          76.47,
          75.23,
          76.43,
          76.01,
          76.44,
          75.82,
          74.43,
          75.43,
          76.15,
          76.09,
          75.09,
          75.42,
          76.19,
          75.73,
          76.08,
          75.45,
          76.07,
          76.71,
          75.71,
          75.82,
          75.23,
          75.84,
          75.2,
          76.76,
          75.93,
          75.5
        ],
        "old_times": [
          90.42,
          90.26,
          90.54,
          90.34,
          90.79,
          90.54,
          90.5,
          90.53,
          89.65,
          90.28,
          90.61,
          90.62,
          90.56,
          90.86,
          90.93,
          91.07,
          90.42,
          90.65,
          90.61,
          89.36,
          90.08,
          90.69,
          90.01,
          89.81,
          90.49,
          90.18,
          90.21,
          90.74,
          91.21
        ]
      },
      {
        "test_name": "benchmark_branchfree",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999987193211256,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.9527222177967898,
        "relative_improvement": -0.004912750190017798,
        "absolute_improvement_ms": -1283.7931034483177,
        "old_mean_ms": 261318.62068965513,
        "new_mean_ms": 262602.4137931034,
        "old_std_ms": 2780.0882875728125,
        "new_std_ms": 2927.825442655367,
        "effect_size_cohens_d": -0.4496785897628663,
        "old_ci95_ms": [
          260261.131660621,
          262376.10971868923
        ],
        "new_ci95_ms": [
          261488.72855570464,
          263716.0990305022
        ],
        "old_ci99_ms": [
          259892.08800903236,
          262745.1533702779
        ],
        "new_ci99_ms": [
          261100.07349125887,
          264104.754094948
        ],
        "new_times": [
          262.35,
          257.3,
          264.21,
          261.19,
          270.23,
          262.38,
          260.16,
          263.82,
          260.54,
          265.43,
          261.71,
          262.54,
          256.93,
          260.31,
          258.26,
          268.33,
          261.71,
          261.34,
          262.76,
          264.91,
          260.76,
          264.45,
          262.92,
          263.89,
          266.82,
          263.59,
          260.96,
          261.95,
          263.72
        ],
        "old_times": [
          265.86,
          258.62,
          263.25,
          263.21,
          260.62,
          265.75,
          262.1,
          257.14,
          260.89,
          267.39,
          262.38,
          258.76,
          258.39,
          258.15,
          261.8,
          262.28,
          257.83,
          259.7,
          264.69,
          257.53,
          263.48,
          260.36,
          261.8,
          259.95,
          257.42,
          261.15,
          261.63,
          265.17,
          260.94
        ]
      }
    ]
  },
  "logs": {
    "full_log_path": "/logs/full.log",
    "config_log_path": "/logs/config.log",
    "build_log_path": "/logs/build.log",
    "test_log_path": "/logs/test.log",
    "build_success": true,
    "test_success": true
  },
  "raw_timing_data": {
    "warmup_runs": 1,
    "measurement_runs": 30,
    "min_exec_time_improvement": 0.05,
    "min_p_value": 0.05
  }
}