{
  "metadata": {
    "collection_date": "2026-02-03T20:00:26.290736",
    "repository": "https://github.com/ERGO-Code/HiGHS",
    "repository_name": "ERGO-Code/HiGHS"
  },
  "commit_info": {
    "old_sha": "6944afef5951c3b3bc1721a74685f8c6199510f5",
    "new_sha": "3559715f224dd2ddba257d1d1194f512367feca5",
    "commit_message": [
      "Use storeRow and getStoredRow"
    ],
    "commit_date": "2025-09-12T11:53:20+00:00",
    "patch": [
      "--- highs/presolve/HPresolve.cpp\n@@ -4605,10 +4605,23 @@ HPresolve::Result HPresolve::dualFixing(HighsPostsolveStack& postsolve_stack,\n     }\n   };\n \n+  // lambda for checking whether a row provides an implied bound\n+  auto hasImpliedBound = [&](HighsInt row, double val) {\n+    return ((val < 0 && model->row_upper_[row] != kHighsInf) ||\n+            (val > 0 && model->row_lower_[row] != -kHighsInf));\n+  };\n+\n   // lambda for variable substitution\n   auto substituteCol = [&](HighsInt col, HighsInt row, HighsInt direction,\n                            double colBound, double otherColBound) {\n-    for (const auto& rowNz : getRowVector(row)) {\n+    // some bookkeeping\n+    HighsInt colNonZerosChecked = 0;\n+    HighsInt binVarsTried = 0;\n+    // use storeRow and getStoredRow since getRowVector's rowroot[row] would be\n+    // overwritten by subsequent findNonZero calls, which would produce\n+    // undefined behavior\n+    storeRow(row);\n+    for (const auto& rowNz : getStoredRow()) {\n       // skip column index that was passed to this lambda\n       if (rowNz.index() == col) continue;\n \n@@ -4618,25 +4631,27 @@ HPresolve::Result HPresolve::dualFixing(HighsPostsolveStack& postsolve_stack,\n           model->col_upper_[rowNz.index()] != 1.0)\n         continue;\n \n-      // check if setting the binary variable to its lower bound bound makes the\n-      // row redundant\n-      double rhs = 0.0;\n-      double residual = 0.0;\n-      if (model->row_upper_[row] != kHighsInf) {\n-        rhs = model->row_upper_[row];\n-        residual = impliedRowBounds.getResidualSumUpperOrig(row, rowNz.index(),\n-                                                            rowNz.value());\n-      } else {\n-        rhs = -model->row_lower_[row];\n-        residual = -impliedRowBounds.getResidualSumLowerOrig(row, rowNz.index(),\n-                                                             rowNz.value());\n-      }\n-      // skip binary variable if the row has not become redundant\n-      if (residual > rhs + primal_feastol) continue;\n+      // skip binary variable if setting it to its lower bound bound does not\n+      // make the row redundant\n+      if (model->row_upper_[row] != kHighsInf &&\n+          impliedRowBounds.getResidualSumUpperOrig(row, rowNz.index(),\n+                                                   rowNz.value()) >\n+              model->row_upper_[row] + primal_feastol)\n+        continue;\n+      if (model->row_lower_[row] != -kHighsInf &&\n+          impliedRowBounds.getResidualSumLowerOrig(row, rowNz.index(),\n+                                                   rowNz.value()) <\n+              model->row_lower_[row] - primal_feastol)\n+        continue;\n \n       // store triplets (row, nonzero, nonzero) in a vector to speed up search\n+      binVarsTried++;\n+      nzs.clear();\n       if (colsize[col] < colsize[rowNz.index()]) {\n         for (const auto& colNz : getColumnVector(col)) {\n+          // skip non-zeros that do not yield an implied bound\n+          if (!hasImpliedBound(colNz.index(), direction * colNz.value()))\n+            continue;\n           HighsInt nzPos = findNonzero(colNz.index(), rowNz.index());\n           if (nzPos == -1) continue;\n           nzs.push_back({colNz.index(), colNz.value(), Avalue[nzPos]});\n@@ -4645,22 +4660,19 @@ HPresolve::Result HPresolve::dualFixing(HighsPostsolveStack& postsolve_stack,\n         for (const auto& colNz : getColumnVector(rowNz.index())) {\n           HighsInt nzPos = findNonzero(colNz.index(), col);\n           if (nzPos == -1) continue;\n+          // skip non-zeros that do not yield an implied bound\n+          if (!hasImpliedBound(colNz.index(), direction * Avalue[nzPos]))\n+            continue;\n           nzs.push_back({colNz.index(), Avalue[nzPos], colNz.value()});\n         }\n       }\n \n-      // identify best implied bound\n+      // store best bound\n       double bestBound = -kHighsInf;\n       for (const auto& triplet : nzs) {\n-        // skip rows directly that do not yield an implied bound\n-        if ((direction * triplet.jval > 0 ||\n-             model->row_upper_[triplet.row] == kHighsInf) &&\n-            (direction * triplet.jval < 0 ||\n-             model->row_lower_[triplet.row] == -kHighsInf))\n-          continue;\n-\n         // compute implied bound from row given that the binary variable is at\n         // its upper bound\n+        colNonZerosChecked++;\n         double rhs = 0.0;\n         double residual = 0.0;\n         if (direction * triplet.jval < 0) {\n@@ -4692,7 +4704,6 @@ HPresolve::Result HPresolve::dualFixing(HighsPostsolveStack& postsolve_stack,\n         HPRESOLVE_CHECKED_CALL(checkLimits(postsolve_stack));\n         break;\n       }\n-      nzs.clear();\n     }\n     return Result::kOk;\n   };"
    ],
    "files_changed": [
      {
        "filename": "highs/presolve/HPresolve.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 25,
        "changes": 61,
        "patch": "@@ -4605,10 +4605,23 @@ HPresolve::Result HPresolve::dualFixing(HighsPostsolveStack& postsolve_stack,\n     }\n   };\n \n+  // lambda for checking whether a row provides an implied bound\n+  auto hasImpliedBound = [&](HighsInt row, double val) {\n+    return ((val < 0 && model->row_upper_[row] != kHighsInf) ||\n+            (val > 0 && model->row_lower_[row] != -kHighsInf));\n+  };\n+\n   // lambda for variable substitution\n   auto substituteCol = [&](HighsInt col, HighsInt row, HighsInt direction,\n                            double colBound, double otherColBound) {\n-    for (const auto& rowNz : getRowVector(row)) {\n+    // some bookkeeping\n+    HighsInt colNonZerosChecked = 0;\n+    HighsInt binVarsTried = 0;\n+    // use storeRow and getStoredRow since getRowVector's rowroot[row] would be\n+    // overwritten by subsequent findNonZero calls, which would produce\n+    // undefined behavior\n+    storeRow(row);\n+    for (const auto& rowNz : getStoredRow()) {\n       // skip column index that was passed to this lambda\n       if (rowNz.index() == col) continue;\n \n@@ -4618,25 +4631,27 @@ HPresolve::Result HPresolve::dualFixing(HighsPostsolveStack& postsolve_stack,\n           model->col_upper_[rowNz.index()] != 1.0)\n         continue;\n \n-      // check if setting the binary variable to its lower bound bound makes the\n-      // row redundant\n-      double rhs = 0.0;\n-      double residual = 0.0;\n-      if (model->row_upper_[row] != kHighsInf) {\n-        rhs = model->row_upper_[row];\n-        residual = impliedRowBounds.getResidualSumUpperOrig(row, rowNz.index(),\n-                                                            rowNz.value());\n-      } else {\n-        rhs = -model->row_lower_[row];\n-        residual = -impliedRowBounds.getResidualSumLowerOrig(row, rowNz.index(),\n-                                                             rowNz.value());\n-      }\n-      // skip binary variable if the row has not become redundant\n-      if (residual > rhs + primal_feastol) continue;\n+      // skip binary variable if setting it to its lower bound bound does not\n+      // make the row redundant\n+      if (model->row_upper_[row] != kHighsInf &&\n+          impliedRowBounds.getResidualSumUpperOrig(row, rowNz.index(),\n+                                                   rowNz.value()) >\n+              model->row_upper_[row] + primal_feastol)\n+        continue;\n+      if (model->row_lower_[row] != -kHighsInf &&\n+          impliedRowBounds.getResidualSumLowerOrig(row, rowNz.index(),\n+                                                   rowNz.value()) <\n+              model->row_lower_[row] - primal_feastol)\n+        continue;\n \n       // store triplets (row, nonzero, nonzero) in a vector to speed up search\n+      binVarsTried++;\n+      nzs.clear();\n       if (colsize[col] < colsize[rowNz.index()]) {\n         for (const auto& colNz : getColumnVector(col)) {\n+          // skip non-zeros that do not yield an implied bound\n+          if (!hasImpliedBound(colNz.index(), direction * colNz.value()))\n+            continue;\n           HighsInt nzPos = findNonzero(colNz.index(), rowNz.index());\n           if (nzPos == -1) continue;\n           nzs.push_back({colNz.index(), colNz.value(), Avalue[nzPos]});\n@@ -4645,22 +4660,19 @@ HPresolve::Result HPresolve::dualFixing(HighsPostsolveStack& postsolve_stack,\n         for (const auto& colNz : getColumnVector(rowNz.index())) {\n           HighsInt nzPos = findNonzero(colNz.index(), col);\n           if (nzPos == -1) continue;\n+          // skip non-zeros that do not yield an implied bound\n+          if (!hasImpliedBound(colNz.index(), direction * Avalue[nzPos]))\n+            continue;\n           nzs.push_back({colNz.index(), Avalue[nzPos], colNz.value()});\n         }\n       }\n \n-      // identify best implied bound\n+      // store best bound\n       double bestBound = -kHighsInf;\n       for (const auto& triplet : nzs) {\n-        // skip rows directly that do not yield an implied bound\n-        if ((direction * triplet.jval > 0 ||\n-             model->row_upper_[triplet.row] == kHighsInf) &&\n-            (direction * triplet.jval < 0 ||\n-             model->row_lower_[triplet.row] == -kHighsInf))\n-          continue;\n-\n         // compute implied bound from row given that the binary variable is at\n         // its upper bound\n+        colNonZerosChecked++;\n         double rhs = 0.0;\n         double residual = 0.0;\n         if (direction * triplet.jval < 0) {\n@@ -4692,7 +4704,6 @@ HPresolve::Result HPresolve::dualFixing(HighsPostsolveStack& postsolve_stack,\n         HPRESOLVE_CHECKED_CALL(checkLimits(postsolve_stack));\n         break;\n       }\n-      nzs.clear();\n     }\n     return Result::kOk;\n   };"
      }
    ],
    "lines_added": 36,
    "lines_removed": 25
  },
  "issues": [],
  "pull_requests": [],
  "build_info": {
    "old_build_script": [
      "apt-get update",
      "cmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON -DBUILD_EXTRA_UNIT_TESTS=ON",
      "cmake --build /test_workspace/workspace/old/build -- -j 1"
    ],
    "new_build_script": [
      "apt-get update",
      "cmake -S /test_workspace/workspace/new -B /test_workspace/workspace/new/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON -DBUILD_EXTRA_UNIT_TESTS=ON",
      "cmake --build /test_workspace/workspace/new/build -- -j 1"
    ],
    "old_test_script": [
      "cd /test_workspace/workspace/old/build",
      "ctest --output-on-failure"
    ],
    "new_test_script": [
      "cd /test_workspace/workspace/new/build",
      "ctest --output-on-failure"
    ],
    "build_system": "cmake"
  },
  "performance_analysis": {
    "is_significant": false,
    "p_value": 0.9694769315736171,
    "is_pair_significant": false,
    "pair_p_value": 0.961285823824436,
    "is_binom_significant": false,
    "binom_p_value": 0.9506314266473055,
    "is_wilcoxon_significant": false,
    "wilcoxon_p_value": 0.977551875558835,
    "is_mannwhitney_significant": false,
    "mannwhitney_p_value": 0.4911421997086361,
    "relative_improvement": 0.009451795841209868,
    "absolute_improvement_ms": 11.666666666666714,
    "old_mean_ms": 1234.3333333333333,
    "new_mean_ms": 1222.6666666666665,
    "old_std_ms": 85.80986734247602,
    "new_std_ms": 117.67674405741361,
    "effect_size_cohens_d": 0.11328689814494843,
    "old_ci95_ms": [
      1202.2914022732543,
      1266.3752643934124
    ],
    "new_ci95_ms": [
      1178.725448281916,
      1266.607885051417
    ],
    "old_ci99_ms": [
      1191.1499541758315,
      1277.516712490835
    ],
    "new_ci99_ms": [
      1163.4464439343544,
      1281.8868893989788
    ],
    "new_times_s": [
      1.3,
      1.19,
      1.35,
      1.34,
      1.28,
      1.22,
      1.25,
      1.24,
      1.34,
      1.22,
      1.13,
      1.21,
      1.15,
      1.22,
      1.29,
      1.33,
      1.33,
      1.08,
      1.42,
      1.33,
      1.01,
      0.9,
      1.15,
      1.01,
      1.24,
      1.35,
      1.25,
      1.17,
      1.19,
      1.34,
      1.15
    ],
    "old_times_s": [
      1.18,
      1.19,
      1.22,
      1.4,
      1.4,
      1.3,
      1.13,
      1.27,
      1.21,
      1.11,
      1.24,
      1.23,
      1.26,
      1.24,
      1.11,
      1.24,
      1.14,
      1.29,
      1.29,
      1.29,
      1.21,
      1.34,
      1.37,
      1.09,
      1.16,
      1.15,
      1.15,
      1.18,
      1.35,
      1.2,
      1.27
    ]
  },
  "tests": {
    "total_tests": 2,
    "significant_improvements": 0,
    "significant_improvements_tests": [],
    "significant_regressions": 0,
    "significant_regressions_tests": [],
    "significant_pair_improvements": 0,
    "significant_pair_improvements_tests": [],
    "significant_pair_regressions": 0,
    "significant_pair_regressions_tests": [],
    "significant_binom_improvements": 0,
    "significant_binom_improvements_tests": [],
    "significant_binom_regressions": 0,
    "significant_binom_regressions_tests": [],
    "significant_wilcoxon_improvements": 0,
    "significant_wilcoxon_improvements_tests": [],
    "significant_wilcoxon_regressions": 0,
    "significant_wilcoxon_regressions_tests": [],
    "significant_mannwhitney_improvements": 0,
    "significant_mannwhitney_improvements_tests": [],
    "significant_mannwhitney_regressions": 0,
    "significant_mannwhitney_regressions_tests": [],
    "tests": [
      {
        "test_name": "cxx_examples_call_highs_from_cpp",
        "is_significant": false,
        "p_value": 0.9890295941151932,
        "is_pair_significant": false,
        "pair_p_value": 0.9880198459868643,
        "is_binom_significant": false,
        "binom_p_value": 0.9075333289802074,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9675264532328449,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.7433808803130795,
        "relative_improvement": -0.02163461538461535,
        "absolute_improvement_ms": -6.428571428571505,
        "old_mean_ms": 297.14285714285717,
        "new_mean_ms": 303.57142857142867,
        "old_std_ms": 35.366561195480266,
        "new_std_ms": 33.90774911042385,
        "effect_size_cohens_d": -0.18555641961674382,
        "old_ci95_ms": [
          283.4291363520216,
          310.8565779336927
        ],
        "new_ci95_ms": [
          290.4233760543668,
          316.71948108849045
        ],
        "old_ci99_ms": [
          278.62457692004796,
          315.6611373656664
        ],
        "new_ci99_ms": [
          285.8169967429877,
          321.3258603998696
        ],
        "new_times": [
          0.3,
          0.35,
          0.29,
          0.33,
          0.31,
          0.32,
          0.32,
          0.31,
          0.27,
          0.33,
          0.3,
          0.32,
          0.3,
          0.24,
          0.27,
          0.28,
          0.32,
          0.27,
          0.2,
          0.33,
          0.32,
          0.33,
          0.36,
          0.29,
          0.27,
          0.33,
          0.32,
          0.32
        ],
        "old_times": [
          0.35,
          0.32,
          0.33,
          0.23,
          0.33,
          0.27,
          0.32,
          0.33,
          0.28,
          0.31,
          0.26,
          0.22,
          0.3,
          0.22,
          0.32,
          0.32,
          0.34,
          0.31,
          0.28,
          0.29,
          0.27,
          0.3,
          0.26,
          0.32,
          0.3,
          0.33,
          0.29,
          0.32
        ]
      },
      {
        "test_name": "c_examples_call_highs_from_c_minimal",
        "is_significant": false,
        "p_value": 0.8311816392493214,
        "is_pair_significant": false,
        "pair_p_value": 0.8253265472322985,
        "is_binom_significant": false,
        "binom_p_value": 0.9075333289802074,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.8989099688255509,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.22267152206071422,
        "relative_improvement": 0.024743052912066944,
        "absolute_improvement_ms": 23.21428571428563,
        "old_mean_ms": 938.2142857142857,
        "new_mean_ms": 915.0,
        "old_std_ms": 73.78916769988176,
        "new_std_ms": 108.78112581387148,
        "effect_size_cohens_d": 0.24975914207976405,
        "old_ci95_ms": [
          909.6018334707342,
          966.8267379578372
        ],
        "new_ci95_ms": [
          872.8190828766571,
          957.180917123343
        ],
        "old_ci99_ms": [
          899.5775498065577,
          976.8510216220136
        ],
        "new_ci99_ms": [
          858.0411297372226,
          971.9588702627775
        ],
        "new_times": [
          1.04,
          0.93,
          0.93,
          0.93,
          0.93,
          1.02,
          0.89,
          0.82,
          0.94,
          0.82,
          0.91,
          0.97,
          1.03,
          1.09,
          0.81,
          1.14,
          1.0,
          0.75,
          0.7,
          0.82,
          0.7,
          0.91,
          0.98,
          0.96,
          0.89,
          0.86,
          1.02,
          0.83
        ],
        "old_times": [
          1.05,
          1.08,
          0.97,
          0.89,
          0.94,
          0.94,
          0.79,
          0.9,
          0.95,
          0.93,
          0.98,
          0.89,
          0.94,
          0.92,
          0.97,
          0.97,
          0.95,
          0.91,
          1.06,
          1.08,
          0.82,
          0.86,
          0.89,
          0.83,
          0.88,
          1.02,
          0.91,
          0.95
        ]
      }
    ]
  },
  "logs": {
    "full_log_path": "/logs/full.log",
    "config_log_path": "/logs/config.log",
    "build_log_path": "/logs/build.log",
    "test_log_path": "/logs/test.log",
    "build_success": true,
    "test_success": true
  },
  "raw_timing_data": {
    "warmup_runs": 1,
    "measurement_runs": 30,
    "min_exec_time_improvement": 0.05,
    "min_p_value": 0.05
  }
}