{
  "metadata": {
    "collection_date": "2026-02-03T20:01:45.429450",
    "repository": "https://github.com/google/highway",
    "repository_name": "google/highway"
  },
  "commit_info": {
    "old_sha": "1d16731233de45a365b43867f27d0a5f73925300",
    "new_sha": "a0b07d08a6a0b1f298cbb02a91f3dedec02e1633",
    "commit_message": [
      "Reduce profiler overhead to 1.04x: interleaved Accumulator\n\nGenerally group by thread, not zone; but also interleave to prevent false sharing. Avoid indirection from allocation.\n\nEnabled (Gemma3 4B):\nTotal analysis [s]: 0.024436\nreal\t0m8.226s\nDisabled:\n[ Timing info ] Generate: 5574 ms for 91 tokens (16.32 tokens / sec)\nreal\t0m7.895s\n\nPrevious overhead was 1.05-1.06x.\n\nPiperOrigin-RevId: 794561048"
    ],
    "commit_date": "2025-08-13T14:04:10+00:00",
    "patch": [
      "--- hwy/profiler.cc\n@@ -23,7 +23,6 @@\n #include <stdint.h>\n #include <stdio.h>\n \n-#include \"hwy/aligned_allocator.h\"\n #include \"hwy/base.h\"\n #include \"hwy/robust_statistics.h\"\n #include \"hwy/timer.h\"\n@@ -42,8 +41,7 @@ constexpr bool kPrintOverhead = true;\n /*static*/ std::atomic<size_t> Profiler::s_num_threads{0};\n \n // Detects duration of a zero-length zone: timer plus packet overhead.\n-static uint64_t DetectSelfOverhead(Profiler& profiler,\n-                                   profiler::ZoneSummarizer& summarizer) {\n+static uint64_t DetectSelfOverhead(Profiler& profiler, size_t thread) {\n   profiler::Results results;\n   const size_t kNumSamples = 25;\n   uint32_t samples[kNumSamples];\n@@ -58,8 +56,9 @@ static uint64_t DetectSelfOverhead(Profiler& profiler,\n             profiler.AddZone(\"DetectSelfOverhead\");\n         PROFILER_ZONE3(profiler, /*thread=*/0, zone);\n       }\n-      durations[idx_duration] =\n-          static_cast<uint32_t>(summarizer.GetFirstDurationAndReset());\n+      durations[idx_duration] = static_cast<uint32_t>(\n+          profiler.GetThread(thread).GetFirstDurationAndReset(\n+              thread, profiler.Accumulators()));\n     }\n     samples[idx_sample] = robust_statistics::Mode(durations, kNumDurations);\n   }\n@@ -69,8 +68,7 @@ static uint64_t DetectSelfOverhead(Profiler& profiler,\n // Detects average duration of a zero-length zone, after deducting self\n // overhead. This accounts for the delay before/after capturing start/end\n // timestamps, for example due to fence instructions in timer::Start/Stop.\n-static uint64_t DetectChildOverhead(Profiler& profiler,\n-                                    profiler::ZoneSummarizer& summarizer,\n+static uint64_t DetectChildOverhead(Profiler& profiler, size_t thread,\n                                     uint64_t self_overhead) {\n   // Enough for stable measurements, but only about 50 ms startup cost.\n   const size_t kMaxSamples = 30;\n@@ -93,12 +91,12 @@ static uint64_t DetectChildOverhead(Profiler& profiler,\n       HWY_FENCE;\n       // We are measuring the total, not individual zone durations, to include\n       // cross-zone overhead.\n-      (void)summarizer.GetFirstDurationAndReset();\n+      (void)profiler.GetThread(thread).GetFirstDurationAndReset(\n+          thread, profiler.Accumulators());\n \n       const uint64_t avg_duration = (t1 - t0 + kReps / 2) / kReps;\n-      durations[d] =\n-          static_cast<uint32_t>(profiler::ZoneSummarizer::ClampedSubtract(\n-              avg_duration, self_overhead));\n+      durations[d] = static_cast<uint32_t>(\n+          profiler::PerThread::ClampedSubtract(avg_duration, self_overhead));\n     }\n     samples[num_samples] = robust_statistics::Mode(durations, kNumDurations);\n     // Overhead is nonzero, but we often measure zero; skip them to prevent\n@@ -113,8 +111,6 @@ Profiler::Profiler() {\n \n   InitThread();\n \n-  threads_ =\n-      MakeUniqueAlignedArray<profiler::ZoneSummarizer>(profiler::kMaxThreads);\n   char cpu[100];\n   if (HWY_UNLIKELY(!platform::HaveTimerStop(cpu))) {\n     HWY_ABORT(\"CPU %s is too old for PROFILER_ENABLED=1, exiting\", cpu);\n@@ -123,8 +119,9 @@ Profiler::Profiler() {\n   profiler::Overheads overheads;\n   // WARNING: must pass in Profiler& and use `PROFILER_ZONE3` to avoid calling\n   // `Profiler::Get()` here, because that would re-enter the magic static init.\n-  overheads.self = DetectSelfOverhead(*this, threads_[0]);\n-  overheads.child = DetectChildOverhead(*this, threads_[0], overheads.self);\n+  constexpr size_t kThread = 0;\n+  overheads.self = DetectSelfOverhead(*this, kThread);\n+  overheads.child = DetectChildOverhead(*this, kThread, overheads.self);\n   for (size_t thread = 0; thread < profiler::kMaxThreads; ++thread) {\n     threads_[thread].SetOverheads(overheads);\n   }\n--- hwy/profiler.h\n@@ -76,13 +76,15 @@ namespace profiler {\n \n HWY_INLINE_VAR constexpr size_t kNumFlags = 1;\n \n-// Upper bounds for fixed-size data structures, guarded via HWY_DASSERT.\n-HWY_INLINE_VAR constexpr size_t kMaxDepth = 32;  // Maximum nesting of zones.\n-// Chosen such that `zone` (including flags) can be written as a u8.\n+// Upper bounds for fixed-size data structures, guarded via HWY_DASSERT:\n+\n+// Maximum nesting of zones, chosen such that PerThread is 256 bytes.\n+HWY_INLINE_VAR constexpr size_t kMaxDepth = 13;\n+// Reports with more than ~50 are anyway difficult to read.\n HWY_INLINE_VAR constexpr size_t kMaxZones = 128;\n // Upper bound on threads that call `InitThread`, and `thread` arguments. Note\n-// that fiber libraries can spawn hundreds of threads.\n-HWY_INLINE_VAR constexpr size_t kMaxThreads = 256;  // enough for 2x Turin cores\n+// that fiber libraries can spawn hundreds of threads. Enough for Turin cores.\n+HWY_INLINE_VAR constexpr size_t kMaxThreads = 256;\n \n // Type-safe wrapper for zone index plus flags, returned by `AddZone`.\n class ZoneHandle {\n@@ -419,14 +421,33 @@ class Results {\n // with frequency throttling disabled, this has a multimodal distribution,\n // including 32, 34, 48, 52, 59, 62.\n struct Overheads {\n-  uint64_t self = 0;\n-  uint64_t child = 0;\n+  uint32_t self = 0;\n+  uint32_t child = 0;\n+};\n+static_assert(sizeof(Overheads) == 8, \"Wrong Overheads size\");\n+\n+class Accumulators {\n+  // We generally want to group threads together because they are often\n+  // accessed together during a zone, but also want to avoid threads sharing a\n+  // cache line. Hence interleave 8 zones per thread.\n+  static constexpr size_t kPerLine = HWY_ALIGNMENT / sizeof(Accumulator);\n+\n+ public:\n+  Accumulator& Get(const size_t thread, const size_t zone_idx) {\n+    HWY_DASSERT(thread < kMaxThreads);\n+    HWY_DASSERT(zone_idx < kMaxZones);\n+    const size_t line = zone_idx / kPerLine;\n+    const size_t offset = zone_idx % kPerLine;\n+    return zones_[(line * kMaxThreads + thread) * kPerLine + offset];\n+  }\n+\n+ private:\n+  Accumulator zones_[kMaxZones * kMaxThreads];\n };\n-static_assert(sizeof(Overheads) == 16, \"Wrong Overheads size\");\n \n // Reacts to zone enter/exit events. Builds a stack of active zones and\n // accumulates self/child duration for each.\n-class ZoneSummarizer {\n+class PerThread {\n  public:\n   template <typename T>\n   static T ClampedSubtract(const T minuend, const T subtrahend) {\n@@ -440,17 +461,18 @@ class ZoneSummarizer {\n   void SetOverheads(const Overheads& overheads) { overheads_ = overheads; }\n \n   // Entering a zone: push onto stack.\n-  void Enter(const uint64_t timestamp) {\n+  void Enter(const uint64_t t_enter) {\n     const size_t depth = depth_;\n     HWY_DASSERT(depth < kMaxDepth);\n-    t_enter_[depth] = timestamp;\n+    t_enter_[depth] = t_enter;\n     child_total_[1 + depth] = 0;\n     depth_ = 1 + depth;\n     HWY_IF_CONSTEXPR(HWY_IS_DEBUG_BUILD) { any_ = 1; }\n   }\n \n   // Exiting the most recently entered zone (top of stack).\n-  void Exit(const ZoneHandle zone, const uint64_t t_exit) {\n+  void Exit(const uint64_t t_exit, const size_t thread, const ZoneHandle zone,\n+            Accumulators& accumulators) {\n     HWY_DASSERT(depth_ > 0);\n     const size_t depth = depth_ - 1;\n     const size_t zone_idx = zone.ZoneIdx();\n@@ -462,7 +484,7 @@ class ZoneSummarizer {\n \n     const uint64_t self_duration = ClampedSubtract(\n         duration, overheads_.self + overheads_.child + child_total);\n-    zones_[zone_idx].Add(zone, self_duration);\n+    accumulators.Get(thread, zone_idx).Add(zone, self_duration);\n     // For faster Assimilate() - not all zones are encountered.\n     visited_zones_.Set(zone_idx);\n \n@@ -477,7 +499,7 @@ class ZoneSummarizer {\n \n   // Returns the duration of one enter/exit pair and resets all state. Called\n   // via `DetectSelfOverhead`.\n-  uint64_t GetFirstDurationAndReset() {\n+  uint64_t GetFirstDurationAndReset(size_t thread, Accumulators& accumulators) {\n     HWY_DASSERT(depth_ == 0);\n \n     HWY_DASSERT(visited_zones_.Count() == 1);\n@@ -486,17 +508,19 @@ class ZoneSummarizer {\n     HWY_DASSERT(visited_zones_.Get(zone_idx));\n     visited_zones_.Clear(zone_idx);\n \n-    const uint64_t duration = zones_[zone_idx].duration;\n-    zones_[zone_idx] = Accumulator();\n+    Accumulator& zone = accumulators.Get(thread, zone_idx);\n+    const uint64_t duration = zone.duration;\n+    zone = Accumulator();\n     return duration;\n   }\n \n   // Adds all data to `results` and resets it here. Called from the main thread.\n-  void MoveTo(const size_t thread, Results& results) {\n+  void MoveTo(const size_t thread, Accumulators& accumulators,\n+              Results& results) {\n     const uint64_t t0 = timer::Start();\n \n     visited_zones_.Foreach([&](size_t zone_idx) {\n-      results.Assimilate(thread, zone_idx, zones_[zone_idx]);\n+      results.Assimilate(thread, zone_idx, accumulators.Get(thread, zone_idx));\n     });\n     // OK to reset even if we have active zones, because we set `visited_zones_`\n     // when exiting the zone.\n@@ -506,22 +530,20 @@ class ZoneSummarizer {\n   }\n \n  private:\n-  // 48 bytes:\n-  uint64_t depth_ = 0;     // Current nesting level for active zones.\n+  // 40 bytes:\n   ZoneSet visited_zones_;  // Which `zones_` have been active on this thread.\n-  Overheads overheads_;\n+  uint64_t depth_ = 0;     // Current nesting level for active zones.\n   uint64_t any_ = 0;\n+  Overheads overheads_;\n \n   uint64_t t_enter_[kMaxDepth];\n   // Used to deduct child duration from parent's self time (unless inclusive).\n   // Shifting by one avoids bounds-checks for depth_ = 0 (root zone).\n   uint64_t child_total_[1 + kMaxDepth] = {0};\n-  Accumulator zones_[kMaxZones];\n-  // Enables shift rather than multiplication.\n-  HWY_MAYBE_UNUSED uint8_t padding[4096 - 48 - sizeof(t_enter_) -\n-                                   sizeof(child_total_) - sizeof(zones_)];\n };\n-static_assert(sizeof(ZoneSummarizer) == 4096, \"Wrong size\");\n+\n+// Enables shift rather than multiplication.\n+static_assert(sizeof(PerThread) == 256, \"Wrong size\");\n \n }  // namespace profiler\n \n@@ -609,19 +631,20 @@ class Profiler {\n   }\n \n   // Only for use by Zone; called from any thread.\n-  profiler::ZoneSummarizer* Summarizer(size_t thread) {\n+  profiler::PerThread& GetThread(size_t thread) {\n     HWY_DASSERT(thread < profiler::kMaxThreads);\n-    return &threads_[thread];\n+    return threads_[thread];\n   }\n+  profiler::Accumulators& Accumulators() { return accumulators_; }\n \n  private:\n-  // Initializes memory, computes self-overhead, and checks timer support.\n+  // Sets main thread index, computes self-overhead, and checks timer support.\n   Profiler();\n \n   // Called from the main thread.\n   void UpdateResults() {\n     for (size_t thread = 0; thread < max_threads_; ++thread) {\n-      threads_[thread].MoveTo(thread, results_);\n+      threads_[thread].MoveTo(thread, accumulators_, results_);\n     }\n \n     // Check that all other threads did not have any zones.\n@@ -637,13 +660,15 @@ class Profiler {\n   static std::atomic<size_t> s_num_threads;\n   size_t max_threads_ = profiler::kMaxThreads;\n \n+  std::atomic_flag run_active_ = ATOMIC_FLAG_INIT;\n+\n   // To avoid locking, each thread has its own working set. We could access this\n   // through `thread_local` pointers, but that is slow to read on x86. Because\n   // our `ThreadPool` anyway passes a `thread` argument, we can instead pass\n   // that through the `PROFILER_ZONE2/PROFILER_ZONE3` macros.\n-  hwy::AlignedUniquePtr<profiler::ZoneSummarizer[]> threads_;\n+  profiler::PerThread threads_[profiler::kMaxThreads];\n \n-  std::atomic_flag run_active_ = ATOMIC_FLAG_INIT;\n+  profiler::Accumulators accumulators_;\n \n   // Updated by the main thread after the root `ThreadPool::Run` and during\n   // `PrintResults`.\n@@ -666,25 +691,28 @@ class Zone {\n   //   a nested pool's `thread` argument.\n   // - obtained from `Profiler::Thread()`, or\n   // - 0 if only a single thread is active.\n-  Zone(Profiler& profiler, size_t thread, ZoneHandle zone) {\n+  Zone(Profiler& profiler, size_t thread, ZoneHandle zone)\n+      : profiler_(profiler) {\n     HWY_FENCE;\n-    const uint64_t timestamp = timer::Start();\n+    const uint64_t t_enter = timer::Start();\n     HWY_FENCE;\n-    summarizer_ = profiler.Summarizer(thread);\n+    thread_ = static_cast<uint32_t>(thread);\n     zone_ = zone;\n-    summarizer_->Enter(timestamp);\n+    profiler.GetThread(thread).Enter(t_enter);\n     HWY_FENCE;\n   }\n \n   ~Zone() {\n     HWY_FENCE;\n-    const uint64_t timestamp = timer::Stop();\n-    summarizer_->Exit(zone_, timestamp);\n+    const uint64_t t_exit = timer::Stop();\n+    profiler_.GetThread(thread_).Exit(t_exit, thread_, zone_,\n+                                      profiler_.Accumulators());\n     HWY_FENCE;\n   }\n \n  private:\n-  ZoneSummarizer* summarizer_;\n+  Profiler& profiler_;\n+  uint32_t thread_;\n   ZoneHandle zone_;\n };\n \n@@ -753,7 +781,4 @@ struct Zone {\n #define PROFILER_END_ROOT_RUN() hwy::Profiler::Get().EndRootRun()\n #define PROFILER_PRINT_RESULTS() hwy::Profiler::Get().PrintResults()\n \n-// TODO(janwas): remove this after user code is updated.\n-using ::hwy::ProfilerFlags;\n-\n #endif  // HIGHWAY_HWY_PROFILER_H_"
    ],
    "files_changed": [
      {
        "filename": "hwy/profiler.cc",
        "status": "modified",
        "additions": 12,
        "deletions": 15,
        "changes": 27,
        "patch": "@@ -23,7 +23,6 @@\n #include <stdint.h>\n #include <stdio.h>\n \n-#include \"hwy/aligned_allocator.h\"\n #include \"hwy/base.h\"\n #include \"hwy/robust_statistics.h\"\n #include \"hwy/timer.h\"\n@@ -42,8 +41,7 @@ constexpr bool kPrintOverhead = true;\n /*static*/ std::atomic<size_t> Profiler::s_num_threads{0};\n \n // Detects duration of a zero-length zone: timer plus packet overhead.\n-static uint64_t DetectSelfOverhead(Profiler& profiler,\n-                                   profiler::ZoneSummarizer& summarizer) {\n+static uint64_t DetectSelfOverhead(Profiler& profiler, size_t thread) {\n   profiler::Results results;\n   const size_t kNumSamples = 25;\n   uint32_t samples[kNumSamples];\n@@ -58,8 +56,9 @@ static uint64_t DetectSelfOverhead(Profiler& profiler,\n             profiler.AddZone(\"DetectSelfOverhead\");\n         PROFILER_ZONE3(profiler, /*thread=*/0, zone);\n       }\n-      durations[idx_duration] =\n-          static_cast<uint32_t>(summarizer.GetFirstDurationAndReset());\n+      durations[idx_duration] = static_cast<uint32_t>(\n+          profiler.GetThread(thread).GetFirstDurationAndReset(\n+              thread, profiler.Accumulators()));\n     }\n     samples[idx_sample] = robust_statistics::Mode(durations, kNumDurations);\n   }\n@@ -69,8 +68,7 @@ static uint64_t DetectSelfOverhead(Profiler& profiler,\n // Detects average duration of a zero-length zone, after deducting self\n // overhead. This accounts for the delay before/after capturing start/end\n // timestamps, for example due to fence instructions in timer::Start/Stop.\n-static uint64_t DetectChildOverhead(Profiler& profiler,\n-                                    profiler::ZoneSummarizer& summarizer,\n+static uint64_t DetectChildOverhead(Profiler& profiler, size_t thread,\n                                     uint64_t self_overhead) {\n   // Enough for stable measurements, but only about 50 ms startup cost.\n   const size_t kMaxSamples = 30;\n@@ -93,12 +91,12 @@ static uint64_t DetectChildOverhead(Profiler& profiler,\n       HWY_FENCE;\n       // We are measuring the total, not individual zone durations, to include\n       // cross-zone overhead.\n-      (void)summarizer.GetFirstDurationAndReset();\n+      (void)profiler.GetThread(thread).GetFirstDurationAndReset(\n+          thread, profiler.Accumulators());\n \n       const uint64_t avg_duration = (t1 - t0 + kReps / 2) / kReps;\n-      durations[d] =\n-          static_cast<uint32_t>(profiler::ZoneSummarizer::ClampedSubtract(\n-              avg_duration, self_overhead));\n+      durations[d] = static_cast<uint32_t>(\n+          profiler::PerThread::ClampedSubtract(avg_duration, self_overhead));\n     }\n     samples[num_samples] = robust_statistics::Mode(durations, kNumDurations);\n     // Overhead is nonzero, but we often measure zero; skip them to prevent\n@@ -113,8 +111,6 @@ Profiler::Profiler() {\n \n   InitThread();\n \n-  threads_ =\n-      MakeUniqueAlignedArray<profiler::ZoneSummarizer>(profiler::kMaxThreads);\n   char cpu[100];\n   if (HWY_UNLIKELY(!platform::HaveTimerStop(cpu))) {\n     HWY_ABORT(\"CPU %s is too old for PROFILER_ENABLED=1, exiting\", cpu);\n@@ -123,8 +119,9 @@ Profiler::Profiler() {\n   profiler::Overheads overheads;\n   // WARNING: must pass in Profiler& and use `PROFILER_ZONE3` to avoid calling\n   // `Profiler::Get()` here, because that would re-enter the magic static init.\n-  overheads.self = DetectSelfOverhead(*this, threads_[0]);\n-  overheads.child = DetectChildOverhead(*this, threads_[0], overheads.self);\n+  constexpr size_t kThread = 0;\n+  overheads.self = DetectSelfOverhead(*this, kThread);\n+  overheads.child = DetectChildOverhead(*this, kThread, overheads.self);\n   for (size_t thread = 0; thread < profiler::kMaxThreads; ++thread) {\n     threads_[thread].SetOverheads(overheads);\n   }"
      },
      {
        "filename": "hwy/profiler.h",
        "status": "modified",
        "additions": 67,
        "deletions": 42,
        "changes": 109,
        "patch": "@@ -76,13 +76,15 @@ namespace profiler {\n \n HWY_INLINE_VAR constexpr size_t kNumFlags = 1;\n \n-// Upper bounds for fixed-size data structures, guarded via HWY_DASSERT.\n-HWY_INLINE_VAR constexpr size_t kMaxDepth = 32;  // Maximum nesting of zones.\n-// Chosen such that `zone` (including flags) can be written as a u8.\n+// Upper bounds for fixed-size data structures, guarded via HWY_DASSERT:\n+\n+// Maximum nesting of zones, chosen such that PerThread is 256 bytes.\n+HWY_INLINE_VAR constexpr size_t kMaxDepth = 13;\n+// Reports with more than ~50 are anyway difficult to read.\n HWY_INLINE_VAR constexpr size_t kMaxZones = 128;\n // Upper bound on threads that call `InitThread`, and `thread` arguments. Note\n-// that fiber libraries can spawn hundreds of threads.\n-HWY_INLINE_VAR constexpr size_t kMaxThreads = 256;  // enough for 2x Turin cores\n+// that fiber libraries can spawn hundreds of threads. Enough for Turin cores.\n+HWY_INLINE_VAR constexpr size_t kMaxThreads = 256;\n \n // Type-safe wrapper for zone index plus flags, returned by `AddZone`.\n class ZoneHandle {\n@@ -419,14 +421,33 @@ class Results {\n // with frequency throttling disabled, this has a multimodal distribution,\n // including 32, 34, 48, 52, 59, 62.\n struct Overheads {\n-  uint64_t self = 0;\n-  uint64_t child = 0;\n+  uint32_t self = 0;\n+  uint32_t child = 0;\n+};\n+static_assert(sizeof(Overheads) == 8, \"Wrong Overheads size\");\n+\n+class Accumulators {\n+  // We generally want to group threads together because they are often\n+  // accessed together during a zone, but also want to avoid threads sharing a\n+  // cache line. Hence interleave 8 zones per thread.\n+  static constexpr size_t kPerLine = HWY_ALIGNMENT / sizeof(Accumulator);\n+\n+ public:\n+  Accumulator& Get(const size_t thread, const size_t zone_idx) {\n+    HWY_DASSERT(thread < kMaxThreads);\n+    HWY_DASSERT(zone_idx < kMaxZones);\n+    const size_t line = zone_idx / kPerLine;\n+    const size_t offset = zone_idx % kPerLine;\n+    return zones_[(line * kMaxThreads + thread) * kPerLine + offset];\n+  }\n+\n+ private:\n+  Accumulator zones_[kMaxZones * kMaxThreads];\n };\n-static_assert(sizeof(Overheads) == 16, \"Wrong Overheads size\");\n \n // Reacts to zone enter/exit events. Builds a stack of active zones and\n // accumulates self/child duration for each.\n-class ZoneSummarizer {\n+class PerThread {\n  public:\n   template <typename T>\n   static T ClampedSubtract(const T minuend, const T subtrahend) {\n@@ -440,17 +461,18 @@ class ZoneSummarizer {\n   void SetOverheads(const Overheads& overheads) { overheads_ = overheads; }\n \n   // Entering a zone: push onto stack.\n-  void Enter(const uint64_t timestamp) {\n+  void Enter(const uint64_t t_enter) {\n     const size_t depth = depth_;\n     HWY_DASSERT(depth < kMaxDepth);\n-    t_enter_[depth] = timestamp;\n+    t_enter_[depth] = t_enter;\n     child_total_[1 + depth] = 0;\n     depth_ = 1 + depth;\n     HWY_IF_CONSTEXPR(HWY_IS_DEBUG_BUILD) { any_ = 1; }\n   }\n \n   // Exiting the most recently entered zone (top of stack).\n-  void Exit(const ZoneHandle zone, const uint64_t t_exit) {\n+  void Exit(const uint64_t t_exit, const size_t thread, const ZoneHandle zone,\n+            Accumulators& accumulators) {\n     HWY_DASSERT(depth_ > 0);\n     const size_t depth = depth_ - 1;\n     const size_t zone_idx = zone.ZoneIdx();\n@@ -462,7 +484,7 @@ class ZoneSummarizer {\n \n     const uint64_t self_duration = ClampedSubtract(\n         duration, overheads_.self + overheads_.child + child_total);\n-    zones_[zone_idx].Add(zone, self_duration);\n+    accumulators.Get(thread, zone_idx).Add(zone, self_duration);\n     // For faster Assimilate() - not all zones are encountered.\n     visited_zones_.Set(zone_idx);\n \n@@ -477,7 +499,7 @@ class ZoneSummarizer {\n \n   // Returns the duration of one enter/exit pair and resets all state. Called\n   // via `DetectSelfOverhead`.\n-  uint64_t GetFirstDurationAndReset() {\n+  uint64_t GetFirstDurationAndReset(size_t thread, Accumulators& accumulators) {\n     HWY_DASSERT(depth_ == 0);\n \n     HWY_DASSERT(visited_zones_.Count() == 1);\n@@ -486,17 +508,19 @@ class ZoneSummarizer {\n     HWY_DASSERT(visited_zones_.Get(zone_idx));\n     visited_zones_.Clear(zone_idx);\n \n-    const uint64_t duration = zones_[zone_idx].duration;\n-    zones_[zone_idx] = Accumulator();\n+    Accumulator& zone = accumulators.Get(thread, zone_idx);\n+    const uint64_t duration = zone.duration;\n+    zone = Accumulator();\n     return duration;\n   }\n \n   // Adds all data to `results` and resets it here. Called from the main thread.\n-  void MoveTo(const size_t thread, Results& results) {\n+  void MoveTo(const size_t thread, Accumulators& accumulators,\n+              Results& results) {\n     const uint64_t t0 = timer::Start();\n \n     visited_zones_.Foreach([&](size_t zone_idx) {\n-      results.Assimilate(thread, zone_idx, zones_[zone_idx]);\n+      results.Assimilate(thread, zone_idx, accumulators.Get(thread, zone_idx));\n     });\n     // OK to reset even if we have active zones, because we set `visited_zones_`\n     // when exiting the zone.\n@@ -506,22 +530,20 @@ class ZoneSummarizer {\n   }\n \n  private:\n-  // 48 bytes:\n-  uint64_t depth_ = 0;     // Current nesting level for active zones.\n+  // 40 bytes:\n   ZoneSet visited_zones_;  // Which `zones_` have been active on this thread.\n-  Overheads overheads_;\n+  uint64_t depth_ = 0;     // Current nesting level for active zones.\n   uint64_t any_ = 0;\n+  Overheads overheads_;\n \n   uint64_t t_enter_[kMaxDepth];\n   // Used to deduct child duration from parent's self time (unless inclusive).\n   // Shifting by one avoids bounds-checks for depth_ = 0 (root zone).\n   uint64_t child_total_[1 + kMaxDepth] = {0};\n-  Accumulator zones_[kMaxZones];\n-  // Enables shift rather than multiplication.\n-  HWY_MAYBE_UNUSED uint8_t padding[4096 - 48 - sizeof(t_enter_) -\n-                                   sizeof(child_total_) - sizeof(zones_)];\n };\n-static_assert(sizeof(ZoneSummarizer) == 4096, \"Wrong size\");\n+\n+// Enables shift rather than multiplication.\n+static_assert(sizeof(PerThread) == 256, \"Wrong size\");\n \n }  // namespace profiler\n \n@@ -609,19 +631,20 @@ class Profiler {\n   }\n \n   // Only for use by Zone; called from any thread.\n-  profiler::ZoneSummarizer* Summarizer(size_t thread) {\n+  profiler::PerThread& GetThread(size_t thread) {\n     HWY_DASSERT(thread < profiler::kMaxThreads);\n-    return &threads_[thread];\n+    return threads_[thread];\n   }\n+  profiler::Accumulators& Accumulators() { return accumulators_; }\n \n  private:\n-  // Initializes memory, computes self-overhead, and checks timer support.\n+  // Sets main thread index, computes self-overhead, and checks timer support.\n   Profiler();\n \n   // Called from the main thread.\n   void UpdateResults() {\n     for (size_t thread = 0; thread < max_threads_; ++thread) {\n-      threads_[thread].MoveTo(thread, results_);\n+      threads_[thread].MoveTo(thread, accumulators_, results_);\n     }\n \n     // Check that all other threads did not have any zones.\n@@ -637,13 +660,15 @@ class Profiler {\n   static std::atomic<size_t> s_num_threads;\n   size_t max_threads_ = profiler::kMaxThreads;\n \n+  std::atomic_flag run_active_ = ATOMIC_FLAG_INIT;\n+\n   // To avoid locking, each thread has its own working set. We could access this\n   // through `thread_local` pointers, but that is slow to read on x86. Because\n   // our `ThreadPool` anyway passes a `thread` argument, we can instead pass\n   // that through the `PROFILER_ZONE2/PROFILER_ZONE3` macros.\n-  hwy::AlignedUniquePtr<profiler::ZoneSummarizer[]> threads_;\n+  profiler::PerThread threads_[profiler::kMaxThreads];\n \n-  std::atomic_flag run_active_ = ATOMIC_FLAG_INIT;\n+  profiler::Accumulators accumulators_;\n \n   // Updated by the main thread after the root `ThreadPool::Run` and during\n   // `PrintResults`.\n@@ -666,25 +691,28 @@ class Zone {\n   //   a nested pool's `thread` argument.\n   // - obtained from `Profiler::Thread()`, or\n   // - 0 if only a single thread is active.\n-  Zone(Profiler& profiler, size_t thread, ZoneHandle zone) {\n+  Zone(Profiler& profiler, size_t thread, ZoneHandle zone)\n+      : profiler_(profiler) {\n     HWY_FENCE;\n-    const uint64_t timestamp = timer::Start();\n+    const uint64_t t_enter = timer::Start();\n     HWY_FENCE;\n-    summarizer_ = profiler.Summarizer(thread);\n+    thread_ = static_cast<uint32_t>(thread);\n     zone_ = zone;\n-    summarizer_->Enter(timestamp);\n+    profiler.GetThread(thread).Enter(t_enter);\n     HWY_FENCE;\n   }\n \n   ~Zone() {\n     HWY_FENCE;\n-    const uint64_t timestamp = timer::Stop();\n-    summarizer_->Exit(zone_, timestamp);\n+    const uint64_t t_exit = timer::Stop();\n+    profiler_.GetThread(thread_).Exit(t_exit, thread_, zone_,\n+                                      profiler_.Accumulators());\n     HWY_FENCE;\n   }\n \n  private:\n-  ZoneSummarizer* summarizer_;\n+  Profiler& profiler_;\n+  uint32_t thread_;\n   ZoneHandle zone_;\n };\n \n@@ -753,7 +781,4 @@ struct Zone {\n #define PROFILER_END_ROOT_RUN() hwy::Profiler::Get().EndRootRun()\n #define PROFILER_PRINT_RESULTS() hwy::Profiler::Get().PrintResults()\n \n-// TODO(janwas): remove this after user code is updated.\n-using ::hwy::ProfilerFlags;\n-\n #endif  // HIGHWAY_HWY_PROFILER_H_"
      }
    ],
    "lines_added": 79,
    "lines_removed": 57
  },
  "issues": [],
  "pull_requests": [],
  "build_info": {
    "old_build_script": [
      "apt-get update",
      "cmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON -DHWY_ENABLE_TESTS=ON",
      "cmake --build /test_workspace/workspace/old/build -- -j 1"
    ],
    "new_build_script": [
      "apt-get update",
      "cmake -S /test_workspace/workspace/new -B /test_workspace/workspace/new/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON -DHWY_ENABLE_TESTS=ON",
      "cmake --build /test_workspace/workspace/new/build -- -j 1"
    ],
    "old_test_script": [
      "cd /test_workspace/workspace/old/build",
      "ctest --output-on-failure"
    ],
    "new_test_script": [
      "cd /test_workspace/workspace/new/build",
      "ctest --output-on-failure"
    ],
    "build_system": "cmake"
  },
  "performance_analysis": {
    "is_significant": false,
    "p_value": 0.8377622698207847,
    "is_pair_significant": false,
    "pair_p_value": 0.9999989734680736,
    "is_binom_significant": false,
    "binom_p_value": 0.9999999990686774,
    "is_wilcoxon_significant": false,
    "wilcoxon_p_value": 0.9999901402458009,
    "is_mannwhitney_significant": false,
    "mannwhitney_p_value": 0.4353982849890529,
    "relative_improvement": -0.007264807808476038,
    "absolute_improvement_ms": -457.00000000000074,
    "old_mean_ms": 62905.99999999999,
    "new_mean_ms": 63362.99999999999,
    "old_std_ms": 13891.544339558905,
    "new_std_ms": 14831.14573433568,
    "effect_size_cohens_d": -0.031804518998408575,
    "old_ci95_ms": [
      57718.81209456145,
      68093.18790543852
    ],
    "new_ci95_ms": [
      57824.959167645335,
      68901.04083235466
    ],
    "old_ci99_ms": [
      55915.150988379646,
      69896.84901162033
    ],
    "new_ci99_ms": [
      55899.30136695297,
      70826.69863304701
    ],
    "new_times_s": [
      55.19,
      55.16,
      55.13,
      58.19,
      56.29,
      58.51,
      57.87,
      56.48,
      55.95,
      58.34,
      56.66,
      57.13,
      56.44,
      57.07,
      57.47,
      57.0,
      59.07,
      57.4,
      56.7,
      56.44,
      57.65,
      57.04,
      57.52,
      57.16,
      58.36,
      55.75,
      105.51,
      106.1,
      89.43,
      88.6,
      84.47
    ],
    "old_times_s": [
      54.81,
      55.4,
      55.54,
      54.94,
      56.9,
      57.96,
      57.67,
      56.53,
      58.19,
      57.08,
      57.73,
      57.05,
      56.53,
      56.92,
      57.87,
      56.45,
      56.9,
      57.68,
      58.2,
      56.63,
      57.43,
      57.53,
      58.19,
      56.83,
      56.95,
      63.69,
      109.54,
      102.5,
      75.81,
      86.05,
      80.49
    ]
  },
  "tests": {
    "total_tests": 9,
    "significant_improvements": 0,
    "significant_improvements_tests": [],
    "significant_regressions": 0,
    "significant_regressions_tests": [],
    "significant_pair_improvements": 0,
    "significant_pair_improvements_tests": [],
    "significant_pair_regressions": 0,
    "significant_pair_regressions_tests": [],
    "significant_binom_improvements": 0,
    "significant_binom_improvements_tests": [],
    "significant_binom_regressions": 0,
    "significant_binom_regressions_tests": [],
    "significant_wilcoxon_improvements": 0,
    "significant_wilcoxon_improvements_tests": [],
    "significant_wilcoxon_regressions": 0,
    "significant_wilcoxon_regressions_tests": [],
    "significant_mannwhitney_improvements": 0,
    "significant_mannwhitney_improvements_tests": [],
    "significant_mannwhitney_regressions": 0,
    "significant_mannwhitney_regressions_tests": [],
    "tests": [
      {
        "test_name": "AbortDeathTest.AbortDefault",
        "is_significant": false,
        "p_value": 0.8510809079838082,
        "is_pair_significant": false,
        "pair_p_value": 0.8385223807388309,
        "is_binom_significant": false,
        "binom_p_value": 0.9999999962747097,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999957453552234,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.5101665707293922,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 10.357142857142858,
        "new_mean_ms": 10.357142857142858,
        "old_std_ms": 1.8898223650461365,
        "new_std_ms": 1.8898223650461365,
        "effect_size_cohens_d": 0.0,
        "old_ci95_ms": [
          9.624346244114186,
          11.08993947017153
        ],
        "new_ci95_ms": [
          9.624346244114186,
          11.08993947017153
        ],
        "old_ci99_ms": [
          9.367613229599403,
          11.346672484686314
        ],
        "new_ci99_ms": [
          9.367613229599403,
          11.346672484686314
        ],
        "new_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.02,
          0.01,
          0.01,
          0.01
        ],
        "old_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.02,
          0.01,
          0.01,
          0.01,
          0.01
        ]
      },
      {
        "test_name": "NanobenchmarkTest.RunTest",
        "is_significant": false,
        "p_value": 0.5956688625774824,
        "is_pair_significant": false,
        "pair_p_value": 0.6103260211401769,
        "is_binom_significant": false,
        "binom_p_value": 0.8275357745587826,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.5989192204553628,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.16422507587241547,
        "relative_improvement": 0.039651070578905635,
        "absolute_improvement_ms": 17.857142857142904,
        "old_mean_ms": 450.3571428571429,
        "new_mean_ms": 432.5,
        "old_std_ms": 71.15357115303974,
        "new_std_ms": 75.50447619794423,
        "effect_size_cohens_d": 0.2434137103114655,
        "old_ci95_ms": [
          422.7666682653316,
          477.9476174489542
        ],
        "new_ci95_ms": [
          403.22242055670307,
          461.77757944329693
        ],
        "old_ci99_ms": [
          413.1004312932837,
          487.61385442100215
        ],
        "new_ci99_ms": [
          392.96511164651633,
          472.03488835348367
        ],
        "new_times": [
          0.5,
          0.41,
          0.35,
          0.46,
          0.42,
          0.4,
          0.58,
          0.42,
          0.33,
          0.34,
          0.35,
          0.43,
          0.42,
          0.34,
          0.53,
          0.52,
          0.36,
          0.38,
          0.52,
          0.4,
          0.38,
          0.43,
          0.34,
          0.39,
          0.51,
          0.53,
          0.53,
          0.54
        ],
        "old_times": [
          0.5,
          0.38,
          0.45,
          0.38,
          0.5,
          0.41,
          0.43,
          0.43,
          0.43,
          0.42,
          0.41,
          0.36,
          0.39,
          0.43,
          0.5,
          0.45,
          0.45,
          0.45,
          0.37,
          0.53,
          0.39,
          0.42,
          0.53,
          0.38,
          0.69,
          0.46,
          0.56,
          0.51
        ]
      },
      {
        "test_name": "AutoTuneTest.TestCostDistribution",
        "is_significant": false,
        "p_value": 0.8613281437274481,
        "is_pair_significant": false,
        "pair_p_value": 0.9983916486847151,
        "is_binom_significant": false,
        "binom_p_value": 0.9999999962747097,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999994936745713,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.7616973560367211,
        "relative_improvement": -0.06970509383378011,
        "absolute_improvement_ms": -9.285714285714313,
        "old_mean_ms": 133.2142857142857,
        "new_mean_ms": 142.50000000000003,
        "old_std_ms": 43.80542596431798,
        "new_std_ms": 64.49949755761813,
        "effect_size_cohens_d": -0.16842658840581082,
        "old_ci95_ms": [
          116.2283147719073,
          150.2002566566641
        ],
        "new_ci95_ms": [
          117.48970579114732,
          167.5102942088527
        ],
        "old_ci99_ms": [
          110.27733267542389,
          156.1512387531475
        ],
        "new_ci99_ms": [
          108.72742699239262,
          176.2725730076074
        ],
        "new_times": [
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.14,
          0.44,
          0.2,
          0.15,
          0.22,
          0.2
        ],
        "old_times": [
          0.13,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.33,
          0.12,
          0.12,
          0.22,
          0.17
        ]
      },
      {
        "test_name": "SpinTest.TestPingPong",
        "is_significant": false,
        "p_value": 0.9967277402889716,
        "is_pair_significant": false,
        "pair_p_value": 0.9999999725660617,
        "is_binom_significant": false,
        "binom_p_value": 0.9999999962747097,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999944543930792,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.521480685932832,
        "relative_improvement": -0.007782101167315182,
        "absolute_improvement_ms": -0.7142857142857367,
        "old_mean_ms": 91.78571428571428,
        "new_mean_ms": 92.50000000000001,
        "old_std_ms": 6.118321864193027,
        "new_std_ms": 7.993052538854533,
        "effect_size_cohens_d": -0.10035371980501076,
        "old_ci95_ms": [
          89.41327673686006,
          94.1581518345685
        ],
        "new_ci95_ms": [
          89.40061778473566,
          95.59938221526437
        ],
        "old_ci99_ms": [
          88.58210061945411,
          94.98932795197445
        ],
        "new_ci99_ms": [
          88.31475886411425,
          96.68524113588576
        ],
        "new_times": [
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.12,
          0.12,
          0.1,
          0.09,
          0.09
        ],
        "old_times": [
          0.08,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.11,
          0.11,
          0.1,
          0.09,
          0.1
        ]
      },
      {
        "test_name": "ThreadPoolTest.TestPool",
        "is_significant": false,
        "p_value": 0.589766322327111,
        "is_pair_significant": false,
        "pair_p_value": 0.6060042558860921,
        "is_binom_significant": false,
        "binom_p_value": 0.5747229903936386,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.6609105169773102,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.57795800863552,
        "relative_improvement": 0.0034340659340659826,
        "absolute_improvement_ms": 1.7857142857143904,
        "old_mean_ms": 520.0000000000001,
        "new_mean_ms": 518.2142857142858,
        "old_std_ms": 448.42935774644474,
        "new_std_ms": 366.22249431720513,
        "effect_size_cohens_d": 0.004361841801492659,
        "old_ci95_ms": [
          346.11724751643777,
          693.8827524835625
        ],
        "new_ci95_ms": [
          376.2080271292316,
          660.2205442993398
        ],
        "old_ci99_ms": [
          285.1979659265186,
          754.8020340734817
        ],
        "new_ci99_ms": [
          326.4565760467465,
          709.971995381825
        ],
        "new_times": [
          0.16,
          0.62,
          1.29,
          0.53,
          0.63,
          0.09,
          0.64,
          0.53,
          0.59,
          0.52,
          1.13,
          0.73,
          0.26,
          0.79,
          0.61,
          0.02,
          0.03,
          1.0,
          0.29,
          0.66,
          0.47,
          0.82,
          0.19,
          0.05,
          0.14,
          0.03,
          0.46,
          1.23
        ],
        "old_times": [
          0.01,
          0.24,
          1.47,
          1.3,
          0.34,
          0.47,
          0.25,
          0.75,
          0.75,
          0.44,
          0.64,
          1.34,
          0.08,
          0.31,
          0.89,
          0.29,
          0.02,
          0.99,
          0.87,
          0.3,
          0.19,
          0.18,
          1.38,
          0.21,
          0.15,
          0.06,
          0.56,
          0.08
        ]
      },
      {
        "test_name": "ThreadPoolTest.TestWaitMode",
        "is_significant": false,
        "p_value": 0.4823255438836618,
        "is_pair_significant": false,
        "pair_p_value": 0.4750814631848266,
        "is_binom_significant": false,
        "binom_p_value": 0.9821509309113026,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.7876237109303474,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.253426335964437,
        "relative_improvement": 0.05259750768732804,
        "absolute_improvement_ms": 348.2142857142847,
        "old_mean_ms": 6620.357142857142,
        "new_mean_ms": 6272.142857142858,
        "old_std_ms": 1676.0678898626306,
        "new_std_ms": 1280.5333296972824,
        "effect_size_cohens_d": 0.2334704302181237,
        "old_ci95_ms": [
          5970.4458625091265,
          7270.268423205159
        ],
        "new_ci95_ms": [
          5775.603867961412,
          6768.6818463243035
        ],
        "old_ci99_ms": [
          5742.751466541197,
          7497.962819173088
        ],
        "new_ci99_ms": [
          5601.642977244675,
          6942.64273704104
        ],
        "new_times": [
          6.17,
          5.37,
          6.85,
          6.7,
          5.27,
          5.29,
          7.05,
          5.56,
          6.08,
          5.41,
          5.45,
          5.92,
          6.0,
          7.36,
          5.67,
          5.67,
          5.5,
          5.58,
          5.61,
          5.62,
          5.64,
          6.39,
          4.42,
          9.3,
          10.61,
          6.76,
          7.74,
          6.63
        ],
        "old_times": [
          4.43,
          6.2,
          6.02,
          5.88,
          5.44,
          7.03,
          6.39,
          6.35,
          5.48,
          5.52,
          5.52,
          5.66,
          5.63,
          5.73,
          5.83,
          6.86,
          5.54,
          5.4,
          5.67,
          6.71,
          5.56,
          5.77,
          9.71,
          10.56,
          10.45,
          10.02,
          7.44,
          8.57
        ]
      },
      {
        "test_name": "ThreadPoolTest.TestCounter",
        "is_significant": false,
        "p_value": 0.8651155897405569,
        "is_pair_significant": false,
        "pair_p_value": 0.9520240264610846,
        "is_binom_significant": false,
        "binom_p_value": 0.956420723348856,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9872247002247846,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.7287529933401502,
        "relative_improvement": -0.022288261515601704,
        "absolute_improvement_ms": -5.357142857142811,
        "old_mean_ms": 240.3571428571429,
        "new_mean_ms": 245.7142857142857,
        "old_std_ms": 59.84437489312765,
        "new_std_ms": 59.71714633283783,
        "effect_size_cohens_d": -0.08961310911895555,
        "old_ci95_ms": [
          217.1519167779016,
          263.5623689363842
        ],
        "new_ci95_ms": [
          222.5583937205041,
          268.8701777080673
        ],
        "old_ci99_ms": [
          209.02203798493346,
          271.6922477293523
        ],
        "new_ci99_ms": [
          214.44579897095707,
          276.9827724576143
        ],
        "new_times": [
          0.28,
          0.21,
          0.19,
          0.2,
          0.19,
          0.26,
          0.21,
          0.23,
          0.21,
          0.25,
          0.2,
          0.25,
          0.23,
          0.24,
          0.21,
          0.2,
          0.22,
          0.27,
          0.25,
          0.26,
          0.18,
          0.27,
          0.17,
          0.42,
          0.41,
          0.3,
          0.26,
          0.31
        ],
        "old_times": [
          0.14,
          0.23,
          0.25,
          0.21,
          0.22,
          0.19,
          0.19,
          0.19,
          0.24,
          0.24,
          0.22,
          0.24,
          0.22,
          0.24,
          0.24,
          0.23,
          0.22,
          0.21,
          0.21,
          0.24,
          0.2,
          0.2,
          0.33,
          0.4,
          0.4,
          0.24,
          0.24,
          0.35
        ]
      },
      {
        "test_name": "TopologyTest.TestTopology",
        "is_significant": false,
        "p_value": 0.4235831882128401,
        "is_pair_significant": false,
        "pair_p_value": 0.4282426482039752,
        "is_binom_significant": false,
        "binom_p_value": 0.9999998919665813,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.999900755735832,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.27828469384122856,
        "relative_improvement": 0.06451612903225812,
        "absolute_improvement_ms": 0.714285714285716,
        "old_mean_ms": 11.071428571428575,
        "new_mean_ms": 10.357142857142858,
        "old_std_ms": 4.162696521251859,
        "new_std_ms": 1.8898223650461365,
        "effect_size_cohens_d": 0.22096287726310684,
        "old_ci95_ms": [
          9.457303366721765,
          12.685553776135382
        ],
        "new_ci95_ms": [
          9.624346244114186,
          11.08993947017153
        ],
        "old_ci99_ms": [
          8.891799620878913,
          13.251057521978234
        ],
        "new_ci99_ms": [
          9.367613229599403,
          11.346672484686314
        ],
        "new_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.02,
          0.01,
          0.01,
          0.01,
          0.01
        ],
        "old_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.03,
          0.01,
          0.01,
          0.01,
          0.01,
          0.02
        ]
      },
      {
        "test_name": "TopologyTest.TestCaches",
        "is_significant": false,
        "p_value": 0.6865503295334909,
        "is_pair_significant": false,
        "pair_p_value": 0.7084339915263311,
        "is_binom_significant": false,
        "binom_p_value": 0.9999984838068485,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9991175640504043,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.5060916695733031,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 11.42857142857143,
        "new_mean_ms": 11.42857142857143,
        "old_std_ms": 4.483951394230328,
        "new_std_ms": 4.483951394230328,
        "effect_size_cohens_d": 0.0,
        "old_ci95_ms": [
          9.689876588542399,
          13.167266268600462
        ],
        "new_ci95_ms": [
          9.689876588542399,
          13.167266268600462
        ],
        "old_ci99_ms": [
          9.08073025835257,
          13.77641259879029
        ],
        "new_ci99_ms": [
          9.08073025835257,
          13.77641259879029
        ],
        "new_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.03,
          0.02,
          0.01,
          0.01,
          0.02
        ],
        "old_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.02,
          0.01,
          0.03,
          0.01,
          0.02,
          0.01
        ]
      }
    ]
  },
  "logs": {
    "full_log_path": "/logs/full.log",
    "config_log_path": "/logs/config.log",
    "build_log_path": "/logs/build.log",
    "test_log_path": "/logs/test.log",
    "build_success": true,
    "test_success": true
  },
  "raw_timing_data": {
    "warmup_runs": 1,
    "measurement_runs": 30,
    "min_exec_time_improvement": 0.05,
    "min_p_value": 0.05
  }
}