{
  "metadata": {
    "collection_date": "2026-02-03T20:00:22.640022",
    "repository": "https://github.com/eliaskosunen/scnlib",
    "repository_name": "eliaskosunen/scnlib"
  },
  "commit_info": {
    "old_sha": "752c3fa204c14b2240e5465573e9ae8eaee36cda",
    "new_sha": "adf07a7cefe94c68549eda16a217e2c5296b2bc6",
    "commit_message": [
      "contiguous buffer optimizations"
    ],
    "commit_date": "2023-12-22T22:19:27+00:00",
    "patch": [
      "--- include/scn/detail/context.h\n@@ -65,23 +65,10 @@ namespace scn {\n         template <typename T>\n         using scanner_type = scanner<T, char_type>;\n \n-        constexpr basic_scan_context(buffer_type& buf,\n-                                     basic_scan_args<basic_scan_context> a,\n-                                     detail::locale_ref loc = {})\n-            : m_buffer(buf),\n-              m_current(buf.get().begin()),\n-              m_args(SCN_MOVE(a)),\n-              m_locale(loc)\n-        {\n-        }\n-\n         constexpr basic_scan_context(iterator curr,\n                                      basic_scan_args<basic_scan_context> a,\n                                      detail::locale_ref loc = {})\n-            : m_buffer(*curr.parent()),\n-              m_current(curr),\n-              m_args(SCN_MOVE(a)),\n-              m_locale(loc)\n+            : m_current(curr), m_args(SCN_MOVE(a)), m_locale(loc)\n         {\n         }\n \n@@ -136,7 +123,6 @@ namespace scn {\n         }\n \n     private:\n-        buffer_type& m_buffer;\n         iterator m_current;\n         basic_scan_args<basic_scan_context> m_args;\n         detail::locale_ref m_locale;\n--- include/scn/detail/input_map.h\n@@ -42,14 +42,20 @@ namespace scn {\n             inline auto impl(scan_buffer::range_type r, priority_tag<4>)\n                 SCN_NOEXCEPT->basic_scan_ref_buffer<char>\n             {\n-                SCN_EXPECT(r.begin().parent());\n+                if (!r.begin().stores_parent()) {\n+                    return basic_scan_ref_buffer{\n+                        r.begin().contiguous_segment()};\n+                }\n                 return basic_scan_ref_buffer{*r.begin().parent(),\n                                              r.begin().position()};\n             }\n             inline auto impl(wscan_buffer::range_type r, priority_tag<4>)\n                 SCN_NOEXCEPT->basic_scan_ref_buffer<wchar_t>\n             {\n-                SCN_EXPECT(r.begin().parent());\n+                if (!r.begin().stores_parent()) {\n+                    return basic_scan_ref_buffer{\n+                        r.begin().contiguous_segment()};\n+                }\n                 return basic_scan_ref_buffer{*r.begin().parent(),\n                                              r.begin().position()};\n             }\n--- include/scn/detail/scan_buffer.h\n@@ -147,19 +147,30 @@ namespace scn {\n                 return m_position;\n             }\n \n+            bool stores_parent() const\n+            {\n+                return m_end == nullptr;\n+            }\n+\n             basic_scan_buffer<CharT>* parent()\n             {\n-                return m_parent;\n+                SCN_EXPECT(stores_parent());\n+                return static_cast<basic_scan_buffer<CharT>*>(m_begin);\n             }\n             const basic_scan_buffer<CharT>* parent() const\n             {\n-                return m_parent;\n+                SCN_EXPECT(stores_parent());\n+                return static_cast<const basic_scan_buffer<CharT>*>(m_begin);\n             }\n \n             std::basic_string_view<CharT> contiguous_segment() const\n             {\n-                SCN_EXPECT(m_parent);\n-                return m_parent->get_segment_starting_at(position());\n+                if (!stores_parent()) {\n+                    return make_string_view_from_pointers(\n+                        static_cast<const CharT*>(m_begin) + position(),\n+                        static_cast<const CharT*>(m_end));\n+                }\n+                return parent()->get_segment_starting_at(position());\n             }\n             auto to_contiguous_segment_iterator() const\n             {\n@@ -168,7 +179,6 @@ namespace scn {\n \n             forward_iterator& operator++()\n             {\n-                SCN_EXPECT(m_parent);\n                 ++m_position;\n                 std::ignore = read_at_position();\n                 return *this;\n@@ -183,34 +193,31 @@ namespace scn {\n \n             CharT operator*() const\n             {\n-                SCN_EXPECT(m_parent);\n-                return m_parent->get_character_at(m_position);\n+                SCN_EXPECT(m_begin);\n+\n+                if (!stores_parent()) {\n+                    auto ptr = static_cast<const CharT*>(m_begin) + position();\n+                    SCN_EXPECT(ptr != m_end);\n+                    return *ptr;\n+                }\n+\n+                auto res = read_at_position();\n+                SCN_EXPECT(res);\n+                return parent()->get_character_at(m_position);\n             }\n \n             forward_iterator& batch_advance(std::ptrdiff_t n)\n             {\n-                SCN_EXPECT(m_parent);\n                 SCN_EXPECT(n >= 0);\n-\n                 m_position += n;\n-                SCN_ENSURE(m_position <= m_parent->chars_available());\n                 return *this;\n             }\n \n             friend bool operator==(const forward_iterator& lhs,\n                                    const forward_iterator& rhs)\n             {\n-                if (!lhs.m_parent && !rhs.m_parent) {\n-                    return true;\n-                }\n-                if (!lhs.m_parent) {\n-                    return ranges_std::default_sentinel == rhs;\n-                }\n-                if (!rhs.m_parent) {\n-                    return lhs == ranges_std::default_sentinel;\n-                }\n-                SCN_EXPECT(lhs.m_parent == rhs.m_parent);\n-                return lhs.m_position == rhs.m_position;\n+                return lhs.m_begin == rhs.m_begin &&\n+                       lhs.m_position == rhs.m_position;\n             }\n             friend bool operator!=(const forward_iterator& lhs,\n                                    const forward_iterator& rhs)\n@@ -243,23 +250,37 @@ namespace scn {\n         private:\n             friend class basic_scan_buffer<CharT>;\n \n-            forward_iterator(basic_scan_buffer<CharT>& parent,\n+            forward_iterator(basic_scan_buffer<CharT>* parent,\n+                             std::ptrdiff_t pos)\n+                : m_begin(parent), m_end(nullptr), m_position(pos)\n+            {\n+                SCN_EXPECT(parent);\n+                SCN_EXPECT(!parent->is_contiguous());\n+            }\n+\n+            forward_iterator(std::basic_string_view<CharT> view,\n                              std::ptrdiff_t pos)\n-                : m_parent(&parent), m_position(pos)\n+                : m_begin(const_cast<CharT*>(view.data())),\n+                  m_end(const_cast<CharT*>(view.data() + view.size())),\n+                  m_position(pos)\n             {\n             }\n \n             SCN_NODISCARD bool read_at_position() const\n             {\n-                if (SCN_LIKELY(m_position < m_parent->chars_available())) {\n+                SCN_EXPECT(m_begin);\n+\n+                if (!stores_parent()) {\n                     return true;\n                 }\n \n-                if (m_parent->is_contiguous()) {\n-                    return false;\n+                if (SCN_LIKELY(m_position < parent()->chars_available())) {\n+                    return true;\n                 }\n-                while (m_position >= m_parent->chars_available()) {\n-                    if (!m_parent->fill()) {\n+\n+                while (m_position >= parent()->chars_available()) {\n+                    if (!const_cast<basic_scan_buffer<CharT>*>(parent())\n+                             ->fill()) {\n                         return false;\n                     }\n                 }\n@@ -268,20 +289,32 @@ namespace scn {\n \n             SCN_NODISCARD bool is_at_end() const\n             {\n-                if (!m_parent) {\n+                if (m_end) {\n+                    return (static_cast<const CharT*>(m_begin) + position()) ==\n+                           m_end;\n+                }\n+                if (!m_begin) {\n                     return true;\n                 }\n                 return !read_at_position();\n             }\n \n-            basic_scan_buffer<CharT>* m_parent{nullptr};\n+            // If m_end is null, m_begin points to the parent scan_buffer\n+            // Otherwise, [m_begin, m_end) is the range of this iterator (and of\n+            // the entire range)\n+            mutable void* m_begin{nullptr};\n+            mutable void* m_end{nullptr};\n             std::ptrdiff_t m_position{0};\n         };\n \n         template <typename CharT>\n         SCN_NODISCARD auto basic_scan_buffer<CharT>::get() -> range_type\n         {\n-            return ranges::subrange{forward_iterator{*this, 0},\n+            if (is_contiguous()) {\n+                return ranges::subrange{forward_iterator{m_current_view, 0},\n+                                        ranges_std::default_sentinel};\n+            }\n+            return ranges::subrange{forward_iterator{this, 0},\n                                     ranges_std::default_sentinel};\n         }\n \n@@ -385,7 +418,7 @@ namespace scn {\n         public:\n             basic_scan_ref_buffer(base& other, std::ptrdiff_t starting_pos)\n                 : base(other.is_contiguous(), std::basic_string_view<CharT>{}),\n-                  m_other(other),\n+                  m_other(&other),\n                   m_starting_pos(starting_pos)\n             {\n                 this->m_current_view =\n@@ -395,31 +428,45 @@ namespace scn {\n                     this->m_current_view.end();\n             }\n \n+            basic_scan_ref_buffer(std::basic_string_view<CharT> view)\n+                : base(true, view), m_other(nullptr)\n+            {\n+            }\n+\n             bool fill() override\n             {\n+                if (!m_other) {\n+                    return false;\n+                }\n+                SCN_EXPECT(m_starting_pos >= 0);\n+\n                 if (m_fill_needs_to_propagate) {\n-                    auto ret = m_other.fill();\n-                    this->m_current_view = m_other.current_view();\n+                    auto ret = m_other->fill();\n+                    this->m_current_view = m_other->current_view();\n                     this->m_putback_buffer =\n-                        m_other.putback_buffer().substr(m_starting_pos);\n+                        m_other->putback_buffer().substr(m_starting_pos);\n                     return ret;\n                 }\n \n                 m_fill_needs_to_propagate = true;\n                 this->m_putback_buffer =\n                     std::basic_string<CharT>{this->m_current_view};\n-                this->m_current_view = m_other.current_view();\n+                this->m_current_view = m_other->current_view();\n                 return true;\n             }\n \n         private:\n-            base& m_other;\n-            std::ptrdiff_t m_starting_pos;\n+            base* m_other;\n+            std::ptrdiff_t m_starting_pos{-1};\n             bool m_fill_needs_to_propagate{false};\n         };\n \n         template <typename CharT>\n-        basic_scan_ref_buffer(basic_scan_buffer<CharT>&)\n+        basic_scan_ref_buffer(basic_scan_buffer<CharT>&, std::ptrdiff_t)\n+            -> basic_scan_ref_buffer<CharT>;\n+\n+        template <typename CharT>\n+        basic_scan_ref_buffer(std::basic_string_view<CharT>)\n             -> basic_scan_ref_buffer<CharT>;\n \n         template <typename Range>\n--- src/scn/impl/algorithms/common.h\n@@ -37,8 +37,11 @@ namespace scn {\n                 std::is_same_v<ranges::iterator_t<Range>,\n                                typename detail::basic_scan_buffer<\n                                    detail::char_t<Range>>::forward_iterator>) {\n-                SCN_EXPECT(ranges::begin(r).parent());\n-                return ranges::begin(r).parent()->is_contiguous();\n+                auto beg = ranges::begin(r);\n+                if (!beg.stores_parent()) {\n+                    return true;\n+                }\n+                return beg.parent()->is_contiguous();\n             }\n             else {\n                 return false;\n@@ -56,14 +59,17 @@ namespace scn {\n                 std::is_same_v<ranges::iterator_t<Range>,\n                                typename detail::basic_scan_buffer<\n                                    detail::char_t<Range>>::forward_iterator>) {\n-                SCN_EXPECT(ranges::begin(r).parent());\n+                auto beg = ranges::begin(r);\n                 if constexpr (ranges::common_range<Range>) {\n-                    return ranges::begin(r).contiguous_segment().end() ==\n+                    return beg.contiguous_segment().end() ==\n                            ranges::end(r).contiguous_segment().end();\n                 }\n                 else {\n-                    return ranges::begin(r).contiguous_segment().end() ==\n-                           ranges::begin(r).parent()->current_view().end();\n+                    if (beg.stores_parent()) {\n+                        return beg.contiguous_segment().end() ==\n+                               beg.parent()->current_view().end();\n+                    }\n+                    return true;\n                 }\n             }\n             else {\n@@ -82,7 +88,6 @@ namespace scn {\n                 std::is_same_v<ranges::iterator_t<Range>,\n                                typename detail::basic_scan_buffer<\n                                    detail::char_t<Range>>::forward_iterator>) {\n-                SCN_EXPECT(ranges::begin(r).parent());\n                 if constexpr (ranges::common_range<Range>) {\n                     auto seg = ranges::begin(r).contiguous_segment();\n                     auto dist =\n@@ -110,7 +115,6 @@ namespace scn {\n                 std::is_same_v<ranges::iterator_t<Range>,\n                                typename detail::basic_scan_buffer<\n                                    detail::char_t<Range>>::forward_iterator>) {\n-                SCN_EXPECT(ranges::begin(r).parent());\n                 if constexpr (ranges::common_range<Range>) {\n                     auto seg = ranges::begin(r).contiguous_segment();\n                     auto dist =\n@@ -170,9 +174,12 @@ namespace scn {\n                                                ranges::begin(r).position());\n                 }\n                 else {\n-                    return static_cast<size_t>(\n-                        ranges::begin(r).parent()->chars_available() -\n-                        ranges::begin(r).position());\n+                    if (ranges::begin(r).stores_parent()) {\n+                        return static_cast<size_t>(\n+                            ranges::begin(r).parent()->chars_available() -\n+                            ranges::begin(r).position());\n+                    }\n+                    return ranges::begin(r).contiguous_segment().size();\n                 }\n             }\n             else {\n--- src/scn/impl/algorithms/contiguous_range_factory.h\n@@ -98,7 +98,7 @@ namespace scn {\n             }\n \n             contiguous_range_factory(string_view_wrapper<CharT> svw)\n-                : m_buffer(std::in_place_type<string_view_type>, svw.view())\n+                : m_storage(std::nullopt), m_view(svw.view())\n             {\n             }\n \n@@ -111,33 +111,28 @@ namespace scn {\n \n             string_view_type view() const\n             {\n-                if (!stores_allocated_string()) {\n-                    return std::get<string_view_type>(m_buffer);\n-                }\n-\n-                const auto& str = get_allocated_string();\n-                return {str.data(), str.size()};\n+                return m_view;\n             }\n \n             constexpr bool stores_allocated_string() const\n             {\n-                return std::holds_alternative<string_type>(m_buffer);\n+                return m_storage.has_value();\n             }\n \n             string_type& get_allocated_string() &\n             {\n                 SCN_EXPECT(stores_allocated_string());\n-                return std::get<string_type>(m_buffer);\n+                return *m_storage;\n             }\n             const string_type& get_allocated_string() const&\n             {\n                 SCN_EXPECT(stores_allocated_string());\n-                return std::get<string_type>(m_buffer);\n+                return *m_storage;\n             }\n-            string_type get_allocated_string() &&\n+            string_type&& get_allocated_string() &&\n             {\n                 SCN_EXPECT(stores_allocated_string());\n-                return std::get<string_type>(SCN_MOVE(m_buffer));\n+                return *m_storage;\n             }\n \n             string_type& make_into_allocated_string()\n@@ -146,9 +141,9 @@ namespace scn {\n                     return get_allocated_string();\n                 }\n \n-                auto sv = std::get<string_view_type>(m_buffer);\n-                return m_buffer.template emplace<string_type>(sv.data(),\n-                                                              sv.size());\n+                auto& str = m_storage.emplace(m_view.data(), m_view.size());\n+                m_view = string_view_type{str.data(), str.size()};\n+                return str;\n             }\n \n         private:\n@@ -159,46 +154,49 @@ namespace scn {\n                 if constexpr (ranges::borrowed_range<Range> &&\n                               ranges::contiguous_range<Range> &&\n                               ranges::sized_range<Range>) {\n-                    m_buffer.template emplace<string_view_type>(\n-                        ranges::data(range), ranges_polyfill::usize(range));\n+                    m_storage.reset();\n+                    m_view = string_view_type{ranges::data(range),\n+                                              ranges_polyfill::usize(range)};\n                 }\n                 else if constexpr (std::is_same_v<detail::remove_cvref_t<Range>,\n                                                   std::basic_string<CharT>>) {\n-                    m_buffer.template emplace<string_type>(SCN_FWD(range));\n+                    m_storage.emplace(SCN_FWD(range));\n+                    m_view = string_view_type{*m_storage};\n                 }\n                 else if constexpr (std::is_same_v<\n                                        ranges::iterator_t<Range>,\n                                        typename detail::basic_scan_buffer<\n                                            value_t>::forward_iterator> &&\n                                    ranges::common_range<Range>) {\n-                    SCN_EXPECT(range.begin().parent() && range.end().parent());\n-\n                     auto beg_seg = range.begin().contiguous_segment();\n                     auto end_seg = range.end().contiguous_segment();\n-                    if (beg_seg.end() != end_seg.end()) {\n-                        auto& str = m_buffer.template emplace<string_type>();\n+                    if (SCN_UNLIKELY(beg_seg.end() != end_seg.end())) {\n+                        auto& str = m_storage.emplace();\n                         str.reserve(range.end().position() -\n                                     range.begin().position());\n                         std::copy(range.begin(), range.end(),\n                                   std::back_inserter(str));\n+                        m_view = string_view_type{str};\n                         return;\n                     }\n \n-                    auto sv = detail::make_string_view_from_pointers(\n+                    m_view = detail::make_string_view_from_pointers(\n                         beg_seg.data(), end_seg.data());\n-                    m_buffer.template emplace<string_view_type>(sv);\n+                    m_storage.reset();\n                 }\n                 else {\n-                    auto& str = m_buffer.template emplace<string_type>();\n+                    auto& str = m_storage.emplace();\n                     if constexpr (ranges::sized_range<Range>) {\n                         str.reserve(ranges_polyfill::usize(range));\n                     }\n                     std::copy(ranges::begin(range), ranges::end(range),\n                               std::back_inserter(str));\n+                    m_view = string_view_type{str};\n                 }\n             }\n \n-            std::variant<string_view_type, string_type> m_buffer{};\n+            std::optional<string_type> m_storage{std::nullopt};\n+            string_view_type m_view{};\n         };\n \n         template <typename Range>\n--- src/scn/impl/algorithms/read.h\n@@ -443,6 +443,7 @@ namespace scn {\n \n             SCN_TRY(it, read_exactly_n_code_units(range, ranges::ssize(str)));\n \n+#if 0\n             auto buf = make_contiguous_buffer(\n                 ranges::subrange{ranges::begin(range), it});\n \n@@ -460,10 +461,10 @@ namespace scn {\n                     return it;\n                 }\n             }\n+#endif\n \n             if (SCN_UNLIKELY(!std::equal(\n-                    buf.view().begin(), buf.view().end(), str.begin(),\n-                    [&](auto a, auto b) {\n+                    ranges::begin(range), it, str.begin(), [&](auto a, auto b) {\n                         return ascii_tolower(a) ==\n                                static_cast<detail::char_t<Range>>(b);\n                     }))) {\n--- src/scn/vscan.cpp\n@@ -225,7 +225,7 @@ namespace scn {\n                            std::size_t argcount)\n                 : format_handler_base{argcount},\n                   parse_ctx{format},\n-                  ctx{source, SCN_MOVE(args), SCN_MOVE(loc)}\n+                  ctx{source.get().begin(), SCN_MOVE(args), SCN_MOVE(loc)}\n             {\n             }\n "
    ],
    "files_changed": [
      {
        "filename": "include/scn/detail/context.h",
        "status": "modified",
        "additions": 1,
        "deletions": 15,
        "changes": 16,
        "patch": "@@ -65,23 +65,10 @@ namespace scn {\n         template <typename T>\n         using scanner_type = scanner<T, char_type>;\n \n-        constexpr basic_scan_context(buffer_type& buf,\n-                                     basic_scan_args<basic_scan_context> a,\n-                                     detail::locale_ref loc = {})\n-            : m_buffer(buf),\n-              m_current(buf.get().begin()),\n-              m_args(SCN_MOVE(a)),\n-              m_locale(loc)\n-        {\n-        }\n-\n         constexpr basic_scan_context(iterator curr,\n                                      basic_scan_args<basic_scan_context> a,\n                                      detail::locale_ref loc = {})\n-            : m_buffer(*curr.parent()),\n-              m_current(curr),\n-              m_args(SCN_MOVE(a)),\n-              m_locale(loc)\n+            : m_current(curr), m_args(SCN_MOVE(a)), m_locale(loc)\n         {\n         }\n \n@@ -136,7 +123,6 @@ namespace scn {\n         }\n \n     private:\n-        buffer_type& m_buffer;\n         iterator m_current;\n         basic_scan_args<basic_scan_context> m_args;\n         detail::locale_ref m_locale;"
      },
      {
        "filename": "include/scn/detail/input_map.h",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "patch": "@@ -42,14 +42,20 @@ namespace scn {\n             inline auto impl(scan_buffer::range_type r, priority_tag<4>)\n                 SCN_NOEXCEPT->basic_scan_ref_buffer<char>\n             {\n-                SCN_EXPECT(r.begin().parent());\n+                if (!r.begin().stores_parent()) {\n+                    return basic_scan_ref_buffer{\n+                        r.begin().contiguous_segment()};\n+                }\n                 return basic_scan_ref_buffer{*r.begin().parent(),\n                                              r.begin().position()};\n             }\n             inline auto impl(wscan_buffer::range_type r, priority_tag<4>)\n                 SCN_NOEXCEPT->basic_scan_ref_buffer<wchar_t>\n             {\n-                SCN_EXPECT(r.begin().parent());\n+                if (!r.begin().stores_parent()) {\n+                    return basic_scan_ref_buffer{\n+                        r.begin().contiguous_segment()};\n+                }\n                 return basic_scan_ref_buffer{*r.begin().parent(),\n                                              r.begin().position()};\n             }"
      },
      {
        "filename": "include/scn/detail/scan_buffer.h",
        "status": "modified",
        "additions": 86,
        "deletions": 39,
        "changes": 125,
        "patch": "@@ -147,19 +147,30 @@ namespace scn {\n                 return m_position;\n             }\n \n+            bool stores_parent() const\n+            {\n+                return m_end == nullptr;\n+            }\n+\n             basic_scan_buffer<CharT>* parent()\n             {\n-                return m_parent;\n+                SCN_EXPECT(stores_parent());\n+                return static_cast<basic_scan_buffer<CharT>*>(m_begin);\n             }\n             const basic_scan_buffer<CharT>* parent() const\n             {\n-                return m_parent;\n+                SCN_EXPECT(stores_parent());\n+                return static_cast<const basic_scan_buffer<CharT>*>(m_begin);\n             }\n \n             std::basic_string_view<CharT> contiguous_segment() const\n             {\n-                SCN_EXPECT(m_parent);\n-                return m_parent->get_segment_starting_at(position());\n+                if (!stores_parent()) {\n+                    return make_string_view_from_pointers(\n+                        static_cast<const CharT*>(m_begin) + position(),\n+                        static_cast<const CharT*>(m_end));\n+                }\n+                return parent()->get_segment_starting_at(position());\n             }\n             auto to_contiguous_segment_iterator() const\n             {\n@@ -168,7 +179,6 @@ namespace scn {\n \n             forward_iterator& operator++()\n             {\n-                SCN_EXPECT(m_parent);\n                 ++m_position;\n                 std::ignore = read_at_position();\n                 return *this;\n@@ -183,34 +193,31 @@ namespace scn {\n \n             CharT operator*() const\n             {\n-                SCN_EXPECT(m_parent);\n-                return m_parent->get_character_at(m_position);\n+                SCN_EXPECT(m_begin);\n+\n+                if (!stores_parent()) {\n+                    auto ptr = static_cast<const CharT*>(m_begin) + position();\n+                    SCN_EXPECT(ptr != m_end);\n+                    return *ptr;\n+                }\n+\n+                auto res = read_at_position();\n+                SCN_EXPECT(res);\n+                return parent()->get_character_at(m_position);\n             }\n \n             forward_iterator& batch_advance(std::ptrdiff_t n)\n             {\n-                SCN_EXPECT(m_parent);\n                 SCN_EXPECT(n >= 0);\n-\n                 m_position += n;\n-                SCN_ENSURE(m_position <= m_parent->chars_available());\n                 return *this;\n             }\n \n             friend bool operator==(const forward_iterator& lhs,\n                                    const forward_iterator& rhs)\n             {\n-                if (!lhs.m_parent && !rhs.m_parent) {\n-                    return true;\n-                }\n-                if (!lhs.m_parent) {\n-                    return ranges_std::default_sentinel == rhs;\n-                }\n-                if (!rhs.m_parent) {\n-                    return lhs == ranges_std::default_sentinel;\n-                }\n-                SCN_EXPECT(lhs.m_parent == rhs.m_parent);\n-                return lhs.m_position == rhs.m_position;\n+                return lhs.m_begin == rhs.m_begin &&\n+                       lhs.m_position == rhs.m_position;\n             }\n             friend bool operator!=(const forward_iterator& lhs,\n                                    const forward_iterator& rhs)\n@@ -243,23 +250,37 @@ namespace scn {\n         private:\n             friend class basic_scan_buffer<CharT>;\n \n-            forward_iterator(basic_scan_buffer<CharT>& parent,\n+            forward_iterator(basic_scan_buffer<CharT>* parent,\n+                             std::ptrdiff_t pos)\n+                : m_begin(parent), m_end(nullptr), m_position(pos)\n+            {\n+                SCN_EXPECT(parent);\n+                SCN_EXPECT(!parent->is_contiguous());\n+            }\n+\n+            forward_iterator(std::basic_string_view<CharT> view,\n                              std::ptrdiff_t pos)\n-                : m_parent(&parent), m_position(pos)\n+                : m_begin(const_cast<CharT*>(view.data())),\n+                  m_end(const_cast<CharT*>(view.data() + view.size())),\n+                  m_position(pos)\n             {\n             }\n \n             SCN_NODISCARD bool read_at_position() const\n             {\n-                if (SCN_LIKELY(m_position < m_parent->chars_available())) {\n+                SCN_EXPECT(m_begin);\n+\n+                if (!stores_parent()) {\n                     return true;\n                 }\n \n-                if (m_parent->is_contiguous()) {\n-                    return false;\n+                if (SCN_LIKELY(m_position < parent()->chars_available())) {\n+                    return true;\n                 }\n-                while (m_position >= m_parent->chars_available()) {\n-                    if (!m_parent->fill()) {\n+\n+                while (m_position >= parent()->chars_available()) {\n+                    if (!const_cast<basic_scan_buffer<CharT>*>(parent())\n+                             ->fill()) {\n                         return false;\n                     }\n                 }\n@@ -268,20 +289,32 @@ namespace scn {\n \n             SCN_NODISCARD bool is_at_end() const\n             {\n-                if (!m_parent) {\n+                if (m_end) {\n+                    return (static_cast<const CharT*>(m_begin) + position()) ==\n+                           m_end;\n+                }\n+                if (!m_begin) {\n                     return true;\n                 }\n                 return !read_at_position();\n             }\n \n-            basic_scan_buffer<CharT>* m_parent{nullptr};\n+            // If m_end is null, m_begin points to the parent scan_buffer\n+            // Otherwise, [m_begin, m_end) is the range of this iterator (and of\n+            // the entire range)\n+            mutable void* m_begin{nullptr};\n+            mutable void* m_end{nullptr};\n             std::ptrdiff_t m_position{0};\n         };\n \n         template <typename CharT>\n         SCN_NODISCARD auto basic_scan_buffer<CharT>::get() -> range_type\n         {\n-            return ranges::subrange{forward_iterator{*this, 0},\n+            if (is_contiguous()) {\n+                return ranges::subrange{forward_iterator{m_current_view, 0},\n+                                        ranges_std::default_sentinel};\n+            }\n+            return ranges::subrange{forward_iterator{this, 0},\n                                     ranges_std::default_sentinel};\n         }\n \n@@ -385,7 +418,7 @@ namespace scn {\n         public:\n             basic_scan_ref_buffer(base& other, std::ptrdiff_t starting_pos)\n                 : base(other.is_contiguous(), std::basic_string_view<CharT>{}),\n-                  m_other(other),\n+                  m_other(&other),\n                   m_starting_pos(starting_pos)\n             {\n                 this->m_current_view =\n@@ -395,31 +428,45 @@ namespace scn {\n                     this->m_current_view.end();\n             }\n \n+            basic_scan_ref_buffer(std::basic_string_view<CharT> view)\n+                : base(true, view), m_other(nullptr)\n+            {\n+            }\n+\n             bool fill() override\n             {\n+                if (!m_other) {\n+                    return false;\n+                }\n+                SCN_EXPECT(m_starting_pos >= 0);\n+\n                 if (m_fill_needs_to_propagate) {\n-                    auto ret = m_other.fill();\n-                    this->m_current_view = m_other.current_view();\n+                    auto ret = m_other->fill();\n+                    this->m_current_view = m_other->current_view();\n                     this->m_putback_buffer =\n-                        m_other.putback_buffer().substr(m_starting_pos);\n+                        m_other->putback_buffer().substr(m_starting_pos);\n                     return ret;\n                 }\n \n                 m_fill_needs_to_propagate = true;\n                 this->m_putback_buffer =\n                     std::basic_string<CharT>{this->m_current_view};\n-                this->m_current_view = m_other.current_view();\n+                this->m_current_view = m_other->current_view();\n                 return true;\n             }\n \n         private:\n-            base& m_other;\n-            std::ptrdiff_t m_starting_pos;\n+            base* m_other;\n+            std::ptrdiff_t m_starting_pos{-1};\n             bool m_fill_needs_to_propagate{false};\n         };\n \n         template <typename CharT>\n-        basic_scan_ref_buffer(basic_scan_buffer<CharT>&)\n+        basic_scan_ref_buffer(basic_scan_buffer<CharT>&, std::ptrdiff_t)\n+            -> basic_scan_ref_buffer<CharT>;\n+\n+        template <typename CharT>\n+        basic_scan_ref_buffer(std::basic_string_view<CharT>)\n             -> basic_scan_ref_buffer<CharT>;\n \n         template <typename Range>"
      },
      {
        "filename": "src/scn/impl/algorithms/common.h",
        "status": "modified",
        "additions": 18,
        "deletions": 11,
        "changes": 29,
        "patch": "@@ -37,8 +37,11 @@ namespace scn {\n                 std::is_same_v<ranges::iterator_t<Range>,\n                                typename detail::basic_scan_buffer<\n                                    detail::char_t<Range>>::forward_iterator>) {\n-                SCN_EXPECT(ranges::begin(r).parent());\n-                return ranges::begin(r).parent()->is_contiguous();\n+                auto beg = ranges::begin(r);\n+                if (!beg.stores_parent()) {\n+                    return true;\n+                }\n+                return beg.parent()->is_contiguous();\n             }\n             else {\n                 return false;\n@@ -56,14 +59,17 @@ namespace scn {\n                 std::is_same_v<ranges::iterator_t<Range>,\n                                typename detail::basic_scan_buffer<\n                                    detail::char_t<Range>>::forward_iterator>) {\n-                SCN_EXPECT(ranges::begin(r).parent());\n+                auto beg = ranges::begin(r);\n                 if constexpr (ranges::common_range<Range>) {\n-                    return ranges::begin(r).contiguous_segment().end() ==\n+                    return beg.contiguous_segment().end() ==\n                            ranges::end(r).contiguous_segment().end();\n                 }\n                 else {\n-                    return ranges::begin(r).contiguous_segment().end() ==\n-                           ranges::begin(r).parent()->current_view().end();\n+                    if (beg.stores_parent()) {\n+                        return beg.contiguous_segment().end() ==\n+                               beg.parent()->current_view().end();\n+                    }\n+                    return true;\n                 }\n             }\n             else {\n@@ -82,7 +88,6 @@ namespace scn {\n                 std::is_same_v<ranges::iterator_t<Range>,\n                                typename detail::basic_scan_buffer<\n                                    detail::char_t<Range>>::forward_iterator>) {\n-                SCN_EXPECT(ranges::begin(r).parent());\n                 if constexpr (ranges::common_range<Range>) {\n                     auto seg = ranges::begin(r).contiguous_segment();\n                     auto dist =\n@@ -110,7 +115,6 @@ namespace scn {\n                 std::is_same_v<ranges::iterator_t<Range>,\n                                typename detail::basic_scan_buffer<\n                                    detail::char_t<Range>>::forward_iterator>) {\n-                SCN_EXPECT(ranges::begin(r).parent());\n                 if constexpr (ranges::common_range<Range>) {\n                     auto seg = ranges::begin(r).contiguous_segment();\n                     auto dist =\n@@ -170,9 +174,12 @@ namespace scn {\n                                                ranges::begin(r).position());\n                 }\n                 else {\n-                    return static_cast<size_t>(\n-                        ranges::begin(r).parent()->chars_available() -\n-                        ranges::begin(r).position());\n+                    if (ranges::begin(r).stores_parent()) {\n+                        return static_cast<size_t>(\n+                            ranges::begin(r).parent()->chars_available() -\n+                            ranges::begin(r).position());\n+                    }\n+                    return ranges::begin(r).contiguous_segment().size();\n                 }\n             }\n             else {"
      },
      {
        "filename": "src/scn/impl/algorithms/contiguous_range_factory.h",
        "status": "modified",
        "additions": 24,
        "deletions": 26,
        "changes": 50,
        "patch": "@@ -98,7 +98,7 @@ namespace scn {\n             }\n \n             contiguous_range_factory(string_view_wrapper<CharT> svw)\n-                : m_buffer(std::in_place_type<string_view_type>, svw.view())\n+                : m_storage(std::nullopt), m_view(svw.view())\n             {\n             }\n \n@@ -111,33 +111,28 @@ namespace scn {\n \n             string_view_type view() const\n             {\n-                if (!stores_allocated_string()) {\n-                    return std::get<string_view_type>(m_buffer);\n-                }\n-\n-                const auto& str = get_allocated_string();\n-                return {str.data(), str.size()};\n+                return m_view;\n             }\n \n             constexpr bool stores_allocated_string() const\n             {\n-                return std::holds_alternative<string_type>(m_buffer);\n+                return m_storage.has_value();\n             }\n \n             string_type& get_allocated_string() &\n             {\n                 SCN_EXPECT(stores_allocated_string());\n-                return std::get<string_type>(m_buffer);\n+                return *m_storage;\n             }\n             const string_type& get_allocated_string() const&\n             {\n                 SCN_EXPECT(stores_allocated_string());\n-                return std::get<string_type>(m_buffer);\n+                return *m_storage;\n             }\n-            string_type get_allocated_string() &&\n+            string_type&& get_allocated_string() &&\n             {\n                 SCN_EXPECT(stores_allocated_string());\n-                return std::get<string_type>(SCN_MOVE(m_buffer));\n+                return *m_storage;\n             }\n \n             string_type& make_into_allocated_string()\n@@ -146,9 +141,9 @@ namespace scn {\n                     return get_allocated_string();\n                 }\n \n-                auto sv = std::get<string_view_type>(m_buffer);\n-                return m_buffer.template emplace<string_type>(sv.data(),\n-                                                              sv.size());\n+                auto& str = m_storage.emplace(m_view.data(), m_view.size());\n+                m_view = string_view_type{str.data(), str.size()};\n+                return str;\n             }\n \n         private:\n@@ -159,46 +154,49 @@ namespace scn {\n                 if constexpr (ranges::borrowed_range<Range> &&\n                               ranges::contiguous_range<Range> &&\n                               ranges::sized_range<Range>) {\n-                    m_buffer.template emplace<string_view_type>(\n-                        ranges::data(range), ranges_polyfill::usize(range));\n+                    m_storage.reset();\n+                    m_view = string_view_type{ranges::data(range),\n+                                              ranges_polyfill::usize(range)};\n                 }\n                 else if constexpr (std::is_same_v<detail::remove_cvref_t<Range>,\n                                                   std::basic_string<CharT>>) {\n-                    m_buffer.template emplace<string_type>(SCN_FWD(range));\n+                    m_storage.emplace(SCN_FWD(range));\n+                    m_view = string_view_type{*m_storage};\n                 }\n                 else if constexpr (std::is_same_v<\n                                        ranges::iterator_t<Range>,\n                                        typename detail::basic_scan_buffer<\n                                            value_t>::forward_iterator> &&\n                                    ranges::common_range<Range>) {\n-                    SCN_EXPECT(range.begin().parent() && range.end().parent());\n-\n                     auto beg_seg = range.begin().contiguous_segment();\n                     auto end_seg = range.end().contiguous_segment();\n-                    if (beg_seg.end() != end_seg.end()) {\n-                        auto& str = m_buffer.template emplace<string_type>();\n+                    if (SCN_UNLIKELY(beg_seg.end() != end_seg.end())) {\n+                        auto& str = m_storage.emplace();\n                         str.reserve(range.end().position() -\n                                     range.begin().position());\n                         std::copy(range.begin(), range.end(),\n                                   std::back_inserter(str));\n+                        m_view = string_view_type{str};\n                         return;\n                     }\n \n-                    auto sv = detail::make_string_view_from_pointers(\n+                    m_view = detail::make_string_view_from_pointers(\n                         beg_seg.data(), end_seg.data());\n-                    m_buffer.template emplace<string_view_type>(sv);\n+                    m_storage.reset();\n                 }\n                 else {\n-                    auto& str = m_buffer.template emplace<string_type>();\n+                    auto& str = m_storage.emplace();\n                     if constexpr (ranges::sized_range<Range>) {\n                         str.reserve(ranges_polyfill::usize(range));\n                     }\n                     std::copy(ranges::begin(range), ranges::end(range),\n                               std::back_inserter(str));\n+                    m_view = string_view_type{str};\n                 }\n             }\n \n-            std::variant<string_view_type, string_type> m_buffer{};\n+            std::optional<string_type> m_storage{std::nullopt};\n+            string_view_type m_view{};\n         };\n \n         template <typename Range>"
      },
      {
        "filename": "src/scn/impl/algorithms/read.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "patch": "@@ -443,6 +443,7 @@ namespace scn {\n \n             SCN_TRY(it, read_exactly_n_code_units(range, ranges::ssize(str)));\n \n+#if 0\n             auto buf = make_contiguous_buffer(\n                 ranges::subrange{ranges::begin(range), it});\n \n@@ -460,10 +461,10 @@ namespace scn {\n                     return it;\n                 }\n             }\n+#endif\n \n             if (SCN_UNLIKELY(!std::equal(\n-                    buf.view().begin(), buf.view().end(), str.begin(),\n-                    [&](auto a, auto b) {\n+                    ranges::begin(range), it, str.begin(), [&](auto a, auto b) {\n                         return ascii_tolower(a) ==\n                                static_cast<detail::char_t<Range>>(b);\n                     }))) {"
      },
      {
        "filename": "src/scn/vscan.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -225,7 +225,7 @@ namespace scn {\n                            std::size_t argcount)\n                 : format_handler_base{argcount},\n                   parse_ctx{format},\n-                  ctx{source, SCN_MOVE(args), SCN_MOVE(loc)}\n+                  ctx{source.get().begin(), SCN_MOVE(args), SCN_MOVE(loc)}\n             {\n             }\n "
      }
    ],
    "lines_added": 141,
    "lines_removed": 96
  },
  "issues": [],
  "pull_requests": [],
  "build_info": {
    "old_build_script": [
      "apt-get update",
      "cmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON",
      "cmake --build /test_workspace/workspace/old/build -- -j 1"
    ],
    "new_build_script": [
      "apt-get update",
      "cmake -S /test_workspace/workspace/new -B /test_workspace/workspace/new/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON",
      "cmake --build /test_workspace/workspace/new/build -- -j 1"
    ],
    "old_test_script": [
      "cd /test_workspace/workspace/old/build",
      "ctest --output-on-failure"
    ],
    "new_test_script": [
      "cd /test_workspace/workspace/new/build",
      "ctest --output-on-failure"
    ],
    "build_system": "cmake"
  },
  "performance_analysis": {
    "is_significant": false,
    "p_value": 0.999819107492696,
    "is_pair_significant": false,
    "pair_p_value": 0.9993754409069421,
    "is_binom_significant": false,
    "binom_p_value": 0.9999957848340273,
    "is_wilcoxon_significant": false,
    "wilcoxon_p_value": 0.9966747767159938,
    "is_mannwhitney_significant": false,
    "mannwhitney_p_value": 0.09483119988207295,
    "relative_improvement": 0.008196721311475417,
    "absolute_improvement_ms": 0.6666666666666626,
    "old_mean_ms": 81.33333333333334,
    "new_mean_ms": 80.66666666666667,
    "old_std_ms": 3.457459036417602,
    "new_std_ms": 3.651483716701108,
    "effect_size_cohens_d": 0.18748737331221732,
    "old_ci95_ms": [
      80.04229691154525,
      82.62436975512142
    ],
    "new_ci95_ms": [
      79.30318023857821,
      82.03015309475515
    ],
    "old_ci99_ms": [
      79.59338466408227,
      83.07328200258442
    ],
    "new_ci99_ms": [
      78.82907606421979,
      82.50425726911357
    ],
    "new_times_s": [
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.1,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08
    ],
    "old_times_s": [
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.09,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.09,
      0.08,
      0.08,
      0.08,
      0.08,
      0.09,
      0.09,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08,
      0.08
    ]
  },
  "tests": {
    "total_tests": 3,
    "significant_improvements": 0,
    "significant_improvements_tests": [],
    "significant_regressions": 0,
    "significant_regressions_tests": [],
    "significant_pair_improvements": 0,
    "significant_pair_improvements_tests": [],
    "significant_pair_regressions": 0,
    "significant_pair_regressions_tests": [],
    "significant_binom_improvements": 0,
    "significant_binom_improvements_tests": [],
    "significant_binom_regressions": 0,
    "significant_binom_regressions_tests": [],
    "significant_wilcoxon_improvements": 0,
    "significant_wilcoxon_improvements_tests": [],
    "significant_wilcoxon_regressions": 0,
    "significant_wilcoxon_regressions_tests": [],
    "significant_mannwhitney_improvements": 0,
    "significant_mannwhitney_improvements_tests": [],
    "significant_mannwhitney_regressions": 0,
    "significant_mannwhitney_regressions_tests": [],
    "tests": [
      {
        "test_name": "scn_tests",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999393422746,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 1.0,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 10.0,
        "new_mean_ms": 10.0,
        "old_std_ms": 0.0,
        "new_std_ms": 0.0,
        "effect_size_cohens_d": "NaN",
        "old_ci95_ms": [
          10.0,
          10.0
        ],
        "new_ci95_ms": [
          10.0,
          10.0
        ],
        "old_ci99_ms": [
          10.0,
          10.0
        ],
        "new_ci99_ms": [
          10.0,
          10.0
        ],
        "new_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ],
        "old_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ]
      },
      {
        "test_name": "scn_impl_tests",
        "is_significant": false,
        "p_value": 0.9782267310840373,
        "is_pair_significant": false,
        "pair_p_value": 0.9889591499354751,
        "is_binom_significant": false,
        "binom_p_value": 0.9999862797558308,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.993213606356576,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.11506967022170822,
        "relative_improvement": 0.017964071856287442,
        "absolute_improvement_ms": 1.0714285714285774,
        "old_mean_ms": 59.64285714285715,
        "new_mean_ms": 58.57142857142857,
        "old_std_ms": 1.889822365046135,
        "new_std_ms": 4.483951394230327,
        "effect_size_cohens_d": 0.3113956944652984,
        "old_ci95_ms": [
          58.91006052982848,
          60.37565375588582
        ],
        "new_ci95_ms": [
          56.83273373139954,
          60.3101234114576
        ],
        "old_ci99_ms": [
          58.65332751531369,
          60.63238677040061
        ],
        "new_ci99_ms": [
          56.22358740120971,
          60.91926974164743
        ],
        "new_times": [
          0.05,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.05,
          0.06,
          0.06,
          0.06,
          0.05,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.05,
          0.06,
          0.05,
          0.07,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06
        ],
        "old_times": [
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.05,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06,
          0.06
        ]
      },
      {
        "test_name": "scn_stdin_test",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999393422746,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 1.0,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 10.0,
        "new_mean_ms": 10.0,
        "old_std_ms": 0.0,
        "new_std_ms": 0.0,
        "effect_size_cohens_d": "NaN",
        "old_ci95_ms": [
          10.0,
          10.0
        ],
        "new_ci95_ms": [
          10.0,
          10.0
        ],
        "old_ci99_ms": [
          10.0,
          10.0
        ],
        "new_ci99_ms": [
          10.0,
          10.0
        ],
        "new_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ],
        "old_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ]
      }
    ]
  },
  "logs": {
    "full_log_path": "/logs/full.log",
    "config_log_path": "/logs/config.log",
    "build_log_path": "/logs/build.log",
    "test_log_path": "/logs/test.log",
    "build_success": true,
    "test_success": true
  },
  "raw_timing_data": {
    "warmup_runs": 1,
    "measurement_runs": 30,
    "min_exec_time_improvement": 0.05,
    "min_p_value": 0.05
  }
}