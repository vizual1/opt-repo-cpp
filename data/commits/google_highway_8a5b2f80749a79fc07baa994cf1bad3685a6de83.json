{
  "metadata": {
    "collection_date": "2026-02-03T20:01:42.870410",
    "repository": "https://github.com/google/highway",
    "repository_name": "google/highway"
  },
  "commit_info": {
    "old_sha": "fe85fdf2b1a28a27e0776c76cd2e2b83b99595e7",
    "new_sha": "8a5b2f80749a79fc07baa994cf1bad3685a6de83",
    "commit_message": [
      "add Sort2 and simplify 3..4 (1.7x speedup), use same code in 5To8 as 9To16\n\nPiperOrigin-RevId: 532101031"
    ],
    "commit_date": "2023-05-15T14:15:07+00:00",
    "patch": [
      "--- hwy/contrib/sort/sorting_networks-inl.h\n@@ -72,8 +72,23 @@ struct SharedTraits : public Base {\n \n // ------------------------------ Sorting network\n \n-// Sorting network for independent columns in 8 vectors.\n-// https://bertdobbelaere.github.io/sorting_networks.html\n+// Sorting networks for independent columns in 2, 4 and 8 vectors from\n+// https://bertdobbelaere.github.io/sorting_networks.html.\n+\n+template <class D, class Traits, class V = Vec<D>>\n+HWY_INLINE void Sort2(D d, Traits st, V& v0, V& v1) {\n+  st.Sort2(d, v0, v1);\n+}\n+\n+template <class D, class Traits, class V = Vec<D>>\n+HWY_INLINE void Sort4(D d, Traits st, V& v0, V& v1, V& v2, V& v3) {\n+  st.Sort2(d, v0, v2);\n+  st.Sort2(d, v1, v3);\n+  st.Sort2(d, v0, v1);\n+  st.Sort2(d, v2, v3);\n+  st.Sort2(d, v1, v2);\n+}\n+\n template <class D, class Traits, class V = Vec<D>>\n HWY_INLINE void Sort8(D d, Traits st, V& v0, V& v1, V& v2, V& v3, V& v4, V& v5,\n                       V& v6, V& v7) {\n--- hwy/contrib/sort/vqsort-inl.h\n@@ -126,98 +126,58 @@ void HeapSort(Traits st, T* HWY_RESTRICT lanes, const size_t num_lanes) {\n \n // Special cases where `num_lanes` is in the specified range (inclusive).\n template <class Traits, typename T>\n-HWY_INLINE void Sort0To8(Traits st, T* HWY_RESTRICT keys, size_t num_lanes,\n+HWY_INLINE void Sort2To2(Traits st, T* HWY_RESTRICT keys, size_t num_lanes,\n                          T* HWY_RESTRICT buf) {\n   constexpr size_t kLPK = st.LanesPerKey();\n   const size_t num_keys = num_lanes / kLPK;\n-  HWY_DASSERT(num_keys <= 8);\n-  HWY_ASSUME(num_keys <= 8);  // reduces branches\n+  HWY_DASSERT(num_keys == 2);\n+  HWY_ASSUME(num_keys == 2);\n \n-  // Copy into buffer so we only require a single masked load. Prevent using\n-  // unnecessarily large vectors by capping - this sorting network only handles\n-  // eight keys, so it does not make sense to load more.\n-  const CappedTagIfFixed<T, 8 * kLPK> dmax;\n-  const size_t Nmax = Lanes(dmax);\n-\n-  // Unless num_keys == 8, we pad the input because the sorting network is\n-  // fixed-size.\n-  const Vec<decltype(dmax)> kPadding = st.LastValue(dmax);\n+  // One key per vector, required to avoid reading past the end of `keys`.\n+  const CappedTag<T, kLPK> d;\n+  using V = Vec<decltype(d)>;\n \n-  // Values to sort, and where to store the sorted output. This may point to\n-  // buf, in which case it must be copied back to `keys`.\n-  T* HWY_RESTRICT in_out = keys;\n-  // Valid lanes in the last vector (only used if num_keys != 8).\n-  Mask<decltype(dmax)> mask;\n+  V v0 = LoadU(d, keys + 0x0 * kLPK);\n+  V v1 = LoadU(d, keys + 0x1 * kLPK);\n \n-  // Not all of the sorting network will be used. May require padding.\n-  if (HWY_UNLIKELY(num_keys != 8)) {\n-    // Done if there are zero or one keys to sort.\n-    if (HWY_UNLIKELY(num_keys <= 1)) return;\n+  Sort2(d, st, v0, v1);\n \n-    in_out = buf;\n-    // Copy whole vectors(s)\n-    size_t i = 0;\n-    for (; i + Nmax <= num_lanes; i += Nmax) {\n-      Store(LoadU(dmax, keys + i), dmax, buf + i);\n-    }\n+  StoreU(v0, d, keys + 0x0 * kLPK);\n+  StoreU(v1, d, keys + 0x1 * kLPK);\n+}\n \n-    // Last iteration: copy partial vector.\n-    const size_t remaining = num_lanes - i;\n-    HWY_ASSUME(remaining < 256);  // helps FirstN\n-    mask = FirstN(dmax, remaining);\n-#if HWY_MEM_OPS_MIGHT_FAULT\n-    SafeCopyN(remaining, dmax, keys + i, buf + i);\n-    i = num_lanes;\n-#else\n-    Store(MaskedLoadOr(kPadding, mask, dmax, keys + i), dmax, buf + i);\n-    i += Nmax;\n-#endif  // HWY_MEM_OPS_MIGHT_FAULT\n-    // If `d` is for exactly one key, we initialize 8 * kLPK lanes, and not just\n-    // for MSAN: padding prevents invalid values from influencing the sort.\n-    // But for 16-bit keys, loading a single lane may be inefficient, so we\n-    // allow larger vectors than necessary. Only the first lane is used; the\n-    // next lane is usually loaded from the next valid keys, but we require one\n-    // more padding for the last vector loaded.\n-    constexpr size_t extra = sizeof(T) == 2 ? 1 : 0;\n-    for (; i < 8 * kLPK + extra; i += Nmax) {\n-      StoreU(kPadding, dmax, buf + i);  // unaligned if HWY_MEM_OPS_MIGHT_FAULT\n-    }\n-  }\n+template <class Traits, typename T>\n+HWY_INLINE void Sort3To4(Traits st, T* HWY_RESTRICT keys, size_t num_lanes,\n+                         T* HWY_RESTRICT buf) {\n+  constexpr size_t kLPK = st.LanesPerKey();\n+  const size_t num_keys = num_lanes / kLPK;\n+  HWY_DASSERT(3 <= num_keys && num_keys <= 4);\n+  HWY_ASSUME(num_keys >= 3);\n+  HWY_ASSUME(num_keys <= 4);  // reduces branches\n \n-  // One key per vector (32.. 2x64 bit), or two for 16-bit (see above).\n-  const CappedTag<T, HWY_MAX(kLPK, 4 / sizeof(T))> d;\n+  // One key per vector, required to avoid reading past the end of `keys`.\n+  const CappedTag<T, kLPK> d;\n   using V = Vec<decltype(d)>;\n \n-  V v0 = LoadU(d, in_out + 0x0 * kLPK);\n-  V v1 = LoadU(d, in_out + 0x1 * kLPK);\n-  V v2 = LoadU(d, in_out + 0x2 * kLPK);\n-  V v3 = LoadU(d, in_out + 0x3 * kLPK);\n-  V v4 = LoadU(d, in_out + 0x4 * kLPK);\n-  V v5 = LoadU(d, in_out + 0x5 * kLPK);\n-  V v6 = LoadU(d, in_out + 0x6 * kLPK);\n-  V v7 = LoadU(d, in_out + 0x7 * kLPK);\n+  // If num_keys == 3, initialize padding for the last sorting network element\n+  // so that it does not influence the other elements.\n+  Store(st.LastValue(d), d, buf);\n \n-  Sort8(d, st, v0, v1, v2, v3, v4, v5, v6, v7);\n+  // Points to a valid key, or padding. This avoids special-casing\n+  // HWY_MEM_OPS_MIGHT_FAULT because there is only a single key per vector.\n+  T* in_out3 = num_keys == 3 ? buf : keys + 0x3 * kLPK;\n \n-  StoreU(v0, d, in_out + 0x0 * kLPK);\n-  StoreU(v1, d, in_out + 0x1 * kLPK);\n-  StoreU(v2, d, in_out + 0x2 * kLPK);\n-  StoreU(v3, d, in_out + 0x3 * kLPK);\n-  StoreU(v4, d, in_out + 0x4 * kLPK);\n-  StoreU(v5, d, in_out + 0x5 * kLPK);\n-  StoreU(v6, d, in_out + 0x6 * kLPK);\n-  StoreU(v7, d, in_out + 0x7 * kLPK);\n-\n-  // in_out == buf, so copy back to `keys`.\n-  if (HWY_UNLIKELY(num_keys != 8)) {\n-    size_t i = 0;\n-    // Copy whole vectors(s).\n-    for (; i + Nmax <= num_lanes; i += Nmax) {\n-      StoreU(Load(dmax, buf + i), dmax, keys + i);\n-    }\n-    // Copy partial vector.\n-    BlendedStore(Load(dmax, buf + i), mask, dmax, keys + i);\n-  }\n+  V v0 = LoadU(d, keys + 0x0 * kLPK);\n+  V v1 = LoadU(d, keys + 0x1 * kLPK);\n+  V v2 = LoadU(d, keys + 0x2 * kLPK);\n+  V v3 = LoadU(d, in_out3);\n+\n+  Sort4(d, st, v0, v1, v2, v3);\n+\n+  StoreU(v0, d, keys + 0x0 * kLPK);\n+  StoreU(v1, d, keys + 0x1 * kLPK);\n+  StoreU(v2, d, keys + 0x2 * kLPK);\n+  StoreU(v3, d, in_out3);\n }\n \n template <size_t kVectors, size_t kLPK, size_t kLanesPerRow, class D,\n@@ -321,6 +281,71 @@ HWY_INLINE void SafeStore(D d, Vec<D> v8, Vec<D> v9, Vec<D> va, Vec<D> vb,\n #endif\n }\n \n+template <class Traits, typename T>\n+HWY_INLINE void Sort5To8(Traits st, T* HWY_RESTRICT keys, size_t num_lanes,\n+                         T* HWY_RESTRICT buf) {\n+  constexpr size_t kLPK = st.LanesPerKey();\n+  const size_t num_keys = num_lanes / kLPK;\n+  HWY_DASSERT(5 <= num_keys && num_keys <= 8);\n+  HWY_ASSUME(num_keys >= 5);\n+  HWY_ASSUME(num_keys <= 8);\n+  // 8 keys divided by 8 rows equals 1 column.\n+  constexpr size_t kLanesPerRow = 1 * kLPK;\n+\n+  const CappedTag<T, kLanesPerRow> d;\n+  using V = Vec<decltype(d)>;\n+  V v0 = LoadU(d, keys + 0x0 * kLanesPerRow);\n+  V v1 = LoadU(d, keys + 0x1 * kLanesPerRow);\n+  V v2 = LoadU(d, keys + 0x2 * kLanesPerRow);\n+  V v3 = LoadU(d, keys + 0x3 * kLanesPerRow);\n+#if HWY_MEM_OPS_MIGHT_FAULT\n+  CopyHalfToPaddedBuf<8, kLPK, kLanesPerRow>(d, st, keys, num_lanes, buf);\n+  V v4 = LoadU(d, buf + 0x4 * kLanesPerRow);\n+  V v5 = LoadU(d, buf + 0x5 * kLanesPerRow);\n+  V v6 = LoadU(d, buf + 0x6 * kLanesPerRow);\n+  V v7 = LoadU(d, buf + 0x7 * kLanesPerRow);\n+#else   // !HWY_MEM_OPS_MIGHT_FAULT\n+  (void)buf;\n+  // To prevent reading past the end, only activate the lanes corresponding to\n+  // the first two keys (other lanes' masks will be false).\n+  const V vnum_lanes = IfThenElseZero(FirstN(d, kLanesPerRow),\n+                                      Set(d, static_cast<T>(num_lanes)));\n+  const V kIota = Iota(d, T{4 * kLPK});\n+  const V k1 = Set(d, T{kLanesPerRow});\n+  const V k2 = Add(k1, k1);\n+\n+  using M = Mask<decltype(d)>;\n+  const M m4 = Gt(vnum_lanes, kIota);\n+  const M m5 = Gt(vnum_lanes, Add(kIota, k1));\n+  const M m6 = Gt(vnum_lanes, Add(kIota, k2));\n+  const M m7 = Gt(vnum_lanes, Add(kIota, Add(k2, k1)));\n+\n+  // Fill with padding - last in sort order, not copied to keys.\n+  const V kPadding = st.LastValue(d);\n+\n+  V v4 = MaskedLoadOr(kPadding, m4, d, keys + 0x4 * kLanesPerRow);\n+  V v5 = MaskedLoadOr(kPadding, m5, d, keys + 0x5 * kLanesPerRow);\n+  V v6 = MaskedLoadOr(kPadding, m6, d, keys + 0x6 * kLanesPerRow);\n+  V v7 = MaskedLoadOr(kPadding, m7, d, keys + 0x7 * kLanesPerRow);\n+#endif  // HWY_MEM_OPS_MIGHT_FAULT\n+\n+  Sort8(d, st, v0, v1, v2, v3, v4, v5, v6, v7);\n+\n+  StoreU(v0, d, keys + 0x0 * kLanesPerRow);\n+  StoreU(v1, d, keys + 0x1 * kLanesPerRow);\n+  StoreU(v2, d, keys + 0x2 * kLanesPerRow);\n+  StoreU(v3, d, keys + 0x3 * kLanesPerRow);\n+\n+#if HWY_MEM_OPS_MIGHT_FAULT\n+  SafeStore<kLanesPerRow>(d, v4, v5, v6, v7, keys, num_lanes, buf);\n+#else\n+  BlendedStore(v4, m4, d, keys + 0x4 * kLanesPerRow);\n+  BlendedStore(v5, m5, d, keys + 0x5 * kLanesPerRow);\n+  BlendedStore(v6, m6, d, keys + 0x6 * kLanesPerRow);\n+  BlendedStore(v7, m7, d, keys + 0x7 * kLanesPerRow);\n+#endif  // HWY_MEM_OPS_MIGHT_FAULT\n+}\n+\n template <class Traits, typename T>\n HWY_INLINE void Sort9To16(Traits st, T* HWY_RESTRICT keys, size_t num_lanes,\n                           T* HWY_RESTRICT buf) {\n@@ -772,12 +797,12 @@ HWY_NOINLINE void BaseCase(D d, Traits st, T* HWY_RESTRICT keys,\n \n   const size_t ceil_log2 =\n       32 - Num0BitsAboveMS1Bit_Nonzero32(static_cast<uint32_t>(num_keys - 1));\n-  using FuncPtr = decltype(&Sort0To8<Traits, T>);\n+  using FuncPtr = decltype(&Sort2To2<Traits, T>);\n   const FuncPtr funcs[9] = {\n     /* <= 1 */ nullptr,  // We ensured num_keys > 1.\n-    /* <= 2 */ &Sort0To8<Traits, T>,\n-    /* <= 4 */ &Sort0To8<Traits, T>,\n-    /* <= 8 */ &Sort0To8<Traits, T>,\n+    /* <= 2 */ &Sort2To2<Traits, T>,\n+    /* <= 4 */ &Sort3To4<Traits, T>,\n+    /* <= 8 */ &Sort5To8<Traits, T>,\n     /* <= 16 */ kMaxKeys >= 2 ? &Sort9To16<Traits, T> : nullptr,\n     // 4 because this is an 8x4 network; everything after is 16x4..\n     /* <= 32 */ kMaxKeys >= 4 ? &Sort17To32<Traits, T> : nullptr,"
    ],
    "files_changed": [
      {
        "filename": "hwy/contrib/sort/sorting_networks-inl.h",
        "status": "modified",
        "additions": 17,
        "deletions": 2,
        "changes": 19,
        "patch": "@@ -72,8 +72,23 @@ struct SharedTraits : public Base {\n \n // ------------------------------ Sorting network\n \n-// Sorting network for independent columns in 8 vectors.\n-// https://bertdobbelaere.github.io/sorting_networks.html\n+// Sorting networks for independent columns in 2, 4 and 8 vectors from\n+// https://bertdobbelaere.github.io/sorting_networks.html.\n+\n+template <class D, class Traits, class V = Vec<D>>\n+HWY_INLINE void Sort2(D d, Traits st, V& v0, V& v1) {\n+  st.Sort2(d, v0, v1);\n+}\n+\n+template <class D, class Traits, class V = Vec<D>>\n+HWY_INLINE void Sort4(D d, Traits st, V& v0, V& v1, V& v2, V& v3) {\n+  st.Sort2(d, v0, v2);\n+  st.Sort2(d, v1, v3);\n+  st.Sort2(d, v0, v1);\n+  st.Sort2(d, v2, v3);\n+  st.Sort2(d, v1, v2);\n+}\n+\n template <class D, class Traits, class V = Vec<D>>\n HWY_INLINE void Sort8(D d, Traits st, V& v0, V& v1, V& v2, V& v3, V& v4, V& v5,\n                       V& v6, V& v7) {"
      },
      {
        "filename": "hwy/contrib/sort/vqsort-inl.h",
        "status": "modified",
        "additions": 108,
        "deletions": 83,
        "changes": 191,
        "patch": "@@ -126,98 +126,58 @@ void HeapSort(Traits st, T* HWY_RESTRICT lanes, const size_t num_lanes) {\n \n // Special cases where `num_lanes` is in the specified range (inclusive).\n template <class Traits, typename T>\n-HWY_INLINE void Sort0To8(Traits st, T* HWY_RESTRICT keys, size_t num_lanes,\n+HWY_INLINE void Sort2To2(Traits st, T* HWY_RESTRICT keys, size_t num_lanes,\n                          T* HWY_RESTRICT buf) {\n   constexpr size_t kLPK = st.LanesPerKey();\n   const size_t num_keys = num_lanes / kLPK;\n-  HWY_DASSERT(num_keys <= 8);\n-  HWY_ASSUME(num_keys <= 8);  // reduces branches\n+  HWY_DASSERT(num_keys == 2);\n+  HWY_ASSUME(num_keys == 2);\n \n-  // Copy into buffer so we only require a single masked load. Prevent using\n-  // unnecessarily large vectors by capping - this sorting network only handles\n-  // eight keys, so it does not make sense to load more.\n-  const CappedTagIfFixed<T, 8 * kLPK> dmax;\n-  const size_t Nmax = Lanes(dmax);\n-\n-  // Unless num_keys == 8, we pad the input because the sorting network is\n-  // fixed-size.\n-  const Vec<decltype(dmax)> kPadding = st.LastValue(dmax);\n+  // One key per vector, required to avoid reading past the end of `keys`.\n+  const CappedTag<T, kLPK> d;\n+  using V = Vec<decltype(d)>;\n \n-  // Values to sort, and where to store the sorted output. This may point to\n-  // buf, in which case it must be copied back to `keys`.\n-  T* HWY_RESTRICT in_out = keys;\n-  // Valid lanes in the last vector (only used if num_keys != 8).\n-  Mask<decltype(dmax)> mask;\n+  V v0 = LoadU(d, keys + 0x0 * kLPK);\n+  V v1 = LoadU(d, keys + 0x1 * kLPK);\n \n-  // Not all of the sorting network will be used. May require padding.\n-  if (HWY_UNLIKELY(num_keys != 8)) {\n-    // Done if there are zero or one keys to sort.\n-    if (HWY_UNLIKELY(num_keys <= 1)) return;\n+  Sort2(d, st, v0, v1);\n \n-    in_out = buf;\n-    // Copy whole vectors(s)\n-    size_t i = 0;\n-    for (; i + Nmax <= num_lanes; i += Nmax) {\n-      Store(LoadU(dmax, keys + i), dmax, buf + i);\n-    }\n+  StoreU(v0, d, keys + 0x0 * kLPK);\n+  StoreU(v1, d, keys + 0x1 * kLPK);\n+}\n \n-    // Last iteration: copy partial vector.\n-    const size_t remaining = num_lanes - i;\n-    HWY_ASSUME(remaining < 256);  // helps FirstN\n-    mask = FirstN(dmax, remaining);\n-#if HWY_MEM_OPS_MIGHT_FAULT\n-    SafeCopyN(remaining, dmax, keys + i, buf + i);\n-    i = num_lanes;\n-#else\n-    Store(MaskedLoadOr(kPadding, mask, dmax, keys + i), dmax, buf + i);\n-    i += Nmax;\n-#endif  // HWY_MEM_OPS_MIGHT_FAULT\n-    // If `d` is for exactly one key, we initialize 8 * kLPK lanes, and not just\n-    // for MSAN: padding prevents invalid values from influencing the sort.\n-    // But for 16-bit keys, loading a single lane may be inefficient, so we\n-    // allow larger vectors than necessary. Only the first lane is used; the\n-    // next lane is usually loaded from the next valid keys, but we require one\n-    // more padding for the last vector loaded.\n-    constexpr size_t extra = sizeof(T) == 2 ? 1 : 0;\n-    for (; i < 8 * kLPK + extra; i += Nmax) {\n-      StoreU(kPadding, dmax, buf + i);  // unaligned if HWY_MEM_OPS_MIGHT_FAULT\n-    }\n-  }\n+template <class Traits, typename T>\n+HWY_INLINE void Sort3To4(Traits st, T* HWY_RESTRICT keys, size_t num_lanes,\n+                         T* HWY_RESTRICT buf) {\n+  constexpr size_t kLPK = st.LanesPerKey();\n+  const size_t num_keys = num_lanes / kLPK;\n+  HWY_DASSERT(3 <= num_keys && num_keys <= 4);\n+  HWY_ASSUME(num_keys >= 3);\n+  HWY_ASSUME(num_keys <= 4);  // reduces branches\n \n-  // One key per vector (32.. 2x64 bit), or two for 16-bit (see above).\n-  const CappedTag<T, HWY_MAX(kLPK, 4 / sizeof(T))> d;\n+  // One key per vector, required to avoid reading past the end of `keys`.\n+  const CappedTag<T, kLPK> d;\n   using V = Vec<decltype(d)>;\n \n-  V v0 = LoadU(d, in_out + 0x0 * kLPK);\n-  V v1 = LoadU(d, in_out + 0x1 * kLPK);\n-  V v2 = LoadU(d, in_out + 0x2 * kLPK);\n-  V v3 = LoadU(d, in_out + 0x3 * kLPK);\n-  V v4 = LoadU(d, in_out + 0x4 * kLPK);\n-  V v5 = LoadU(d, in_out + 0x5 * kLPK);\n-  V v6 = LoadU(d, in_out + 0x6 * kLPK);\n-  V v7 = LoadU(d, in_out + 0x7 * kLPK);\n+  // If num_keys == 3, initialize padding for the last sorting network element\n+  // so that it does not influence the other elements.\n+  Store(st.LastValue(d), d, buf);\n \n-  Sort8(d, st, v0, v1, v2, v3, v4, v5, v6, v7);\n+  // Points to a valid key, or padding. This avoids special-casing\n+  // HWY_MEM_OPS_MIGHT_FAULT because there is only a single key per vector.\n+  T* in_out3 = num_keys == 3 ? buf : keys + 0x3 * kLPK;\n \n-  StoreU(v0, d, in_out + 0x0 * kLPK);\n-  StoreU(v1, d, in_out + 0x1 * kLPK);\n-  StoreU(v2, d, in_out + 0x2 * kLPK);\n-  StoreU(v3, d, in_out + 0x3 * kLPK);\n-  StoreU(v4, d, in_out + 0x4 * kLPK);\n-  StoreU(v5, d, in_out + 0x5 * kLPK);\n-  StoreU(v6, d, in_out + 0x6 * kLPK);\n-  StoreU(v7, d, in_out + 0x7 * kLPK);\n-\n-  // in_out == buf, so copy back to `keys`.\n-  if (HWY_UNLIKELY(num_keys != 8)) {\n-    size_t i = 0;\n-    // Copy whole vectors(s).\n-    for (; i + Nmax <= num_lanes; i += Nmax) {\n-      StoreU(Load(dmax, buf + i), dmax, keys + i);\n-    }\n-    // Copy partial vector.\n-    BlendedStore(Load(dmax, buf + i), mask, dmax, keys + i);\n-  }\n+  V v0 = LoadU(d, keys + 0x0 * kLPK);\n+  V v1 = LoadU(d, keys + 0x1 * kLPK);\n+  V v2 = LoadU(d, keys + 0x2 * kLPK);\n+  V v3 = LoadU(d, in_out3);\n+\n+  Sort4(d, st, v0, v1, v2, v3);\n+\n+  StoreU(v0, d, keys + 0x0 * kLPK);\n+  StoreU(v1, d, keys + 0x1 * kLPK);\n+  StoreU(v2, d, keys + 0x2 * kLPK);\n+  StoreU(v3, d, in_out3);\n }\n \n template <size_t kVectors, size_t kLPK, size_t kLanesPerRow, class D,\n@@ -321,6 +281,71 @@ HWY_INLINE void SafeStore(D d, Vec<D> v8, Vec<D> v9, Vec<D> va, Vec<D> vb,\n #endif\n }\n \n+template <class Traits, typename T>\n+HWY_INLINE void Sort5To8(Traits st, T* HWY_RESTRICT keys, size_t num_lanes,\n+                         T* HWY_RESTRICT buf) {\n+  constexpr size_t kLPK = st.LanesPerKey();\n+  const size_t num_keys = num_lanes / kLPK;\n+  HWY_DASSERT(5 <= num_keys && num_keys <= 8);\n+  HWY_ASSUME(num_keys >= 5);\n+  HWY_ASSUME(num_keys <= 8);\n+  // 8 keys divided by 8 rows equals 1 column.\n+  constexpr size_t kLanesPerRow = 1 * kLPK;\n+\n+  const CappedTag<T, kLanesPerRow> d;\n+  using V = Vec<decltype(d)>;\n+  V v0 = LoadU(d, keys + 0x0 * kLanesPerRow);\n+  V v1 = LoadU(d, keys + 0x1 * kLanesPerRow);\n+  V v2 = LoadU(d, keys + 0x2 * kLanesPerRow);\n+  V v3 = LoadU(d, keys + 0x3 * kLanesPerRow);\n+#if HWY_MEM_OPS_MIGHT_FAULT\n+  CopyHalfToPaddedBuf<8, kLPK, kLanesPerRow>(d, st, keys, num_lanes, buf);\n+  V v4 = LoadU(d, buf + 0x4 * kLanesPerRow);\n+  V v5 = LoadU(d, buf + 0x5 * kLanesPerRow);\n+  V v6 = LoadU(d, buf + 0x6 * kLanesPerRow);\n+  V v7 = LoadU(d, buf + 0x7 * kLanesPerRow);\n+#else   // !HWY_MEM_OPS_MIGHT_FAULT\n+  (void)buf;\n+  // To prevent reading past the end, only activate the lanes corresponding to\n+  // the first two keys (other lanes' masks will be false).\n+  const V vnum_lanes = IfThenElseZero(FirstN(d, kLanesPerRow),\n+                                      Set(d, static_cast<T>(num_lanes)));\n+  const V kIota = Iota(d, T{4 * kLPK});\n+  const V k1 = Set(d, T{kLanesPerRow});\n+  const V k2 = Add(k1, k1);\n+\n+  using M = Mask<decltype(d)>;\n+  const M m4 = Gt(vnum_lanes, kIota);\n+  const M m5 = Gt(vnum_lanes, Add(kIota, k1));\n+  const M m6 = Gt(vnum_lanes, Add(kIota, k2));\n+  const M m7 = Gt(vnum_lanes, Add(kIota, Add(k2, k1)));\n+\n+  // Fill with padding - last in sort order, not copied to keys.\n+  const V kPadding = st.LastValue(d);\n+\n+  V v4 = MaskedLoadOr(kPadding, m4, d, keys + 0x4 * kLanesPerRow);\n+  V v5 = MaskedLoadOr(kPadding, m5, d, keys + 0x5 * kLanesPerRow);\n+  V v6 = MaskedLoadOr(kPadding, m6, d, keys + 0x6 * kLanesPerRow);\n+  V v7 = MaskedLoadOr(kPadding, m7, d, keys + 0x7 * kLanesPerRow);\n+#endif  // HWY_MEM_OPS_MIGHT_FAULT\n+\n+  Sort8(d, st, v0, v1, v2, v3, v4, v5, v6, v7);\n+\n+  StoreU(v0, d, keys + 0x0 * kLanesPerRow);\n+  StoreU(v1, d, keys + 0x1 * kLanesPerRow);\n+  StoreU(v2, d, keys + 0x2 * kLanesPerRow);\n+  StoreU(v3, d, keys + 0x3 * kLanesPerRow);\n+\n+#if HWY_MEM_OPS_MIGHT_FAULT\n+  SafeStore<kLanesPerRow>(d, v4, v5, v6, v7, keys, num_lanes, buf);\n+#else\n+  BlendedStore(v4, m4, d, keys + 0x4 * kLanesPerRow);\n+  BlendedStore(v5, m5, d, keys + 0x5 * kLanesPerRow);\n+  BlendedStore(v6, m6, d, keys + 0x6 * kLanesPerRow);\n+  BlendedStore(v7, m7, d, keys + 0x7 * kLanesPerRow);\n+#endif  // HWY_MEM_OPS_MIGHT_FAULT\n+}\n+\n template <class Traits, typename T>\n HWY_INLINE void Sort9To16(Traits st, T* HWY_RESTRICT keys, size_t num_lanes,\n                           T* HWY_RESTRICT buf) {\n@@ -772,12 +797,12 @@ HWY_NOINLINE void BaseCase(D d, Traits st, T* HWY_RESTRICT keys,\n \n   const size_t ceil_log2 =\n       32 - Num0BitsAboveMS1Bit_Nonzero32(static_cast<uint32_t>(num_keys - 1));\n-  using FuncPtr = decltype(&Sort0To8<Traits, T>);\n+  using FuncPtr = decltype(&Sort2To2<Traits, T>);\n   const FuncPtr funcs[9] = {\n     /* <= 1 */ nullptr,  // We ensured num_keys > 1.\n-    /* <= 2 */ &Sort0To8<Traits, T>,\n-    /* <= 4 */ &Sort0To8<Traits, T>,\n-    /* <= 8 */ &Sort0To8<Traits, T>,\n+    /* <= 2 */ &Sort2To2<Traits, T>,\n+    /* <= 4 */ &Sort3To4<Traits, T>,\n+    /* <= 8 */ &Sort5To8<Traits, T>,\n     /* <= 16 */ kMaxKeys >= 2 ? &Sort9To16<Traits, T> : nullptr,\n     // 4 because this is an 8x4 network; everything after is 16x4..\n     /* <= 32 */ kMaxKeys >= 4 ? &Sort17To32<Traits, T> : nullptr,"
      }
    ],
    "lines_added": 125,
    "lines_removed": 85
  },
  "issues": [],
  "pull_requests": [],
  "build_info": {
    "old_build_script": [
      "apt-get update",
      "cmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON -DHWY_ENABLE_TESTS=ON",
      "cmake --build /test_workspace/workspace/old/build -- -j 1"
    ],
    "new_build_script": [
      "apt-get update",
      "cmake -S /test_workspace/workspace/new -B /test_workspace/workspace/new/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON -DHWY_ENABLE_TESTS=ON",
      "cmake --build /test_workspace/workspace/new/build -- -j 1"
    ],
    "old_test_script": [
      "cd /test_workspace/workspace/old/build",
      "ctest --output-on-failure"
    ],
    "new_test_script": [
      "cd /test_workspace/workspace/new/build",
      "ctest --output-on-failure"
    ],
    "build_system": "cmake"
  },
  "performance_analysis": {
    "is_significant": false,
    "p_value": 0.9999999999999309,
    "is_pair_significant": false,
    "pair_p_value": 0.9999999973454945,
    "is_binom_significant": false,
    "binom_p_value": 0.9999995660036802,
    "is_wilcoxon_significant": false,
    "wilcoxon_p_value": 0.999997396235003,
    "is_mannwhitney_significant": false,
    "mannwhitney_p_value": 0.2845564032236994,
    "relative_improvement": 0.00387686610346023,
    "absolute_improvement_ms": 66.99999999999662,
    "old_mean_ms": 17281.999999999996,
    "new_mean_ms": 17215.0,
    "old_std_ms": 344.25732156088674,
    "new_std_ms": 315.8322339470751,
    "effect_size_cohens_d": 0.20281479715869735,
    "old_ci95_ms": [
      17153.452203505254,
      17410.54779649474
    ],
    "new_ci95_ms": [
      17097.066305658143,
      17332.933694341857
    ],
    "old_ci99_ms": [
      17108.754254433497,
      17455.245745566495
    ],
    "new_ci99_ms": [
      17056.059035154267,
      17373.940964845733
    ],
    "new_times_s": [
      17.05,
      17.18,
      16.81,
      17.63,
      17.63,
      16.94,
      17.43,
      17.04,
      16.6,
      17.62,
      17.11,
      17.57,
      17.25,
      16.76,
      17.19,
      16.94,
      17.78,
      16.85,
      17.42,
      17.37,
      17.19,
      16.93,
      17.56,
      16.99,
      17.05,
      17.67,
      16.84,
      17.25,
      17.55,
      17.15,
      17.15
    ],
    "old_times_s": [
      17.13,
      17.09,
      17.24,
      16.82,
      17.32,
      17.37,
      17.07,
      16.69,
      17.98,
      17.58,
      16.82,
      17.03,
      16.97,
      17.9,
      17.4,
      17.17,
      17.07,
      17.22,
      17.73,
      17.04,
      17.57,
      16.94,
      17.37,
      16.9,
      17.38,
      17.13,
      18.0,
      17.4,
      17.19,
      17.71,
      17.36
    ]
  },
  "tests": {
    "total_tests": 1,
    "significant_improvements": 0,
    "significant_improvements_tests": [],
    "significant_regressions": 0,
    "significant_regressions_tests": [],
    "significant_pair_improvements": 0,
    "significant_pair_improvements_tests": [],
    "significant_pair_regressions": 0,
    "significant_pair_regressions_tests": [],
    "significant_binom_improvements": 0,
    "significant_binom_improvements_tests": [],
    "significant_binom_regressions": 0,
    "significant_binom_regressions_tests": [],
    "significant_wilcoxon_improvements": 0,
    "significant_wilcoxon_improvements_tests": [],
    "significant_wilcoxon_regressions": 0,
    "significant_wilcoxon_regressions_tests": [],
    "significant_mannwhitney_improvements": 0,
    "significant_mannwhitney_improvements_tests": [],
    "significant_mannwhitney_regressions": 0,
    "significant_mannwhitney_regressions_tests": [],
    "tests": [
      {
        "test_name": "NanobenchmarkTest.RunAll",
        "is_significant": false,
        "p_value": 0.9248985213710803,
        "is_pair_significant": false,
        "pair_p_value": 0.9302497332707533,
        "is_binom_significant": false,
        "binom_p_value": 0.956420723348856,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9067849313595573,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.7389513166911502,
        "relative_improvement": -0.030705394190871302,
        "absolute_improvement_ms": -13.214285714285623,
        "old_mean_ms": 430.3571428571429,
        "new_mean_ms": 443.5714285714285,
        "old_std_ms": 90.7777972061917,
        "new_std_ms": 91.7409511417999,
        "effect_size_cohens_d": -0.14479719863804996,
        "old_ci95_ms": [
          395.15718779190746,
          465.5570979223783
        ],
        "new_ci95_ms": [
          407.99800139850015,
          479.14485574435685
        ],
        "old_ci99_ms": [
          382.82499300005026,
          477.8892927142355
        ],
        "new_ci99_ms": [
          395.5349618151409,
          491.60789532771616
        ],
        "new_times": [
          0.51,
          0.5,
          0.45,
          0.43,
          0.53,
          0.38,
          0.22,
          0.42,
          0.44,
          0.52,
          0.5,
          0.48,
          0.25,
          0.29,
          0.58,
          0.47,
          0.5,
          0.46,
          0.41,
          0.54,
          0.46,
          0.45,
          0.26,
          0.44,
          0.49,
          0.51,
          0.54,
          0.39
        ],
        "old_times": [
          0.5,
          0.55,
          0.45,
          0.51,
          0.4,
          0.36,
          0.51,
          0.42,
          0.19,
          0.48,
          0.32,
          0.54,
          0.38,
          0.42,
          0.49,
          0.41,
          0.51,
          0.46,
          0.46,
          0.38,
          0.55,
          0.46,
          0.36,
          0.28,
          0.36,
          0.29,
          0.55,
          0.46
        ]
      }
    ]
  },
  "logs": {
    "full_log_path": "/logs/full.log",
    "config_log_path": "/logs/config.log",
    "build_log_path": "/logs/build.log",
    "test_log_path": "/logs/test.log",
    "build_success": true,
    "test_success": true
  },
  "raw_timing_data": {
    "warmup_runs": 1,
    "measurement_runs": 30,
    "min_exec_time_improvement": 0.05,
    "min_p_value": 0.05
  }
}