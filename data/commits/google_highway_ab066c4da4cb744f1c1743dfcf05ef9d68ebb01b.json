{
  "metadata": {
    "collection_date": "2026-02-03T20:01:46.728569",
    "repository": "https://github.com/google/highway",
    "repository_name": "google/highway"
  },
  "commit_info": {
    "old_sha": "4464e1b0319a0e827cdbdf6c6a6f32daa6b85d9d",
    "new_sha": "ab066c4da4cb744f1c1743dfcf05ef9d68ebb01b",
    "commit_message": [
      "Merge pull request #2592 from johnplatts:hwy_avx10_2_conv_enh_061225\n\nPiperOrigin-RevId: 771061284"
    ],
    "commit_date": "2025-06-13T12:59:23+00:00",
    "patch": [
      "--- hwy/ops/x86_128-inl.h\n@@ -70,6 +70,14 @@ namespace detail {\n #define HWY_X86_GCC_INLINE_ASM_VEC_CONSTRAINT \"x\"\n #endif\n \n+#undef HWY_X86_HAVE_AVX10_2_OPS\n+#if HWY_TARGET_IS_AVX10_2 && \\\n+    (HWY_COMPILER_GCC_ACTUAL >= 1501 || HWY_COMPILER3_CLANG >= 200103)\n+#define HWY_X86_HAVE_AVX10_2_OPS 1\n+#else\n+#define HWY_X86_HAVE_AVX10_2_OPS 0\n+#endif\n+\n template <typename T>\n struct Raw128 {\n   using type = __m128i;\n@@ -10443,6 +10451,7 @@ X86ConvertScalarFromFloat(TF from_val) {\n   return X86ConvertScalarFromFloat<TTo>(hwy::TypeTag<RemoveCvRef<TTo>>(),\n                                         from_val);\n }\n+\n #endif  // HWY_COMPILER_GCC_ACTUAL >= 700 && !HWY_IS_DEBUG_BUILD\n \n }  // namespace detail\n@@ -10455,7 +10464,9 @@ X86ConvertScalarFromFloat(TF from_val) {\n \n template <class D, HWY_IF_V_SIZE_LE_D(D, 8), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, VFromD<Rebind<double, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm_cvtts_pd_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttpd_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n@@ -10492,7 +10503,9 @@ HWY_API VFromD<D> DemoteTo(D di32, VFromD<Rebind<double, D>> v) {\n #if HWY_TARGET <= HWY_AVX3\n template <class D, HWY_IF_V_SIZE_LE_D(D, 8), HWY_IF_U32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, VFromD<Rebind<double, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm_cvtts_pd_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttpd_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -10520,8 +10533,12 @@ HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, VFromD<Rebind<double, D>> v) {\n \n // F64->U32 DemoteTo is generic for all vector lengths\n template <class D, HWY_IF_U32_D(D)>\n-HWY_API VFromD<D> DemoteTo(D /* tag */, VFromD<Rebind<double, D>> v) {\n-  return DemoteInRangeTo(D(), ZeroIfNegative(v));\n+HWY_API VFromD<D> DemoteTo(D du32, VFromD<Rebind<double, D>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return DemoteInRangeTo(du32, v);\n+#else\n+  return DemoteInRangeTo(du32, ZeroIfNegative(v));\n+#endif\n }\n #else   // HWY_TARGET > HWY_AVX3\n \n@@ -10649,7 +10666,9 @@ HWY_API Vec128<uint8_t, N> U8FromU32(const Vec128<uint32_t, N> v) {\n #if HWY_TARGET <= HWY_AVX3\n template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_I64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm_cvtts_ps_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an int64_t\n \n@@ -10677,6 +10696,9 @@ HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n // Generic for all vector lengths.\n template <class D, HWY_IF_I64_D(D)>\n HWY_API VFromD<D> PromoteTo(D di64, VFromD<Rebind<float, D>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return PromoteInRangeTo(di64, v);\n+#else\n   const Rebind<float, decltype(di64)> df32;\n   const RebindToFloat<decltype(di64)> df64;\n   // We now avoid GCC UB in PromoteInRangeTo via assembly, see #2189 and\n@@ -10689,14 +10711,21 @@ HWY_API VFromD<D> PromoteTo(D di64, VFromD<Rebind<float, D>> v) {\n       di64, PromoteMaskTo(df64, df32, Ge(v, Set(df32, 9.223372e18f))));\n   return IfThenElse(overflow, Set(di64, LimitsMax<int64_t>()),\n                     PromoteInRangeTo(di64, v));\n+#endif\n }\n template <class D, HWY_IF_U64_D(D)>\n-HWY_API VFromD<D> PromoteTo(D /* tag */, VFromD<Rebind<float, D>> v) {\n-  return PromoteInRangeTo(D(), ZeroIfNegative(v));\n+HWY_API VFromD<D> PromoteTo(D du64, VFromD<Rebind<float, D>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return PromoteInRangeTo(du64, v);\n+#else\n+  return PromoteInRangeTo(du64, ZeroIfNegative(v));\n+#endif\n }\n template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_U64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /* tag */, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm_cvtts_ps_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an uint64_t\n \n@@ -11375,7 +11404,9 @@ HWY_API VFromD<D> ConvertTo(D /* tag */, VFromD<RebindToFloat<D>> v) {\n \n template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, VFromD<RebindToFloat<D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm_cvtts_ps_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttps_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n@@ -11405,17 +11436,23 @@ HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, VFromD<RebindToFloat<D>> v) {\n // F32 to I32 ConvertTo is generic for all vector lengths\n template <class D, HWY_IF_I32_D(D)>\n HWY_API VFromD<D> ConvertTo(D di, VFromD<RebindToFloat<D>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return ConvertInRangeTo(di, v);\n+#else\n   const RebindToFloat<decltype(di)> df;\n   // See comment at the first occurrence of \"IfThenElse(overflow,\".\n   const MFromD<D> overflow = RebindMask(di, Ge(v, Set(df, 2147483648.0f)));\n   return IfThenElse(overflow, Set(di, LimitsMax<int32_t>()),\n                     ConvertInRangeTo(di, v));\n+#endif\n }\n \n #if HWY_TARGET <= HWY_AVX3\n template <class DI, HWY_IF_V_SIZE_LE_D(DI, 16), HWY_IF_I64_D(DI)>\n HWY_API VFromD<DI> ConvertInRangeTo(DI /*di*/, VFromD<RebindToFloat<DI>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DI>{_mm_cvtts_pd_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttpd_epi64 with GCC if any\n   // values of v[i] are not within the range of an int64_t\n \n@@ -11443,17 +11480,23 @@ HWY_API VFromD<DI> ConvertInRangeTo(DI /*di*/, VFromD<RebindToFloat<DI>> v) {\n // F64 to I64 ConvertTo is generic for all vector lengths on AVX3\n template <class DI, HWY_IF_I64_D(DI)>\n HWY_API VFromD<DI> ConvertTo(DI di, VFromD<RebindToFloat<DI>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return ConvertInRangeTo(di, v);\n+#else\n   const RebindToFloat<decltype(di)> df;\n   // See comment at the first occurrence of \"IfThenElse(overflow,\".\n   const MFromD<DI> overflow =\n       RebindMask(di, Ge(v, Set(df, 9.223372036854776e18)));\n   return IfThenElse(overflow, Set(di, LimitsMax<int64_t>()),\n                     ConvertInRangeTo(di, v));\n+#endif\n }\n \n template <class DU, HWY_IF_V_SIZE_LE_D(DU, 16), HWY_IF_U32_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm_cvtts_ps_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttps_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -11482,13 +11525,19 @@ HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n \n // F32->U32 ConvertTo is generic for all vector lengths\n template <class DU, HWY_IF_U32_D(DU)>\n-HWY_API VFromD<DU> ConvertTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-  return ConvertInRangeTo(DU(), ZeroIfNegative(v));\n+HWY_API VFromD<DU> ConvertTo(DU du32, VFromD<RebindToFloat<DU>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return ConvertInRangeTo(du32, v);\n+#else\n+  return ConvertInRangeTo(du32, ZeroIfNegative(v));\n+#endif\n }\n \n template <class DU, HWY_IF_V_SIZE_LE_D(DU, 16), HWY_IF_U64_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm_cvtts_pd_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttpd_epu64 with GCC if any\n   // values of v[i] are not within the range of an uint64_t\n \n@@ -11515,8 +11564,12 @@ HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n \n // F64->U64 ConvertTo is generic for all vector lengths\n template <class DU, HWY_IF_U64_D(DU)>\n-HWY_API VFromD<DU> ConvertTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-  return ConvertInRangeTo(DU(), ZeroIfNegative(v));\n+HWY_API VFromD<DU> ConvertTo(DU du64, VFromD<RebindToFloat<DU>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return ConvertInRangeTo(du64, v);\n+#else\n+  return ConvertInRangeTo(du64, ZeroIfNegative(v));\n+#endif\n }\n \n #else  // AVX2 or below\n--- hwy/ops/x86_256-inl.h\n@@ -6446,7 +6446,9 @@ HWY_API VFromD<D> PromoteTo(D /* tag */, Vec32<int8_t> v) {\n #if HWY_TARGET <= HWY_AVX3\n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_I64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_ps_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an int64_t\n \n@@ -6474,7 +6476,9 @@ HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n }\n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_U64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /* tag */, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_ps_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an uint64_t\n #if HWY_COMPILER_GCC_ACTUAL >= 700 && !HWY_IS_DEBUG_BUILD\n@@ -6853,7 +6857,9 @@ HWY_API VFromD<D> DemoteTo(D /* tag */, Vec256<double> v) {\n \n template <class D, HWY_IF_V_SIZE_D(D, 16), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec256<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_pd_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttpd_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n@@ -6883,7 +6889,9 @@ HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec256<double> v) {\n #if HWY_TARGET <= HWY_AVX3\n template <class D, HWY_IF_V_SIZE_D(D, 16), HWY_IF_U32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec256<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_pd_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttpd_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -7178,7 +7186,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /* tag */, VFromD<RebindToFloat<D>> v) {\n \n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> ConvertInRangeTo(D /*d*/, Vec256<float> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_ps_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttps_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n@@ -7212,7 +7222,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /*d*/, Vec256<float> v) {\n #if HWY_TARGET <= HWY_AVX3\n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_I64_D(D)>\n HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, Vec256<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_pd_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttpd_epi64 with GCC if any\n   // values of v[i] are not within the range of an int64_t\n \n@@ -7240,7 +7252,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, Vec256<double> v) {\n }\n template <class DU, HWY_IF_V_SIZE_D(DU, 32), HWY_IF_U32_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm256_cvtts_ps_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttps_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -7280,7 +7294,9 @@ HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n }\n template <class DU, HWY_IF_V_SIZE_D(DU, 32), HWY_IF_U64_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm256_cvtts_pd_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttpd_epu64 with GCC if any\n   // values of v[i] are not within the range of an uint64_t\n \n--- hwy/ops/x86_512-inl.h\n@@ -5511,7 +5511,9 @@ HWY_API VFromD<D> PromoteTo(D /* tag */, Vec256<uint32_t> v) {\n \n template <class D, HWY_IF_V_SIZE_D(D, 64), HWY_IF_I64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_ps_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an int64_t\n \n@@ -5543,7 +5545,9 @@ HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n }\n template <class D, HWY_IF_V_SIZE_D(D, 64), HWY_IF_U64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /* tag */, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_ps_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an uint64_t\n \n@@ -5831,23 +5835,27 @@ HWY_API VFromD<D> DemoteTo(D /* tag */, Vec512<double> v) {\n \n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec512<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_pd_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttpd_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n #if HWY_COMPILER_GCC_ACTUAL >= 700 && !HWY_IS_DEBUG_BUILD\n   if (detail::IsConstantX86VecForF2IConv<int32_t>(v)) {\n     typedef double GccF64RawVectType __attribute__((__vector_size__(64)));\n     const auto raw_v = reinterpret_cast<GccF64RawVectType>(v.raw);\n-    return VFromD<D>{_mm256_setr_epi32(\n+    return VFromD<D>{\n+        _mm256_setr_epi32(\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[0]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[1]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[2]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[3]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[4]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[5]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[6]),\n-        detail::X86ConvertScalarFromFloat<int32_t>(raw_v[7]))};\n+        detail::X86ConvertScalarFromFloat<int32_t>(raw_v[7]))\n+        };\n   }\n #endif\n \n@@ -5864,7 +5872,9 @@ HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec512<double> v) {\n \n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_U32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec512<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_pd_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttpd_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -6210,7 +6220,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /* tag */, VFromD<RebindToFloat<D>> v) {\n #endif  // HWY_HAVE_FLOAT16\n template <class D, HWY_IF_V_SIZE_D(D, 64), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> ConvertInRangeTo(D /*d*/, Vec512<float> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_ps_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttps_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n@@ -6250,7 +6262,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /*d*/, Vec512<float> v) {\n }\n template <class D, HWY_IF_V_SIZE_D(D, 64), HWY_IF_I64_D(D)>\n HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, Vec512<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_pd_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttpd_epi64 with GCC if any\n   // values of v[i] are not within the range of an int64_t\n \n@@ -6282,7 +6296,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, Vec512<double> v) {\n }\n template <class DU, HWY_IF_V_SIZE_D(DU, 64), HWY_IF_U32_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm512_cvtts_ps_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttps_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -6338,7 +6354,9 @@ HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n }\n template <class DU, HWY_IF_V_SIZE_D(DU, 64), HWY_IF_U64_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm512_cvtts_pd_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttpd_epu64 with GCC if any\n   // values of v[i] are not within the range of an uint64_t\n "
    ],
    "files_changed": [
      {
        "filename": "hwy/ops/x86_128-inl.h",
        "status": "modified",
        "additions": 69,
        "deletions": 16,
        "changes": 85,
        "patch": "@@ -70,6 +70,14 @@ namespace detail {\n #define HWY_X86_GCC_INLINE_ASM_VEC_CONSTRAINT \"x\"\n #endif\n \n+#undef HWY_X86_HAVE_AVX10_2_OPS\n+#if HWY_TARGET_IS_AVX10_2 && \\\n+    (HWY_COMPILER_GCC_ACTUAL >= 1501 || HWY_COMPILER3_CLANG >= 200103)\n+#define HWY_X86_HAVE_AVX10_2_OPS 1\n+#else\n+#define HWY_X86_HAVE_AVX10_2_OPS 0\n+#endif\n+\n template <typename T>\n struct Raw128 {\n   using type = __m128i;\n@@ -10443,6 +10451,7 @@ X86ConvertScalarFromFloat(TF from_val) {\n   return X86ConvertScalarFromFloat<TTo>(hwy::TypeTag<RemoveCvRef<TTo>>(),\n                                         from_val);\n }\n+\n #endif  // HWY_COMPILER_GCC_ACTUAL >= 700 && !HWY_IS_DEBUG_BUILD\n \n }  // namespace detail\n@@ -10455,7 +10464,9 @@ X86ConvertScalarFromFloat(TF from_val) {\n \n template <class D, HWY_IF_V_SIZE_LE_D(D, 8), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, VFromD<Rebind<double, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm_cvtts_pd_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttpd_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n@@ -10492,7 +10503,9 @@ HWY_API VFromD<D> DemoteTo(D di32, VFromD<Rebind<double, D>> v) {\n #if HWY_TARGET <= HWY_AVX3\n template <class D, HWY_IF_V_SIZE_LE_D(D, 8), HWY_IF_U32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, VFromD<Rebind<double, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm_cvtts_pd_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttpd_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -10520,8 +10533,12 @@ HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, VFromD<Rebind<double, D>> v) {\n \n // F64->U32 DemoteTo is generic for all vector lengths\n template <class D, HWY_IF_U32_D(D)>\n-HWY_API VFromD<D> DemoteTo(D /* tag */, VFromD<Rebind<double, D>> v) {\n-  return DemoteInRangeTo(D(), ZeroIfNegative(v));\n+HWY_API VFromD<D> DemoteTo(D du32, VFromD<Rebind<double, D>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return DemoteInRangeTo(du32, v);\n+#else\n+  return DemoteInRangeTo(du32, ZeroIfNegative(v));\n+#endif\n }\n #else   // HWY_TARGET > HWY_AVX3\n \n@@ -10649,7 +10666,9 @@ HWY_API Vec128<uint8_t, N> U8FromU32(const Vec128<uint32_t, N> v) {\n #if HWY_TARGET <= HWY_AVX3\n template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_I64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm_cvtts_ps_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an int64_t\n \n@@ -10677,6 +10696,9 @@ HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n // Generic for all vector lengths.\n template <class D, HWY_IF_I64_D(D)>\n HWY_API VFromD<D> PromoteTo(D di64, VFromD<Rebind<float, D>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return PromoteInRangeTo(di64, v);\n+#else\n   const Rebind<float, decltype(di64)> df32;\n   const RebindToFloat<decltype(di64)> df64;\n   // We now avoid GCC UB in PromoteInRangeTo via assembly, see #2189 and\n@@ -10689,14 +10711,21 @@ HWY_API VFromD<D> PromoteTo(D di64, VFromD<Rebind<float, D>> v) {\n       di64, PromoteMaskTo(df64, df32, Ge(v, Set(df32, 9.223372e18f))));\n   return IfThenElse(overflow, Set(di64, LimitsMax<int64_t>()),\n                     PromoteInRangeTo(di64, v));\n+#endif\n }\n template <class D, HWY_IF_U64_D(D)>\n-HWY_API VFromD<D> PromoteTo(D /* tag */, VFromD<Rebind<float, D>> v) {\n-  return PromoteInRangeTo(D(), ZeroIfNegative(v));\n+HWY_API VFromD<D> PromoteTo(D du64, VFromD<Rebind<float, D>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return PromoteInRangeTo(du64, v);\n+#else\n+  return PromoteInRangeTo(du64, ZeroIfNegative(v));\n+#endif\n }\n template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_U64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /* tag */, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm_cvtts_ps_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an uint64_t\n \n@@ -11375,7 +11404,9 @@ HWY_API VFromD<D> ConvertTo(D /* tag */, VFromD<RebindToFloat<D>> v) {\n \n template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, VFromD<RebindToFloat<D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm_cvtts_ps_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttps_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n@@ -11405,17 +11436,23 @@ HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, VFromD<RebindToFloat<D>> v) {\n // F32 to I32 ConvertTo is generic for all vector lengths\n template <class D, HWY_IF_I32_D(D)>\n HWY_API VFromD<D> ConvertTo(D di, VFromD<RebindToFloat<D>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return ConvertInRangeTo(di, v);\n+#else\n   const RebindToFloat<decltype(di)> df;\n   // See comment at the first occurrence of \"IfThenElse(overflow,\".\n   const MFromD<D> overflow = RebindMask(di, Ge(v, Set(df, 2147483648.0f)));\n   return IfThenElse(overflow, Set(di, LimitsMax<int32_t>()),\n                     ConvertInRangeTo(di, v));\n+#endif\n }\n \n #if HWY_TARGET <= HWY_AVX3\n template <class DI, HWY_IF_V_SIZE_LE_D(DI, 16), HWY_IF_I64_D(DI)>\n HWY_API VFromD<DI> ConvertInRangeTo(DI /*di*/, VFromD<RebindToFloat<DI>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DI>{_mm_cvtts_pd_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttpd_epi64 with GCC if any\n   // values of v[i] are not within the range of an int64_t\n \n@@ -11443,17 +11480,23 @@ HWY_API VFromD<DI> ConvertInRangeTo(DI /*di*/, VFromD<RebindToFloat<DI>> v) {\n // F64 to I64 ConvertTo is generic for all vector lengths on AVX3\n template <class DI, HWY_IF_I64_D(DI)>\n HWY_API VFromD<DI> ConvertTo(DI di, VFromD<RebindToFloat<DI>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return ConvertInRangeTo(di, v);\n+#else\n   const RebindToFloat<decltype(di)> df;\n   // See comment at the first occurrence of \"IfThenElse(overflow,\".\n   const MFromD<DI> overflow =\n       RebindMask(di, Ge(v, Set(df, 9.223372036854776e18)));\n   return IfThenElse(overflow, Set(di, LimitsMax<int64_t>()),\n                     ConvertInRangeTo(di, v));\n+#endif\n }\n \n template <class DU, HWY_IF_V_SIZE_LE_D(DU, 16), HWY_IF_U32_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm_cvtts_ps_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttps_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -11482,13 +11525,19 @@ HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n \n // F32->U32 ConvertTo is generic for all vector lengths\n template <class DU, HWY_IF_U32_D(DU)>\n-HWY_API VFromD<DU> ConvertTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-  return ConvertInRangeTo(DU(), ZeroIfNegative(v));\n+HWY_API VFromD<DU> ConvertTo(DU du32, VFromD<RebindToFloat<DU>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return ConvertInRangeTo(du32, v);\n+#else\n+  return ConvertInRangeTo(du32, ZeroIfNegative(v));\n+#endif\n }\n \n template <class DU, HWY_IF_V_SIZE_LE_D(DU, 16), HWY_IF_U64_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm_cvtts_pd_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttpd_epu64 with GCC if any\n   // values of v[i] are not within the range of an uint64_t\n \n@@ -11515,8 +11564,12 @@ HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n \n // F64->U64 ConvertTo is generic for all vector lengths\n template <class DU, HWY_IF_U64_D(DU)>\n-HWY_API VFromD<DU> ConvertTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-  return ConvertInRangeTo(DU(), ZeroIfNegative(v));\n+HWY_API VFromD<DU> ConvertTo(DU du64, VFromD<RebindToFloat<DU>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return ConvertInRangeTo(du64, v);\n+#else\n+  return ConvertInRangeTo(du64, ZeroIfNegative(v));\n+#endif\n }\n \n #else  // AVX2 or below"
      },
      {
        "filename": "hwy/ops/x86_256-inl.h",
        "status": "modified",
        "additions": 24,
        "deletions": 8,
        "changes": 32,
        "patch": "@@ -6446,7 +6446,9 @@ HWY_API VFromD<D> PromoteTo(D /* tag */, Vec32<int8_t> v) {\n #if HWY_TARGET <= HWY_AVX3\n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_I64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_ps_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an int64_t\n \n@@ -6474,7 +6476,9 @@ HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n }\n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_U64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /* tag */, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_ps_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an uint64_t\n #if HWY_COMPILER_GCC_ACTUAL >= 700 && !HWY_IS_DEBUG_BUILD\n@@ -6853,7 +6857,9 @@ HWY_API VFromD<D> DemoteTo(D /* tag */, Vec256<double> v) {\n \n template <class D, HWY_IF_V_SIZE_D(D, 16), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec256<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_pd_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttpd_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n@@ -6883,7 +6889,9 @@ HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec256<double> v) {\n #if HWY_TARGET <= HWY_AVX3\n template <class D, HWY_IF_V_SIZE_D(D, 16), HWY_IF_U32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec256<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_pd_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttpd_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -7178,7 +7186,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /* tag */, VFromD<RebindToFloat<D>> v) {\n \n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> ConvertInRangeTo(D /*d*/, Vec256<float> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_ps_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttps_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n@@ -7212,7 +7222,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /*d*/, Vec256<float> v) {\n #if HWY_TARGET <= HWY_AVX3\n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_I64_D(D)>\n HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, Vec256<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_pd_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttpd_epi64 with GCC if any\n   // values of v[i] are not within the range of an int64_t\n \n@@ -7240,7 +7252,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, Vec256<double> v) {\n }\n template <class DU, HWY_IF_V_SIZE_D(DU, 32), HWY_IF_U32_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm256_cvtts_ps_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttps_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -7280,7 +7294,9 @@ HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n }\n template <class DU, HWY_IF_V_SIZE_D(DU, 32), HWY_IF_U64_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm256_cvtts_pd_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttpd_epu64 with GCC if any\n   // values of v[i] are not within the range of an uint64_t\n "
      },
      {
        "filename": "hwy/ops/x86_512-inl.h",
        "status": "modified",
        "additions": 28,
        "deletions": 10,
        "changes": 38,
        "patch": "@@ -5511,7 +5511,9 @@ HWY_API VFromD<D> PromoteTo(D /* tag */, Vec256<uint32_t> v) {\n \n template <class D, HWY_IF_V_SIZE_D(D, 64), HWY_IF_I64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_ps_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an int64_t\n \n@@ -5543,7 +5545,9 @@ HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n }\n template <class D, HWY_IF_V_SIZE_D(D, 64), HWY_IF_U64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /* tag */, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_ps_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an uint64_t\n \n@@ -5831,23 +5835,27 @@ HWY_API VFromD<D> DemoteTo(D /* tag */, Vec512<double> v) {\n \n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec512<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_pd_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttpd_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n #if HWY_COMPILER_GCC_ACTUAL >= 700 && !HWY_IS_DEBUG_BUILD\n   if (detail::IsConstantX86VecForF2IConv<int32_t>(v)) {\n     typedef double GccF64RawVectType __attribute__((__vector_size__(64)));\n     const auto raw_v = reinterpret_cast<GccF64RawVectType>(v.raw);\n-    return VFromD<D>{_mm256_setr_epi32(\n+    return VFromD<D>{\n+        _mm256_setr_epi32(\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[0]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[1]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[2]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[3]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[4]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[5]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[6]),\n-        detail::X86ConvertScalarFromFloat<int32_t>(raw_v[7]))};\n+        detail::X86ConvertScalarFromFloat<int32_t>(raw_v[7]))\n+        };\n   }\n #endif\n \n@@ -5864,7 +5872,9 @@ HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec512<double> v) {\n \n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_U32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec512<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_pd_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttpd_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -6210,7 +6220,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /* tag */, VFromD<RebindToFloat<D>> v) {\n #endif  // HWY_HAVE_FLOAT16\n template <class D, HWY_IF_V_SIZE_D(D, 64), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> ConvertInRangeTo(D /*d*/, Vec512<float> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_ps_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttps_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n@@ -6250,7 +6262,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /*d*/, Vec512<float> v) {\n }\n template <class D, HWY_IF_V_SIZE_D(D, 64), HWY_IF_I64_D(D)>\n HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, Vec512<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_pd_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttpd_epi64 with GCC if any\n   // values of v[i] are not within the range of an int64_t\n \n@@ -6282,7 +6296,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, Vec512<double> v) {\n }\n template <class DU, HWY_IF_V_SIZE_D(DU, 64), HWY_IF_U32_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm512_cvtts_ps_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttps_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -6338,7 +6354,9 @@ HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n }\n template <class DU, HWY_IF_V_SIZE_D(DU, 64), HWY_IF_U64_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm512_cvtts_pd_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttpd_epu64 with GCC if any\n   // values of v[i] are not within the range of an uint64_t\n "
      }
    ],
    "lines_added": 121,
    "lines_removed": 34
  },
  "issues": [],
  "pull_requests": [],
  "build_info": {
    "old_build_script": [
      "apt-get update",
      "cmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON -DHWY_ENABLE_TESTS=ON",
      "cmake --build /test_workspace/workspace/old/build -- -j 1"
    ],
    "new_build_script": [
      "apt-get update",
      "cmake -S /test_workspace/workspace/new -B /test_workspace/workspace/new/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON -DHWY_ENABLE_TESTS=ON",
      "cmake --build /test_workspace/workspace/new/build -- -j 1"
    ],
    "old_test_script": [
      "cd /test_workspace/workspace/old/build",
      "ctest --output-on-failure"
    ],
    "new_test_script": [
      "cd /test_workspace/workspace/new/build",
      "ctest --output-on-failure"
    ],
    "build_system": "cmake"
  },
  "performance_analysis": {
    "is_significant": false,
    "p_value": 1.0,
    "is_pair_significant": false,
    "pair_p_value": 1.0,
    "is_binom_significant": false,
    "binom_p_value": 1.0,
    "is_wilcoxon_significant": false,
    "wilcoxon_p_value": 0.9999991333466779,
    "is_mannwhitney_significant": false,
    "mannwhitney_p_value": 0.27957977904801207,
    "relative_improvement": 0.0009200778801406721,
    "absolute_improvement_ms": 51.666666666669414,
    "old_mean_ms": 56154.666666666664,
    "new_mean_ms": 56102.99999999999,
    "old_std_ms": 556.7623979904645,
    "new_std_ms": 564.533069188065,
    "effect_size_cohens_d": 0.09215309889411784,
    "old_ci95_ms": [
      55946.76817054087,
      56362.56516279246
    ],
    "new_ci95_ms": [
      55892.19988756228,
      56313.800112437704
    ],
    "old_ci99_ms": [
      55874.47882256821,
      56434.854510765115
    ],
    "new_ci99_ms": [
      55818.9016051569,
      56387.098394843095
    ],
    "new_times_s": [
      54.69,
      56.0,
      55.89,
      55.59,
      56.7,
      55.59,
      55.48,
      55.59,
      55.42,
      55.42,
      56.37,
      55.74,
      55.32,
      56.12,
      57.17,
      57.06,
      55.6,
      55.61,
      56.07,
      56.06,
      55.98,
      56.06,
      56.2,
      56.41,
      57.06,
      56.52,
      55.77,
      56.41,
      56.77,
      55.82,
      57.29
    ],
    "old_times_s": [
      55.53,
      55.12,
      56.0,
      56.78,
      57.15,
      55.54,
      55.68,
      55.74,
      56.58,
      56.02,
      55.26,
      55.46,
      56.28,
      55.64,
      56.66,
      55.76,
      56.52,
      55.47,
      55.64,
      56.56,
      56.57,
      56.42,
      56.5,
      57.08,
      57.17,
      56.23,
      56.48,
      56.24,
      55.87,
      56.31,
      55.91
    ]
  },
  "tests": {
    "total_tests": 9,
    "significant_improvements": 0,
    "significant_improvements_tests": [],
    "significant_regressions": 0,
    "significant_regressions_tests": [],
    "significant_pair_improvements": 0,
    "significant_pair_improvements_tests": [],
    "significant_pair_regressions": 0,
    "significant_pair_regressions_tests": [],
    "significant_binom_improvements": 0,
    "significant_binom_improvements_tests": [],
    "significant_binom_regressions": 0,
    "significant_binom_regressions_tests": [],
    "significant_wilcoxon_improvements": 0,
    "significant_wilcoxon_improvements_tests": [],
    "significant_wilcoxon_regressions": 0,
    "significant_wilcoxon_regressions_tests": [],
    "significant_mannwhitney_improvements": 0,
    "significant_mannwhitney_improvements_tests": [],
    "significant_mannwhitney_regressions": 0,
    "significant_mannwhitney_regressions_tests": [],
    "tests": [
      {
        "test_name": "AbortDeathTest.AbortDefault",
        "is_significant": false,
        "p_value": 0.9604187905160846,
        "is_pair_significant": false,
        "pair_p_value": 0.9902982536925514,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999998590240646,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.8524056346033264,
        "relative_improvement": -0.06896551724137938,
        "absolute_improvement_ms": -0.714285714285716,
        "old_mean_ms": 10.357142857142858,
        "new_mean_ms": 11.071428571428575,
        "old_std_ms": 1.8898223650461363,
        "new_std_ms": 3.14970394174356,
        "effect_size_cohens_d": -0.275009549108464,
        "old_ci95_ms": [
          9.624346244114186,
          11.08993947017153
        ],
        "new_ci95_ms": [
          9.850100883047453,
          12.292756259809694
        ],
        "old_ci99_ms": [
          9.367613229599403,
          11.346672484686314
        ],
        "new_ci99_ms": [
          9.422212525522815,
          12.720644617334333
        ],
        "new_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.02,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.02,
          0.02,
          0.01
        ],
        "old_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.02,
          0.01,
          0.01
        ]
      },
      {
        "test_name": "NanobenchmarkTest.RunTest",
        "is_significant": false,
        "p_value": 0.9310836021312858,
        "is_pair_significant": false,
        "pair_p_value": 0.9226377912434829,
        "is_binom_significant": false,
        "binom_p_value": 0.9821509309113026,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9749460028706439,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.5684772233943376,
        "relative_improvement": -0.008826125330979668,
        "absolute_improvement_ms": -3.5714285714286143,
        "old_mean_ms": 404.6428571428571,
        "new_mean_ms": 408.2142857142857,
        "old_std_ms": 52.80867934115201,
        "new_std_ms": 66.7806565156115,
        "effect_size_cohens_d": -0.0593246944704538,
        "old_ci95_ms": [
          384.1657889932436,
          425.11992529247055
        ],
        "new_ci95_ms": [
          382.3194504029909,
          434.10912102558046
        ],
        "old_ci99_ms": [
          376.9917118468619,
          432.29400243885226
        ],
        "new_ci99_ms": [
          373.24727537975235,
          443.18129604881904
        ],
        "new_times": [
          0.42,
          0.63,
          0.34,
          0.35,
          0.37,
          0.43,
          0.43,
          0.5,
          0.39,
          0.4,
          0.31,
          0.43,
          0.5,
          0.4,
          0.42,
          0.4,
          0.36,
          0.38,
          0.3,
          0.37,
          0.42,
          0.44,
          0.47,
          0.47,
          0.34,
          0.38,
          0.42,
          0.36
        ],
        "old_times": [
          0.36,
          0.36,
          0.34,
          0.43,
          0.38,
          0.37,
          0.34,
          0.44,
          0.36,
          0.45,
          0.37,
          0.38,
          0.46,
          0.41,
          0.39,
          0.56,
          0.34,
          0.44,
          0.51,
          0.36,
          0.46,
          0.4,
          0.45,
          0.38,
          0.39,
          0.42,
          0.41,
          0.37
        ]
      },
      {
        "test_name": "AutoTuneTest.TestCostDistribution",
        "is_significant": false,
        "p_value": 0.9997990405690469,
        "is_pair_significant": false,
        "pair_p_value": 0.9980173431817089,
        "is_binom_significant": false,
        "binom_p_value": 0.9981404170393944,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9993066604061847,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.5773606575237981,
        "relative_improvement": -0.0029673590504450406,
        "absolute_improvement_ms": -0.3571428571428614,
        "old_mean_ms": 120.35714285714285,
        "new_mean_ms": 120.71428571428571,
        "old_std_ms": 6.929348671835833,
        "new_std_ms": 6.042179781166441,
        "effect_size_cohens_d": -0.05493731565986402,
        "old_ci95_ms": [
          117.67022194270437,
          123.0440637715813
        ],
        "new_ci95_ms": [
          118.37137298299257,
          123.05719844557885
        ],
        "old_ci99_ms": [
          116.72886755615016,
          123.98541815813552
        ],
        "new_ci99_ms": [
          117.5505407936025,
          123.87803063496891
        ],
        "new_times": [
          0.13,
          0.12,
          0.13,
          0.13,
          0.12,
          0.13,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.11,
          0.11,
          0.12,
          0.11,
          0.12,
          0.13,
          0.12,
          0.12,
          0.12,
          0.12,
          0.11,
          0.12,
          0.12,
          0.13,
          0.12,
          0.12,
          0.12
        ],
        "old_times": [
          0.11,
          0.12,
          0.12,
          0.13,
          0.12,
          0.12,
          0.12,
          0.11,
          0.11,
          0.12,
          0.12,
          0.13,
          0.13,
          0.13,
          0.12,
          0.12,
          0.11,
          0.12,
          0.13,
          0.12,
          0.12,
          0.13,
          0.12,
          0.11,
          0.12,
          0.11,
          0.13,
          0.12
        ]
      },
      {
        "test_name": "SpinTest.TestPingPong",
        "is_significant": false,
        "p_value": 0.9999999997944539,
        "is_pair_significant": false,
        "pair_p_value": 0.9999999997944539,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999998590240646,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.9268512769289898,
        "relative_improvement": -0.008928571428571435,
        "absolute_improvement_ms": -0.7142857142857229,
        "old_mean_ms": 80.0,
        "new_mean_ms": 80.71428571428572,
        "old_std_ms": 0.0,
        "new_std_ms": 2.6226526415648097,
        "effect_size_cohens_d": -0.38516444325982635,
        "old_ci95_ms": [
          80.0,
          80.0
        ],
        "new_ci95_ms": [
          79.69732718504191,
          81.73124424352955
        ],
        "old_ci99_ms": [
          80.0,
          80.0
        ],
        "new_ci99_ms": [
          79.34103892687133,
          82.08753250170011
        ],
        "new_times": [
          0.08,
          0.09,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.09,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08
        ],
        "old_times": [
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08
        ]
      },
      {
        "test_name": "ThreadPoolTest.TestPool",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999393422746,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 1.0,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 10.0,
        "new_mean_ms": 10.0,
        "old_std_ms": 0.0,
        "new_std_ms": 0.0,
        "effect_size_cohens_d": "NaN",
        "old_ci95_ms": [
          10.0,
          10.0
        ],
        "new_ci95_ms": [
          10.0,
          10.0
        ],
        "old_ci99_ms": [
          10.0,
          10.0
        ],
        "new_ci99_ms": [
          10.0,
          10.0
        ],
        "new_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ],
        "old_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ]
      },
      {
        "test_name": "ThreadPoolTest.TestWaitMode",
        "is_significant": false,
        "p_value": 0.9983398693258332,
        "is_pair_significant": false,
        "pair_p_value": 0.9965505279208252,
        "is_binom_significant": false,
        "binom_p_value": 0.9995438829064369,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9976267156982908,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.17503615056273641,
        "relative_improvement": 0.006030229461978198,
        "absolute_improvement_ms": 27.500000000000746,
        "old_mean_ms": 4560.357142857143,
        "new_mean_ms": 4532.857142857142,
        "old_std_ms": 236.03957833313146,
        "new_std_ms": 262.08363300257923,
        "effect_size_cohens_d": 0.11026384040446462,
        "old_ci95_ms": [
          4468.8305492775335,
          4651.883736436752
        ],
        "new_ci95_ms": [
          4431.2317191418015,
          4634.482566572482
        ],
        "old_ci99_ms": [
          4436.76449184743,
          4683.9497938668555
        ],
        "new_ci99_ms": [
          4395.62756797911,
          4670.086717735174
        ],
        "new_times": [
          4.64,
          4.67,
          4.77,
          4.38,
          4.39,
          4.33,
          4.37,
          4.29,
          4.83,
          4.34,
          4.37,
          4.84,
          4.72,
          4.33,
          4.35,
          4.37,
          4.19,
          4.89,
          4.49,
          4.47,
          4.45,
          4.77,
          4.68,
          4.41,
          4.33,
          4.48,
          4.35,
          5.42
        ],
        "old_times": [
          4.46,
          4.97,
          4.63,
          4.39,
          4.79,
          5.14,
          4.42,
          4.23,
          4.74,
          4.78,
          4.38,
          5.09,
          4.39,
          4.62,
          4.41,
          4.4,
          4.82,
          4.44,
          4.71,
          4.47,
          4.52,
          4.38,
          4.44,
          4.45,
          4.52,
          4.32,
          4.46,
          4.32
        ]
      },
      {
        "test_name": "ThreadPoolTest.TestCounter",
        "is_significant": false,
        "p_value": 0.9940920817970501,
        "is_pair_significant": false,
        "pair_p_value": 0.9957306873520502,
        "is_binom_significant": false,
        "binom_p_value": 0.9981404170393944,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9956328882502888,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.8559998404005659,
        "relative_improvement": -0.05369127516778528,
        "absolute_improvement_ms": -8.57142857142859,
        "old_mean_ms": 159.64285714285714,
        "new_mean_ms": 168.21428571428572,
        "old_std_ms": 20.089087300607474,
        "new_std_ms": 27.49458821208968,
        "effect_size_cohens_d": -0.3559822738425538,
        "old_ci95_ms": [
          151.85312229528427,
          167.43259199043
        ],
        "new_ci95_ms": [
          157.55299738841416,
          178.8755740401573
        ],
        "old_ci99_ms": [
          149.1240129160492,
          170.16170136966508
        ],
        "new_ci99_ms": [
          153.81784817804905,
          182.6107232505224
        ],
        "new_times": [
          0.18,
          0.16,
          0.19,
          0.17,
          0.19,
          0.15,
          0.14,
          0.16,
          0.23,
          0.18,
          0.24,
          0.14,
          0.19,
          0.15,
          0.17,
          0.16,
          0.17,
          0.14,
          0.15,
          0.13,
          0.15,
          0.2,
          0.15,
          0.16,
          0.16,
          0.15,
          0.21,
          0.14
        ],
        "old_times": [
          0.17,
          0.15,
          0.15,
          0.16,
          0.19,
          0.14,
          0.17,
          0.17,
          0.14,
          0.14,
          0.16,
          0.2,
          0.17,
          0.13,
          0.14,
          0.15,
          0.17,
          0.15,
          0.15,
          0.15,
          0.13,
          0.18,
          0.18,
          0.15,
          0.19,
          0.15,
          0.2,
          0.14
        ]
      },
      {
        "test_name": "TopologyTest.TestTopology",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999393422746,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 1.0,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 10.0,
        "new_mean_ms": 10.0,
        "old_std_ms": 0.0,
        "new_std_ms": 0.0,
        "effect_size_cohens_d": "NaN",
        "old_ci95_ms": [
          10.0,
          10.0
        ],
        "new_ci95_ms": [
          10.0,
          10.0
        ],
        "old_ci99_ms": [
          10.0,
          10.0
        ],
        "new_ci99_ms": [
          10.0,
          10.0
        ],
        "new_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ],
        "old_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ]
      },
      {
        "test_name": "TopologyTest.TestCaches",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999393422746,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 1.0,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 10.0,
        "new_mean_ms": 10.0,
        "old_std_ms": 0.0,
        "new_std_ms": 0.0,
        "effect_size_cohens_d": "NaN",
        "old_ci95_ms": [
          10.0,
          10.0
        ],
        "new_ci95_ms": [
          10.0,
          10.0
        ],
        "old_ci99_ms": [
          10.0,
          10.0
        ],
        "new_ci99_ms": [
          10.0,
          10.0
        ],
        "new_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ],
        "old_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ]
      }
    ]
  },
  "logs": {
    "full_log_path": "/logs/full.log",
    "config_log_path": "/logs/config.log",
    "build_log_path": "/logs/build.log",
    "test_log_path": "/logs/test.log",
    "build_success": true,
    "test_success": true
  },
  "raw_timing_data": {
    "warmup_runs": 1,
    "measurement_runs": 30,
    "min_exec_time_improvement": 0.05,
    "min_p_value": 0.05
  }
}