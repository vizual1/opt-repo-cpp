{
  "metadata": {
    "collection_date": "2026-02-03T20:04:31.130743",
    "repository": "https://github.com/nfrechette/acl",
    "repository_name": "nfrechette/acl"
  },
  "commit_info": {
    "old_sha": "d4470327981561994e116a13a19318f43f276e0a",
    "new_sha": "f2eee9de134b3ab33088ba32b21d25269db005b5",
    "commit_message": [
      "fix(decompression): unroll when prefetching is done and reduce prefetching"
    ],
    "commit_date": "2025-04-06T02:42:07+00:00",
    "patch": [
      "--- includes/acl/decompression/impl/steps/rotation_constant.h\n@@ -159,7 +159,7 @@ namespace acl\n \t\t\t\tif (packed_entry == 0)\n \t\t\t\t{\n \t\t\t\t\tif (entry_index > last_entry_index)\n-\t\t\t\t\t\tbreak;\t// We are done\n+\t\t\t\t\t\tgoto done;\t// We are done\n \n \t\t\t\t\t// Mask out everything but constant sub-tracks, this way we can early out when we iterate\n \t\t\t\t\t// Use and_not(..) to load our sub-track types directly from memory on x64 with BMI\n@@ -174,20 +174,21 @@ namespace acl\n \t\t\t\t// Reset our unpack count if it is k_sub_step_unpack_count\n \t\t\t\tnum_unpacked %= k_sub_step_unpack_count;\n \n+\t\t\t\t// Our sub-step loop takes about 60 instructions and so we want to prefetch\n+\t\t\t\t// 2 cache lines into the L1 each iteration\n+\t\t\t\tmemory_prefetch_into_L1(constant_data_rotations + (3 * 64));\n+\n \t\t\t\tif (num_unpacked == 0)\n \t\t\t\t{\n-\t\t\t\t\t// Our sub-step loop takes about 60 instructions and so we want to prefetch\n-\t\t\t\t\t// 4 cache lines into the L2 each iteration\n \t\t\t\t\tif (next_prefetch_ptr)\n \t\t\t\t\t{\n-\t\t\t\t\t\tmemory_prefetch_into_L2(next_prefetch_ptr);\n-\t\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[1]);\n-\t\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[2]);\n-\t\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[3]);\n+\t\t\t\t\t\tmemory_prefetch_into_L1(next_prefetch_ptr);\n \n-\t\t\t\t\t\tprefetch_queue_ptr += 4;\n+\t\t\t\t\t\tprefetch_queue_ptr += 1;\n \t\t\t\t\t\tnext_prefetch_ptr = *prefetch_queue_ptr;\n \t\t\t\t\t}\n+\t\t\t\t\telse\n+\t\t\t\t\t\tbreak;\n \n \t\t\t\t\t// Unpack up to 4 rotations\n \t\t\t\t\tunpack_constant_rotation_group<decompression_settings_type>(decomp_context, constant_data_rotations, num_left_to_unpack, constant_rotations);\n@@ -212,6 +213,54 @@ namespace acl\n \t\t\t\t}\n \t\t\t}\n \n+\t\t\tmemory_prefetch_into_L1(constant_data_rotations + (3 * 64));\n+\t\t\tmemory_prefetch_into_L1(constant_data_rotations + (4 * 64));\n+\n+\t\t\twhile (true)\n+\t\t\t{\n+\t\t\t\t// If our entry is empty, grab the next one\n+\t\t\t\tif (packed_entry == 0)\n+\t\t\t\t{\n+\t\t\t\t\tif (entry_index > last_entry_index)\n+\t\t\t\t\t\tgoto done;\t// We are done\n+\n+\t\t\t\t\t// Mask out everything but constant sub-tracks, this way we can early out when we iterate\n+\t\t\t\t\t// Use and_not(..) to load our sub-track types directly from memory on x64 with BMI\n+\t\t\t\t\tpacked_entry = and_not(~0x55555555U, rotation_sub_track_types[entry_index].types);\n+\n+\t\t\t\t\t// We have 2 bits per sub-track\n+\t\t\t\t\tcurr_entry_track_index = entry_index * 16;\n+\n+\t\t\t\t\tentry_index++;\n+\t\t\t\t}\n+\n+\t\t\t\tnum_unpacked %= k_sub_step_unpack_count;\n+\n+\t\t\t\tif (num_unpacked == 0)\n+\t\t\t\t{\n+\t\t\t\t\t// Unpack up to 4 rotations\n+\t\t\t\t\tunpack_constant_rotation_group<decompression_settings_type>(decomp_context, constant_data_rotations, num_left_to_unpack, constant_rotations);\n+\t\t\t\t}\n+\n+\t\t\t\twhile (packed_entry != 0 && num_unpacked < k_sub_step_unpack_count)\n+\t\t\t\t{\n+\t\t\t\t\tconst uint32_t set_bit_index = count_leading_zeros(packed_entry);\n+\t\t\t\t\tconst uint32_t highest_set_bit = 1 << (31 - set_bit_index);\n+\n+\t\t\t\t\t// Mask out the bit we just consumed\n+\t\t\t\t\tpacked_entry ^= highest_set_bit;\n+\n+\t\t\t\t\t// We have 2 bits per sub-track\n+\t\t\t\t\tconst uint32_t track_index = curr_entry_track_index + (set_bit_index / 2);\n+\n+\t\t\t\t\tif (!writer.skip_track_rotation(track_index))\n+\t\t\t\t\t\twriter.write_rotation(track_index, constant_rotations[num_unpacked]);\n+\n+\t\t\t\t\tnum_unpacked++;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\tdone:\n \t\t\tstep_context.prefetch_queue_ptr = prefetch_queue_ptr;\n \t\t}\n \t}\n--- includes/acl/decompression/impl/steps/rotation_default.h\n@@ -82,13 +82,13 @@ namespace acl\n \t\t\tuint32_t packed_entry = 0;\n \n \t\t\t// This is our sub-step loop\n-\t\t\twhile (true)\n+\t\t\twhile (next_prefetch_ptr != nullptr)\n \t\t\t{\n \t\t\t\t// If our entry is empty, grab the next one\n \t\t\t\tif (packed_entry == 0)\n \t\t\t\t{\n \t\t\t\t\tif (entry_index > last_entry_index)\n-\t\t\t\t\t\tbreak;\t// We are done\n+\t\t\t\t\t\tgoto done;\t// We are done\n \n \t\t\t\t\tpacked_entry = rotation_sub_track_types[entry_index].types;\n \n@@ -115,15 +115,13 @@ namespace acl\n \t\t\t\tnum_unpacked %= k_sub_step_unpack_count;\n \n \t\t\t\t// Our sub-step loop takes about 60 instructions and so we want to prefetch\n-\t\t\t\t// 4 cache lines into the L2 each iteration\n-\t\t\t\tif (next_prefetch_ptr && num_unpacked == 0)\n+\t\t\t\t// 2 cache lines into the L1 each iteration\n+\t\t\t\tif (num_unpacked == 0)\n \t\t\t\t{\n-\t\t\t\t\tmemory_prefetch_into_L2(next_prefetch_ptr);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[1]);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[2]);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[3]);\n+\t\t\t\t\tmemory_prefetch_into_L1(next_prefetch_ptr);\n+\t\t\t\t\tmemory_prefetch_into_L1(prefetch_queue_ptr[1]);\n \n-\t\t\t\t\tprefetch_queue_ptr += 4;\n+\t\t\t\t\tprefetch_queue_ptr += 2;\n \t\t\t\t\tnext_prefetch_ptr = *prefetch_queue_ptr;\n \t\t\t\t}\n \n@@ -150,6 +148,57 @@ namespace acl\n \t\t\t\t}\n \t\t\t}\n \n+\t\t\twhile (true)\n+\t\t\t{\n+\t\t\t\t// If our entry is empty, grab the next one\n+\t\t\t\tif (packed_entry == 0)\n+\t\t\t\t{\n+\t\t\t\t\tif (entry_index > last_entry_index)\n+\t\t\t\t\t\tgoto done;\t// We are done\n+\n+\t\t\t\t\tpacked_entry = rotation_sub_track_types[entry_index].types;\n+\n+\t\t\t\t\t// Mask out everything but default sub-tracks, this way we can early out when we iterate\n+\t\t\t\t\t// Each sub-track is either 0 (default), 1 (constant), or 2 (animated)\n+\t\t\t\t\t// By flipping the bits with logical NOT, 0 becomes 3, 1 becomes 2, and 2 becomes 1\n+\t\t\t\t\t// We then subtract 1 from every group so 3 becomes 2, 2 becomes 1, and 1 becomes 0\n+\t\t\t\t\t// Finally, we mask out everything but the second bit for each sub-track\n+\t\t\t\t\t// After this, our original default tracks are equal to 2, our constant tracks are equal to 1, and our animated tracks are equal to 0\n+\t\t\t\t\t// Testing for default tracks can be done by testing the second bit of each group (same as animated track testing)\n+\t\t\t\t\tpacked_entry = ~packed_entry - 0x55555555;\n+\n+\t\t\t\t\t// Because our last entry might have padding with 0 (default), we have to strip any padding we might have\n+\t\t\t\t\tconst uint32_t entry_padding_mask = (entry_index == last_entry_index) ? padding_mask : 0xAAAAAAAA;\n+\t\t\t\t\tpacked_entry &= entry_padding_mask;\n+\n+\t\t\t\t\t// We have 2 bits per sub-track\n+\t\t\t\t\tcurr_entry_track_index = entry_index * 16;\n+\n+\t\t\t\t\tentry_index++;\n+\t\t\t\t}\n+\n+\t\t\t\twhile (packed_entry != 0)\n+\t\t\t\t{\n+\t\t\t\t\tconst uint32_t set_bit_index = count_leading_zeros(packed_entry);\n+\t\t\t\t\tconst uint32_t highest_set_bit = 1 << (31 - set_bit_index);\n+\n+\t\t\t\t\t// Mask out the bit we just consumed\n+\t\t\t\t\tpacked_entry ^= highest_set_bit;\n+\n+\t\t\t\t\t// We have 2 bits per sub-track\n+\t\t\t\t\tconst uint32_t track_index = curr_entry_track_index + (set_bit_index / 2);\n+\n+\t\t\t\t\tif (!writer.skip_track_rotation(track_index))\n+\t\t\t\t\t{\n+\t\t\t\t\t\tif (default_mode == default_sub_track_mode::variable)\n+\t\t\t\t\t\t\twriter.write_rotation(track_index, writer.get_variable_default_rotation(track_index));\n+\t\t\t\t\t\telse\n+\t\t\t\t\t\t\twriter.write_rotation(track_index, default_rotation);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\tdone:\n \t\t\tstep_context.prefetch_queue_ptr = prefetch_queue_ptr;\n \t\t}\n \t}\n--- includes/acl/decompression/impl/steps/scale_default.h\n@@ -87,13 +87,13 @@ namespace acl\n \t\t\tuint32_t packed_entry = 0;\n \n \t\t\t// This is our sub-step loop\n-\t\t\twhile (true)\n+\t\t\twhile (next_prefetch_ptr != nullptr)\n \t\t\t{\n \t\t\t\t// If our entry is empty, grab the next one\n \t\t\t\tif (packed_entry == 0)\n \t\t\t\t{\n \t\t\t\t\tif (entry_index > last_entry_index)\n-\t\t\t\t\t\tbreak;\t// We are done\n+\t\t\t\t\t\tgoto done;\t// We are done\n \n \t\t\t\t\tpacked_entry = scale_sub_track_types[entry_index].types;\n \n@@ -120,15 +120,13 @@ namespace acl\n \t\t\t\tnum_unpacked %= k_sub_step_unpack_count;\n \n \t\t\t\t// Our sub-step loop takes about 60 instructions and so we want to prefetch\n-\t\t\t\t// 4 cache lines into the L2 each iteration\n-\t\t\t\tif (next_prefetch_ptr && num_unpacked == 0)\n+\t\t\t\t// 2 cache lines into the L1 each iteration\n+\t\t\t\tif (num_unpacked == 0)\n \t\t\t\t{\n-\t\t\t\t\tmemory_prefetch_into_L2(next_prefetch_ptr);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[1]);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[2]);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[3]);\n+\t\t\t\t\tmemory_prefetch_into_L1(next_prefetch_ptr);\n+\t\t\t\t\tmemory_prefetch_into_L1(prefetch_queue_ptr[1]);\n \n-\t\t\t\t\tprefetch_queue_ptr += 4;\n+\t\t\t\t\tprefetch_queue_ptr += 2;\n \t\t\t\t\tnext_prefetch_ptr = *prefetch_queue_ptr;\n \t\t\t\t}\n \n@@ -155,6 +153,57 @@ namespace acl\n \t\t\t\t}\n \t\t\t}\n \n+\t\t\twhile (true)\n+\t\t\t{\n+\t\t\t\t// If our entry is empty, grab the next one\n+\t\t\t\tif (packed_entry == 0)\n+\t\t\t\t{\n+\t\t\t\t\tif (entry_index > last_entry_index)\n+\t\t\t\t\t\tgoto done;\t// We are done\n+\n+\t\t\t\t\tpacked_entry = scale_sub_track_types[entry_index].types;\n+\n+\t\t\t\t\t// Mask out everything but default sub-tracks, this way we can early out when we iterate\n+\t\t\t\t\t// Each sub-track is either 0 (default), 1 (constant), or 2 (animated)\n+\t\t\t\t\t// By flipping the bits with logical NOT, 0 becomes 3, 1 becomes 2, and 2 becomes 1\n+\t\t\t\t\t// We then subtract 1 from every group so 3 becomes 2, 2 becomes 1, and 1 becomes 0\n+\t\t\t\t\t// Finally, we mask out everything but the second bit for each sub-track\n+\t\t\t\t\t// After this, our original default tracks are equal to 2, our constant tracks are equal to 1, and our animated tracks are equal to 0\n+\t\t\t\t\t// Testing for default tracks can be done by testing the second bit of each group (same as animated track testing)\n+\t\t\t\t\tpacked_entry = ~packed_entry - 0x55555555;\n+\n+\t\t\t\t\t// Because our last entry might have padding with 0 (default), we have to strip any padding we might have\n+\t\t\t\t\tconst uint32_t entry_padding_mask = (entry_index == last_entry_index) ? padding_mask : 0xAAAAAAAA;\n+\t\t\t\t\tpacked_entry &= entry_padding_mask;\n+\n+\t\t\t\t\t// We have 2 bits per sub-track\n+\t\t\t\t\tcurr_entry_track_index = entry_index * 16;\n+\n+\t\t\t\t\tentry_index++;\n+\t\t\t\t}\n+\n+\t\t\t\twhile (packed_entry != 0)\n+\t\t\t\t{\n+\t\t\t\t\tconst uint32_t set_bit_index = count_leading_zeros(packed_entry);\n+\t\t\t\t\tconst uint32_t highest_set_bit = 1 << (31 - set_bit_index);\n+\n+\t\t\t\t\t// Mask out the bit we just consumed\n+\t\t\t\t\tpacked_entry ^= highest_set_bit;\n+\n+\t\t\t\t\t// We have 2 bits per sub-track\n+\t\t\t\t\tconst uint32_t track_index = curr_entry_track_index + (set_bit_index / 2);\n+\n+\t\t\t\t\tif (!writer.skip_track_scale(track_index))\n+\t\t\t\t\t{\n+\t\t\t\t\t\tif (default_mode == default_sub_track_mode::variable)\n+\t\t\t\t\t\t\twriter.write_scale(track_index, writer.get_variable_default_scale(track_index));\n+\t\t\t\t\t\telse\n+\t\t\t\t\t\t\twriter.write_scale(track_index, default_scale);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\tdone:\n \t\t\tstep_context.prefetch_queue_ptr = prefetch_queue_ptr;\n \t\t}\n \n@@ -198,19 +247,22 @@ namespace acl\n \t\t\tconstexpr uint32_t k_prefetch_multiple = 8;\n \n \t\t\t// No scale present, everything is just the default value\n-\t\t\tfor (uint32_t track_index = 0; track_index < num_tracks; ++track_index)\n+\t\t\tuint32_t track_index = 0;\n+\t\t\tfor (; track_index < num_tracks; ++track_index)\n \t\t\t{\n \t\t\t\t// Our step takes about 50 instructions and so we want to prefetch\n-\t\t\t\t// 4 cache lines into the L2\n-\t\t\t\tif (next_prefetch_ptr && (track_index % k_prefetch_multiple) == 0)\n+\t\t\t\t// 1 cache line into the L1\n+\t\t\t\tif ((track_index % k_prefetch_multiple) == 0)\n \t\t\t\t{\n-\t\t\t\t\tmemory_prefetch_into_L2(next_prefetch_ptr);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[1]);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[2]);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[3]);\n+\t\t\t\t\tif (next_prefetch_ptr != nullptr)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tmemory_prefetch_into_L1(next_prefetch_ptr);\n \n-\t\t\t\t\tprefetch_queue_ptr += 4;\n-\t\t\t\t\tnext_prefetch_ptr = *prefetch_queue_ptr;\n+\t\t\t\t\t\tprefetch_queue_ptr += 1;\n+\t\t\t\t\t\tnext_prefetch_ptr = *prefetch_queue_ptr;\n+\t\t\t\t\t}\n+\t\t\t\t\telse\n+\t\t\t\t\t\tbreak;\n \t\t\t\t}\n \n \t\t\t\tif (!writer.skip_track_scale(track_index))\n@@ -222,6 +274,17 @@ namespace acl\n \t\t\t\t}\n \t\t\t}\n \n+\t\t\tfor (; track_index < num_tracks; ++track_index)\n+\t\t\t{\n+\t\t\t\tif (!writer.skip_track_scale(track_index))\n+\t\t\t\t{\n+\t\t\t\t\tif (default_mode == default_sub_track_mode::variable)\n+\t\t\t\t\t\twriter.write_scale(track_index, writer.get_variable_default_scale(track_index));\n+\t\t\t\t\telse\n+\t\t\t\t\t\twriter.write_scale(track_index, scale);\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\tstep_context.prefetch_queue_ptr = prefetch_queue_ptr;\n \t\t}\n \t}\n--- includes/acl/decompression/impl/steps/translation_constant.h\n@@ -73,13 +73,13 @@ namespace acl\n \t\t\tuint32_t packed_entry = 0;\n \n \t\t\t// This is our sub-step loop\n-\t\t\twhile (true)\n+\t\t\twhile (next_prefetch_ptr != nullptr)\n \t\t\t{\n \t\t\t\t// If our entry is empty, grab the next one\n \t\t\t\tif (packed_entry == 0)\n \t\t\t\t{\n \t\t\t\t\tif (entry_index > last_entry_index)\n-\t\t\t\t\t\tbreak;\t// We are done\n+\t\t\t\t\t\tgoto done;\t// We are done\n \n \t\t\t\t\t// Mask out everything but constant sub-tracks, this way we can early out when we iterate\n \t\t\t\t\t// Use and_not(..) to load our sub-track types directly from memory on x64 with BMI\n@@ -95,15 +95,14 @@ namespace acl\n \t\t\t\tnum_unpacked %= k_sub_step_unpack_count;\n \n \t\t\t\t// Our sub-step loop takes about 60 instructions and so we want to prefetch\n-\t\t\t\t// 4 cache lines into the L2 each iteration\n-\t\t\t\tif (next_prefetch_ptr && num_unpacked == 0)\n+\t\t\t\t// 2 cache lines into the L1 each iteration\n+\t\t\t\tmemory_prefetch_into_L1(constant_data_translations + (3 * 64));\n+\n+\t\t\t\tif (num_unpacked == 0)\n \t\t\t\t{\n-\t\t\t\t\tmemory_prefetch_into_L2(next_prefetch_ptr);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[1]);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[2]);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[3]);\n+\t\t\t\t\tmemory_prefetch_into_L1(next_prefetch_ptr);\n \n-\t\t\t\t\tprefetch_queue_ptr += 4;\n+\t\t\t\t\tprefetch_queue_ptr += 1;\n \t\t\t\t\tnext_prefetch_ptr = *prefetch_queue_ptr;\n \t\t\t\t}\n \n@@ -129,6 +128,47 @@ namespace acl\n \t\t\t\t}\n \t\t\t}\n \n+\t\t\tmemory_prefetch_into_L1(constant_data_translations + (3 * 64));\n+\t\t\tmemory_prefetch_into_L1(constant_data_translations + (4 * 64));\n+\n+\t\t\twhile (true)\n+\t\t\t{\n+\t\t\t\t// If our entry is empty, grab the next one\n+\t\t\t\tif (packed_entry == 0)\n+\t\t\t\t{\n+\t\t\t\t\tif (entry_index > last_entry_index)\n+\t\t\t\t\t\tgoto done;\t// We are done\n+\n+\t\t\t\t\t// Mask out everything but constant sub-tracks, this way we can early out when we iterate\n+\t\t\t\t\t// Use and_not(..) to load our sub-track types directly from memory on x64 with BMI\n+\t\t\t\t\tpacked_entry = and_not(~0x55555555U, translation_sub_track_types[entry_index].types);\n+\n+\t\t\t\t\t// We have 2 bits per sub-track\n+\t\t\t\t\tcurr_entry_track_index = entry_index * 16;\n+\n+\t\t\t\t\tentry_index++;\n+\t\t\t\t}\n+\n+\t\t\t\twhile (packed_entry != 0)\n+\t\t\t\t{\n+\t\t\t\t\tconst uint32_t set_bit_index = count_leading_zeros(packed_entry);\n+\t\t\t\t\tconst uint32_t highest_set_bit = 1 << (31 - set_bit_index);\n+\n+\t\t\t\t\t// Mask out the bit we just consumed\n+\t\t\t\t\tpacked_entry ^= highest_set_bit;\n+\n+\t\t\t\t\t// We have 2 bits per sub-track\n+\t\t\t\t\tconst uint32_t track_index = curr_entry_track_index + (set_bit_index / 2);\n+\n+\t\t\t\t\tconst uint8_t* translation_ptr = constant_data_translations;\n+\t\t\t\t\tconstant_data_translations += sizeof(rtm::float3f);\n+\n+\t\t\t\t\tif (!writer.skip_track_translation(track_index))\n+\t\t\t\t\t\twriter.write_translation(track_index, rtm::vector_load(translation_ptr));\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\tdone:\n \t\t\tstep_context.prefetch_queue_ptr = prefetch_queue_ptr;\n \t\t}\n \t}\n--- includes/acl/decompression/impl/steps/translation_default.h\n@@ -82,13 +82,13 @@ namespace acl\n \t\t\tuint32_t packed_entry = 0;\n \n \t\t\t// This is our sub-step loop\n-\t\t\twhile (true)\n+\t\t\twhile (next_prefetch_ptr != nullptr)\n \t\t\t{\n \t\t\t\t// If our entry is empty, grab the next one\n \t\t\t\tif (packed_entry == 0)\n \t\t\t\t{\n \t\t\t\t\tif (entry_index > last_entry_index)\n-\t\t\t\t\t\tbreak;\t// We are done\n+\t\t\t\t\t\tgoto done;\t// We are done\n \n \t\t\t\t\tpacked_entry = translation_sub_track_types[entry_index].types;\n \n@@ -115,15 +115,13 @@ namespace acl\n \t\t\t\tnum_unpacked %= k_sub_step_unpack_count;\n \n \t\t\t\t// Our sub-step loop takes about 60 instructions and so we want to prefetch\n-\t\t\t\t// 4 cache lines into the L2 each iteration\n-\t\t\t\tif (next_prefetch_ptr && num_unpacked == 0)\n+\t\t\t\t// 2 cache lines into the L1 each iteration\n+\t\t\t\tif (num_unpacked == 0)\n \t\t\t\t{\n-\t\t\t\t\tmemory_prefetch_into_L2(next_prefetch_ptr);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[1]);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[2]);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[3]);\n+\t\t\t\t\tmemory_prefetch_into_L1(next_prefetch_ptr);\n+\t\t\t\t\tmemory_prefetch_into_L1(prefetch_queue_ptr[1]);\n \n-\t\t\t\t\tprefetch_queue_ptr += 4;\n+\t\t\t\t\tprefetch_queue_ptr += 2;\n \t\t\t\t\tnext_prefetch_ptr = *prefetch_queue_ptr;\n \t\t\t\t}\n \n@@ -150,6 +148,57 @@ namespace acl\n \t\t\t\t}\n \t\t\t}\n \n+\t\t\twhile (true)\n+\t\t\t{\n+\t\t\t\t// If our entry is empty, grab the next one\n+\t\t\t\tif (packed_entry == 0)\n+\t\t\t\t{\n+\t\t\t\t\tif (entry_index > last_entry_index)\n+\t\t\t\t\t\tgoto done;\t// We are done\n+\n+\t\t\t\t\tpacked_entry = translation_sub_track_types[entry_index].types;\n+\n+\t\t\t\t\t// Mask out everything but default sub-tracks, this way we can early out when we iterate\n+\t\t\t\t\t// Each sub-track is either 0 (default), 1 (constant), or 2 (animated)\n+\t\t\t\t\t// By flipping the bits with logical NOT, 0 becomes 3, 1 becomes 2, and 2 becomes 1\n+\t\t\t\t\t// We then subtract 1 from every group so 3 becomes 2, 2 becomes 1, and 1 becomes 0\n+\t\t\t\t\t// Finally, we mask out everything but the second bit for each sub-track\n+\t\t\t\t\t// After this, our original default tracks are equal to 2, our constant tracks are equal to 1, and our animated tracks are equal to 0\n+\t\t\t\t\t// Testing for default tracks can be done by testing the second bit of each group (same as animated track testing)\n+\t\t\t\t\tpacked_entry = ~packed_entry - 0x55555555;\n+\n+\t\t\t\t\t// Because our last entry might have padding with 0 (default), we have to strip any padding we might have\n+\t\t\t\t\tconst uint32_t entry_padding_mask = (entry_index == last_entry_index) ? padding_mask : 0xAAAAAAAA;\n+\t\t\t\t\tpacked_entry &= entry_padding_mask;\n+\n+\t\t\t\t\t// We have 2 bits per sub-track\n+\t\t\t\t\tcurr_entry_track_index = entry_index * 16;\n+\n+\t\t\t\t\tentry_index++;\n+\t\t\t\t}\n+\n+\t\t\t\twhile (packed_entry != 0)\n+\t\t\t\t{\n+\t\t\t\t\tconst uint32_t set_bit_index = count_leading_zeros(packed_entry);\n+\t\t\t\t\tconst uint32_t highest_set_bit = 1 << (31 - set_bit_index);\n+\n+\t\t\t\t\t// Mask out the bit we just consumed\n+\t\t\t\t\tpacked_entry ^= highest_set_bit;\n+\n+\t\t\t\t\t// We have 2 bits per sub-track\n+\t\t\t\t\tconst uint32_t track_index = curr_entry_track_index + (set_bit_index / 2);\n+\n+\t\t\t\t\tif (!writer.skip_track_translation(track_index))\n+\t\t\t\t\t{\n+\t\t\t\t\t\tif (default_mode == default_sub_track_mode::variable)\n+\t\t\t\t\t\t\twriter.write_translation(track_index, writer.get_variable_default_translation(track_index));\n+\t\t\t\t\t\telse\n+\t\t\t\t\t\t\twriter.write_translation(track_index, default_translation);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\tdone:\n \t\t\tstep_context.prefetch_queue_ptr = prefetch_queue_ptr;\n \t\t}\n \t}"
    ],
    "files_changed": [
      {
        "filename": "includes/acl/decompression/impl/steps/rotation_constant.h",
        "status": "modified",
        "additions": 57,
        "deletions": 8,
        "changes": 65,
        "patch": "@@ -159,7 +159,7 @@ namespace acl\n \t\t\t\tif (packed_entry == 0)\n \t\t\t\t{\n \t\t\t\t\tif (entry_index > last_entry_index)\n-\t\t\t\t\t\tbreak;\t// We are done\n+\t\t\t\t\t\tgoto done;\t// We are done\n \n \t\t\t\t\t// Mask out everything but constant sub-tracks, this way we can early out when we iterate\n \t\t\t\t\t// Use and_not(..) to load our sub-track types directly from memory on x64 with BMI\n@@ -174,20 +174,21 @@ namespace acl\n \t\t\t\t// Reset our unpack count if it is k_sub_step_unpack_count\n \t\t\t\tnum_unpacked %= k_sub_step_unpack_count;\n \n+\t\t\t\t// Our sub-step loop takes about 60 instructions and so we want to prefetch\n+\t\t\t\t// 2 cache lines into the L1 each iteration\n+\t\t\t\tmemory_prefetch_into_L1(constant_data_rotations + (3 * 64));\n+\n \t\t\t\tif (num_unpacked == 0)\n \t\t\t\t{\n-\t\t\t\t\t// Our sub-step loop takes about 60 instructions and so we want to prefetch\n-\t\t\t\t\t// 4 cache lines into the L2 each iteration\n \t\t\t\t\tif (next_prefetch_ptr)\n \t\t\t\t\t{\n-\t\t\t\t\t\tmemory_prefetch_into_L2(next_prefetch_ptr);\n-\t\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[1]);\n-\t\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[2]);\n-\t\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[3]);\n+\t\t\t\t\t\tmemory_prefetch_into_L1(next_prefetch_ptr);\n \n-\t\t\t\t\t\tprefetch_queue_ptr += 4;\n+\t\t\t\t\t\tprefetch_queue_ptr += 1;\n \t\t\t\t\t\tnext_prefetch_ptr = *prefetch_queue_ptr;\n \t\t\t\t\t}\n+\t\t\t\t\telse\n+\t\t\t\t\t\tbreak;\n \n \t\t\t\t\t// Unpack up to 4 rotations\n \t\t\t\t\tunpack_constant_rotation_group<decompression_settings_type>(decomp_context, constant_data_rotations, num_left_to_unpack, constant_rotations);\n@@ -212,6 +213,54 @@ namespace acl\n \t\t\t\t}\n \t\t\t}\n \n+\t\t\tmemory_prefetch_into_L1(constant_data_rotations + (3 * 64));\n+\t\t\tmemory_prefetch_into_L1(constant_data_rotations + (4 * 64));\n+\n+\t\t\twhile (true)\n+\t\t\t{\n+\t\t\t\t// If our entry is empty, grab the next one\n+\t\t\t\tif (packed_entry == 0)\n+\t\t\t\t{\n+\t\t\t\t\tif (entry_index > last_entry_index)\n+\t\t\t\t\t\tgoto done;\t// We are done\n+\n+\t\t\t\t\t// Mask out everything but constant sub-tracks, this way we can early out when we iterate\n+\t\t\t\t\t// Use and_not(..) to load our sub-track types directly from memory on x64 with BMI\n+\t\t\t\t\tpacked_entry = and_not(~0x55555555U, rotation_sub_track_types[entry_index].types);\n+\n+\t\t\t\t\t// We have 2 bits per sub-track\n+\t\t\t\t\tcurr_entry_track_index = entry_index * 16;\n+\n+\t\t\t\t\tentry_index++;\n+\t\t\t\t}\n+\n+\t\t\t\tnum_unpacked %= k_sub_step_unpack_count;\n+\n+\t\t\t\tif (num_unpacked == 0)\n+\t\t\t\t{\n+\t\t\t\t\t// Unpack up to 4 rotations\n+\t\t\t\t\tunpack_constant_rotation_group<decompression_settings_type>(decomp_context, constant_data_rotations, num_left_to_unpack, constant_rotations);\n+\t\t\t\t}\n+\n+\t\t\t\twhile (packed_entry != 0 && num_unpacked < k_sub_step_unpack_count)\n+\t\t\t\t{\n+\t\t\t\t\tconst uint32_t set_bit_index = count_leading_zeros(packed_entry);\n+\t\t\t\t\tconst uint32_t highest_set_bit = 1 << (31 - set_bit_index);\n+\n+\t\t\t\t\t// Mask out the bit we just consumed\n+\t\t\t\t\tpacked_entry ^= highest_set_bit;\n+\n+\t\t\t\t\t// We have 2 bits per sub-track\n+\t\t\t\t\tconst uint32_t track_index = curr_entry_track_index + (set_bit_index / 2);\n+\n+\t\t\t\t\tif (!writer.skip_track_rotation(track_index))\n+\t\t\t\t\t\twriter.write_rotation(track_index, constant_rotations[num_unpacked]);\n+\n+\t\t\t\t\tnum_unpacked++;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\tdone:\n \t\t\tstep_context.prefetch_queue_ptr = prefetch_queue_ptr;\n \t\t}\n \t}"
      },
      {
        "filename": "includes/acl/decompression/impl/steps/rotation_default.h",
        "status": "modified",
        "additions": 58,
        "deletions": 9,
        "changes": 67,
        "patch": "@@ -82,13 +82,13 @@ namespace acl\n \t\t\tuint32_t packed_entry = 0;\n \n \t\t\t// This is our sub-step loop\n-\t\t\twhile (true)\n+\t\t\twhile (next_prefetch_ptr != nullptr)\n \t\t\t{\n \t\t\t\t// If our entry is empty, grab the next one\n \t\t\t\tif (packed_entry == 0)\n \t\t\t\t{\n \t\t\t\t\tif (entry_index > last_entry_index)\n-\t\t\t\t\t\tbreak;\t// We are done\n+\t\t\t\t\t\tgoto done;\t// We are done\n \n \t\t\t\t\tpacked_entry = rotation_sub_track_types[entry_index].types;\n \n@@ -115,15 +115,13 @@ namespace acl\n \t\t\t\tnum_unpacked %= k_sub_step_unpack_count;\n \n \t\t\t\t// Our sub-step loop takes about 60 instructions and so we want to prefetch\n-\t\t\t\t// 4 cache lines into the L2 each iteration\n-\t\t\t\tif (next_prefetch_ptr && num_unpacked == 0)\n+\t\t\t\t// 2 cache lines into the L1 each iteration\n+\t\t\t\tif (num_unpacked == 0)\n \t\t\t\t{\n-\t\t\t\t\tmemory_prefetch_into_L2(next_prefetch_ptr);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[1]);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[2]);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[3]);\n+\t\t\t\t\tmemory_prefetch_into_L1(next_prefetch_ptr);\n+\t\t\t\t\tmemory_prefetch_into_L1(prefetch_queue_ptr[1]);\n \n-\t\t\t\t\tprefetch_queue_ptr += 4;\n+\t\t\t\t\tprefetch_queue_ptr += 2;\n \t\t\t\t\tnext_prefetch_ptr = *prefetch_queue_ptr;\n \t\t\t\t}\n \n@@ -150,6 +148,57 @@ namespace acl\n \t\t\t\t}\n \t\t\t}\n \n+\t\t\twhile (true)\n+\t\t\t{\n+\t\t\t\t// If our entry is empty, grab the next one\n+\t\t\t\tif (packed_entry == 0)\n+\t\t\t\t{\n+\t\t\t\t\tif (entry_index > last_entry_index)\n+\t\t\t\t\t\tgoto done;\t// We are done\n+\n+\t\t\t\t\tpacked_entry = rotation_sub_track_types[entry_index].types;\n+\n+\t\t\t\t\t// Mask out everything but default sub-tracks, this way we can early out when we iterate\n+\t\t\t\t\t// Each sub-track is either 0 (default), 1 (constant), or 2 (animated)\n+\t\t\t\t\t// By flipping the bits with logical NOT, 0 becomes 3, 1 becomes 2, and 2 becomes 1\n+\t\t\t\t\t// We then subtract 1 from every group so 3 becomes 2, 2 becomes 1, and 1 becomes 0\n+\t\t\t\t\t// Finally, we mask out everything but the second bit for each sub-track\n+\t\t\t\t\t// After this, our original default tracks are equal to 2, our constant tracks are equal to 1, and our animated tracks are equal to 0\n+\t\t\t\t\t// Testing for default tracks can be done by testing the second bit of each group (same as animated track testing)\n+\t\t\t\t\tpacked_entry = ~packed_entry - 0x55555555;\n+\n+\t\t\t\t\t// Because our last entry might have padding with 0 (default), we have to strip any padding we might have\n+\t\t\t\t\tconst uint32_t entry_padding_mask = (entry_index == last_entry_index) ? padding_mask : 0xAAAAAAAA;\n+\t\t\t\t\tpacked_entry &= entry_padding_mask;\n+\n+\t\t\t\t\t// We have 2 bits per sub-track\n+\t\t\t\t\tcurr_entry_track_index = entry_index * 16;\n+\n+\t\t\t\t\tentry_index++;\n+\t\t\t\t}\n+\n+\t\t\t\twhile (packed_entry != 0)\n+\t\t\t\t{\n+\t\t\t\t\tconst uint32_t set_bit_index = count_leading_zeros(packed_entry);\n+\t\t\t\t\tconst uint32_t highest_set_bit = 1 << (31 - set_bit_index);\n+\n+\t\t\t\t\t// Mask out the bit we just consumed\n+\t\t\t\t\tpacked_entry ^= highest_set_bit;\n+\n+\t\t\t\t\t// We have 2 bits per sub-track\n+\t\t\t\t\tconst uint32_t track_index = curr_entry_track_index + (set_bit_index / 2);\n+\n+\t\t\t\t\tif (!writer.skip_track_rotation(track_index))\n+\t\t\t\t\t{\n+\t\t\t\t\t\tif (default_mode == default_sub_track_mode::variable)\n+\t\t\t\t\t\t\twriter.write_rotation(track_index, writer.get_variable_default_rotation(track_index));\n+\t\t\t\t\t\telse\n+\t\t\t\t\t\t\twriter.write_rotation(track_index, default_rotation);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\tdone:\n \t\t\tstep_context.prefetch_queue_ptr = prefetch_queue_ptr;\n \t\t}\n \t}"
      },
      {
        "filename": "includes/acl/decompression/impl/steps/scale_default.h",
        "status": "modified",
        "additions": 81,
        "deletions": 18,
        "changes": 99,
        "patch": "@@ -87,13 +87,13 @@ namespace acl\n \t\t\tuint32_t packed_entry = 0;\n \n \t\t\t// This is our sub-step loop\n-\t\t\twhile (true)\n+\t\t\twhile (next_prefetch_ptr != nullptr)\n \t\t\t{\n \t\t\t\t// If our entry is empty, grab the next one\n \t\t\t\tif (packed_entry == 0)\n \t\t\t\t{\n \t\t\t\t\tif (entry_index > last_entry_index)\n-\t\t\t\t\t\tbreak;\t// We are done\n+\t\t\t\t\t\tgoto done;\t// We are done\n \n \t\t\t\t\tpacked_entry = scale_sub_track_types[entry_index].types;\n \n@@ -120,15 +120,13 @@ namespace acl\n \t\t\t\tnum_unpacked %= k_sub_step_unpack_count;\n \n \t\t\t\t// Our sub-step loop takes about 60 instructions and so we want to prefetch\n-\t\t\t\t// 4 cache lines into the L2 each iteration\n-\t\t\t\tif (next_prefetch_ptr && num_unpacked == 0)\n+\t\t\t\t// 2 cache lines into the L1 each iteration\n+\t\t\t\tif (num_unpacked == 0)\n \t\t\t\t{\n-\t\t\t\t\tmemory_prefetch_into_L2(next_prefetch_ptr);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[1]);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[2]);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[3]);\n+\t\t\t\t\tmemory_prefetch_into_L1(next_prefetch_ptr);\n+\t\t\t\t\tmemory_prefetch_into_L1(prefetch_queue_ptr[1]);\n \n-\t\t\t\t\tprefetch_queue_ptr += 4;\n+\t\t\t\t\tprefetch_queue_ptr += 2;\n \t\t\t\t\tnext_prefetch_ptr = *prefetch_queue_ptr;\n \t\t\t\t}\n \n@@ -155,6 +153,57 @@ namespace acl\n \t\t\t\t}\n \t\t\t}\n \n+\t\t\twhile (true)\n+\t\t\t{\n+\t\t\t\t// If our entry is empty, grab the next one\n+\t\t\t\tif (packed_entry == 0)\n+\t\t\t\t{\n+\t\t\t\t\tif (entry_index > last_entry_index)\n+\t\t\t\t\t\tgoto done;\t// We are done\n+\n+\t\t\t\t\tpacked_entry = scale_sub_track_types[entry_index].types;\n+\n+\t\t\t\t\t// Mask out everything but default sub-tracks, this way we can early out when we iterate\n+\t\t\t\t\t// Each sub-track is either 0 (default), 1 (constant), or 2 (animated)\n+\t\t\t\t\t// By flipping the bits with logical NOT, 0 becomes 3, 1 becomes 2, and 2 becomes 1\n+\t\t\t\t\t// We then subtract 1 from every group so 3 becomes 2, 2 becomes 1, and 1 becomes 0\n+\t\t\t\t\t// Finally, we mask out everything but the second bit for each sub-track\n+\t\t\t\t\t// After this, our original default tracks are equal to 2, our constant tracks are equal to 1, and our animated tracks are equal to 0\n+\t\t\t\t\t// Testing for default tracks can be done by testing the second bit of each group (same as animated track testing)\n+\t\t\t\t\tpacked_entry = ~packed_entry - 0x55555555;\n+\n+\t\t\t\t\t// Because our last entry might have padding with 0 (default), we have to strip any padding we might have\n+\t\t\t\t\tconst uint32_t entry_padding_mask = (entry_index == last_entry_index) ? padding_mask : 0xAAAAAAAA;\n+\t\t\t\t\tpacked_entry &= entry_padding_mask;\n+\n+\t\t\t\t\t// We have 2 bits per sub-track\n+\t\t\t\t\tcurr_entry_track_index = entry_index * 16;\n+\n+\t\t\t\t\tentry_index++;\n+\t\t\t\t}\n+\n+\t\t\t\twhile (packed_entry != 0)\n+\t\t\t\t{\n+\t\t\t\t\tconst uint32_t set_bit_index = count_leading_zeros(packed_entry);\n+\t\t\t\t\tconst uint32_t highest_set_bit = 1 << (31 - set_bit_index);\n+\n+\t\t\t\t\t// Mask out the bit we just consumed\n+\t\t\t\t\tpacked_entry ^= highest_set_bit;\n+\n+\t\t\t\t\t// We have 2 bits per sub-track\n+\t\t\t\t\tconst uint32_t track_index = curr_entry_track_index + (set_bit_index / 2);\n+\n+\t\t\t\t\tif (!writer.skip_track_scale(track_index))\n+\t\t\t\t\t{\n+\t\t\t\t\t\tif (default_mode == default_sub_track_mode::variable)\n+\t\t\t\t\t\t\twriter.write_scale(track_index, writer.get_variable_default_scale(track_index));\n+\t\t\t\t\t\telse\n+\t\t\t\t\t\t\twriter.write_scale(track_index, default_scale);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\tdone:\n \t\t\tstep_context.prefetch_queue_ptr = prefetch_queue_ptr;\n \t\t}\n \n@@ -198,19 +247,22 @@ namespace acl\n \t\t\tconstexpr uint32_t k_prefetch_multiple = 8;\n \n \t\t\t// No scale present, everything is just the default value\n-\t\t\tfor (uint32_t track_index = 0; track_index < num_tracks; ++track_index)\n+\t\t\tuint32_t track_index = 0;\n+\t\t\tfor (; track_index < num_tracks; ++track_index)\n \t\t\t{\n \t\t\t\t// Our step takes about 50 instructions and so we want to prefetch\n-\t\t\t\t// 4 cache lines into the L2\n-\t\t\t\tif (next_prefetch_ptr && (track_index % k_prefetch_multiple) == 0)\n+\t\t\t\t// 1 cache line into the L1\n+\t\t\t\tif ((track_index % k_prefetch_multiple) == 0)\n \t\t\t\t{\n-\t\t\t\t\tmemory_prefetch_into_L2(next_prefetch_ptr);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[1]);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[2]);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[3]);\n+\t\t\t\t\tif (next_prefetch_ptr != nullptr)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tmemory_prefetch_into_L1(next_prefetch_ptr);\n \n-\t\t\t\t\tprefetch_queue_ptr += 4;\n-\t\t\t\t\tnext_prefetch_ptr = *prefetch_queue_ptr;\n+\t\t\t\t\t\tprefetch_queue_ptr += 1;\n+\t\t\t\t\t\tnext_prefetch_ptr = *prefetch_queue_ptr;\n+\t\t\t\t\t}\n+\t\t\t\t\telse\n+\t\t\t\t\t\tbreak;\n \t\t\t\t}\n \n \t\t\t\tif (!writer.skip_track_scale(track_index))\n@@ -222,6 +274,17 @@ namespace acl\n \t\t\t\t}\n \t\t\t}\n \n+\t\t\tfor (; track_index < num_tracks; ++track_index)\n+\t\t\t{\n+\t\t\t\tif (!writer.skip_track_scale(track_index))\n+\t\t\t\t{\n+\t\t\t\t\tif (default_mode == default_sub_track_mode::variable)\n+\t\t\t\t\t\twriter.write_scale(track_index, writer.get_variable_default_scale(track_index));\n+\t\t\t\t\telse\n+\t\t\t\t\t\twriter.write_scale(track_index, scale);\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\tstep_context.prefetch_queue_ptr = prefetch_queue_ptr;\n \t\t}\n \t}"
      },
      {
        "filename": "includes/acl/decompression/impl/steps/translation_constant.h",
        "status": "modified",
        "additions": 49,
        "deletions": 9,
        "changes": 58,
        "patch": "@@ -73,13 +73,13 @@ namespace acl\n \t\t\tuint32_t packed_entry = 0;\n \n \t\t\t// This is our sub-step loop\n-\t\t\twhile (true)\n+\t\t\twhile (next_prefetch_ptr != nullptr)\n \t\t\t{\n \t\t\t\t// If our entry is empty, grab the next one\n \t\t\t\tif (packed_entry == 0)\n \t\t\t\t{\n \t\t\t\t\tif (entry_index > last_entry_index)\n-\t\t\t\t\t\tbreak;\t// We are done\n+\t\t\t\t\t\tgoto done;\t// We are done\n \n \t\t\t\t\t// Mask out everything but constant sub-tracks, this way we can early out when we iterate\n \t\t\t\t\t// Use and_not(..) to load our sub-track types directly from memory on x64 with BMI\n@@ -95,15 +95,14 @@ namespace acl\n \t\t\t\tnum_unpacked %= k_sub_step_unpack_count;\n \n \t\t\t\t// Our sub-step loop takes about 60 instructions and so we want to prefetch\n-\t\t\t\t// 4 cache lines into the L2 each iteration\n-\t\t\t\tif (next_prefetch_ptr && num_unpacked == 0)\n+\t\t\t\t// 2 cache lines into the L1 each iteration\n+\t\t\t\tmemory_prefetch_into_L1(constant_data_translations + (3 * 64));\n+\n+\t\t\t\tif (num_unpacked == 0)\n \t\t\t\t{\n-\t\t\t\t\tmemory_prefetch_into_L2(next_prefetch_ptr);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[1]);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[2]);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[3]);\n+\t\t\t\t\tmemory_prefetch_into_L1(next_prefetch_ptr);\n \n-\t\t\t\t\tprefetch_queue_ptr += 4;\n+\t\t\t\t\tprefetch_queue_ptr += 1;\n \t\t\t\t\tnext_prefetch_ptr = *prefetch_queue_ptr;\n \t\t\t\t}\n \n@@ -129,6 +128,47 @@ namespace acl\n \t\t\t\t}\n \t\t\t}\n \n+\t\t\tmemory_prefetch_into_L1(constant_data_translations + (3 * 64));\n+\t\t\tmemory_prefetch_into_L1(constant_data_translations + (4 * 64));\n+\n+\t\t\twhile (true)\n+\t\t\t{\n+\t\t\t\t// If our entry is empty, grab the next one\n+\t\t\t\tif (packed_entry == 0)\n+\t\t\t\t{\n+\t\t\t\t\tif (entry_index > last_entry_index)\n+\t\t\t\t\t\tgoto done;\t// We are done\n+\n+\t\t\t\t\t// Mask out everything but constant sub-tracks, this way we can early out when we iterate\n+\t\t\t\t\t// Use and_not(..) to load our sub-track types directly from memory on x64 with BMI\n+\t\t\t\t\tpacked_entry = and_not(~0x55555555U, translation_sub_track_types[entry_index].types);\n+\n+\t\t\t\t\t// We have 2 bits per sub-track\n+\t\t\t\t\tcurr_entry_track_index = entry_index * 16;\n+\n+\t\t\t\t\tentry_index++;\n+\t\t\t\t}\n+\n+\t\t\t\twhile (packed_entry != 0)\n+\t\t\t\t{\n+\t\t\t\t\tconst uint32_t set_bit_index = count_leading_zeros(packed_entry);\n+\t\t\t\t\tconst uint32_t highest_set_bit = 1 << (31 - set_bit_index);\n+\n+\t\t\t\t\t// Mask out the bit we just consumed\n+\t\t\t\t\tpacked_entry ^= highest_set_bit;\n+\n+\t\t\t\t\t// We have 2 bits per sub-track\n+\t\t\t\t\tconst uint32_t track_index = curr_entry_track_index + (set_bit_index / 2);\n+\n+\t\t\t\t\tconst uint8_t* translation_ptr = constant_data_translations;\n+\t\t\t\t\tconstant_data_translations += sizeof(rtm::float3f);\n+\n+\t\t\t\t\tif (!writer.skip_track_translation(track_index))\n+\t\t\t\t\t\twriter.write_translation(track_index, rtm::vector_load(translation_ptr));\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\tdone:\n \t\t\tstep_context.prefetch_queue_ptr = prefetch_queue_ptr;\n \t\t}\n \t}"
      },
      {
        "filename": "includes/acl/decompression/impl/steps/translation_default.h",
        "status": "modified",
        "additions": 58,
        "deletions": 9,
        "changes": 67,
        "patch": "@@ -82,13 +82,13 @@ namespace acl\n \t\t\tuint32_t packed_entry = 0;\n \n \t\t\t// This is our sub-step loop\n-\t\t\twhile (true)\n+\t\t\twhile (next_prefetch_ptr != nullptr)\n \t\t\t{\n \t\t\t\t// If our entry is empty, grab the next one\n \t\t\t\tif (packed_entry == 0)\n \t\t\t\t{\n \t\t\t\t\tif (entry_index > last_entry_index)\n-\t\t\t\t\t\tbreak;\t// We are done\n+\t\t\t\t\t\tgoto done;\t// We are done\n \n \t\t\t\t\tpacked_entry = translation_sub_track_types[entry_index].types;\n \n@@ -115,15 +115,13 @@ namespace acl\n \t\t\t\tnum_unpacked %= k_sub_step_unpack_count;\n \n \t\t\t\t// Our sub-step loop takes about 60 instructions and so we want to prefetch\n-\t\t\t\t// 4 cache lines into the L2 each iteration\n-\t\t\t\tif (next_prefetch_ptr && num_unpacked == 0)\n+\t\t\t\t// 2 cache lines into the L1 each iteration\n+\t\t\t\tif (num_unpacked == 0)\n \t\t\t\t{\n-\t\t\t\t\tmemory_prefetch_into_L2(next_prefetch_ptr);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[1]);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[2]);\n-\t\t\t\t\tmemory_prefetch_into_L2(prefetch_queue_ptr[3]);\n+\t\t\t\t\tmemory_prefetch_into_L1(next_prefetch_ptr);\n+\t\t\t\t\tmemory_prefetch_into_L1(prefetch_queue_ptr[1]);\n \n-\t\t\t\t\tprefetch_queue_ptr += 4;\n+\t\t\t\t\tprefetch_queue_ptr += 2;\n \t\t\t\t\tnext_prefetch_ptr = *prefetch_queue_ptr;\n \t\t\t\t}\n \n@@ -150,6 +148,57 @@ namespace acl\n \t\t\t\t}\n \t\t\t}\n \n+\t\t\twhile (true)\n+\t\t\t{\n+\t\t\t\t// If our entry is empty, grab the next one\n+\t\t\t\tif (packed_entry == 0)\n+\t\t\t\t{\n+\t\t\t\t\tif (entry_index > last_entry_index)\n+\t\t\t\t\t\tgoto done;\t// We are done\n+\n+\t\t\t\t\tpacked_entry = translation_sub_track_types[entry_index].types;\n+\n+\t\t\t\t\t// Mask out everything but default sub-tracks, this way we can early out when we iterate\n+\t\t\t\t\t// Each sub-track is either 0 (default), 1 (constant), or 2 (animated)\n+\t\t\t\t\t// By flipping the bits with logical NOT, 0 becomes 3, 1 becomes 2, and 2 becomes 1\n+\t\t\t\t\t// We then subtract 1 from every group so 3 becomes 2, 2 becomes 1, and 1 becomes 0\n+\t\t\t\t\t// Finally, we mask out everything but the second bit for each sub-track\n+\t\t\t\t\t// After this, our original default tracks are equal to 2, our constant tracks are equal to 1, and our animated tracks are equal to 0\n+\t\t\t\t\t// Testing for default tracks can be done by testing the second bit of each group (same as animated track testing)\n+\t\t\t\t\tpacked_entry = ~packed_entry - 0x55555555;\n+\n+\t\t\t\t\t// Because our last entry might have padding with 0 (default), we have to strip any padding we might have\n+\t\t\t\t\tconst uint32_t entry_padding_mask = (entry_index == last_entry_index) ? padding_mask : 0xAAAAAAAA;\n+\t\t\t\t\tpacked_entry &= entry_padding_mask;\n+\n+\t\t\t\t\t// We have 2 bits per sub-track\n+\t\t\t\t\tcurr_entry_track_index = entry_index * 16;\n+\n+\t\t\t\t\tentry_index++;\n+\t\t\t\t}\n+\n+\t\t\t\twhile (packed_entry != 0)\n+\t\t\t\t{\n+\t\t\t\t\tconst uint32_t set_bit_index = count_leading_zeros(packed_entry);\n+\t\t\t\t\tconst uint32_t highest_set_bit = 1 << (31 - set_bit_index);\n+\n+\t\t\t\t\t// Mask out the bit we just consumed\n+\t\t\t\t\tpacked_entry ^= highest_set_bit;\n+\n+\t\t\t\t\t// We have 2 bits per sub-track\n+\t\t\t\t\tconst uint32_t track_index = curr_entry_track_index + (set_bit_index / 2);\n+\n+\t\t\t\t\tif (!writer.skip_track_translation(track_index))\n+\t\t\t\t\t{\n+\t\t\t\t\t\tif (default_mode == default_sub_track_mode::variable)\n+\t\t\t\t\t\t\twriter.write_translation(track_index, writer.get_variable_default_translation(track_index));\n+\t\t\t\t\t\telse\n+\t\t\t\t\t\t\twriter.write_translation(track_index, default_translation);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\tdone:\n \t\t\tstep_context.prefetch_queue_ptr = prefetch_queue_ptr;\n \t\t}\n \t}"
      }
    ],
    "lines_added": 303,
    "lines_removed": 53
  },
  "issues": [],
  "pull_requests": [],
  "build_info": {
    "old_build_script": [
      "apt-get update",
      "cmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON -DBENCHMARK_ENABLE_GTEST_TESTS=ON -DCATCH_BUILD_TESTING=ON -DBENCHMARK_ENABLE_TESTING=ON -DINCLUDE_UNIT_TESTS=ON -DBENCHMARK_USE_BUNDLED_GTEST=ON -DBENCHMARK_ENABLE_ASSEMBLY_TESTS=ON",
      "cmake --build /test_workspace/workspace/old/build -- -j 1"
    ],
    "new_build_script": [
      "apt-get update",
      "cmake -S /test_workspace/workspace/new -B /test_workspace/workspace/new/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON -DBENCHMARK_ENABLE_GTEST_TESTS=ON -DCATCH_BUILD_TESTING=ON -DBENCHMARK_ENABLE_TESTING=ON -DINCLUDE_UNIT_TESTS=ON -DBENCHMARK_USE_BUNDLED_GTEST=ON -DBENCHMARK_ENABLE_ASSEMBLY_TESTS=ON",
      "cmake --build /test_workspace/workspace/new/build -- -j 1"
    ],
    "old_test_script": [
      "cd /test_workspace/workspace/old/build",
      "ctest --output-on-failure"
    ],
    "new_test_script": [
      "cd /test_workspace/workspace/new/build",
      "ctest --output-on-failure"
    ],
    "build_system": "cmake"
  },
  "performance_analysis": {
    "is_significant": false,
    "p_value": 1.0,
    "is_pair_significant": false,
    "pair_p_value": 1.0,
    "is_binom_significant": false,
    "binom_p_value": 1.0,
    "is_wilcoxon_significant": false,
    "wilcoxon_p_value": 0.9999991338918834,
    "is_mannwhitney_significant": false,
    "mannwhitney_p_value": 0.67402335858381,
    "relative_improvement": -7.438233804206799e-05,
    "absolute_improvement_ms": -19.333333333349856,
    "old_mean_ms": 259918.33333333334,
    "new_mean_ms": 259937.6666666667,
    "old_std_ms": 301.3885490048775,
    "new_std_ms": 291.21248710121733,
    "effect_size_cohens_d": -0.0652394523433051,
    "old_ci95_ms": [
      259805.7929995863,
      260030.87366708042
    ],
    "new_ci95_ms": [
      259828.9261368825,
      260046.4071964509
    ],
    "old_ci99_ms": [
      259766.66107944833,
      260070.00558721836
    ],
    "new_ci99_ms": [
      259791.11546416106,
      260084.21786917234
    ],
    "new_times_s": [
      260.43,
      260.07,
      259.77,
      259.95,
      260.37,
      260.65,
      260.26,
      259.55,
      259.66,
      259.79,
      259.44,
      259.89,
      259.53,
      260.05,
      259.8,
      259.87,
      259.84,
      259.97,
      260.18,
      260.09,
      260.3,
      259.78,
      259.75,
      259.95,
      259.83,
      259.51,
      259.72,
      260.13,
      260.52,
      260.03,
      259.88
    ],
    "old_times_s": [
      259.9,
      259.86,
      260.07,
      260.14,
      260.07,
      260.22,
      261.05,
      260.38,
      259.78,
      259.7,
      259.93,
      259.75,
      259.78,
      259.88,
      259.72,
      259.68,
      259.74,
      259.57,
      259.31,
      259.83,
      259.99,
      259.7,
      259.7,
      260.15,
      259.76,
      259.96,
      259.86,
      259.96,
      260.0,
      260.0,
      260.01
    ]
  },
  "tests": {
    "total_tests": 9,
    "significant_improvements": 0,
    "significant_improvements_tests": [],
    "significant_regressions": 0,
    "significant_regressions_tests": [],
    "significant_pair_improvements": 0,
    "significant_pair_improvements_tests": [],
    "significant_pair_regressions": 0,
    "significant_pair_regressions_tests": [],
    "significant_binom_improvements": 0,
    "significant_binom_improvements_tests": [],
    "significant_binom_regressions": 0,
    "significant_binom_regressions_tests": [],
    "significant_wilcoxon_improvements": 0,
    "significant_wilcoxon_improvements_tests": [],
    "significant_wilcoxon_regressions": 0,
    "significant_wilcoxon_regressions_tests": [],
    "significant_mannwhitney_improvements": 1,
    "significant_mannwhitney_improvements_tests": [
      "decay_vector3_XX"
    ],
    "significant_mannwhitney_regressions": 0,
    "significant_mannwhitney_regressions_tests": [],
    "tests": [
      {
        "test_name": "scalar",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999987840980745,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.25508377690981077,
        "relative_improvement": 0.002020202020202049,
        "absolute_improvement_ms": 1.7857142857143904,
        "old_mean_ms": 883.9285714285714,
        "new_mean_ms": 882.142857142857,
        "old_std_ms": 9.940297973880059,
        "new_std_ms": 5.681120688308982,
        "effect_size_cohens_d": 0.22057233532400164,
        "old_ci95_ms": [
          880.0741262582301,
          887.7830165989127
        ],
        "new_ci95_ms": [
          879.9399485120776,
          884.3457657736363
        ],
        "old_ci99_ms": [
          878.7237333794014,
          889.1334094777413
        ],
        "new_ci99_ms": [
          879.1681663239161,
          885.1175479617979
        ],
        "new_times": [
          0.88,
          0.88,
          0.88,
          0.88,
          0.88,
          0.88,
          0.88,
          0.88,
          0.88,
          0.88,
          0.89,
          0.88,
          0.88,
          0.89,
          0.88,
          0.9,
          0.88,
          0.88,
          0.88,
          0.88,
          0.88,
          0.88,
          0.88,
          0.88,
          0.88,
          0.9,
          0.88,
          0.88
        ],
        "old_times": [
          0.88,
          0.88,
          0.9,
          0.87,
          0.88,
          0.88,
          0.89,
          0.89,
          0.88,
          0.89,
          0.88,
          0.88,
          0.88,
          0.88,
          0.88,
          0.88,
          0.88,
          0.88,
          0.88,
          0.88,
          0.88,
          0.87,
          0.89,
          0.9,
          0.88,
          0.89,
          0.92,
          0.88
        ]
      },
      {
        "test_name": "unpack_scalarf_uXX_unsafe",
        "is_significant": false,
        "p_value": 0.9999999693659123,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999999880785,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.5375307923249258,
        "relative_improvement": 4.6726060681464146e-05,
        "absolute_improvement_ms": 2.5423728813507296,
        "old_mean_ms": 54410.16949152542,
        "new_mean_ms": 54407.62711864407,
        "old_std_ms": 2609.242518912617,
        "new_std_ms": 2617.715731638119,
        "effect_size_cohens_d": 0.0009727912177682773,
        "old_ci95_ms": [
          53730.19718766283,
          55090.141795388015
        ],
        "new_ci95_ms": [
          53725.44668351875,
          55089.807553769395
        ],
        "old_ci99_ms": [
          53505.465715898725,
          55314.87326715212
        ],
        "new_ci99_ms": [
          53499.98542234159,
          55315.268814946554
        ],
        "new_times": [
          56.98,
          51.71,
          56.86,
          51.78,
          56.99,
          51.61,
          57.05,
          52.0,
          57.09,
          51.88,
          57.13,
          51.72,
          56.74,
          51.75,
          56.81,
          51.73,
          57.01,
          51.55,
          57.01,
          51.73,
          56.89,
          51.65,
          56.79,
          51.8,
          56.75,
          51.86,
          56.91,
          51.75,
          57.02,
          51.74,
          57.01,
          51.83,
          56.92,
          52.0,
          57.02,
          51.77,
          57.16,
          51.84,
          56.85,
          51.72,
          56.94,
          51.75,
          56.85,
          51.77,
          57.03,
          51.65,
          57.07,
          51.71,
          56.78,
          51.84,
          56.9,
          51.75,
          57.09,
          51.82,
          57.05,
          51.84,
          57.07,
          51.78,
          56.95
        ],
        "old_times": [
          56.87,
          51.73,
          57.0,
          51.82,
          56.82,
          51.92,
          57.03,
          51.79,
          57.0,
          52.0,
          57.26,
          52.28,
          57.0,
          51.74,
          57.04,
          51.7,
          57.01,
          51.84,
          57.01,
          51.51,
          56.91,
          51.79,
          56.81,
          51.76,
          56.97,
          51.71,
          56.88,
          51.78,
          56.76,
          51.8,
          56.82,
          51.68,
          56.86,
          51.5,
          56.86,
          51.76,
          56.97,
          51.79,
          57.06,
          51.77,
          56.8,
          51.75,
          56.93,
          51.85,
          57.28,
          51.84,
          56.82,
          51.76,
          56.9,
          51.74,
          56.97,
          51.76,
          56.93,
          51.73,
          57.03,
          51.81,
          56.87,
          51.77,
          57.05
        ]
      },
      {
        "test_name": "pack_vector4_64",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999393422746,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 1.0,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 40.0,
        "new_mean_ms": 40.0,
        "old_std_ms": 0.0,
        "new_std_ms": 0.0,
        "effect_size_cohens_d": "NaN",
        "old_ci95_ms": [
          40.0,
          40.0
        ],
        "new_ci95_ms": [
          40.0,
          40.0
        ],
        "old_ci99_ms": [
          40.0,
          40.0
        ],
        "new_ci99_ms": [
          40.0,
          40.0
        ],
        "new_times": [
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04
        ],
        "old_times": [
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04,
          0.04
        ]
      },
      {
        "test_name": "pack_vector4_XX",
        "is_significant": false,
        "p_value": 0.9999998033153672,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999999884374,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.706972357436968,
        "relative_improvement": -0.0007755074516150121,
        "absolute_improvement_ms": -11.694915254238936,
        "old_mean_ms": 15080.338983050848,
        "new_mean_ms": 15092.033898305086,
        "old_std_ms": 791.5828013449728,
        "new_std_ms": 793.3794579823291,
        "effect_size_cohens_d": -0.014757332765025838,
        "old_ci95_ms": [
          14874.051381485602,
          15286.626584616093
        ],
        "new_ci95_ms": [
          14885.278085470058,
          15298.789711140114
        ],
        "old_ci99_ms": [
          14805.873139455593,
          15354.804826646103
        ],
        "new_ci99_ms": [
          14816.945099184793,
          15367.122697425379
        ],
        "new_times": [
          15.86,
          14.25,
          15.84,
          14.29,
          15.83,
          14.39,
          15.91,
          14.34,
          15.99,
          14.29,
          15.85,
          14.27,
          15.84,
          14.26,
          15.95,
          14.26,
          15.84,
          14.31,
          15.85,
          14.31,
          15.83,
          14.32,
          15.86,
          14.35,
          15.9,
          14.34,
          15.86,
          14.29,
          16.0,
          14.29,
          15.81,
          14.28,
          15.82,
          14.27,
          15.85,
          14.31,
          15.89,
          14.31,
          15.96,
          14.27,
          15.85,
          14.3,
          15.84,
          14.3,
          15.81,
          14.28,
          15.86,
          14.26,
          15.83,
          14.25,
          15.83,
          14.28,
          15.86,
          14.29,
          15.85,
          14.3,
          15.82,
          14.24,
          15.84
        ],
        "old_times": [
          15.88,
          14.31,
          15.94,
          14.4,
          15.89,
          14.31,
          15.89,
          14.31,
          15.85,
          14.29,
          15.91,
          14.29,
          15.86,
          14.26,
          15.81,
          14.24,
          15.84,
          14.26,
          15.85,
          14.33,
          15.84,
          14.26,
          15.81,
          14.28,
          15.87,
          14.28,
          15.82,
          14.3,
          15.86,
          14.25,
          15.86,
          14.27,
          15.82,
          14.27,
          15.82,
          14.29,
          15.84,
          14.31,
          15.86,
          14.31,
          15.82,
          14.27,
          15.86,
          14.25,
          15.82,
          14.23,
          15.86,
          14.26,
          15.84,
          14.27,
          15.78,
          14.3,
          15.87,
          14.27,
          15.83,
          14.27,
          15.87,
          14.26,
          15.87
        ]
      },
      {
        "test_name": "pack_vector3_48",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999393422746,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 1.0,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 30.000000000000004,
        "new_mean_ms": 30.000000000000004,
        "old_std_ms": 3.5331118393247232e-15,
        "new_std_ms": 3.5331118393247232e-15,
        "effect_size_cohens_d": 0.0,
        "old_ci95_ms": [
          30.000000000000004,
          30.000000000000004
        ],
        "new_ci95_ms": [
          30.000000000000004,
          30.000000000000004
        ],
        "old_ci99_ms": [
          30.0,
          30.000000000000007
        ],
        "new_ci99_ms": [
          30.0,
          30.000000000000007
        ],
        "new_times": [
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03
        ],
        "old_times": [
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03
        ]
      },
      {
        "test_name": "decay_vector3_48",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999393422746,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 1.0,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 20.0,
        "new_mean_ms": 20.0,
        "old_std_ms": 0.0,
        "new_std_ms": 0.0,
        "effect_size_cohens_d": "NaN",
        "old_ci95_ms": [
          20.0,
          20.0
        ],
        "new_ci95_ms": [
          20.0,
          20.0
        ],
        "old_ci99_ms": [
          20.0,
          20.0
        ],
        "new_ci99_ms": [
          20.0,
          20.0
        ],
        "new_times": [
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02
        ],
        "old_times": [
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02
        ]
      },
      {
        "test_name": "pack_vector3_XX",
        "is_significant": false,
        "p_value": 0.9999999998876541,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999999881346,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.4731531321006943,
        "relative_improvement": -2.181619852738676e-05,
        "absolute_improvement_ms": -0.6779661016942384,
        "old_mean_ms": 31076.271186440674,
        "new_mean_ms": 31076.94915254237,
        "old_std_ms": 1246.3241100367566,
        "new_std_ms": 1243.4383007269753,
        "effect_size_cohens_d": -0.0005446026844642672,
        "old_ci95_ms": [
          30751.4773543923,
          31401.06501848905
        ],
        "new_ci95_ms": [
          30752.907366496103,
          31400.990938588635
        ],
        "old_ci99_ms": [
          30644.132694203185,
          31508.409678678163
        ],
        "new_ci99_ms": [
          30645.811258202306,
          31508.08704688243
        ],
        "new_times": [
          32.34,
          29.86,
          32.25,
          29.78,
          32.31,
          29.81,
          32.45,
          29.9,
          32.37,
          29.85,
          32.27,
          29.86,
          32.2,
          29.77,
          32.29,
          29.81,
          32.27,
          29.78,
          32.25,
          29.83,
          32.24,
          29.85,
          32.27,
          29.87,
          32.3,
          29.81,
          32.25,
          29.8,
          32.26,
          29.77,
          32.25,
          29.78,
          32.28,
          29.8,
          32.28,
          29.88,
          32.26,
          29.88,
          32.32,
          29.82,
          32.24,
          29.79,
          32.3,
          29.82,
          32.35,
          29.83,
          32.27,
          29.83,
          32.34,
          29.83,
          32.23,
          29.84,
          32.25,
          29.82,
          32.28,
          29.78,
          32.35,
          29.84,
          32.33
        ],
        "old_times": [
          32.28,
          29.83,
          32.26,
          29.88,
          32.35,
          29.88,
          32.24,
          29.8,
          32.36,
          29.88,
          32.4,
          29.81,
          32.35,
          29.82,
          32.28,
          29.78,
          32.29,
          29.71,
          32.3,
          29.91,
          32.3,
          29.85,
          32.27,
          29.77,
          32.22,
          29.83,
          32.37,
          29.83,
          32.29,
          29.8,
          32.29,
          29.83,
          32.29,
          29.77,
          32.25,
          29.77,
          32.28,
          29.84,
          32.26,
          29.84,
          32.2,
          29.78,
          32.26,
          29.81,
          32.27,
          29.75,
          32.24,
          29.91,
          32.25,
          29.84,
          32.28,
          29.78,
          32.36,
          29.9,
          32.34,
          29.81,
          32.29,
          29.78,
          32.29
        ]
      },
      {
        "test_name": "decay_vector3_XX",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.999999452948378,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.02986493413782621,
        "relative_improvement": 0.0018042399639151621,
        "absolute_improvement_ms": 2.8571428571428914,
        "old_mean_ms": 1583.5714285714287,
        "new_mean_ms": 1580.7142857142858,
        "old_std_ms": 9.511897312113428,
        "new_std_ms": 6.042179781166445,
        "effect_size_cohens_d": 0.3585685828003221,
        "old_ci95_ms": [
          1579.883099836033,
          1587.2597573068244
        ],
        "new_ci95_ms": [
          1578.3713729829926,
          1583.0571984455787
        ],
        "old_ci99_ms": [
          1578.5909053335965,
          1588.5519518092608
        ],
        "new_ci99_ms": [
          1577.5505407936025,
          1583.8780306349688
        ],
        "new_times": [
          1.58,
          1.58,
          1.58,
          1.58,
          1.58,
          1.58,
          1.58,
          1.58,
          1.58,
          1.57,
          1.58,
          1.58,
          1.58,
          1.58,
          1.58,
          1.58,
          1.58,
          1.58,
          1.61,
          1.58,
          1.58,
          1.58,
          1.58,
          1.58,
          1.58,
          1.58,
          1.58,
          1.58
        ],
        "old_times": [
          1.58,
          1.58,
          1.58,
          1.62,
          1.58,
          1.58,
          1.58,
          1.58,
          1.58,
          1.58,
          1.58,
          1.59,
          1.58,
          1.58,
          1.58,
          1.58,
          1.58,
          1.58,
          1.58,
          1.58,
          1.58,
          1.61,
          1.58,
          1.58,
          1.58,
          1.58,
          1.59,
          1.59
        ]
      },
      {
        "test_name": "pack_vector2_XX",
        "is_significant": false,
        "p_value": 0.9999999785939448,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999999881423,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.5,
        "relative_improvement": -0.00021092215164694587,
        "absolute_improvement_ms": -5.93220338983258,
        "old_mean_ms": 28125.08474576271,
        "new_mean_ms": 28131.01694915254,
        "old_std_ms": 1337.7069583759496,
        "new_std_ms": 1342.2442540904424,
        "effect_size_cohens_d": -0.004427091702379934,
        "old_ci95_ms": [
          27776.4764137327,
          28473.69307779272
        ],
        "new_ci95_ms": [
          27781.226191419315,
          28480.80770688577
        ],
        "old_ci99_ms": [
          27661.261039398618,
          28588.9084521268
        ],
        "new_ci99_ms": [
          27665.6200243029,
          28596.413874002184
        ],
        "new_times": [
          29.35,
          26.82,
          29.46,
          26.8,
          29.47,
          26.83,
          29.59,
          26.77,
          29.48,
          26.76,
          29.52,
          26.77,
          29.46,
          26.72,
          29.41,
          26.75,
          29.42,
          26.71,
          29.29,
          26.95,
          29.39,
          26.68,
          29.4,
          26.82,
          29.49,
          26.74,
          29.33,
          26.7,
          29.34,
          26.69,
          29.51,
          26.88,
          29.48,
          26.73,
          29.43,
          26.72,
          29.42,
          26.91,
          29.51,
          26.77,
          29.43,
          26.73,
          29.47,
          26.75,
          29.4,
          26.72,
          29.44,
          26.73,
          29.33,
          26.72,
          29.41,
          26.79,
          29.52,
          27.16,
          29.5,
          26.74,
          29.43,
          26.76,
          29.43
        ],
        "old_times": [
          29.45,
          26.8,
          29.42,
          26.77,
          29.45,
          26.7,
          29.41,
          26.85,
          29.47,
          26.92,
          29.63,
          26.7,
          29.38,
          26.72,
          29.4,
          26.79,
          29.28,
          26.83,
          29.36,
          26.75,
          29.5,
          26.8,
          29.4,
          26.85,
          29.45,
          26.75,
          29.37,
          26.72,
          29.41,
          26.78,
          29.41,
          26.64,
          29.48,
          26.77,
          29.36,
          26.74,
          29.45,
          26.75,
          29.42,
          26.77,
          29.48,
          26.78,
          29.35,
          26.79,
          29.37,
          26.9,
          29.4,
          26.76,
          29.5,
          26.83,
          29.37,
          26.75,
          29.5,
          26.7,
          29.42,
          26.86,
          29.46,
          26.78,
          29.48
        ]
      }
    ]
  },
  "logs": {
    "full_log_path": "/logs/full.log",
    "config_log_path": "/logs/config.log",
    "build_log_path": "/logs/build.log",
    "test_log_path": "/logs/test.log",
    "build_success": true,
    "test_success": true
  },
  "raw_timing_data": {
    "warmup_runs": 1,
    "measurement_runs": 30,
    "min_exec_time_improvement": 0.05,
    "min_p_value": 0.05
  }
}