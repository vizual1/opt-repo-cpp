{
  "metadata": {
    "collection_date": "2026-02-03T20:02:25.371014",
    "repository": "https://github.com/kimci86/bkcrack",
    "repository_name": "kimci86/bkcrack"
  },
  "commit_info": {
    "old_sha": "fc7d9bbaa56b39c742fdf1ee1722756809f8db9d",
    "new_sha": "02b53af99c70d1667c8a1fff10179d1677093901",
    "commit_message": [
      "Extract special case for six characters and rework bruteforce recovery"
    ],
    "commit_date": "2024-06-27T22:00:00+00:00",
    "patch": [
      "--- include/password.hpp\n@@ -4,73 +4,8 @@\n #include \"Keys.hpp\"\n #include \"Progress.hpp\"\n \n-#include <bitset>\n-#include <mutex>\n-\n /// \\file password.hpp\n \n-/// Class to recover a password from internal keys\n-class Recovery\n-{\n-public:\n-    /// Constructor\n-    Recovery(const Keys& keys, const std::vector<std::uint8_t>& charset, std::vector<std::string>& solutions,\n-             std::mutex& solutionsMutex, bool exhaustive, Progress& progress);\n-\n-    /// \\brief Look for a password of length 6 or less\n-    ///\n-    /// Try to derive 6 characters such that updating the given cipher state\n-    /// with them gives the target cipher state (the password representation).\n-    /// On success, the current prefix followed by those 6 characters is added\n-    /// to the shared output vector.\n-    ///\n-    /// If the target length is less than 6, the first characters are ignored so that\n-    /// the saved solution has the target length. This is useful to recover passwords\n-    /// shorter than 6 characters.\n-    ///\n-    /// \\pre prefix.size() + 6 == length && initial == Keys{prefix} || length < 6\n-    void recoverShortPassword(const Keys& initial);\n-\n-    /// \\brief Look for password of length 7 or more\n-    ///\n-    /// Recursively iterate on possible prefixes of length-6 characters.\n-    /// For each prefix, try to recover the last 6 characters like recoverShortPassword.\n-    ///\n-    /// \\pre prefix.size() + 6 < length && initial == Keys{prefix}\n-    void recoverLongPassword(const Keys& initial);\n-\n-    /// Length of the password to recover\n-    std::size_t length;\n-\n-    /// The first characters of the password candidate, up to length-6 characters long\n-    std::string prefix;\n-\n-    /// Set of characters to generate password candidates\n-    const std::vector<std::uint8_t>& charset;\n-\n-private:\n-    // iterate recursively on possible Y values\n-    void recursion(int i);\n-\n-    // set of possible Z0[16,31) values considering given character set\n-    std::bitset<1 << 16> z0_16_32;\n-\n-    // set of possible Z{-1}[24,32) values considering given character set\n-    std::bitset<1 << 8> zm1_24_32;\n-\n-    // cipher state (X,Y,Z)_i for index i in [0, 6] where the last state (X,Y,Z)_6 is\n-    // the representation of the password to recover\n-    std::array<std::uint32_t, 7> x, y, z;\n-    std::uint32_t                candidateX0; // backup of candidate X value for convenience\n-\n-    std::array<std::uint8_t, 6> p; // password last 6 bytes\n-\n-    std::vector<std::string>& solutions; // shared output vector of valid passwords\n-    std::mutex&               solutionsMutex;\n-    const bool                exhaustive;\n-    Progress&                 progress;\n-};\n-\n /// \\brief Try to recover the password associated with the given keys\n /// \\param keys Internal keys for which a password is wanted\n /// \\param charset The set of characters with which to constitute password candidates\n--- src/password.cpp\n@@ -2,399 +2,487 @@\n \n #include \"Crc32Tab.hpp\"\n #include \"MultTab.hpp\"\n+#include \"log.hpp\"\n \n #include <algorithm>\n #include <atomic>\n+#include <bitset>\n #include <iomanip>\n+#include <mutex>\n #include <thread>\n \n-Recovery::Recovery(const Keys& keys, const std::vector<std::uint8_t>& charset, std::vector<std::string>& solutions,\n-                   std::mutex& solutionsMutex, bool exhaustive, Progress& progress)\n-: charset{charset}\n-, solutions{solutions}\n-, solutionsMutex{solutionsMutex}\n-, exhaustive{exhaustive}\n-, progress{progress}\n+template <typename Derived /* must implement onSolutionFound() method */>\n+class SixCharactersRecovery\n {\n-    // initialize target X, Y and Z values\n-    x[6] = keys.getX();\n-    y[6] = keys.getY();\n-    z[6] = keys.getZ();\n-\n-    // derive Y5\n-    y[5] = (y[6] - 1) * MultTab::multInv - lsb(x[6]);\n-\n-    // derive more Z bytes\n-    for (auto i = 6; 1 < i; i--)\n-        z[i - 1] = Crc32Tab::crc32inv(z[i], msb(y[i]));\n-\n-    // precompute possible Z0[16,32) and Z{-1}[24,32)\n-    for (const auto p5 : charset)\n+public:\n+    SixCharactersRecovery(const Keys& target, const std::vector<std::uint8_t>& charset4,\n+                          const std::vector<std::uint8_t>& charset5)\n     {\n-        x[5] = Crc32Tab::crc32inv(x[6], p5);\n-        y[4] = (y[5] - 1) * MultTab::multInv - lsb(x[5]);\n-        z[3] = Crc32Tab::crc32inv(z[4], msb(y[4]));\n+        // initialize target X, Y and Z values\n+        x[6] = target.getX();\n+        y[6] = target.getY();\n+        z[6] = target.getZ();\n \n-        for (const auto p4 : charset)\n-        {\n-            x[4] = Crc32Tab::crc32inv(x[5], p4);\n-            y[3] = (y[4] - 1) * MultTab::multInv - lsb(x[4]);\n-            z[2] = Crc32Tab::crc32inv(z[3], msb(y[3]));\n-            z[1] = Crc32Tab::crc32inv(z[2], 0);\n-            z[0] = Crc32Tab::crc32inv(z[1], 0);\n-\n-            z0_16_32.set(z[0] >> 16);\n-            zm1_24_32.set(Crc32Tab::crc32inv(z[0], 0) >> 24);\n-        }\n-    }\n-}\n+        // derive Y5\n+        y[5] = (y[6] - 1) * MultTab::multInv - lsb(x[6]);\n \n-void Recovery::recoverShortPassword(const Keys& initial)\n-{\n-    // check compatible Z0[16,32)\n-    if (!z0_16_32[initial.getZ() >> 16])\n-        return;\n+        // derive more Z bytes\n+        for (auto i = 6; 1 < i; i--)\n+            z[i - 1] = Crc32Tab::crc32inv(z[i], msb(y[i]));\n \n-    // initialize starting X, Y and Z values\n-    x[0] = candidateX0 = initial.getX();\n-    y[0]               = initial.getY();\n-    z[0]               = initial.getZ();\n+        // precompute possible Z0[16,32) and Z{-1}[24,32)\n+        for (const auto p5 : charset5)\n+        {\n+            x[5] = Crc32Tab::crc32inv(x[6], p5);\n+            y[4] = (y[5] - 1) * MultTab::multInv - lsb(x[5]);\n+            z[3] = Crc32Tab::crc32inv(z[4], msb(y[4]));\n \n-    // complete Z values and derive Y[24,32) values\n-    for (auto i = 1; i <= 4; i++)\n-    {\n-        y[i] = Crc32Tab::getYi_24_32(z[i], z[i - 1]);\n-        z[i] = Crc32Tab::crc32(z[i - 1], msb(y[i]));\n+            for (const auto p4 : charset4)\n+            {\n+                x[4] = Crc32Tab::crc32inv(x[5], p4);\n+                y[3] = (y[4] - 1) * MultTab::multInv - lsb(x[4]);\n+                z[2] = Crc32Tab::crc32inv(z[3], msb(y[3]));\n+                z[1] = Crc32Tab::crc32inv(z[2], 0);\n+                z[0] = Crc32Tab::crc32inv(z[1], 0);\n+\n+                z0_16_32.set(z[0] >> 16);\n+                zm1_24_32.set(Crc32Tab::crc32inv(z[0], 0) >> 24);\n+            }\n+        }\n     }\n \n-    // recursively complete Y values and derive password\n-    recursion(5);\n-}\n-\n-void Recovery::recoverLongPassword(const Keys& initial)\n-{\n-    if (prefix.size() + 7 == length) // there is only one more character to bruteforce\n+    void search(const Keys& initial)\n     {\n-        // check compatible Z{-1}[24, 32)\n-        if (!zm1_24_32[initial.getZ() >> 24])\n+        // check compatible Z0[16,32)\n+        if (!z0_16_32[initial.getZ() >> 16])\n             return;\n \n-        prefix.push_back(charset[0]);\n+        // initialize starting X, Y and Z values\n+        x[0] = candidateX0 = initial.getX();\n+        y[0]               = initial.getY();\n+        z[0]               = initial.getZ();\n \n-        // precompute as much as we can about the next cipher state without knowing the password byte\n-        const auto x0_partial = Crc32Tab::crc32(initial.getX(), 0);\n-        const auto y0_partial = initial.getY() * MultTab::mult + 1;\n-        const auto z0_partial = Crc32Tab::crc32(initial.getZ(), 0);\n-\n-        for (const auto pi : charset)\n+        // complete Z values and derive Y[24,32) values\n+        for (auto i = 1; i <= 4; i++)\n         {\n-            // finish to update the cipher state\n-            const auto x0 = x0_partial ^ Crc32Tab::crc32(0, pi);\n-            const auto y0 = y0_partial + MultTab::getMult(lsb(x0));\n-            const auto z0 = z0_partial ^ Crc32Tab::crc32(0, msb(y0));\n-\n-            // recoverShortPassword is inlined below for performance\n-\n-            // check compatible Z0[16,32)\n-            if (!z0_16_32[z0 >> 16])\n-                continue;\n-\n-            prefix.back() = pi;\n-\n-            // initialize starting X, Y and Z values\n-            x[0] = candidateX0 = x0;\n-            y[0]               = y0;\n-            z[0]               = z0;\n-\n-            // complete Z values and derive Y[24,32) values\n-            y[1] = Crc32Tab::getYi_24_32(z[1], z[1 - 1]);\n-            z[1] = Crc32Tab::crc32(z[1 - 1], msb(y[1]));\n-            y[2] = Crc32Tab::getYi_24_32(z[2], z[2 - 1]);\n-            z[2] = Crc32Tab::crc32(z[2 - 1], msb(y[2]));\n-            y[3] = Crc32Tab::getYi_24_32(z[3], z[3 - 1]);\n-            z[3] = Crc32Tab::crc32(z[3 - 1], msb(y[3]));\n-            y[4] = Crc32Tab::getYi_24_32(z[4], z[4 - 1]);\n-            // z[4] = Crc32Tab::crc32(z[4 - 1], msb(y[4])); // this one is already known\n-\n-            // recursively complete Y values and derive password\n-            recursion(5);\n+            y[i] = Crc32Tab::getYi_24_32(z[i], z[i - 1]);\n+            z[i] = Crc32Tab::crc32(z[i - 1], msb(y[i]));\n         }\n \n-        prefix.pop_back();\n+        // recursively complete Y values and derive password\n+        searchRecursive(5);\n     }\n-    else // bruteforce the next character and continue recursively\n-    {\n-        prefix.push_back(charset[0]);\n \n-        for (const auto pi : charset)\n+protected:\n+    void searchRecursive(int i)\n+    {\n+        if (i != 1) // the Y-list is not complete so generate Y{i-1} values\n         {\n-            Keys init = initial;\n-            init.update(pi);\n+            const auto fy  = (y[i] - 1) * MultTab::multInv;\n+            const auto ffy = (fy - 1) * MultTab::multInv;\n+\n+            // get possible LSB(Xi)\n+            for (const auto xi_0_8 : MultTab::getMsbProdFiber2(msb(ffy - (y[i - 2] & mask<24, 32>))))\n+            {\n+                // compute corresponding Y{i-1}\n+                const auto yim1 = fy - xi_0_8;\n+\n+                // filter values with Y{i-2}[24,32)\n+                if (ffy - MultTab::getMultinv(xi_0_8) - (y[i - 2] & mask<24, 32>) <= maxdiff<24> &&\n+                    msb(yim1) == msb(y[i - 1]))\n+                {\n+                    // add Y{i-1} to the Y-list\n+                    y[i - 1] = yim1;\n \n-            prefix.back() = pi;\n+                    // set Xi value\n+                    x[i] = xi_0_8;\n \n-            recoverLongPassword(init);\n+                    searchRecursive(i - 1);\n+                }\n+            }\n         }\n+        else // the Y-list is complete\n+        {\n+            // only the X1 LSB was not set yet, so do it here\n+            x[1] = (y[1] - 1) * MultTab::multInv - y[0];\n+            if (x[1] > 0xff)\n+                return;\n+\n+            // complete X values and derive password\n+            for (auto j = 5; 0 <= j; j--)\n+            {\n+                const auto xi_xor_pi = Crc32Tab::crc32inv(x[j + 1], 0);\n+                p[j]                 = lsb(xi_xor_pi ^ x[j]);\n+                x[j]                 = xi_xor_pi ^ p[j];\n+            }\n \n-        prefix.pop_back();\n+            if (x[0] == candidateX0) // the password is successfully recovered\n+                (static_cast<Derived*>(this))->onSolutionFound();\n+        }\n     }\n-}\n \n-void Recovery::recursion(int i)\n+    // set of possible Z0[16,32) values considering given character set\n+    std::bitset<1 << 16> z0_16_32;\n+\n+    // set of possible Z{-1}[24,32) values considering given character set\n+    std::bitset<1 << 8> zm1_24_32;\n+\n+    // cipher state (X,Y,Z)_i for index i in [0, 6] where the last state (X,Y,Z)_6 is\n+    // the representation of the password to recover\n+    std::array<std::uint32_t, 7> x{}, y{}, z{};\n+    std::uint32_t                candidateX0{}; // backup of candidate X value for convenience\n+\n+    std::array<std::uint8_t, 6> p{}; // password last 6 bytes\n+};\n+\n+class BruteforceRecovery : public SixCharactersRecovery<BruteforceRecovery>\n {\n-    if (i != 1) // the Y-list is not complete so generate Y{i-1} values\n+public:\n+    BruteforceRecovery(const Keys& keys, const std::vector<std::uint8_t>& charset, std::vector<std::string>& solutions,\n+                       std::mutex& solutionsMutex, bool exhaustive, Progress& progress)\n+    : SixCharactersRecovery{keys, charset, charset}\n+    , charset{charset}\n+    , solutions{solutions}\n+    , solutionsMutex{solutionsMutex}\n+    , exhaustive{exhaustive}\n+    , progress{progress}\n     {\n-        const auto fy  = (y[i] - 1) * MultTab::multInv;\n-        const auto ffy = (fy - 1) * MultTab::multInv;\n-\n-        // get possible LSB(Xi)\n-        for (const auto xi_0_8 : MultTab::getMsbProdFiber2(msb(ffy - (y[i - 2] & mask<24, 32>))))\n-        {\n-            // compute corresponding Y{i-1}\n-            const auto yim1 = fy - xi_0_8;\n+    }\n \n-            // filter values with Y{i-2}[24,32)\n-            if (ffy - MultTab::getMultinv(xi_0_8) - (y[i - 2] & mask<24, 32>) <= maxdiff<24> &&\n-                msb(yim1) == msb(y[i - 1]))\n-            {\n-                // add Y{i-1} to the Y-list\n-                y[i - 1] = yim1;\n+    void search(const Keys& initial, std::size_t length)\n+    {\n+        auto restart = std::string{};\n+        search(initial, length, \"\", restart, 1);\n+    }\n \n-                // set Xi value\n-                x[i] = xi_0_8;\n+    void search(const Keys& initial, std::size_t length, const std::string& start, std::string& restart, int jobs)\n+    {\n+        prefix.clear();\n+        this->length = length;\n \n-                recursion(i - 1);\n-            }\n+        if (length <= 6)\n+            searchShort(initial);\n+        else if (length <= 9)\n+            searchLongRecursive(initial);\n+        else\n+        {\n+            progress.done  = 0;\n+            progress.total = charset.size() * charset.size();\n+            searchLongParallelRecursive(initial, start, restart, jobs);\n         }\n     }\n-    else // the Y-list is complete\n+\n+    void onSolutionFound() const\n     {\n-        // only the X1 LSB was not set yet, so do it here\n-        x[1] = (y[1] - 1) * MultTab::multInv - y[0];\n-        if (x[1] > 0xff)\n-            return;\n+        auto password = prefix;\n+        password.append(p.begin(), p.end());\n+        password.erase(password.begin(), password.end() - length);\n \n-        // complete X values and derive password\n-        for (auto j = 5; 0 <= j; j--)\n+        const auto isInCharset =\n+            std::all_of(password.begin(), password.end(),\n+                        [this](char c)\n+                        { return std::binary_search(charset.begin(), charset.end(), static_cast<std::uint8_t>(c)); });\n+\n+        if (!isInCharset)\n         {\n-            const auto xi_xor_pi = Crc32Tab::crc32inv(x[j + 1], 0);\n-            p[j]                 = lsb(xi_xor_pi ^ x[j]);\n-            x[j]                 = xi_xor_pi ^ p[j];\n+            progress.log(\n+                [&password](std::ostream& os)\n+                {\n+                    const auto flagsBefore = os.setf(std::ios::hex, std::ios::basefield);\n+                    const auto fillBefore  = os.fill('0');\n+\n+                    os << \"Password: \" << password << \" (as bytes:\";\n+                    for (const auto c : password)\n+                        os << ' ' << std::setw(2) << static_cast<int>(c);\n+                    os << ')' << std::endl;\n+\n+                    os.fill(fillBefore);\n+                    os.flags(flagsBefore);\n+\n+                    os << \"Some characters are not in the expected charset. Continuing.\" << std::endl;\n+                });\n+\n+            return;\n         }\n \n-        if (x[0] == candidateX0) // the password is successfully recovered\n         {\n-            auto password = prefix;\n-            password.append(p.begin(), p.end());\n-            password.erase(password.begin(), password.end() - length);\n-\n-            const auto isInCharset =\n-                std::all_of(password.begin(), password.end(),\n-                            [this](char c) {\n-                                return std::binary_search(charset.begin(), charset.end(), static_cast<std::uint8_t>(c));\n-                            });\n+            const auto lock = std::scoped_lock{solutionsMutex};\n+            solutions.push_back(password);\n+        }\n \n-            if (!isInCharset)\n-            {\n-                progress.log(\n-                    [&password](std::ostream& os)\n-                    {\n-                        const auto flagsBefore = os.setf(std::ios::hex, std::ios::basefield);\n-                        const auto fillBefore  = os.fill('0');\n+        progress.log([&password](std::ostream& os) { os << \"Password: \" << password << std::endl; });\n \n-                        os << \"Password: \" << password << \" (as bytes:\";\n-                        for (const auto c : password)\n-                            os << ' ' << std::setw(2) << static_cast<int>(c);\n-                        os << ')' << std::endl;\n+        if (!exhaustive)\n+            progress.state = Progress::State::EarlyExit;\n+    }\n \n-                        os.fill(fillBefore);\n-                        os.flags(flagsBefore);\n+private:\n+    /// \\brief Look for a password of length 6 or less\n+    ///\n+    /// \\pre prefix.empty() && length <= 6\n+    void searchShort(Keys initial)\n+    {\n+        // update initial state backward so that there are exactly 6 updates between it and the target state\n+        for (auto i = length; i < 6; i++)\n+            initial.updateBackwardPlaintext(charset.front());\n \n-                        os << \"Some characters are not in the expected charset. Continuing.\" << std::endl;\n-                    });\n+        SixCharactersRecovery::search(initial);\n+    }\n \n+    /// \\brief Look for password of length 7 or more\n+    ///\n+    /// Recursively iterate on possible prefixes of length-6 characters.\n+    /// For each prefix, try to recover the last 6 characters with SixCharactersRecovery::search.\n+    ///\n+    /// \\pre prefix.size() + 6 < length\n+    void searchLongRecursive(const Keys& initial)\n+    {\n+        if (prefix.size() + 7 == length) // there is only one more character to bruteforce\n+        {\n+            // check compatible Z{-1}[24, 32)\n+            if (!zm1_24_32[initial.getZ() >> 24])\n                 return;\n-            }\n \n+            prefix.push_back(charset[0]);\n+\n+            // precompute as much as we can about the next cipher state without knowing the password byte\n+            const auto x0_partial = Crc32Tab::crc32(initial.getX(), 0);\n+            const auto y0_partial = initial.getY() * MultTab::mult + 1;\n+            const auto z0_partial = Crc32Tab::crc32(initial.getZ(), 0);\n+\n+            for (const auto pi : charset)\n             {\n-                const auto lock = std::scoped_lock{solutionsMutex};\n-                solutions.push_back(password);\n+                // finish to update the cipher state\n+                const auto x0 = x0_partial ^ Crc32Tab::crc32(0, pi);\n+                const auto y0 = y0_partial + MultTab::getMult(lsb(x0));\n+                const auto z0 = z0_partial ^ Crc32Tab::crc32(0, msb(y0));\n+\n+                // SixCharactersRecovery::search is inlined below for performance\n+\n+                // check compatible Z0[16,32)\n+                if (!z0_16_32[z0 >> 16])\n+                    continue;\n+\n+                prefix.back() = pi;\n+\n+                // initialize starting X, Y and Z values\n+                x[0] = candidateX0 = x0;\n+                y[0]               = y0;\n+                z[0]               = z0;\n+\n+                // complete Z values and derive Y[24,32) values\n+                y[1] = Crc32Tab::getYi_24_32(z[1], z[1 - 1]);\n+                z[1] = Crc32Tab::crc32(z[1 - 1], msb(y[1]));\n+                y[2] = Crc32Tab::getYi_24_32(z[2], z[2 - 1]);\n+                z[2] = Crc32Tab::crc32(z[2 - 1], msb(y[2]));\n+                y[3] = Crc32Tab::getYi_24_32(z[3], z[3 - 1]);\n+                z[3] = Crc32Tab::crc32(z[3 - 1], msb(y[3]));\n+                y[4] = Crc32Tab::getYi_24_32(z[4], z[4 - 1]);\n+                // z[4] = Crc32Tab::crc32(z[4 - 1], msb(y[4])); // this one is already known\n+\n+                // recursively complete Y values and derive password\n+                searchRecursive(5);\n             }\n \n-            progress.log([&password](std::ostream& os) { os << \"Password: \" << password << std::endl; });\n-\n-            if (!exhaustive)\n-                progress.state = Progress::State::EarlyExit;\n+            prefix.pop_back();\n         }\n-    }\n-}\n+        else // bruteforce the next character and continue recursively\n+        {\n+            prefix.push_back(charset[0]);\n \n-namespace\n-{\n+            for (const auto pi : charset)\n+            {\n+                Keys init = initial;\n+                init.update(pi);\n \n-void recoverPasswordRecursive(Recovery& worker, int jobs, const Keys& initial, const std::string& start,\n-                              std::string& restart, Progress& progress)\n-{\n-    const auto charsetSize = static_cast<int>(worker.charset.size());\n+                prefix.back() = pi;\n \n-    auto index_start = 0;\n-    if (worker.prefix.size() < start.size())\n-        while (index_start < charsetSize &&\n-               worker.charset[index_start] < static_cast<unsigned char>(start[worker.prefix.size()]))\n-            ++index_start;\n+                searchLongRecursive(init);\n+            }\n+\n+            prefix.pop_back();\n+        }\n+    }\n \n-    if (worker.prefix.size() + 1 + 9 == worker.length) // bruteforce one character in parallel\n+    /// \\brief Look for password of length 10 or more\n+    ///\n+    /// Recursively iterate on possible prefixes of length-6 characters.\n+    /// Start parallel workers looking for a password of length 9.\n+    ///\n+    /// \\pre prefix.size() + 9 < length\n+    void searchLongParallelRecursive(const Keys& initial, const std::string& start, std::string& restart, int jobs)\n     {\n-        worker.prefix.push_back(worker.charset[0]);\n+        const auto charsetSize = static_cast<int>(charset.size());\n \n-        progress.done += index_start * charsetSize;\n+        auto index_start = 0;\n+        if (prefix.size() < start.size())\n+            while (index_start < charsetSize && charset[index_start] < static_cast<unsigned char>(start[prefix.size()]))\n+                ++index_start;\n \n-        const auto threadCount        = std::clamp(jobs, 1, charsetSize);\n-        auto       threads            = std::vector<std::thread>{};\n-        auto       nextCandidateIndex = std::atomic<int>{index_start};\n-        for (auto i = 0; i < threadCount; ++i)\n-            threads.emplace_back(\n-                [&nextCandidateIndex, charsetSize, &progress, worker, initial]() mutable\n-                {\n-                    for (auto i = nextCandidateIndex++; i < charsetSize; i = nextCandidateIndex++)\n+        if (prefix.size() + 1 + 9 == length) // bruteforce one character in parallel\n+        {\n+            prefix.push_back(charset[0]);\n+\n+            progress.done += index_start * charsetSize;\n+\n+            const auto threadCount        = std::clamp(jobs, 1, charsetSize);\n+            auto       threads            = std::vector<std::thread>{};\n+            auto       nextCandidateIndex = std::atomic<int>{index_start};\n+            for (auto i = 0; i < threadCount; ++i)\n+                threads.emplace_back(\n+                    [&nextCandidateIndex, charsetSize, clone = *this, initial]() mutable\n                     {\n-                        const auto pm4 = worker.charset[i];\n+                        for (auto i = nextCandidateIndex++; i < charsetSize; i = nextCandidateIndex++)\n+                        {\n+                            const auto pm4 = clone.charset[i];\n \n-                        auto init = initial;\n-                        init.update(pm4);\n+                            auto init = initial;\n+                            init.update(pm4);\n \n-                        worker.prefix.back() = pm4;\n+                            clone.prefix.back() = pm4;\n \n-                        worker.recoverLongPassword(init);\n+                            clone.searchLongRecursive(init);\n \n-                        progress.done += charsetSize;\n+                            clone.progress.done += charsetSize;\n \n-                        if (progress.state != Progress::State::Normal)\n-                            break;\n-                    }\n-                });\n-        for (auto& thread : threads)\n-            thread.join();\n+                            if (clone.progress.state != Progress::State::Normal)\n+                                break;\n+                        }\n+                    });\n+            for (auto& thread : threads)\n+                thread.join();\n \n-        worker.prefix.pop_back();\n+            prefix.pop_back();\n \n-        if (nextCandidateIndex < charsetSize)\n-        {\n-            restart = worker.prefix;\n-            restart.push_back(worker.charset[nextCandidateIndex]);\n-            restart.append(worker.length - 6 - restart.size(), worker.charset[0]);\n+            if (nextCandidateIndex < charsetSize)\n+            {\n+                restart = prefix;\n+                restart.push_back(charset[nextCandidateIndex]);\n+                restart.append(length - 6 - restart.size(), charset[0]);\n+            }\n         }\n-    }\n-    else if (worker.prefix.size() + 2 + 9 == worker.length) // bruteforce two characters in parallel\n-    {\n-        index_start *= charsetSize;\n-        if (worker.prefix.size() + 1 < start.size())\n+        else if (prefix.size() + 2 + 9 == length) // bruteforce two characters in parallel\n         {\n-            const auto maxIndex = std::min(charsetSize * charsetSize, index_start + charsetSize);\n-            while (index_start < maxIndex && worker.charset[index_start % charsetSize] <\n-                                                 static_cast<unsigned char>(start[worker.prefix.size() + 1]))\n-                ++index_start;\n-        }\n-\n-        worker.prefix.push_back(worker.charset[0]);\n-        worker.prefix.push_back(worker.charset[0]);\n+            index_start *= charsetSize;\n+            if (prefix.size() + 1 < start.size())\n+            {\n+                const auto maxIndex = std::min(charsetSize * charsetSize, index_start + charsetSize);\n+                while (index_start < maxIndex &&\n+                       charset[index_start % charsetSize] < static_cast<unsigned char>(start[prefix.size() + 1]))\n+                    ++index_start;\n+            }\n \n-        const auto reportProgress       = worker.prefix.size() == 2;\n-        const auto reportProgressCoarse = worker.prefix.size() == 3;\n+            prefix.push_back(charset[0]);\n+            prefix.push_back(charset[0]);\n \n-        if (reportProgress)\n-            progress.done += index_start;\n-        else if (reportProgressCoarse)\n-            progress.done += index_start / charsetSize;\n+            const auto reportProgress       = prefix.size() == 2;\n+            const auto reportProgressCoarse = prefix.size() == 3;\n \n-        const auto threadCount        = std::clamp(jobs, 1, charsetSize);\n-        auto       threads            = std::vector<std::thread>{};\n-        auto       nextCandidateIndex = std::atomic<int>{index_start};\n-        for (auto i = 0; i < threadCount; ++i)\n-            threads.emplace_back(\n-                [&nextCandidateIndex, charsetSize, &progress, worker, initial, reportProgress,\n-                 reportProgressCoarse]() mutable\n-                {\n-                    for (auto i = nextCandidateIndex++; i < charsetSize * charsetSize; i = nextCandidateIndex++)\n+            if (reportProgress)\n+                progress.done += index_start;\n+            else if (reportProgressCoarse)\n+                progress.done += index_start / charsetSize;\n+\n+            const auto threadCount        = std::clamp(jobs, 1, charsetSize * charsetSize);\n+            auto       threads            = std::vector<std::thread>{};\n+            auto       nextCandidateIndex = std::atomic<int>{index_start};\n+            for (auto i = 0; i < threadCount; ++i)\n+                threads.emplace_back(\n+                    [&nextCandidateIndex, charsetSize, clone = *this, initial, reportProgress,\n+                     reportProgressCoarse]() mutable\n                     {\n-                        const auto pm4 = worker.charset[i / charsetSize];\n-                        const auto pm3 = worker.charset[i % charsetSize];\n+                        for (auto i = nextCandidateIndex++; i < charsetSize * charsetSize; i = nextCandidateIndex++)\n+                        {\n+                            const auto pm4 = clone.charset[i / charsetSize];\n+                            const auto pm3 = clone.charset[i % charsetSize];\n \n-                        auto init = initial;\n-                        init.update(pm4);\n-                        init.update(pm3);\n+                            auto init = initial;\n+                            init.update(pm4);\n+                            init.update(pm3);\n \n-                        worker.prefix[worker.prefix.size() - 2] = pm4;\n-                        worker.prefix[worker.prefix.size() - 1] = pm3;\n+                            clone.prefix[clone.prefix.size() - 2] = pm4;\n+                            clone.prefix[clone.prefix.size() - 1] = pm3;\n \n-                        worker.recoverLongPassword(init);\n+                            clone.searchLongRecursive(init);\n \n-                        if (reportProgress || (reportProgressCoarse && i % charsetSize == 0))\n-                            progress.done++;\n+                            if (reportProgress || (reportProgressCoarse && i % charsetSize == 0))\n+                                clone.progress.done++;\n \n-                        if (progress.state != Progress::State::Normal)\n-                            break;\n-                    }\n-                });\n-        for (auto& thread : threads)\n-            thread.join();\n+                            if (clone.progress.state != Progress::State::Normal)\n+                                break;\n+                        }\n+                    });\n+            for (auto& thread : threads)\n+                thread.join();\n \n-        worker.prefix.pop_back();\n-        worker.prefix.pop_back();\n+            prefix.pop_back();\n+            prefix.pop_back();\n \n-        if (nextCandidateIndex < charsetSize * charsetSize)\n-        {\n-            restart = worker.prefix;\n-            restart.push_back(worker.charset[nextCandidateIndex / charsetSize]);\n-            restart.push_back(worker.charset[nextCandidateIndex % charsetSize]);\n-            restart.append(worker.length - 6 - restart.size(), worker.charset[0]);\n+            if (nextCandidateIndex < charsetSize * charsetSize)\n+            {\n+                restart = prefix;\n+                restart.push_back(charset[nextCandidateIndex / charsetSize]);\n+                restart.push_back(charset[nextCandidateIndex % charsetSize]);\n+                restart.append(length - 6 - restart.size(), charset[0]);\n+            }\n         }\n-    }\n-    else // try password prefixes recursively\n-    {\n-        worker.prefix.push_back(worker.charset[0]);\n+        else // try password prefixes recursively\n+        {\n+            prefix.push_back(charset[0]);\n \n-        const auto reportProgress = worker.prefix.size() == 2;\n+            const auto reportProgress = prefix.size() == 2;\n \n-        if (worker.prefix.size() == 1)\n-            progress.done += index_start * charsetSize;\n-        else if (reportProgress)\n-            progress.done += index_start;\n+            if (prefix.size() == 1)\n+                progress.done += index_start * charsetSize;\n+            else if (reportProgress)\n+                progress.done += index_start;\n \n-        for (auto i = index_start; i < charsetSize; i++)\n-        {\n-            const auto pi = worker.charset[i];\n+            for (auto i = index_start; i < charsetSize; i++)\n+            {\n+                const auto pi = charset[i];\n \n-            auto init = initial;\n-            init.update(pi);\n+                auto init = initial;\n+                init.update(pi);\n \n-            worker.prefix.back() = pi;\n+                prefix.back() = pi;\n \n-            recoverPasswordRecursive(worker, jobs, init, i == index_start ? start : \"\", restart, progress);\n+                searchLongParallelRecursive(init, i == index_start ? start : \"\", restart, jobs);\n \n-            // Because the recursive call may explore only a fraction of its\n-            // search space, check that it was run in full before counting progress.\n+                // Because the recursive call may explore only a fraction of its\n+                // search space, check that it was run in full before counting progress.\n+                if (!restart.empty())\n+                    break;\n \n-            if (!restart.empty())\n-                break;\n+                if (reportProgress)\n+                    progress.done++;\n+            }\n \n-            if (reportProgress)\n-                progress.done++;\n+            prefix.pop_back();\n         }\n-\n-        worker.prefix.pop_back();\n     }\n-}\n \n-} // namespace\n+    /// Length of the password to recover\n+    std::size_t length;\n+\n+    /// The first characters of the password candidate, up to length-6 characters long\n+    std::string prefix;\n+\n+    /// Set of characters to generate password candidates\n+    const std::vector<std::uint8_t>& charset;\n+\n+    std::vector<std::string>& solutions; // shared output vector of valid passwords\n+    std::mutex&               solutionsMutex;\n+    const bool                exhaustive;\n+    Progress&                 progress;\n+};\n \n auto recoverPassword(const Keys& keys, const std::vector<std::uint8_t>& charset, std::size_t minLength,\n                      std::size_t maxLength, std::string& start, int jobs, bool exhaustive, Progress& progress)\n     -> std::vector<std::string>\n {\n     auto solutions      = std::vector<std::string>{};\n     auto solutionsMutex = std::mutex{};\n-    auto worker         = Recovery{keys, charset, solutions, solutionsMutex, exhaustive, progress};\n+    auto worker         = BruteforceRecovery{keys, charset, solutions, solutionsMutex, exhaustive, progress};\n \n     auto       restart     = std::string{};\n     const auto startLength = std::max(minLength, start.empty() ? 0 : start.size() + 6);\n@@ -407,35 +495,16 @@ auto recoverPassword(const Keys& keys, const std::vector<std::uint8_t>& charset,\n         {\n             progress.log([](std::ostream& os) { os << \"length 0-6...\" << std::endl; });\n \n-            auto initial = Keys{};\n-\n             // look for a password of length between 0 and 6\n-            for (auto l = 6; l >= 0; l--)\n-            {\n-                worker.length = l;\n-                worker.recoverShortPassword(initial);\n-\n-                initial.updateBackwardPlaintext(charset.front());\n-            }\n+            for (auto l = 0; l <= 6; l++)\n+                worker.search(Keys{}, l);\n \n             length = 6; // searching up to length 6 is done\n         }\n         else\n         {\n             progress.log([length](std::ostream& os) { os << \"length \" << length << \"...\" << std::endl; });\n-\n-            worker.length = length;\n-            if (length < 10)\n-            {\n-                worker.recoverLongPassword(Keys{});\n-            }\n-            else\n-            {\n-                progress.done  = 0;\n-                progress.total = charset.size() * charset.size();\n-\n-                recoverPasswordRecursive(worker, jobs, Keys{}, length == startLength ? start : \"\", restart, progress);\n-            }\n+            worker.search(Keys{}, length, length == startLength ? start : \"\", restart, jobs);\n         }\n     }\n "
    ],
    "files_changed": [
      {
        "filename": "include/password.hpp",
        "status": "modified",
        "additions": 0,
        "deletions": 65,
        "changes": 65,
        "patch": "@@ -4,73 +4,8 @@\n #include \"Keys.hpp\"\n #include \"Progress.hpp\"\n \n-#include <bitset>\n-#include <mutex>\n-\n /// \\file password.hpp\n \n-/// Class to recover a password from internal keys\n-class Recovery\n-{\n-public:\n-    /// Constructor\n-    Recovery(const Keys& keys, const std::vector<std::uint8_t>& charset, std::vector<std::string>& solutions,\n-             std::mutex& solutionsMutex, bool exhaustive, Progress& progress);\n-\n-    /// \\brief Look for a password of length 6 or less\n-    ///\n-    /// Try to derive 6 characters such that updating the given cipher state\n-    /// with them gives the target cipher state (the password representation).\n-    /// On success, the current prefix followed by those 6 characters is added\n-    /// to the shared output vector.\n-    ///\n-    /// If the target length is less than 6, the first characters are ignored so that\n-    /// the saved solution has the target length. This is useful to recover passwords\n-    /// shorter than 6 characters.\n-    ///\n-    /// \\pre prefix.size() + 6 == length && initial == Keys{prefix} || length < 6\n-    void recoverShortPassword(const Keys& initial);\n-\n-    /// \\brief Look for password of length 7 or more\n-    ///\n-    /// Recursively iterate on possible prefixes of length-6 characters.\n-    /// For each prefix, try to recover the last 6 characters like recoverShortPassword.\n-    ///\n-    /// \\pre prefix.size() + 6 < length && initial == Keys{prefix}\n-    void recoverLongPassword(const Keys& initial);\n-\n-    /// Length of the password to recover\n-    std::size_t length;\n-\n-    /// The first characters of the password candidate, up to length-6 characters long\n-    std::string prefix;\n-\n-    /// Set of characters to generate password candidates\n-    const std::vector<std::uint8_t>& charset;\n-\n-private:\n-    // iterate recursively on possible Y values\n-    void recursion(int i);\n-\n-    // set of possible Z0[16,31) values considering given character set\n-    std::bitset<1 << 16> z0_16_32;\n-\n-    // set of possible Z{-1}[24,32) values considering given character set\n-    std::bitset<1 << 8> zm1_24_32;\n-\n-    // cipher state (X,Y,Z)_i for index i in [0, 6] where the last state (X,Y,Z)_6 is\n-    // the representation of the password to recover\n-    std::array<std::uint32_t, 7> x, y, z;\n-    std::uint32_t                candidateX0; // backup of candidate X value for convenience\n-\n-    std::array<std::uint8_t, 6> p; // password last 6 bytes\n-\n-    std::vector<std::string>& solutions; // shared output vector of valid passwords\n-    std::mutex&               solutionsMutex;\n-    const bool                exhaustive;\n-    Progress&                 progress;\n-};\n-\n /// \\brief Try to recover the password associated with the given keys\n /// \\param keys Internal keys for which a password is wanted\n /// \\param charset The set of characters with which to constitute password candidates"
      },
      {
        "filename": "src/password.cpp",
        "status": "modified",
        "additions": 382,
        "deletions": 313,
        "changes": 695,
        "patch": "@@ -2,399 +2,487 @@\n \n #include \"Crc32Tab.hpp\"\n #include \"MultTab.hpp\"\n+#include \"log.hpp\"\n \n #include <algorithm>\n #include <atomic>\n+#include <bitset>\n #include <iomanip>\n+#include <mutex>\n #include <thread>\n \n-Recovery::Recovery(const Keys& keys, const std::vector<std::uint8_t>& charset, std::vector<std::string>& solutions,\n-                   std::mutex& solutionsMutex, bool exhaustive, Progress& progress)\n-: charset{charset}\n-, solutions{solutions}\n-, solutionsMutex{solutionsMutex}\n-, exhaustive{exhaustive}\n-, progress{progress}\n+template <typename Derived /* must implement onSolutionFound() method */>\n+class SixCharactersRecovery\n {\n-    // initialize target X, Y and Z values\n-    x[6] = keys.getX();\n-    y[6] = keys.getY();\n-    z[6] = keys.getZ();\n-\n-    // derive Y5\n-    y[5] = (y[6] - 1) * MultTab::multInv - lsb(x[6]);\n-\n-    // derive more Z bytes\n-    for (auto i = 6; 1 < i; i--)\n-        z[i - 1] = Crc32Tab::crc32inv(z[i], msb(y[i]));\n-\n-    // precompute possible Z0[16,32) and Z{-1}[24,32)\n-    for (const auto p5 : charset)\n+public:\n+    SixCharactersRecovery(const Keys& target, const std::vector<std::uint8_t>& charset4,\n+                          const std::vector<std::uint8_t>& charset5)\n     {\n-        x[5] = Crc32Tab::crc32inv(x[6], p5);\n-        y[4] = (y[5] - 1) * MultTab::multInv - lsb(x[5]);\n-        z[3] = Crc32Tab::crc32inv(z[4], msb(y[4]));\n+        // initialize target X, Y and Z values\n+        x[6] = target.getX();\n+        y[6] = target.getY();\n+        z[6] = target.getZ();\n \n-        for (const auto p4 : charset)\n-        {\n-            x[4] = Crc32Tab::crc32inv(x[5], p4);\n-            y[3] = (y[4] - 1) * MultTab::multInv - lsb(x[4]);\n-            z[2] = Crc32Tab::crc32inv(z[3], msb(y[3]));\n-            z[1] = Crc32Tab::crc32inv(z[2], 0);\n-            z[0] = Crc32Tab::crc32inv(z[1], 0);\n-\n-            z0_16_32.set(z[0] >> 16);\n-            zm1_24_32.set(Crc32Tab::crc32inv(z[0], 0) >> 24);\n-        }\n-    }\n-}\n+        // derive Y5\n+        y[5] = (y[6] - 1) * MultTab::multInv - lsb(x[6]);\n \n-void Recovery::recoverShortPassword(const Keys& initial)\n-{\n-    // check compatible Z0[16,32)\n-    if (!z0_16_32[initial.getZ() >> 16])\n-        return;\n+        // derive more Z bytes\n+        for (auto i = 6; 1 < i; i--)\n+            z[i - 1] = Crc32Tab::crc32inv(z[i], msb(y[i]));\n \n-    // initialize starting X, Y and Z values\n-    x[0] = candidateX0 = initial.getX();\n-    y[0]               = initial.getY();\n-    z[0]               = initial.getZ();\n+        // precompute possible Z0[16,32) and Z{-1}[24,32)\n+        for (const auto p5 : charset5)\n+        {\n+            x[5] = Crc32Tab::crc32inv(x[6], p5);\n+            y[4] = (y[5] - 1) * MultTab::multInv - lsb(x[5]);\n+            z[3] = Crc32Tab::crc32inv(z[4], msb(y[4]));\n \n-    // complete Z values and derive Y[24,32) values\n-    for (auto i = 1; i <= 4; i++)\n-    {\n-        y[i] = Crc32Tab::getYi_24_32(z[i], z[i - 1]);\n-        z[i] = Crc32Tab::crc32(z[i - 1], msb(y[i]));\n+            for (const auto p4 : charset4)\n+            {\n+                x[4] = Crc32Tab::crc32inv(x[5], p4);\n+                y[3] = (y[4] - 1) * MultTab::multInv - lsb(x[4]);\n+                z[2] = Crc32Tab::crc32inv(z[3], msb(y[3]));\n+                z[1] = Crc32Tab::crc32inv(z[2], 0);\n+                z[0] = Crc32Tab::crc32inv(z[1], 0);\n+\n+                z0_16_32.set(z[0] >> 16);\n+                zm1_24_32.set(Crc32Tab::crc32inv(z[0], 0) >> 24);\n+            }\n+        }\n     }\n \n-    // recursively complete Y values and derive password\n-    recursion(5);\n-}\n-\n-void Recovery::recoverLongPassword(const Keys& initial)\n-{\n-    if (prefix.size() + 7 == length) // there is only one more character to bruteforce\n+    void search(const Keys& initial)\n     {\n-        // check compatible Z{-1}[24, 32)\n-        if (!zm1_24_32[initial.getZ() >> 24])\n+        // check compatible Z0[16,32)\n+        if (!z0_16_32[initial.getZ() >> 16])\n             return;\n \n-        prefix.push_back(charset[0]);\n+        // initialize starting X, Y and Z values\n+        x[0] = candidateX0 = initial.getX();\n+        y[0]               = initial.getY();\n+        z[0]               = initial.getZ();\n \n-        // precompute as much as we can about the next cipher state without knowing the password byte\n-        const auto x0_partial = Crc32Tab::crc32(initial.getX(), 0);\n-        const auto y0_partial = initial.getY() * MultTab::mult + 1;\n-        const auto z0_partial = Crc32Tab::crc32(initial.getZ(), 0);\n-\n-        for (const auto pi : charset)\n+        // complete Z values and derive Y[24,32) values\n+        for (auto i = 1; i <= 4; i++)\n         {\n-            // finish to update the cipher state\n-            const auto x0 = x0_partial ^ Crc32Tab::crc32(0, pi);\n-            const auto y0 = y0_partial + MultTab::getMult(lsb(x0));\n-            const auto z0 = z0_partial ^ Crc32Tab::crc32(0, msb(y0));\n-\n-            // recoverShortPassword is inlined below for performance\n-\n-            // check compatible Z0[16,32)\n-            if (!z0_16_32[z0 >> 16])\n-                continue;\n-\n-            prefix.back() = pi;\n-\n-            // initialize starting X, Y and Z values\n-            x[0] = candidateX0 = x0;\n-            y[0]               = y0;\n-            z[0]               = z0;\n-\n-            // complete Z values and derive Y[24,32) values\n-            y[1] = Crc32Tab::getYi_24_32(z[1], z[1 - 1]);\n-            z[1] = Crc32Tab::crc32(z[1 - 1], msb(y[1]));\n-            y[2] = Crc32Tab::getYi_24_32(z[2], z[2 - 1]);\n-            z[2] = Crc32Tab::crc32(z[2 - 1], msb(y[2]));\n-            y[3] = Crc32Tab::getYi_24_32(z[3], z[3 - 1]);\n-            z[3] = Crc32Tab::crc32(z[3 - 1], msb(y[3]));\n-            y[4] = Crc32Tab::getYi_24_32(z[4], z[4 - 1]);\n-            // z[4] = Crc32Tab::crc32(z[4 - 1], msb(y[4])); // this one is already known\n-\n-            // recursively complete Y values and derive password\n-            recursion(5);\n+            y[i] = Crc32Tab::getYi_24_32(z[i], z[i - 1]);\n+            z[i] = Crc32Tab::crc32(z[i - 1], msb(y[i]));\n         }\n \n-        prefix.pop_back();\n+        // recursively complete Y values and derive password\n+        searchRecursive(5);\n     }\n-    else // bruteforce the next character and continue recursively\n-    {\n-        prefix.push_back(charset[0]);\n \n-        for (const auto pi : charset)\n+protected:\n+    void searchRecursive(int i)\n+    {\n+        if (i != 1) // the Y-list is not complete so generate Y{i-1} values\n         {\n-            Keys init = initial;\n-            init.update(pi);\n+            const auto fy  = (y[i] - 1) * MultTab::multInv;\n+            const auto ffy = (fy - 1) * MultTab::multInv;\n+\n+            // get possible LSB(Xi)\n+            for (const auto xi_0_8 : MultTab::getMsbProdFiber2(msb(ffy - (y[i - 2] & mask<24, 32>))))\n+            {\n+                // compute corresponding Y{i-1}\n+                const auto yim1 = fy - xi_0_8;\n+\n+                // filter values with Y{i-2}[24,32)\n+                if (ffy - MultTab::getMultinv(xi_0_8) - (y[i - 2] & mask<24, 32>) <= maxdiff<24> &&\n+                    msb(yim1) == msb(y[i - 1]))\n+                {\n+                    // add Y{i-1} to the Y-list\n+                    y[i - 1] = yim1;\n \n-            prefix.back() = pi;\n+                    // set Xi value\n+                    x[i] = xi_0_8;\n \n-            recoverLongPassword(init);\n+                    searchRecursive(i - 1);\n+                }\n+            }\n         }\n+        else // the Y-list is complete\n+        {\n+            // only the X1 LSB was not set yet, so do it here\n+            x[1] = (y[1] - 1) * MultTab::multInv - y[0];\n+            if (x[1] > 0xff)\n+                return;\n+\n+            // complete X values and derive password\n+            for (auto j = 5; 0 <= j; j--)\n+            {\n+                const auto xi_xor_pi = Crc32Tab::crc32inv(x[j + 1], 0);\n+                p[j]                 = lsb(xi_xor_pi ^ x[j]);\n+                x[j]                 = xi_xor_pi ^ p[j];\n+            }\n \n-        prefix.pop_back();\n+            if (x[0] == candidateX0) // the password is successfully recovered\n+                (static_cast<Derived*>(this))->onSolutionFound();\n+        }\n     }\n-}\n \n-void Recovery::recursion(int i)\n+    // set of possible Z0[16,32) values considering given character set\n+    std::bitset<1 << 16> z0_16_32;\n+\n+    // set of possible Z{-1}[24,32) values considering given character set\n+    std::bitset<1 << 8> zm1_24_32;\n+\n+    // cipher state (X,Y,Z)_i for index i in [0, 6] where the last state (X,Y,Z)_6 is\n+    // the representation of the password to recover\n+    std::array<std::uint32_t, 7> x{}, y{}, z{};\n+    std::uint32_t                candidateX0{}; // backup of candidate X value for convenience\n+\n+    std::array<std::uint8_t, 6> p{}; // password last 6 bytes\n+};\n+\n+class BruteforceRecovery : public SixCharactersRecovery<BruteforceRecovery>\n {\n-    if (i != 1) // the Y-list is not complete so generate Y{i-1} values\n+public:\n+    BruteforceRecovery(const Keys& keys, const std::vector<std::uint8_t>& charset, std::vector<std::string>& solutions,\n+                       std::mutex& solutionsMutex, bool exhaustive, Progress& progress)\n+    : SixCharactersRecovery{keys, charset, charset}\n+    , charset{charset}\n+    , solutions{solutions}\n+    , solutionsMutex{solutionsMutex}\n+    , exhaustive{exhaustive}\n+    , progress{progress}\n     {\n-        const auto fy  = (y[i] - 1) * MultTab::multInv;\n-        const auto ffy = (fy - 1) * MultTab::multInv;\n-\n-        // get possible LSB(Xi)\n-        for (const auto xi_0_8 : MultTab::getMsbProdFiber2(msb(ffy - (y[i - 2] & mask<24, 32>))))\n-        {\n-            // compute corresponding Y{i-1}\n-            const auto yim1 = fy - xi_0_8;\n+    }\n \n-            // filter values with Y{i-2}[24,32)\n-            if (ffy - MultTab::getMultinv(xi_0_8) - (y[i - 2] & mask<24, 32>) <= maxdiff<24> &&\n-                msb(yim1) == msb(y[i - 1]))\n-            {\n-                // add Y{i-1} to the Y-list\n-                y[i - 1] = yim1;\n+    void search(const Keys& initial, std::size_t length)\n+    {\n+        auto restart = std::string{};\n+        search(initial, length, \"\", restart, 1);\n+    }\n \n-                // set Xi value\n-                x[i] = xi_0_8;\n+    void search(const Keys& initial, std::size_t length, const std::string& start, std::string& restart, int jobs)\n+    {\n+        prefix.clear();\n+        this->length = length;\n \n-                recursion(i - 1);\n-            }\n+        if (length <= 6)\n+            searchShort(initial);\n+        else if (length <= 9)\n+            searchLongRecursive(initial);\n+        else\n+        {\n+            progress.done  = 0;\n+            progress.total = charset.size() * charset.size();\n+            searchLongParallelRecursive(initial, start, restart, jobs);\n         }\n     }\n-    else // the Y-list is complete\n+\n+    void onSolutionFound() const\n     {\n-        // only the X1 LSB was not set yet, so do it here\n-        x[1] = (y[1] - 1) * MultTab::multInv - y[0];\n-        if (x[1] > 0xff)\n-            return;\n+        auto password = prefix;\n+        password.append(p.begin(), p.end());\n+        password.erase(password.begin(), password.end() - length);\n \n-        // complete X values and derive password\n-        for (auto j = 5; 0 <= j; j--)\n+        const auto isInCharset =\n+            std::all_of(password.begin(), password.end(),\n+                        [this](char c)\n+                        { return std::binary_search(charset.begin(), charset.end(), static_cast<std::uint8_t>(c)); });\n+\n+        if (!isInCharset)\n         {\n-            const auto xi_xor_pi = Crc32Tab::crc32inv(x[j + 1], 0);\n-            p[j]                 = lsb(xi_xor_pi ^ x[j]);\n-            x[j]                 = xi_xor_pi ^ p[j];\n+            progress.log(\n+                [&password](std::ostream& os)\n+                {\n+                    const auto flagsBefore = os.setf(std::ios::hex, std::ios::basefield);\n+                    const auto fillBefore  = os.fill('0');\n+\n+                    os << \"Password: \" << password << \" (as bytes:\";\n+                    for (const auto c : password)\n+                        os << ' ' << std::setw(2) << static_cast<int>(c);\n+                    os << ')' << std::endl;\n+\n+                    os.fill(fillBefore);\n+                    os.flags(flagsBefore);\n+\n+                    os << \"Some characters are not in the expected charset. Continuing.\" << std::endl;\n+                });\n+\n+            return;\n         }\n \n-        if (x[0] == candidateX0) // the password is successfully recovered\n         {\n-            auto password = prefix;\n-            password.append(p.begin(), p.end());\n-            password.erase(password.begin(), password.end() - length);\n-\n-            const auto isInCharset =\n-                std::all_of(password.begin(), password.end(),\n-                            [this](char c) {\n-                                return std::binary_search(charset.begin(), charset.end(), static_cast<std::uint8_t>(c));\n-                            });\n+            const auto lock = std::scoped_lock{solutionsMutex};\n+            solutions.push_back(password);\n+        }\n \n-            if (!isInCharset)\n-            {\n-                progress.log(\n-                    [&password](std::ostream& os)\n-                    {\n-                        const auto flagsBefore = os.setf(std::ios::hex, std::ios::basefield);\n-                        const auto fillBefore  = os.fill('0');\n+        progress.log([&password](std::ostream& os) { os << \"Password: \" << password << std::endl; });\n \n-                        os << \"Password: \" << password << \" (as bytes:\";\n-                        for (const auto c : password)\n-                            os << ' ' << std::setw(2) << static_cast<int>(c);\n-                        os << ')' << std::endl;\n+        if (!exhaustive)\n+            progress.state = Progress::State::EarlyExit;\n+    }\n \n-                        os.fill(fillBefore);\n-                        os.flags(flagsBefore);\n+private:\n+    /// \\brief Look for a password of length 6 or less\n+    ///\n+    /// \\pre prefix.empty() && length <= 6\n+    void searchShort(Keys initial)\n+    {\n+        // update initial state backward so that there are exactly 6 updates between it and the target state\n+        for (auto i = length; i < 6; i++)\n+            initial.updateBackwardPlaintext(charset.front());\n \n-                        os << \"Some characters are not in the expected charset. Continuing.\" << std::endl;\n-                    });\n+        SixCharactersRecovery::search(initial);\n+    }\n \n+    /// \\brief Look for password of length 7 or more\n+    ///\n+    /// Recursively iterate on possible prefixes of length-6 characters.\n+    /// For each prefix, try to recover the last 6 characters with SixCharactersRecovery::search.\n+    ///\n+    /// \\pre prefix.size() + 6 < length\n+    void searchLongRecursive(const Keys& initial)\n+    {\n+        if (prefix.size() + 7 == length) // there is only one more character to bruteforce\n+        {\n+            // check compatible Z{-1}[24, 32)\n+            if (!zm1_24_32[initial.getZ() >> 24])\n                 return;\n-            }\n \n+            prefix.push_back(charset[0]);\n+\n+            // precompute as much as we can about the next cipher state without knowing the password byte\n+            const auto x0_partial = Crc32Tab::crc32(initial.getX(), 0);\n+            const auto y0_partial = initial.getY() * MultTab::mult + 1;\n+            const auto z0_partial = Crc32Tab::crc32(initial.getZ(), 0);\n+\n+            for (const auto pi : charset)\n             {\n-                const auto lock = std::scoped_lock{solutionsMutex};\n-                solutions.push_back(password);\n+                // finish to update the cipher state\n+                const auto x0 = x0_partial ^ Crc32Tab::crc32(0, pi);\n+                const auto y0 = y0_partial + MultTab::getMult(lsb(x0));\n+                const auto z0 = z0_partial ^ Crc32Tab::crc32(0, msb(y0));\n+\n+                // SixCharactersRecovery::search is inlined below for performance\n+\n+                // check compatible Z0[16,32)\n+                if (!z0_16_32[z0 >> 16])\n+                    continue;\n+\n+                prefix.back() = pi;\n+\n+                // initialize starting X, Y and Z values\n+                x[0] = candidateX0 = x0;\n+                y[0]               = y0;\n+                z[0]               = z0;\n+\n+                // complete Z values and derive Y[24,32) values\n+                y[1] = Crc32Tab::getYi_24_32(z[1], z[1 - 1]);\n+                z[1] = Crc32Tab::crc32(z[1 - 1], msb(y[1]));\n+                y[2] = Crc32Tab::getYi_24_32(z[2], z[2 - 1]);\n+                z[2] = Crc32Tab::crc32(z[2 - 1], msb(y[2]));\n+                y[3] = Crc32Tab::getYi_24_32(z[3], z[3 - 1]);\n+                z[3] = Crc32Tab::crc32(z[3 - 1], msb(y[3]));\n+                y[4] = Crc32Tab::getYi_24_32(z[4], z[4 - 1]);\n+                // z[4] = Crc32Tab::crc32(z[4 - 1], msb(y[4])); // this one is already known\n+\n+                // recursively complete Y values and derive password\n+                searchRecursive(5);\n             }\n \n-            progress.log([&password](std::ostream& os) { os << \"Password: \" << password << std::endl; });\n-\n-            if (!exhaustive)\n-                progress.state = Progress::State::EarlyExit;\n+            prefix.pop_back();\n         }\n-    }\n-}\n+        else // bruteforce the next character and continue recursively\n+        {\n+            prefix.push_back(charset[0]);\n \n-namespace\n-{\n+            for (const auto pi : charset)\n+            {\n+                Keys init = initial;\n+                init.update(pi);\n \n-void recoverPasswordRecursive(Recovery& worker, int jobs, const Keys& initial, const std::string& start,\n-                              std::string& restart, Progress& progress)\n-{\n-    const auto charsetSize = static_cast<int>(worker.charset.size());\n+                prefix.back() = pi;\n \n-    auto index_start = 0;\n-    if (worker.prefix.size() < start.size())\n-        while (index_start < charsetSize &&\n-               worker.charset[index_start] < static_cast<unsigned char>(start[worker.prefix.size()]))\n-            ++index_start;\n+                searchLongRecursive(init);\n+            }\n+\n+            prefix.pop_back();\n+        }\n+    }\n \n-    if (worker.prefix.size() + 1 + 9 == worker.length) // bruteforce one character in parallel\n+    /// \\brief Look for password of length 10 or more\n+    ///\n+    /// Recursively iterate on possible prefixes of length-6 characters.\n+    /// Start parallel workers looking for a password of length 9.\n+    ///\n+    /// \\pre prefix.size() + 9 < length\n+    void searchLongParallelRecursive(const Keys& initial, const std::string& start, std::string& restart, int jobs)\n     {\n-        worker.prefix.push_back(worker.charset[0]);\n+        const auto charsetSize = static_cast<int>(charset.size());\n \n-        progress.done += index_start * charsetSize;\n+        auto index_start = 0;\n+        if (prefix.size() < start.size())\n+            while (index_start < charsetSize && charset[index_start] < static_cast<unsigned char>(start[prefix.size()]))\n+                ++index_start;\n \n-        const auto threadCount        = std::clamp(jobs, 1, charsetSize);\n-        auto       threads            = std::vector<std::thread>{};\n-        auto       nextCandidateIndex = std::atomic<int>{index_start};\n-        for (auto i = 0; i < threadCount; ++i)\n-            threads.emplace_back(\n-                [&nextCandidateIndex, charsetSize, &progress, worker, initial]() mutable\n-                {\n-                    for (auto i = nextCandidateIndex++; i < charsetSize; i = nextCandidateIndex++)\n+        if (prefix.size() + 1 + 9 == length) // bruteforce one character in parallel\n+        {\n+            prefix.push_back(charset[0]);\n+\n+            progress.done += index_start * charsetSize;\n+\n+            const auto threadCount        = std::clamp(jobs, 1, charsetSize);\n+            auto       threads            = std::vector<std::thread>{};\n+            auto       nextCandidateIndex = std::atomic<int>{index_start};\n+            for (auto i = 0; i < threadCount; ++i)\n+                threads.emplace_back(\n+                    [&nextCandidateIndex, charsetSize, clone = *this, initial]() mutable\n                     {\n-                        const auto pm4 = worker.charset[i];\n+                        for (auto i = nextCandidateIndex++; i < charsetSize; i = nextCandidateIndex++)\n+                        {\n+                            const auto pm4 = clone.charset[i];\n \n-                        auto init = initial;\n-                        init.update(pm4);\n+                            auto init = initial;\n+                            init.update(pm4);\n \n-                        worker.prefix.back() = pm4;\n+                            clone.prefix.back() = pm4;\n \n-                        worker.recoverLongPassword(init);\n+                            clone.searchLongRecursive(init);\n \n-                        progress.done += charsetSize;\n+                            clone.progress.done += charsetSize;\n \n-                        if (progress.state != Progress::State::Normal)\n-                            break;\n-                    }\n-                });\n-        for (auto& thread : threads)\n-            thread.join();\n+                            if (clone.progress.state != Progress::State::Normal)\n+                                break;\n+                        }\n+                    });\n+            for (auto& thread : threads)\n+                thread.join();\n \n-        worker.prefix.pop_back();\n+            prefix.pop_back();\n \n-        if (nextCandidateIndex < charsetSize)\n-        {\n-            restart = worker.prefix;\n-            restart.push_back(worker.charset[nextCandidateIndex]);\n-            restart.append(worker.length - 6 - restart.size(), worker.charset[0]);\n+            if (nextCandidateIndex < charsetSize)\n+            {\n+                restart = prefix;\n+                restart.push_back(charset[nextCandidateIndex]);\n+                restart.append(length - 6 - restart.size(), charset[0]);\n+            }\n         }\n-    }\n-    else if (worker.prefix.size() + 2 + 9 == worker.length) // bruteforce two characters in parallel\n-    {\n-        index_start *= charsetSize;\n-        if (worker.prefix.size() + 1 < start.size())\n+        else if (prefix.size() + 2 + 9 == length) // bruteforce two characters in parallel\n         {\n-            const auto maxIndex = std::min(charsetSize * charsetSize, index_start + charsetSize);\n-            while (index_start < maxIndex && worker.charset[index_start % charsetSize] <\n-                                                 static_cast<unsigned char>(start[worker.prefix.size() + 1]))\n-                ++index_start;\n-        }\n-\n-        worker.prefix.push_back(worker.charset[0]);\n-        worker.prefix.push_back(worker.charset[0]);\n+            index_start *= charsetSize;\n+            if (prefix.size() + 1 < start.size())\n+            {\n+                const auto maxIndex = std::min(charsetSize * charsetSize, index_start + charsetSize);\n+                while (index_start < maxIndex &&\n+                       charset[index_start % charsetSize] < static_cast<unsigned char>(start[prefix.size() + 1]))\n+                    ++index_start;\n+            }\n \n-        const auto reportProgress       = worker.prefix.size() == 2;\n-        const auto reportProgressCoarse = worker.prefix.size() == 3;\n+            prefix.push_back(charset[0]);\n+            prefix.push_back(charset[0]);\n \n-        if (reportProgress)\n-            progress.done += index_start;\n-        else if (reportProgressCoarse)\n-            progress.done += index_start / charsetSize;\n+            const auto reportProgress       = prefix.size() == 2;\n+            const auto reportProgressCoarse = prefix.size() == 3;\n \n-        const auto threadCount        = std::clamp(jobs, 1, charsetSize);\n-        auto       threads            = std::vector<std::thread>{};\n-        auto       nextCandidateIndex = std::atomic<int>{index_start};\n-        for (auto i = 0; i < threadCount; ++i)\n-            threads.emplace_back(\n-                [&nextCandidateIndex, charsetSize, &progress, worker, initial, reportProgress,\n-                 reportProgressCoarse]() mutable\n-                {\n-                    for (auto i = nextCandidateIndex++; i < charsetSize * charsetSize; i = nextCandidateIndex++)\n+            if (reportProgress)\n+                progress.done += index_start;\n+            else if (reportProgressCoarse)\n+                progress.done += index_start / charsetSize;\n+\n+            const auto threadCount        = std::clamp(jobs, 1, charsetSize * charsetSize);\n+            auto       threads            = std::vector<std::thread>{};\n+            auto       nextCandidateIndex = std::atomic<int>{index_start};\n+            for (auto i = 0; i < threadCount; ++i)\n+                threads.emplace_back(\n+                    [&nextCandidateIndex, charsetSize, clone = *this, initial, reportProgress,\n+                     reportProgressCoarse]() mutable\n                     {\n-                        const auto pm4 = worker.charset[i / charsetSize];\n-                        const auto pm3 = worker.charset[i % charsetSize];\n+                        for (auto i = nextCandidateIndex++; i < charsetSize * charsetSize; i = nextCandidateIndex++)\n+                        {\n+                            const auto pm4 = clone.charset[i / charsetSize];\n+                            const auto pm3 = clone.charset[i % charsetSize];\n \n-                        auto init = initial;\n-                        init.update(pm4);\n-                        init.update(pm3);\n+                            auto init = initial;\n+                            init.update(pm4);\n+                            init.update(pm3);\n \n-                        worker.prefix[worker.prefix.size() - 2] = pm4;\n-                        worker.prefix[worker.prefix.size() - 1] = pm3;\n+                            clone.prefix[clone.prefix.size() - 2] = pm4;\n+                            clone.prefix[clone.prefix.size() - 1] = pm3;\n \n-                        worker.recoverLongPassword(init);\n+                            clone.searchLongRecursive(init);\n \n-                        if (reportProgress || (reportProgressCoarse && i % charsetSize == 0))\n-                            progress.done++;\n+                            if (reportProgress || (reportProgressCoarse && i % charsetSize == 0))\n+                                clone.progress.done++;\n \n-                        if (progress.state != Progress::State::Normal)\n-                            break;\n-                    }\n-                });\n-        for (auto& thread : threads)\n-            thread.join();\n+                            if (clone.progress.state != Progress::State::Normal)\n+                                break;\n+                        }\n+                    });\n+            for (auto& thread : threads)\n+                thread.join();\n \n-        worker.prefix.pop_back();\n-        worker.prefix.pop_back();\n+            prefix.pop_back();\n+            prefix.pop_back();\n \n-        if (nextCandidateIndex < charsetSize * charsetSize)\n-        {\n-            restart = worker.prefix;\n-            restart.push_back(worker.charset[nextCandidateIndex / charsetSize]);\n-            restart.push_back(worker.charset[nextCandidateIndex % charsetSize]);\n-            restart.append(worker.length - 6 - restart.size(), worker.charset[0]);\n+            if (nextCandidateIndex < charsetSize * charsetSize)\n+            {\n+                restart = prefix;\n+                restart.push_back(charset[nextCandidateIndex / charsetSize]);\n+                restart.push_back(charset[nextCandidateIndex % charsetSize]);\n+                restart.append(length - 6 - restart.size(), charset[0]);\n+            }\n         }\n-    }\n-    else // try password prefixes recursively\n-    {\n-        worker.prefix.push_back(worker.charset[0]);\n+        else // try password prefixes recursively\n+        {\n+            prefix.push_back(charset[0]);\n \n-        const auto reportProgress = worker.prefix.size() == 2;\n+            const auto reportProgress = prefix.size() == 2;\n \n-        if (worker.prefix.size() == 1)\n-            progress.done += index_start * charsetSize;\n-        else if (reportProgress)\n-            progress.done += index_start;\n+            if (prefix.size() == 1)\n+                progress.done += index_start * charsetSize;\n+            else if (reportProgress)\n+                progress.done += index_start;\n \n-        for (auto i = index_start; i < charsetSize; i++)\n-        {\n-            const auto pi = worker.charset[i];\n+            for (auto i = index_start; i < charsetSize; i++)\n+            {\n+                const auto pi = charset[i];\n \n-            auto init = initial;\n-            init.update(pi);\n+                auto init = initial;\n+                init.update(pi);\n \n-            worker.prefix.back() = pi;\n+                prefix.back() = pi;\n \n-            recoverPasswordRecursive(worker, jobs, init, i == index_start ? start : \"\", restart, progress);\n+                searchLongParallelRecursive(init, i == index_start ? start : \"\", restart, jobs);\n \n-            // Because the recursive call may explore only a fraction of its\n-            // search space, check that it was run in full before counting progress.\n+                // Because the recursive call may explore only a fraction of its\n+                // search space, check that it was run in full before counting progress.\n+                if (!restart.empty())\n+                    break;\n \n-            if (!restart.empty())\n-                break;\n+                if (reportProgress)\n+                    progress.done++;\n+            }\n \n-            if (reportProgress)\n-                progress.done++;\n+            prefix.pop_back();\n         }\n-\n-        worker.prefix.pop_back();\n     }\n-}\n \n-} // namespace\n+    /// Length of the password to recover\n+    std::size_t length;\n+\n+    /// The first characters of the password candidate, up to length-6 characters long\n+    std::string prefix;\n+\n+    /// Set of characters to generate password candidates\n+    const std::vector<std::uint8_t>& charset;\n+\n+    std::vector<std::string>& solutions; // shared output vector of valid passwords\n+    std::mutex&               solutionsMutex;\n+    const bool                exhaustive;\n+    Progress&                 progress;\n+};\n \n auto recoverPassword(const Keys& keys, const std::vector<std::uint8_t>& charset, std::size_t minLength,\n                      std::size_t maxLength, std::string& start, int jobs, bool exhaustive, Progress& progress)\n     -> std::vector<std::string>\n {\n     auto solutions      = std::vector<std::string>{};\n     auto solutionsMutex = std::mutex{};\n-    auto worker         = Recovery{keys, charset, solutions, solutionsMutex, exhaustive, progress};\n+    auto worker         = BruteforceRecovery{keys, charset, solutions, solutionsMutex, exhaustive, progress};\n \n     auto       restart     = std::string{};\n     const auto startLength = std::max(minLength, start.empty() ? 0 : start.size() + 6);\n@@ -407,35 +495,16 @@ auto recoverPassword(const Keys& keys, const std::vector<std::uint8_t>& charset,\n         {\n             progress.log([](std::ostream& os) { os << \"length 0-6...\" << std::endl; });\n \n-            auto initial = Keys{};\n-\n             // look for a password of length between 0 and 6\n-            for (auto l = 6; l >= 0; l--)\n-            {\n-                worker.length = l;\n-                worker.recoverShortPassword(initial);\n-\n-                initial.updateBackwardPlaintext(charset.front());\n-            }\n+            for (auto l = 0; l <= 6; l++)\n+                worker.search(Keys{}, l);\n \n             length = 6; // searching up to length 6 is done\n         }\n         else\n         {\n             progress.log([length](std::ostream& os) { os << \"length \" << length << \"...\" << std::endl; });\n-\n-            worker.length = length;\n-            if (length < 10)\n-            {\n-                worker.recoverLongPassword(Keys{});\n-            }\n-            else\n-            {\n-                progress.done  = 0;\n-                progress.total = charset.size() * charset.size();\n-\n-                recoverPasswordRecursive(worker, jobs, Keys{}, length == startLength ? start : \"\", restart, progress);\n-            }\n+            worker.search(Keys{}, length, length == startLength ? start : \"\", restart, jobs);\n         }\n     }\n "
      }
    ],
    "lines_added": 382,
    "lines_removed": 378
  },
  "issues": [],
  "pull_requests": [],
  "build_info": {
    "old_build_script": [
      "apt-get update",
      "cmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBKCRACK_BUILD_TESTING=ON",
      "cmake --build /test_workspace/workspace/old/build -- -j 1"
    ],
    "new_build_script": [
      "apt-get update",
      "cmake -S /test_workspace/workspace/new -B /test_workspace/workspace/new/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBKCRACK_BUILD_TESTING=ON",
      "cmake --build /test_workspace/workspace/new/build -- -j 1"
    ],
    "old_test_script": [
      "cd /test_workspace/workspace/old/build",
      "ctest --output-on-failure"
    ],
    "new_test_script": [
      "cd /test_workspace/workspace/new/build",
      "ctest --output-on-failure"
    ],
    "build_system": "cmake"
  },
  "performance_analysis": {
    "is_significant": false,
    "p_value": 0.9999999999999984,
    "is_pair_significant": false,
    "pair_p_value": 1.0,
    "is_binom_significant": false,
    "binom_p_value": 1.0,
    "is_wilcoxon_significant": false,
    "wilcoxon_p_value": 0.9999991344368026,
    "is_mannwhitney_significant": false,
    "mannwhitney_p_value": 0.6135720808223016,
    "relative_improvement": 0.004240350792656462,
    "absolute_improvement_ms": 58.66666666666731,
    "old_mean_ms": 13835.333333333334,
    "new_mean_ms": 13776.666666666668,
    "old_std_ms": 272.55791328074486,
    "new_std_ms": 128.12529786901158,
    "effect_size_cohens_d": 0.2754821166764946,
    "old_ci95_ms": [
      13733.558535892324,
      13937.108130774346
    ],
    "new_ci95_ms": [
      13728.82389416842,
      13824.509439164915
    ],
    "old_ci99_ms": [
      13698.16995019227,
      13972.4967164744
    ],
    "new_ci99_ms": [
      13712.188262388718,
      13841.145070944616
    ],
    "new_times_s": [
      14.26,
      14.1,
      14.04,
      13.66,
      13.71,
      14.03,
      13.66,
      13.64,
      13.79,
      14.06,
      13.76,
      13.89,
      13.84,
      13.8,
      13.7,
      13.76,
      13.77,
      13.64,
      13.75,
      13.75,
      13.7,
      13.71,
      13.72,
      13.71,
      13.68,
      13.83,
      13.63,
      13.7,
      13.72,
      13.74,
      13.81
    ],
    "old_times_s": [
      14.22,
      14.79,
      14.42,
      13.72,
      13.97,
      13.7,
      13.7,
      13.66,
      13.62,
      14.15,
      13.75,
      14.38,
      13.89,
      13.69,
      13.69,
      13.68,
      13.71,
      13.67,
      13.71,
      13.69,
      14.05,
      13.69,
      13.84,
      13.77,
      13.73,
      13.72,
      13.74,
      13.63,
      13.72,
      13.65,
      13.93
    ]
  },
  "tests": {
    "total_tests": 14,
    "significant_improvements": 0,
    "significant_improvements_tests": [],
    "significant_regressions": 1,
    "significant_regressions_tests": [
      "cli.bruteforce.long"
    ],
    "significant_pair_improvements": 0,
    "significant_pair_improvements_tests": [],
    "significant_pair_regressions": 1,
    "significant_pair_regressions_tests": [
      "cli.bruteforce.long"
    ],
    "significant_binom_improvements": 0,
    "significant_binom_improvements_tests": [],
    "significant_binom_regressions": 1,
    "significant_binom_regressions_tests": [
      "cli.bruteforce.long"
    ],
    "significant_wilcoxon_improvements": 0,
    "significant_wilcoxon_improvements_tests": [],
    "significant_wilcoxon_regressions": 1,
    "significant_wilcoxon_regressions_tests": [
      "cli.bruteforce.long"
    ],
    "significant_mannwhitney_improvements": 0,
    "significant_mannwhitney_improvements_tests": [],
    "significant_mannwhitney_regressions": 1,
    "significant_mannwhitney_regressions_tests": [
      "cli.bruteforce.long"
    ],
    "tests": [
      {
        "test_name": "cli.attack",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999981242748044,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.3775198625065499,
        "relative_improvement": 0.0031288945456474076,
        "absolute_improvement_ms": 42.14285714285637,
        "old_mean_ms": 13468.928571428572,
        "new_mean_ms": 13426.785714285716,
        "old_std_ms": 175.46423684813504,
        "new_std_ms": 96.6495606101629,
        "effect_size_cohens_d": 0.29751625086670536,
        "old_ci95_ms": [
          13400.890643182953,
          13536.966499674192
        ],
        "new_ci95_ms": [
          13389.308927061798,
          13464.262501509633
        ],
        "old_ci99_ms": [
          13377.053766607278,
          13560.803376249867
        ],
        "new_ci99_ms": [
          13376.179051203666,
          13477.392377367765
        ],
        "new_times": [
          13.35,
          13.4,
          13.7,
          13.33,
          13.32,
          13.46,
          13.68,
          13.45,
          13.57,
          13.5,
          13.47,
          13.39,
          13.43,
          13.44,
          13.31,
          13.43,
          13.42,
          13.37,
          13.34,
          13.39,
          13.4,
          13.35,
          13.5,
          13.32,
          13.37,
          13.41,
          13.39,
          13.46
        ],
        "old_times": [
          13.41,
          13.65,
          13.38,
          13.39,
          13.35,
          13.29,
          13.83,
          13.43,
          14.08,
          13.56,
          13.39,
          13.36,
          13.36,
          13.41,
          13.37,
          13.4,
          13.39,
          13.75,
          13.39,
          13.53,
          13.46,
          13.43,
          13.4,
          13.43,
          13.31,
          13.4,
          13.35,
          13.63
        ]
      },
      {
        "test_name": "cli.password",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999393422746,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 1.0,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 10.0,
        "new_mean_ms": 10.0,
        "old_std_ms": 0.0,
        "new_std_ms": 0.0,
        "effect_size_cohens_d": "NaN",
        "old_ci95_ms": [
          10.0,
          10.0
        ],
        "new_ci95_ms": [
          10.0,
          10.0
        ],
        "old_ci99_ms": [
          10.0,
          10.0
        ],
        "new_ci99_ms": [
          10.0,
          10.0
        ],
        "new_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ],
        "old_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ]
      },
      {
        "test_name": "cli.decipher",
        "is_significant": false,
        "p_value": 0.7718874982322776,
        "is_pair_significant": false,
        "pair_p_value": 0.7505300934400425,
        "is_binom_significant": false,
        "binom_p_value": 0.9937295243144035,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.92766548793686,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.3959743619453877,
        "relative_improvement": 0.013513513513513526,
        "absolute_improvement_ms": 0.357142857142858,
        "old_mean_ms": 26.428571428571434,
        "new_mean_ms": 26.071428571428577,
        "old_std_ms": 4.879500364742665,
        "new_std_ms": 4.97347461393438,
        "effect_size_cohens_d": 0.07249112373684534,
        "old_ci95_ms": [
          24.5364987096266,
          28.320644147516266
        ],
        "new_ci95_ms": [
          24.142916442731114,
          27.99994070012604
        ],
        "old_ci99_ms": [
          23.87361691653501,
          28.983525940607855
        ],
        "new_ci99_ms": [
          23.46726821575241,
          28.67558892710474
        ],
        "new_times": [
          0.02,
          0.02,
          0.03,
          0.03,
          0.02,
          0.03,
          0.03,
          0.02,
          0.02,
          0.03,
          0.03,
          0.02,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.02,
          0.03,
          0.03,
          0.02,
          0.03,
          0.02,
          0.02,
          0.02
        ],
        "old_times": [
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.02,
          0.03,
          0.02,
          0.03,
          0.03,
          0.02,
          0.02,
          0.03,
          0.02,
          0.02,
          0.02,
          0.03,
          0.03,
          0.02,
          0.03,
          0.03,
          0.03,
          0.03,
          0.02,
          0.02
        ]
      },
      {
        "test_name": "cli.decrypt",
        "is_significant": false,
        "p_value": 0.7718874982322776,
        "is_pair_significant": false,
        "pair_p_value": 0.7505300934400425,
        "is_binom_significant": false,
        "binom_p_value": 0.9937295243144035,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.92766548793686,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.3959743619453877,
        "relative_improvement": 0.013513513513513526,
        "absolute_improvement_ms": 0.357142857142858,
        "old_mean_ms": 26.428571428571434,
        "new_mean_ms": 26.071428571428577,
        "old_std_ms": 4.879500364742665,
        "new_std_ms": 4.97347461393438,
        "effect_size_cohens_d": 0.07249112373684534,
        "old_ci95_ms": [
          24.5364987096266,
          28.320644147516266
        ],
        "new_ci95_ms": [
          24.142916442731114,
          27.99994070012604
        ],
        "old_ci99_ms": [
          23.87361691653501,
          28.983525940607855
        ],
        "new_ci99_ms": [
          23.46726821575241,
          28.67558892710474
        ],
        "new_times": [
          0.02,
          0.02,
          0.03,
          0.03,
          0.02,
          0.03,
          0.03,
          0.02,
          0.02,
          0.03,
          0.03,
          0.02,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.02,
          0.03,
          0.03,
          0.02,
          0.03,
          0.02,
          0.02,
          0.02
        ],
        "old_times": [
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.03,
          0.02,
          0.03,
          0.02,
          0.03,
          0.03,
          0.02,
          0.02,
          0.03,
          0.02,
          0.02,
          0.02,
          0.03,
          0.03,
          0.02,
          0.03,
          0.03,
          0.03,
          0.03,
          0.02,
          0.02
        ]
      },
      {
        "test_name": "cli.change-password",
        "is_significant": false,
        "p_value": 0.8207262519478771,
        "is_pair_significant": false,
        "pair_p_value": 0.80116427790558,
        "is_binom_significant": false,
        "binom_p_value": 0.9999984838068485,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9991189640361041,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.32713652976287044,
        "relative_improvement": 0.0169491525423729,
        "absolute_improvement_ms": 0.357142857142858,
        "old_mean_ms": 21.071428571428573,
        "new_mean_ms": 20.714285714285715,
        "old_std_ms": 3.1497039417435593,
        "new_std_ms": 2.62265264156481,
        "effect_size_cohens_d": 0.12322987381221773,
        "old_ci95_ms": [
          19.850100883047453,
          22.292756259809696
        ],
        "new_ci95_ms": [
          19.6973271850419,
          21.731244243529535
        ],
        "old_ci99_ms": [
          19.422212525522813,
          22.720644617334333
        ],
        "new_ci99_ms": [
          19.341038926871317,
          22.087532501700114
        ],
        "new_times": [
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.03,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.03
        ],
        "old_times": [
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.03,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.03,
          0.03,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02
        ]
      },
      {
        "test_name": "cli.change-keys",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999393422746,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 1.0,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 20.0,
        "new_mean_ms": 20.0,
        "old_std_ms": 0.0,
        "new_std_ms": 0.0,
        "effect_size_cohens_d": "NaN",
        "old_ci95_ms": [
          20.0,
          20.0
        ],
        "new_ci95_ms": [
          20.0,
          20.0
        ],
        "old_ci99_ms": [
          20.0,
          20.0
        ],
        "new_ci99_ms": [
          20.0,
          20.0
        ],
        "new_times": [
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02
        ],
        "old_times": [
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02,
          0.02
        ]
      },
      {
        "test_name": "cli.bruteforce.empty",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999393422746,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 1.0,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 10.0,
        "new_mean_ms": 10.0,
        "old_std_ms": 0.0,
        "new_std_ms": 0.0,
        "effect_size_cohens_d": "NaN",
        "old_ci95_ms": [
          10.0,
          10.0
        ],
        "new_ci95_ms": [
          10.0,
          10.0
        ],
        "old_ci99_ms": [
          10.0,
          10.0
        ],
        "new_ci99_ms": [
          10.0,
          10.0
        ],
        "new_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ],
        "old_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ]
      },
      {
        "test_name": "cli.bruteforce.tiny",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999393422746,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 1.0,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 10.0,
        "new_mean_ms": 10.0,
        "old_std_ms": 0.0,
        "new_std_ms": 0.0,
        "effect_size_cohens_d": "NaN",
        "old_ci95_ms": [
          10.0,
          10.0
        ],
        "new_ci95_ms": [
          10.0,
          10.0
        ],
        "old_ci99_ms": [
          10.0,
          10.0
        ],
        "new_ci99_ms": [
          10.0,
          10.0
        ],
        "new_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ],
        "old_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ]
      },
      {
        "test_name": "cli.bruteforce.small",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999393422746,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 1.0,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 10.0,
        "new_mean_ms": 10.0,
        "old_std_ms": 0.0,
        "new_std_ms": 0.0,
        "effect_size_cohens_d": "NaN",
        "old_ci95_ms": [
          10.0,
          10.0
        ],
        "new_ci95_ms": [
          10.0,
          10.0
        ],
        "old_ci99_ms": [
          10.0,
          10.0
        ],
        "new_ci99_ms": [
          10.0,
          10.0
        ],
        "new_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ],
        "old_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ]
      },
      {
        "test_name": "cli.bruteforce.medium",
        "is_significant": false,
        "p_value": 0.9999999999999936,
        "is_pair_significant": false,
        "pair_p_value": 0.9999999999999936,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999048408935,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.8498322721616629,
        "relative_improvement": -0.003571428571428495,
        "absolute_improvement_ms": -0.3571428571428614,
        "old_mean_ms": 100.00000000000001,
        "new_mean_ms": 100.35714285714288,
        "old_std_ms": 1.4132447357298893e-14,
        "new_std_ms": 1.8898223650461352,
        "effect_size_cohens_d": -0.2672612419124277,
        "old_ci95_ms": [
          100.00000000000001,
          100.00000000000001
        ],
        "new_ci95_ms": [
          99.62434624411421,
          101.08993947017156
        ],
        "old_ci99_ms": [
          100.0,
          100.00000000000003
        ],
        "new_ci99_ms": [
          99.36761322959943,
          101.34667248468634
        ],
        "new_times": [
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.11
        ],
        "old_times": [
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1
        ]
      },
      {
        "test_name": "cli.bruteforce.long",
        "is_significant": false,
        "p_value": 0.9999999999782252,
        "is_pair_significant": false,
        "pair_p_value": 0.9999999999617275,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999990282423338,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.9999999999966379,
        "relative_improvement": -0.40268456375838946,
        "absolute_improvement_ms": -21.428571428571423,
        "old_mean_ms": 53.21428571428573,
        "new_mean_ms": 74.64285714285715,
        "old_std_ms": 4.755948656056707,
        "new_std_ms": 12.61455445614248,
        "effect_size_cohens_d": -2.2478935866813274,
        "old_ci95_ms": [
          51.370121346587844,
          55.05845008198361
        ],
        "new_ci95_ms": [
          69.75144356277642,
          79.53427072293788
        ],
        "old_ci99_ms": [
          50.72402409536966,
          55.7045473332018
        ],
        "new_ci99_ms": [
          68.03775202637252,
          81.24796225934178
        ],
        "new_times": [
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.11,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.11,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.07,
          0.11,
          0.08
        ],
        "old_times": [
          0.05,
          0.05,
          0.06,
          0.06,
          0.05,
          0.05,
          0.06,
          0.06,
          0.05,
          0.06,
          0.05,
          0.05,
          0.05,
          0.05,
          0.05,
          0.05,
          0.05,
          0.05,
          0.05,
          0.05,
          0.05,
          0.05,
          0.06,
          0.05,
          0.06,
          0.06,
          0.06,
          0.05
        ]
      },
      {
        "test_name": "cli.list",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999393422746,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 1.0,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 10.0,
        "new_mean_ms": 10.0,
        "old_std_ms": 0.0,
        "new_std_ms": 0.0,
        "effect_size_cohens_d": "NaN",
        "old_ci95_ms": [
          10.0,
          10.0
        ],
        "new_ci95_ms": [
          10.0,
          10.0
        ],
        "old_ci99_ms": [
          10.0,
          10.0
        ],
        "new_ci99_ms": [
          10.0,
          10.0
        ],
        "new_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ],
        "old_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ]
      },
      {
        "test_name": "cli.version",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999393422746,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 1.0,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 10.0,
        "new_mean_ms": 10.0,
        "old_std_ms": 0.0,
        "new_std_ms": 0.0,
        "effect_size_cohens_d": "NaN",
        "old_ci95_ms": [
          10.0,
          10.0
        ],
        "new_ci95_ms": [
          10.0,
          10.0
        ],
        "old_ci99_ms": [
          10.0,
          10.0
        ],
        "new_ci99_ms": [
          10.0,
          10.0
        ],
        "new_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ],
        "old_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ]
      },
      {
        "test_name": "cli.help",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999393422746,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 1.0,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 10.0,
        "new_mean_ms": 10.0,
        "old_std_ms": 0.0,
        "new_std_ms": 0.0,
        "effect_size_cohens_d": "NaN",
        "old_ci95_ms": [
          10.0,
          10.0
        ],
        "new_ci95_ms": [
          10.0,
          10.0
        ],
        "old_ci99_ms": [
          10.0,
          10.0
        ],
        "new_ci99_ms": [
          10.0,
          10.0
        ],
        "new_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ],
        "old_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ]
      }
    ]
  },
  "logs": {
    "full_log_path": "/logs/full.log",
    "config_log_path": "/logs/config.log",
    "build_log_path": "/logs/build.log",
    "test_log_path": "/logs/test.log",
    "build_success": true,
    "test_success": true
  },
  "raw_timing_data": {
    "warmup_runs": 1,
    "measurement_runs": 30,
    "min_exec_time_improvement": 0.05,
    "min_p_value": 0.05
  }
}