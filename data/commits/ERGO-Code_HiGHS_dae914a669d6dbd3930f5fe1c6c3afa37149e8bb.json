{
  "metadata": {
    "collection_date": "2026-02-03T20:00:34.047387",
    "repository": "https://github.com/ERGO-Code/HiGHS",
    "repository_name": "ERGO-Code/HiGHS"
  },
  "commit_info": {
    "old_sha": "124f405fe3038547a53ab5a6f4775ed087b9c15b",
    "new_sha": "dae914a669d6dbd3930f5fe1c6c3afa37149e8bb",
    "commit_message": [
      "NE values also use partial rw copy and corresponding entries"
    ],
    "commit_date": "2025-09-19T12:33:30+00:00",
    "patch": [
      "--- highs/ipm/hipo/ipm/FactorHiGHSSolver.cpp\n@@ -86,18 +86,18 @@ Int FactorHiGHSSolver::buildNEvalues(const HighsSparseMatrix& A,\n     // go along the entries of the row, and then down each column.\n     // this builds the lower triangular part of the row-th column of AAt.\n \n-    Int current = headNE_[row];\n-    while (current != -1) {\n-      Int col = colNE_[current];\n+    for (Int el = ptrNE_rw_[row]; el < ptrNE_rw_[row + 1]; ++el) {\n+      Int col = idxNE_rw_[el];\n+      Int corr = corr_NE_[el];\n \n       const double theta =\n           scaling.empty() ? 1.0 : 1.0 / (scaling[col] + regul_.primal);\n \n-      const double row_value = theta * A.value_[current];\n+      const double row_value = theta * A.value_[corr];\n \n       // for each nonzero in the row, go down corresponding column, starting\n       // from current position\n-      for (Int colEl = current; colEl < A.start_[col + 1]; ++colEl) {\n+      for (Int colEl = corr; colEl < A.start_[col + 1]; ++colEl) {\n         Int row2 = A.index_[colEl];\n \n         // row2 is guaranteed to be larger or equal than row\n@@ -107,8 +107,6 @@ Int FactorHiGHSSolver::buildNEvalues(const HighsSparseMatrix& A,\n         double value = row_value * A.value_[colEl];\n         work[row2] += value;\n       }\n-\n-      current = nextNE_[current];\n     }\n     // intersection of row with rows below finished.\n \n@@ -126,106 +124,6 @@ Int FactorHiGHSSolver::buildNEvalues(const HighsSparseMatrix& A,\n Int FactorHiGHSSolver::buildNEstructure(const HighsSparseMatrix& A,\n                                         int64_t nz_limit) {\n   // Build lower triangular structure of AAt.\n-  // This approach uses a column-wise copy of A and a collection of linked lists\n-  // to access the rows\n-\n-  // NB: A must have sorted columns for this to work\n-\n-  // colNE stores the index of the column of each entry.\n-  // It's useless when accessing the matrix by columns, but useful when doing it\n-  // by rows.\n-  colNE_.resize(A.numNz());\n-\n-  // head and next are a collection of linked lists to access the matrix by\n-  // rows.\n-  nextNE_.resize(A.numNz(), -1);\n-  headNE_.resize(A.num_row_, -1);\n-\n-  // temp stores the address of the latest entry in each row\n-  std::vector<Int> temp(A.num_row_, -1);\n-\n-  // build linked lists for row access\n-  for (Int col = 0; col < A.num_col_; ++col) {\n-    for (Int el = A.start_[col]; el < A.start_[col + 1]; ++el) {\n-      Int row = A.index_[el];\n-      colNE_[el] = col;\n-\n-      if (temp[row] == -1)\n-        headNE_[row] = el;\n-      else\n-        nextNE_[temp[row]] = el;\n-\n-      temp[row] = el;\n-    }\n-  }\n-\n-  ptrNE_.clear();\n-  rowsNE_.clear();\n-\n-  // ptr is allocated its exact size\n-  ptrNE_.resize(A.num_row_ + 1, 0);\n-\n-  // keep track if given entry is nonzero, in column considered\n-  std::vector<bool> is_nz(A.num_row_, false);\n-\n-  // temporary storage of indices\n-  std::vector<Int> temp_index(A.num_row_);\n-\n-  Clock clock;\n-\n-  for (Int row = 0; row < A.num_row_; ++row) {\n-    // go along the entries of the row, and then down each column.\n-    // this builds the lower triangular part of the row-th column of AAt.\n-\n-    Int nz_in_col = 0;\n-\n-    Int current = headNE_[row];\n-    while (current != -1) {\n-      Int col = colNE_[current];\n-\n-      // for each nonzero in the row, go down corresponding column, starting\n-      // from current position\n-      for (Int colEl = current; colEl < A.start_[col + 1]; ++colEl) {\n-        Int row2 = A.index_[colEl];\n-\n-        // row2 is guaranteed to be larger or equal than row\n-        // (provided that the columns of A are sorted)\n-\n-        // save information that there is nonzero in position (row2,row).\n-        if (!is_nz[row2]) {\n-          is_nz[row2] = true;\n-          temp_index[nz_in_col] = row2;\n-          ++nz_in_col;\n-        }\n-      }\n-\n-      current = nextNE_[current];\n-    }\n-    // intersection of row with rows below finished.\n-\n-    // if the total number of nonzeros exceeds the maximum, return error\n-    if ((int64_t)ptrNE_[row] + (int64_t)nz_in_col >= nz_limit)\n-      return kStatusOoM;\n-\n-    // update pointers\n-    ptrNE_[row + 1] = ptrNE_[row] + nz_in_col;\n-\n-    // now assign indices\n-    for (Int i = 0; i < nz_in_col; ++i) {\n-      Int index = temp_index[i];\n-      rowsNE_.push_back(index);\n-      is_nz[index] = false;\n-    }\n-  }\n-\n-  printf(\"time 1: %f\\n\", clock.stop());\n-\n-  return kStatusOk;\n-}\n-\n-Int FactorHiGHSSolver::buildNEstructure_2(const HighsSparseMatrix& A,\n-                                          int64_t nz_limit) {\n-  // Build lower triangular structure of AAt.\n   // This approach uses a column-wise copy of A, a partial row-wise copy and a\n   // vector of corresponding indices.\n \n@@ -255,17 +153,18 @@ Int FactorHiGHSSolver::buildNEstructure_2(const HighsSparseMatrix& A,\n     }\n   }\n \n-  std::vector<Int> ptrNE(A.num_row_ + 1);\n-  std::vector<Int> rowsNE;\n+  ptrNE_.clear();\n+  rowsNE_.clear();\n+\n+  // ptr is allocated its exact size\n+  ptrNE_.resize(A.num_row_ + 1, 0);\n \n   // keep track if given entry is nonzero, in column considered\n   std::vector<bool> is_nz(A.num_row_, false);\n \n   // temporary storage of indices\n   std::vector<Int> temp_index(A.num_row_);\n \n-  Clock clock;\n-\n   for (Int row = 0; row < A.num_row_; ++row) {\n     // go along the entries of the row, and then down each column.\n     // this builds the lower triangular part of the row-th column of AAt.\n@@ -295,21 +194,20 @@ Int FactorHiGHSSolver::buildNEstructure_2(const HighsSparseMatrix& A,\n     // intersection of row with rows below finished.\n \n     // if the total number of nonzeros exceeds the maximum, return error\n-    if ((int64_t)ptrNE[row] + (int64_t)nz_in_col >= nz_limit) return kStatusOoM;\n+    if ((int64_t)ptrNE_[row] + (int64_t)nz_in_col >= nz_limit)\n+      return kStatusOoM;\n \n     // update pointers\n-    ptrNE[row + 1] = ptrNE[row] + nz_in_col;\n+    ptrNE_[row + 1] = ptrNE_[row] + nz_in_col;\n \n     // now assign indices\n     for (Int i = 0; i < nz_in_col; ++i) {\n       Int index = temp_index[i];\n-      rowsNE.push_back(index);\n+      rowsNE_.push_back(index);\n       is_nz[index] = false;\n     }\n   }\n \n-  printf(\"time 2: %f\\n\", clock.stop());\n-\n   return kStatusOk;\n }\n \n@@ -512,8 +410,6 @@ Int FactorHiGHSSolver::analyseNE(Symbolic& S, int64_t nz_limit) {\n   if (Int status = buildNEstructure(model_.A(), nz_limit)) return status;\n   if (info_) info_->matrix_structure_time = clock.stop();\n \n-  buildNEstructure_2(model_.A(), nz_limit);\n-\n   // create vector of signs of pivots\n   std::vector<Int> pivot_signs(model_.A().num_row_, 1);\n \n--- highs/ipm/hipo/ipm/FactorHiGHSSolver.h\n@@ -22,8 +22,6 @@ class FactorHiGHSSolver : public LinearSolver {\n   // normal equations data\n   std::vector<Int> ptrNE_, rowsNE_;\n   std::vector<double> valNE_;\n-  std::vector<Int> colNE_, nextNE_, headNE_;\n-\n   std::vector<Int> ptrNE_rw_, idxNE_rw_;\n   std::vector<Int> corr_NE_;\n \n@@ -42,8 +40,6 @@ class FactorHiGHSSolver : public LinearSolver {\n \n   Int buildNEstructure(const HighsSparseMatrix& A,\n                        int64_t nz_limit = kHighsIInf);\n-  Int buildNEstructure_2(const HighsSparseMatrix& A,\n-                         int64_t nz_limit = kHighsIInf);\n   Int buildNEvalues(const HighsSparseMatrix& A,\n                     const std::vector<double>& scaling);\n "
    ],
    "files_changed": [
      {
        "filename": "highs/ipm/hipo/ipm/FactorHiGHSSolver.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 118,
        "changes": 132,
        "patch": "@@ -86,18 +86,18 @@ Int FactorHiGHSSolver::buildNEvalues(const HighsSparseMatrix& A,\n     // go along the entries of the row, and then down each column.\n     // this builds the lower triangular part of the row-th column of AAt.\n \n-    Int current = headNE_[row];\n-    while (current != -1) {\n-      Int col = colNE_[current];\n+    for (Int el = ptrNE_rw_[row]; el < ptrNE_rw_[row + 1]; ++el) {\n+      Int col = idxNE_rw_[el];\n+      Int corr = corr_NE_[el];\n \n       const double theta =\n           scaling.empty() ? 1.0 : 1.0 / (scaling[col] + regul_.primal);\n \n-      const double row_value = theta * A.value_[current];\n+      const double row_value = theta * A.value_[corr];\n \n       // for each nonzero in the row, go down corresponding column, starting\n       // from current position\n-      for (Int colEl = current; colEl < A.start_[col + 1]; ++colEl) {\n+      for (Int colEl = corr; colEl < A.start_[col + 1]; ++colEl) {\n         Int row2 = A.index_[colEl];\n \n         // row2 is guaranteed to be larger or equal than row\n@@ -107,8 +107,6 @@ Int FactorHiGHSSolver::buildNEvalues(const HighsSparseMatrix& A,\n         double value = row_value * A.value_[colEl];\n         work[row2] += value;\n       }\n-\n-      current = nextNE_[current];\n     }\n     // intersection of row with rows below finished.\n \n@@ -126,106 +124,6 @@ Int FactorHiGHSSolver::buildNEvalues(const HighsSparseMatrix& A,\n Int FactorHiGHSSolver::buildNEstructure(const HighsSparseMatrix& A,\n                                         int64_t nz_limit) {\n   // Build lower triangular structure of AAt.\n-  // This approach uses a column-wise copy of A and a collection of linked lists\n-  // to access the rows\n-\n-  // NB: A must have sorted columns for this to work\n-\n-  // colNE stores the index of the column of each entry.\n-  // It's useless when accessing the matrix by columns, but useful when doing it\n-  // by rows.\n-  colNE_.resize(A.numNz());\n-\n-  // head and next are a collection of linked lists to access the matrix by\n-  // rows.\n-  nextNE_.resize(A.numNz(), -1);\n-  headNE_.resize(A.num_row_, -1);\n-\n-  // temp stores the address of the latest entry in each row\n-  std::vector<Int> temp(A.num_row_, -1);\n-\n-  // build linked lists for row access\n-  for (Int col = 0; col < A.num_col_; ++col) {\n-    for (Int el = A.start_[col]; el < A.start_[col + 1]; ++el) {\n-      Int row = A.index_[el];\n-      colNE_[el] = col;\n-\n-      if (temp[row] == -1)\n-        headNE_[row] = el;\n-      else\n-        nextNE_[temp[row]] = el;\n-\n-      temp[row] = el;\n-    }\n-  }\n-\n-  ptrNE_.clear();\n-  rowsNE_.clear();\n-\n-  // ptr is allocated its exact size\n-  ptrNE_.resize(A.num_row_ + 1, 0);\n-\n-  // keep track if given entry is nonzero, in column considered\n-  std::vector<bool> is_nz(A.num_row_, false);\n-\n-  // temporary storage of indices\n-  std::vector<Int> temp_index(A.num_row_);\n-\n-  Clock clock;\n-\n-  for (Int row = 0; row < A.num_row_; ++row) {\n-    // go along the entries of the row, and then down each column.\n-    // this builds the lower triangular part of the row-th column of AAt.\n-\n-    Int nz_in_col = 0;\n-\n-    Int current = headNE_[row];\n-    while (current != -1) {\n-      Int col = colNE_[current];\n-\n-      // for each nonzero in the row, go down corresponding column, starting\n-      // from current position\n-      for (Int colEl = current; colEl < A.start_[col + 1]; ++colEl) {\n-        Int row2 = A.index_[colEl];\n-\n-        // row2 is guaranteed to be larger or equal than row\n-        // (provided that the columns of A are sorted)\n-\n-        // save information that there is nonzero in position (row2,row).\n-        if (!is_nz[row2]) {\n-          is_nz[row2] = true;\n-          temp_index[nz_in_col] = row2;\n-          ++nz_in_col;\n-        }\n-      }\n-\n-      current = nextNE_[current];\n-    }\n-    // intersection of row with rows below finished.\n-\n-    // if the total number of nonzeros exceeds the maximum, return error\n-    if ((int64_t)ptrNE_[row] + (int64_t)nz_in_col >= nz_limit)\n-      return kStatusOoM;\n-\n-    // update pointers\n-    ptrNE_[row + 1] = ptrNE_[row] + nz_in_col;\n-\n-    // now assign indices\n-    for (Int i = 0; i < nz_in_col; ++i) {\n-      Int index = temp_index[i];\n-      rowsNE_.push_back(index);\n-      is_nz[index] = false;\n-    }\n-  }\n-\n-  printf(\"time 1: %f\\n\", clock.stop());\n-\n-  return kStatusOk;\n-}\n-\n-Int FactorHiGHSSolver::buildNEstructure_2(const HighsSparseMatrix& A,\n-                                          int64_t nz_limit) {\n-  // Build lower triangular structure of AAt.\n   // This approach uses a column-wise copy of A, a partial row-wise copy and a\n   // vector of corresponding indices.\n \n@@ -255,17 +153,18 @@ Int FactorHiGHSSolver::buildNEstructure_2(const HighsSparseMatrix& A,\n     }\n   }\n \n-  std::vector<Int> ptrNE(A.num_row_ + 1);\n-  std::vector<Int> rowsNE;\n+  ptrNE_.clear();\n+  rowsNE_.clear();\n+\n+  // ptr is allocated its exact size\n+  ptrNE_.resize(A.num_row_ + 1, 0);\n \n   // keep track if given entry is nonzero, in column considered\n   std::vector<bool> is_nz(A.num_row_, false);\n \n   // temporary storage of indices\n   std::vector<Int> temp_index(A.num_row_);\n \n-  Clock clock;\n-\n   for (Int row = 0; row < A.num_row_; ++row) {\n     // go along the entries of the row, and then down each column.\n     // this builds the lower triangular part of the row-th column of AAt.\n@@ -295,21 +194,20 @@ Int FactorHiGHSSolver::buildNEstructure_2(const HighsSparseMatrix& A,\n     // intersection of row with rows below finished.\n \n     // if the total number of nonzeros exceeds the maximum, return error\n-    if ((int64_t)ptrNE[row] + (int64_t)nz_in_col >= nz_limit) return kStatusOoM;\n+    if ((int64_t)ptrNE_[row] + (int64_t)nz_in_col >= nz_limit)\n+      return kStatusOoM;\n \n     // update pointers\n-    ptrNE[row + 1] = ptrNE[row] + nz_in_col;\n+    ptrNE_[row + 1] = ptrNE_[row] + nz_in_col;\n \n     // now assign indices\n     for (Int i = 0; i < nz_in_col; ++i) {\n       Int index = temp_index[i];\n-      rowsNE.push_back(index);\n+      rowsNE_.push_back(index);\n       is_nz[index] = false;\n     }\n   }\n \n-  printf(\"time 2: %f\\n\", clock.stop());\n-\n   return kStatusOk;\n }\n \n@@ -512,8 +410,6 @@ Int FactorHiGHSSolver::analyseNE(Symbolic& S, int64_t nz_limit) {\n   if (Int status = buildNEstructure(model_.A(), nz_limit)) return status;\n   if (info_) info_->matrix_structure_time = clock.stop();\n \n-  buildNEstructure_2(model_.A(), nz_limit);\n-\n   // create vector of signs of pivots\n   std::vector<Int> pivot_signs(model_.A().num_row_, 1);\n "
      },
      {
        "filename": "highs/ipm/hipo/ipm/FactorHiGHSSolver.h",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "patch": "@@ -22,8 +22,6 @@ class FactorHiGHSSolver : public LinearSolver {\n   // normal equations data\n   std::vector<Int> ptrNE_, rowsNE_;\n   std::vector<double> valNE_;\n-  std::vector<Int> colNE_, nextNE_, headNE_;\n-\n   std::vector<Int> ptrNE_rw_, idxNE_rw_;\n   std::vector<Int> corr_NE_;\n \n@@ -42,8 +40,6 @@ class FactorHiGHSSolver : public LinearSolver {\n \n   Int buildNEstructure(const HighsSparseMatrix& A,\n                        int64_t nz_limit = kHighsIInf);\n-  Int buildNEstructure_2(const HighsSparseMatrix& A,\n-                         int64_t nz_limit = kHighsIInf);\n   Int buildNEvalues(const HighsSparseMatrix& A,\n                     const std::vector<double>& scaling);\n "
      }
    ],
    "lines_added": 14,
    "lines_removed": 122
  },
  "issues": [],
  "pull_requests": [],
  "build_info": {
    "old_build_script": [
      "apt-get update",
      "cmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON -DBUILD_EXTRA_UNIT_TESTS=ON",
      "cmake --build /test_workspace/workspace/old/build -- -j 1"
    ],
    "new_build_script": [
      "apt-get update",
      "cmake -S /test_workspace/workspace/new -B /test_workspace/workspace/new/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON -DBUILD_EXTRA_UNIT_TESTS=ON",
      "cmake --build /test_workspace/workspace/new/build -- -j 1"
    ],
    "old_test_script": [
      "cd /test_workspace/workspace/old/build",
      "ctest --output-on-failure"
    ],
    "new_test_script": [
      "cd /test_workspace/workspace/new/build",
      "ctest --output-on-failure"
    ],
    "build_system": "cmake"
  },
  "performance_analysis": {
    "is_significant": false,
    "p_value": 0.9939793451048835,
    "is_pair_significant": false,
    "pair_p_value": 0.9892653097035794,
    "is_binom_significant": false,
    "binom_p_value": 0.9692858271300793,
    "is_wilcoxon_significant": false,
    "wilcoxon_p_value": 0.9833702100464375,
    "is_mannwhitney_significant": false,
    "mannwhitney_p_value": 0.735237498488611,
    "relative_improvement": -0.014662756598240468,
    "absolute_improvement_ms": -16.666666666666387,
    "old_mean_ms": 1136.6666666666667,
    "new_mean_ms": 1153.333333333333,
    "old_std_ms": 105.44923057986273,
    "new_std_ms": 118.47692437430761,
    "effect_size_cohens_d": -0.1486073111635126,
    "old_ci95_ms": [
      1097.291276851726,
      1176.0420564816075
    ],
    "new_ci95_ms": [
      1109.0933227077412,
      1197.5733439589249
    ],
    "old_ci99_ms": [
      1083.5998778809092,
      1189.7334554524243
    ],
    "new_ci99_ms": [
      1093.7104239276935,
      1212.9562427389728
    ],
    "new_times_s": [
      1.05,
      1.08,
      1.1,
      1.14,
      1.16,
      0.99,
      1.2,
      1.21,
      1.27,
      1.15,
      1.27,
      1.16,
      1.23,
      0.97,
      1.07,
      1.13,
      0.94,
      0.98,
      1.34,
      1.3,
      1.19,
      1.29,
      1.1,
      0.97,
      1.04,
      1.24,
      1.31,
      1.32,
      1.11,
      1.05,
      1.29
    ],
    "old_times_s": [
      1.21,
      0.91,
      1.35,
      1.2,
      1.12,
      1.04,
      1.07,
      1.13,
      1.1,
      1.2,
      0.96,
      1.17,
      1.18,
      1.12,
      1.19,
      1.27,
      1.28,
      1.1,
      1.19,
      1.05,
      1.2,
      1.33,
      1.24,
      1.08,
      1.12,
      1.14,
      1.02,
      0.96,
      1.17,
      1.03,
      1.18
    ]
  },
  "tests": {
    "total_tests": 2,
    "significant_improvements": 0,
    "significant_improvements_tests": [],
    "significant_regressions": 0,
    "significant_regressions_tests": [],
    "significant_pair_improvements": 0,
    "significant_pair_improvements_tests": [],
    "significant_pair_regressions": 0,
    "significant_pair_regressions_tests": [],
    "significant_binom_improvements": 0,
    "significant_binom_improvements_tests": [],
    "significant_binom_regressions": 0,
    "significant_binom_regressions_tests": [],
    "significant_wilcoxon_improvements": 0,
    "significant_wilcoxon_improvements_tests": [],
    "significant_wilcoxon_regressions": 0,
    "significant_wilcoxon_regressions_tests": [],
    "significant_mannwhitney_improvements": 0,
    "significant_mannwhitney_improvements_tests": [],
    "significant_mannwhitney_regressions": 0,
    "significant_mannwhitney_regressions_tests": [],
    "tests": [
      {
        "test_name": "cxx_examples_call_highs_from_cpp",
        "is_significant": false,
        "p_value": 0.9395148747972717,
        "is_pair_significant": false,
        "pair_p_value": 0.9224689403755493,
        "is_binom_significant": false,
        "binom_p_value": 0.9937295243144035,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9622756711255462,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.31935810000758025,
        "relative_improvement": -0.003699136868064259,
        "absolute_improvement_ms": -1.071428571428501,
        "old_mean_ms": 289.64285714285717,
        "new_mean_ms": 290.71428571428567,
        "old_std_ms": 38.052803747107426,
        "new_std_ms": 37.705346062503146,
        "effect_size_cohens_d": -0.028285202462870026,
        "old_ci95_ms": [
          274.8875202297794,
          304.3981940559349
        ],
        "new_ci95_ms": [
          276.09367882618704,
          305.33489260238423
        ],
        "old_ci99_ms": [
          269.7180338286087,
          309.5676804571056
        ],
        "new_ci99_ms": [
          270.9713946702827,
          310.4571767582886
        ],
        "new_times": [
          0.31,
          0.31,
          0.28,
          0.31,
          0.31,
          0.32,
          0.24,
          0.27,
          0.26,
          0.31,
          0.21,
          0.3,
          0.3,
          0.15,
          0.31,
          0.32,
          0.28,
          0.29,
          0.3,
          0.3,
          0.29,
          0.31,
          0.32,
          0.31,
          0.3,
          0.31,
          0.33,
          0.29
        ],
        "old_times": [
          0.32,
          0.25,
          0.23,
          0.17,
          0.25,
          0.32,
          0.31,
          0.32,
          0.24,
          0.27,
          0.31,
          0.32,
          0.31,
          0.31,
          0.24,
          0.31,
          0.26,
          0.32,
          0.31,
          0.31,
          0.32,
          0.33,
          0.31,
          0.27,
          0.31,
          0.31,
          0.3,
          0.28
        ]
      },
      {
        "test_name": "c_examples_call_highs_from_c_minimal",
        "is_significant": false,
        "p_value": 0.9888303146774969,
        "is_pair_significant": false,
        "pair_p_value": 0.983967308611234,
        "is_binom_significant": false,
        "binom_p_value": 0.9075333289802074,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9640183882684732,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.7845954098518002,
        "relative_improvement": -0.023648648648648744,
        "absolute_improvement_ms": -19.999999999999794,
        "old_mean_ms": 845.7142857142859,
        "new_mean_ms": 865.7142857142857,
        "old_std_ms": 88.83728660907812,
        "new_std_ms": 111.46926403900237,
        "effect_size_cohens_d": -0.19843134832984227,
        "old_ci95_ms": [
          811.2667821066118,
          880.1617893219599
        ],
        "new_ci95_ms": [
          822.4910174032528,
          908.9375540253185
        ],
        "old_ci99_ms": [
          799.1982063429285,
          892.2303650856433
        ],
        "new_ci99_ms": [
          807.3478797667275,
          924.0806916618438
        ],
        "new_times": [
          0.82,
          0.85,
          0.71,
          0.9,
          0.89,
          0.95,
          0.91,
          1.0,
          0.9,
          0.92,
          0.76,
          0.77,
          0.83,
          0.79,
          0.67,
          1.01,
          1.01,
          0.9,
          1.0,
          0.79,
          0.67,
          0.73,
          0.92,
          1.0,
          1.02,
          0.79,
          0.73,
          1.0
        ],
        "old_times": [
          0.88,
          0.87,
          0.8,
          0.9,
          0.88,
          0.79,
          0.89,
          0.64,
          0.93,
          0.91,
          0.81,
          0.87,
          0.96,
          0.96,
          0.86,
          0.87,
          0.79,
          0.89,
          1.01,
          0.92,
          0.75,
          0.79,
          0.84,
          0.75,
          0.64,
          0.85,
          0.73,
          0.9
        ]
      }
    ]
  },
  "logs": {
    "full_log_path": "/logs/full.log",
    "config_log_path": "/logs/config.log",
    "build_log_path": "/logs/build.log",
    "test_log_path": "/logs/test.log",
    "build_success": true,
    "test_success": true
  },
  "raw_timing_data": {
    "warmup_runs": 1,
    "measurement_runs": 30,
    "min_exec_time_improvement": 0.05,
    "min_p_value": 0.05
  }
}