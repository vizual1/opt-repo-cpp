diff --git a/src/parse.cpp b/src/parse.cpp
index 41b9962a..2244acd8 100644
--- a/src/parse.cpp
+++ b/src/parse.cpp
@@ -711,6 +711,14 @@ expression* parser::parse_await_expression(token await_token, precedence prec) {
       // await / rhs;
       case token_type::slash:
       case token_type::slash_equal: {
+        // First check the guess cache to avoid expensive speculative parsing for
+        // pathological cases.
+        parser::await_cache_key cache_key{this->peek().begin, this->in_top_level_};
+        auto cache_it = this->await_guess_cache_.find(cache_key);
+        if (cache_it != this->await_guess_cache_.end()) {
+          return cache_it->second;
+        }
+
         buffering_error_reporter temp_error_reporter(&this->temporary_memory_);
         error_reporter* old_error_reporter =
             std::exchange(this->error_reporter_, &temp_error_reporter);
@@ -729,16 +737,25 @@ expression* parser::parse_await_expression(token await_token, precedence prec) {
         bool parsed_ok = temp_error_reporter.empty() &&
                          !this->lexer_.transaction_has_lex_errors(transaction);
 
-        this->lexer_.roll_back_transaction(std::move(transaction));
-        this->error_reporter_ = old_error_reporter;
-
+        bool is_identifier;
         if (this->in_top_level_) {
           bool parsed_slash_as_regexp = parsed_ok;
-          return !parsed_slash_as_regexp;
+          is_identifier = !parsed_slash_as_regexp;
         } else {
           bool parsed_slash_as_divide = parsed_ok;
-          return parsed_slash_as_divide;
+          is_identifier = parsed_slash_as_divide;
         }
+
+        // Cache the result for this position so future speculative parses can be
+        // avoided. Use emplace to avoid overwriting in the unlikely event of
+        // concurrent modifications (this parser is single-threaded, but emplace
+        // is still slightly cheaper when key already exists).
+        this->await_guess_cache_.emplace(cache_key, is_identifier);
+
+        this->lexer_.roll_back_transaction(std::move(transaction));
+        this->error_reporter_ = old_error_reporter;
+
+        return is_identifier;
       }
 
       case token_type::kw_of:
diff --git a/src/quick-lint-js/parse.h b/src/quick-lint-js/parse.h
index 0660b54c..da26fb0e 100644
--- a/src/quick-lint-js/parse.h
+++ b/src/quick-lint-js/parse.h
@@ -6,6 +6,8 @@
 
 #include <cstdlib>
 #include <optional>
+#include <array>
+#include <unordered_map>
 #include <quick-lint-js/assert.h>
 #include <quick-lint-js/buffering-visitor.h>
 #include <quick-lint-js/char8.h>
@@ -102,6 +104,27 @@ class parser {
 
   class depth_guard;
 
+  struct await_cache_key {
+    const char8* pos;
+    bool in_top_level;
+    bool operator==(const await_cache_key& other) const noexcept {
+      return pos == other.pos && in_top_level == other.in_top_level;
+    }
+  };
+
+  struct await_cache_key_hash {
+    std::size_t operator()(const await_cache_key& k) const noexcept {
+      // Mix pointer hash with boolean flag.
+      return std::hash<const char8*>()(k.pos) ^ (k.in_top_level ? 0x9e3779b97f4a7c15ULL : 0);
+    }
+  };
+
+  // Cache guesses for whether an 'await' followed by the token at 'pos' should
+  // be treated as an identifier (true) or an operator (false). The key stores
+  // the pointer to the next token's begin and the current in_top_level_ flag,
+  // since parsing behavior differs at top level.
+  std::unordered_map<await_cache_key, bool, await_cache_key_hash> await_guess_cache_;
+
  public:
   explicit parser(padded_string_view input, error_reporter *error_reporter)
       : lexer_(input, error_reporter), error_reporter_(error_reporter) {}
