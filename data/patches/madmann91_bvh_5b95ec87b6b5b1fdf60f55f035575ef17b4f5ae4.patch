diff --git a/bvh.hpp b/bvh.hpp
index 3447a11..976e608 100644
--- a/bvh.hpp
+++ b/bvh.hpp
@@ -493,15 +493,16 @@ struct BVH {
         TraversalStack<size_t, stack_size> stack;
         stack.push(0);
         while (!stack.empty()) {
-            auto& node = nodes[stack.pop()];
+            size_t node_index = stack.pop();
+            auto& node = nodes[node_index];
             auto first_child = node.first_child_or_primitive;
 
             auto& left  = nodes[first_child + 0];
             auto& right = nodes[first_child + 1];
-            auto distance_left  = left .intersect(inverse_origin, inverse_direction, ray.tmin, ray.tmax, ix, iy, iz);
-            auto distance_right = right.intersect(inverse_origin, inverse_direction, ray.tmin, ray.tmax, ix, iy, iz);
-            bool hit_left  = distance_left.first  <= distance_left.second;
-            bool hit_right = distance_right.first <= distance_right.second;
+
+            // Test the left child first and eagerly process leaves to shorten ray.tmax
+            auto distance_left = left.intersect(inverse_origin, inverse_direction, ray.tmin, ray.tmax, ix, iy, iz);
+            bool hit_left = distance_left.first <= distance_left.second;
 
             if (hit_left && left.leaf) {
                 if (intersect_leaf(left.first_child_or_primitive, left.primitive_count) && AnyHit)
@@ -509,6 +510,10 @@ struct BVH {
                 hit_left = false;
             }
 
+            // Compute right child only after handling left leaf case (allows early out or tmax reduction)
+            auto distance_right = right.intersect(inverse_origin, inverse_direction, ray.tmin, ray.tmax, ix, iy, iz);
+            bool hit_right = distance_right.first <= distance_right.second;
+
             if (hit_right && right.leaf) {
                 if (intersect_leaf(right.first_child_or_primitive, right.primitive_count) && AnyHit)
                     break;
@@ -517,10 +522,13 @@ struct BVH {
 
             if (hit_left && hit_right) {
                 int order = distance_left.first < distance_right.first ? 0 : 1;
+                // push far then near
                 stack.push(first_child + (1 - order));
                 stack.push(first_child + order);
-            } else if (hit_left ^ hit_right) {
-                stack.push(first_child + (hit_left ? 0 : 1));
+            } else if (hit_left) {
+                stack.push(first_child + 0);
+            } else if (hit_right) {
+                stack.push(first_child + 1);
             }
         }
 
