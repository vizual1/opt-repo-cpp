diff --git a/src/ccache/util/threadpool.cpp b/src/ccache/util/threadpool.cpp
index 96aabbbe..69b52d05 100644
--- a/src/ccache/util/threadpool.cpp
+++ b/src/ccache/util/threadpool.cpp
@@ -42,6 +42,29 @@ ThreadPool::~ThreadPool() noexcept
 void
 ThreadPool::enqueue(std::function<void()> function)
 {
+  // Fast path: try to acquire the mutex without blocking. If we succeed and
+  // there's room in the queue we can push the task immediately and return
+  // without going through the wait path. This helps when enqueue is called
+  // frequently and the queue is rarely full.
+  {
+    std::unique_lock<std::mutex> lock(m_mutex, std::try_to_lock);
+    if (lock.owns_lock()) {
+      if (m_shutting_down) {
+        return;
+      }
+      if (m_task_queue.size() < m_task_queue_max_size) {
+        m_task_queue.emplace(std::move(function));
+        // Unlock before notifying to avoid waking a thread only to have it
+        // immediately block on the same mutex.
+        lock.unlock();
+        m_task_enqueued_or_shutting_down_condition.notify_one();
+        return;
+      }
+    }
+  }
+
+  // Slow path (existing behavior): wait until there's room in the queue or
+  // the pool is shutting down.
   {
     std::unique_lock<std::mutex> lock(m_mutex);
     m_task_popped_condition.wait(lock, [this] {
