diff --git a/src/quick-lint-js/fe/lex.cpp b/src/quick-lint-js/fe/lex.cpp
index 20763c5f..5211ddac 100644
--- a/src/quick-lint-js/fe/lex.cpp
+++ b/src/quick-lint-js/fe/lex.cpp
@@ -1604,6 +1604,8 @@ const char8* lexer::parse_identifier_fast_only(const char8* input) {
 
 #if QLJS_HAVE_ARM_NEON
   using char_vector = char_vector_16_neon;
+#elif QLJS_HAVE_WASM_SIMD128
+  using char_vector = char_vector_16_wasm;
 #elif QLJS_HAVE_X86_SSE2
   using char_vector = char_vector_16_sse2;
 #else
@@ -1918,7 +1920,10 @@ void lexer::skip_block_comment() {
   QLJS_SLOW_ASSERT(this->input_[0] == '/' && this->input_[1] == '*');
   const char8* c = this->input_ + 2;
 
-#if QLJS_HAVE_X86_SSE2
+#if QLJS_HAVE_WASM_SIMD128
+  using bool_vector = bool_vector_16_wasm;
+  using char_vector = char_vector_16_wasm;
+#elif QLJS_HAVE_X86_SSE2
   using bool_vector = bool_vector_16_sse2;
   using char_vector = char_vector_16_sse2;
 #else
diff --git a/src/quick-lint-js/port/have.h b/src/quick-lint-js/port/have.h
index 1d29ab89..a3fe5a5d 100644
--- a/src/quick-lint-js/port/have.h
+++ b/src/quick-lint-js/port/have.h
@@ -292,6 +292,15 @@
 #endif
 #endif
 
+// Detect WebAssembly SIMD128 support when compiling with -msimd128.
+#if !defined(QLJS_HAVE_WASM_SIMD128)
+#if defined(__wasm_simd128__)
+#define QLJS_HAVE_WASM_SIMD128 1
+#else
+#define QLJS_HAVE_WASM_SIMD128 0
+#endif
+#endif
+
 #if !defined(QLJS_HAVE_X86_SSE2)
 #if defined(_M_AMD64) || defined(_M_X64) || \
     (defined(_M_IX86_FP) && _M_IX86_FP == 2) || defined(__SSE2__)
diff --git a/src/quick-lint-js/port/simd.h b/src/quick-lint-js/port/simd.h
index 124633d6..dac64c8a 100644
--- a/src/quick-lint-js/port/simd.h
+++ b/src/quick-lint-js/port/simd.h
@@ -5,6 +5,7 @@
 #define QUICK_LINT_JS_PORT_SIMD_H
 
 #include <cstdint>
+#include <cstring>
 #include <quick-lint-js/port/attribute.h>
 #include <quick-lint-js/port/bit.h>
 #include <quick-lint-js/port/char8.h>
@@ -101,6 +102,108 @@ class alignas(__m128i) char_vector_16_sse2 {
 };
 #endif
 
+#if QLJS_HAVE_WASM_SIMD128
+class alignas(16) bool_vector_16_wasm {
+ public:
+  static constexpr int size = 16;
+
+  QLJS_FORCE_INLINE explicit bool_vector_16_wasm(const std::uint8_t* data) noexcept {
+    std::memcpy(this->data_, data, 16);
+  }
+
+  QLJS_FORCE_INLINE friend bool_vector_16_wasm operator|(
+      bool_vector_16_wasm x, bool_vector_16_wasm y) noexcept {
+    std::uint8_t r[16];
+    for (int i = 0; i < 16; ++i) r[i] = x.data_[i] | y.data_[i];
+    return bool_vector_16_wasm(r);
+  }
+
+  QLJS_FORCE_INLINE friend bool_vector_16_wasm operator&(
+      bool_vector_16_wasm x, bool_vector_16_wasm y) noexcept {
+    std::uint8_t r[16];
+    for (int i = 0; i < 16; ++i) r[i] = x.data_[i] & y.data_[i];
+    return bool_vector_16_wasm(r);
+  }
+
+  QLJS_FORCE_INLINE int find_first_false() const noexcept {
+    std::uint32_t mask = this->mask();
+    if (~mask == 0) {
+      QLJS_UNREACHABLE();
+    }
+    return countr_one(mask);
+  }
+
+  QLJS_FORCE_INLINE std::uint32_t mask() const noexcept {
+    std::uint32_t mask = 0;
+    for (int i = 0; i < 16; ++i) {
+      if (this->data_[i] != 0) mask |= (1u << i);
+    }
+    return mask;
+  }
+
+ private:
+  std::uint8_t data_[16];
+};
+
+class alignas(16) char_vector_16_wasm {
+ public:
+  static constexpr int size = 16;
+
+  QLJS_FORCE_INLINE explicit char_vector_16_wasm(const std::uint8_t* data) noexcept {
+    std::memcpy(this->data_, data, 16);
+  }
+
+  QLJS_FORCE_INLINE static char_vector_16_wasm load(const char8* data) {
+    return char_vector_16_wasm(reinterpret_cast<const std::uint8_t*>(data));
+  }
+
+  QLJS_FORCE_INLINE static char_vector_16_wasm repeated(std::uint8_t c) {
+    std::uint8_t r[16];
+    for (int i = 0; i < 16; ++i) r[i] = c;
+    return char_vector_16_wasm(r);
+  }
+
+  QLJS_FORCE_INLINE friend char_vector_16_wasm operator|(
+      char_vector_16_wasm x, char_vector_16_wasm y) noexcept {
+    std::uint8_t r[16];
+    for (int i = 0; i < 16; ++i) r[i] = x.data_[i] | y.data_[i];
+    return char_vector_16_wasm(r);
+  }
+
+  QLJS_FORCE_INLINE friend bool_vector_16_wasm operator==(
+      char_vector_16_wasm x, char_vector_16_wasm y) noexcept {
+    std::uint8_t r[16];
+    for (int i = 0; i < 16; ++i) r[i] = (x.data_[i] == y.data_[i]) ? 0xFF : 0x00;
+    return bool_vector_16_wasm(r);
+  }
+
+  QLJS_FORCE_INLINE friend bool_vector_16_wasm operator<(
+      char_vector_16_wasm x, char_vector_16_wasm y) noexcept {
+    std::uint8_t r[16];
+    for (int i = 0; i < 16; ++i) r[i] = (static_cast<int8_t>(x.data_[i]) < static_cast<int8_t>(y.data_[i])) ? 0xFF : 0x00;
+    return bool_vector_16_wasm(r);
+  }
+
+  QLJS_FORCE_INLINE friend bool_vector_16_wasm operator>(
+      char_vector_16_wasm x, char_vector_16_wasm y) noexcept {
+    std::uint8_t r[16];
+    for (int i = 0; i < 16; ++i) r[i] = (static_cast<int8_t>(x.data_[i]) > static_cast<int8_t>(y.data_[i])) ? 0xFF : 0x00;
+    return bool_vector_16_wasm(r);
+  }
+
+  QLJS_FORCE_INLINE std::uint32_t mask() const noexcept {
+    std::uint32_t mask = 0;
+    for (int i = 0; i < 16; ++i) {
+      if (this->data_[i] != 0) mask |= (1u << i);
+    }
+    return mask;
+  }
+
+ private:
+  std::uint8_t data_[16];
+};
+#endif
+
 #if QLJS_HAVE_ARM_NEON
 class alignas(::uint8x16_t) bool_vector_16_neon {
  public:
