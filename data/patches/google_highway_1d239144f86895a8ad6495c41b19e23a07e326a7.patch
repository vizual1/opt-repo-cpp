diff --git a/hwy/targets.cc b/hwy/targets.cc
index 489307db..4fc572d5 100644
--- a/hwy/targets.cc
+++ b/hwy/targets.cc
@@ -351,18 +351,25 @@ HWY_DLLEXPORT uint32_t SupportedTargets() {
 
     // VectorBytes invokes HWY_DYNAMIC_DISPATCH. To prevent infinite recursion,
     // first set up ChosenTarget.
-    chosen.Update(targets);
+    const uint32_t initial_targets = targets;
+    chosen.Update(initial_targets);
 
     // Now that we can call VectorBytes, check for targets with specific sizes.
     const size_t vec_bytes = VectorBytes();  // uncached, see declaration
-    if (HWY_ARCH_ARM_A64 && (targets & HWY_SVE) && vec_bytes == 32) {
-      targets =
-          static_cast<uint32_t>(targets | static_cast<uint32_t>(HWY_SVE_256));
+    uint32_t adjusted_targets;
+    if (HWY_ARCH_ARM_A64 && (initial_targets & HWY_SVE) && vec_bytes == 32) {
+      adjusted_targets =
+          static_cast<uint32_t>(initial_targets | static_cast<uint32_t>(HWY_SVE_256));
     } else {
-      targets =
-          static_cast<uint32_t>(targets & ~static_cast<uint32_t>(HWY_SVE_256));
+      adjusted_targets =
+          static_cast<uint32_t>(initial_targets & ~static_cast<uint32_t>(HWY_SVE_256));
+    }
+    if (adjusted_targets != initial_targets) {
+      chosen.Update(adjusted_targets);
+      targets = adjusted_targets;
+    } else {
+      targets = initial_targets;
     }
-    chosen.Update(targets);
   }
 
   targets &= supported_mask_;
