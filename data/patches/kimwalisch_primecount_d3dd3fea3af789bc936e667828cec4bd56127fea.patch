diff --git a/src/gourdon/LoadBalancerAC.cpp b/src/gourdon/LoadBalancerAC.cpp
index ba8641fc..b7a1be13 100644
--- a/src/gourdon/LoadBalancerAC.cpp
+++ b/src/gourdon/LoadBalancerAC.cpp
@@ -18,6 +18,7 @@
 #include <stdint.h>
 #include <algorithm>
 #include <iostream>
+#include <mutex>
 
 namespace {
 
@@ -78,27 +79,36 @@ LoadBalancerAC::LoadBalancerAC(int64_t sqrtx,
 
 bool LoadBalancerAC::get_work(int64_t& low, int64_t& high)
 {
-  LockGuard lockGuard(lock_);
-
-  if (low_ >= sqrtx_)
-    return false;
-
-  // Most special leaves are below y (~ x^(1/3) * log(x)).
-  // We make sure this interval is evenly distributed
-  // amongst all threads by using a small segment size.
-  // Above y we use a larger segment size but still ensure
-  // that it fits into the CPU's cache.
-  if (low_ > y_)
-    segment_size_ = large_segment_size_;
-
-  low = low_;
-  high = low + segment_size_;
-  high = std::min(high, sqrtx_);
-  low_ = high;
-  segment_nr_++;
-  print_status();
+  // Fast lock-free fetch-and-add for the current low_ offset.
+  // We avoid taking the lock here to reduce contention between threads.
+  while (true)
+  {
+    int64_t cur = __atomic_load_n(&low_, __ATOMIC_RELAXED);
+    if (cur >= sqrtx_)
+      return false;
+
+    int64_t seg = (cur > y_) ? large_segment_size_ : segment_size_;
+    if (seg <= 0)
+      seg = segment_size_;
+
+    int64_t old = __atomic_fetch_add(&low_, seg, __ATOMIC_RELAXED);
+
+    // If another thread moved low_ past sqrtx_ we may get old >= sqrtx_;
+    // in that case there is no work left.
+    if (old >= sqrtx_)
+      return false;
+
+    low = old;
+    high = low + seg;
+    high = std::min(high, sqrtx_);
+
+    __atomic_fetch_add(&segment_nr_, 1, __ATOMIC_RELAXED);
+
+    // Print progress (print_status is made thread-safe).
+    print_status();
 
-  return low < sqrtx_;
+    return low < sqrtx_;
+  }
 }
 
 void LoadBalancerAC::validate_segment_sizes()
@@ -122,17 +132,21 @@ void LoadBalancerAC::compute_total_segments()
 
 void LoadBalancerAC::print_status()
 {
-  if (is_print_)
-  {
-    double time = get_time();
-    double old = time_;
-    double threshold = 0.1;
+  if (!is_print_)
+    return;
 
-    if (old == 0 || (time - old) >= threshold)
-    {
-      time_ = time;
-      std::cout << "\rStatus: " << segment_nr_ << "/" << total_segments_ << std::flush;
-    }
+  static std::mutex print_mtx;
+  std::lock_guard<std::mutex> guard(print_mtx);
+
+  double time = get_time();
+  double old = time_;
+  double threshold = 0.1;
+
+  if (old == 0 || (time - old) >= threshold)
+  {
+    time_ = time;
+    int64_t segnr = __atomic_load_n(&segment_nr_, __ATOMIC_RELAXED);
+    std::cout << "\rStatus: " << segnr << "/" << total_segments_ << std::flush;
   }
 }
 
