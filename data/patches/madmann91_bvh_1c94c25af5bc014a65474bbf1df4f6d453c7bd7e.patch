diff --git a/include/bvh/platform.hpp b/include/bvh/platform.hpp
index 8902954..201b413 100644
--- a/include/bvh/platform.hpp
+++ b/include/bvh/platform.hpp
@@ -18,12 +18,18 @@
 #if defined(__GNUC__) || defined(__clang__)
 #define bvh__restrict__      __restrict
 #define bvh__always_inline__ __attribute__((always_inline))
+#define bvh__likely(x)       __builtin_expect(!!(x), 1)
+#define bvh__unlikely(x)     __builtin_expect(!!(x), 0)
 #elif defined(_MSC_VER)
 #define bvh__restrict__      __restrict
 #define bvh__always_inline__ __forceinline
+#define bvh__likely(x)       (x)
+#define bvh__unlikely(x)     (x)
 #else
 #define bvh__restrict__
 #define bvh__always_inline__
+#define bvh__likely(x)       (x)
+#define bvh__unlikely(x)     (x)
 #endif
 
 #endif
diff --git a/include/bvh/single_ray_traversal.hpp b/include/bvh/single_ray_traversal.hpp
index 2dee776..1850b07 100644
--- a/include/bvh/single_ray_traversal.hpp
+++ b/include/bvh/single_ray_traversal.hpp
@@ -17,7 +17,7 @@ private:
     using Scalar = typename Bvh::ScalarType;
 
     struct Stack {
-        using Element = typename Bvh::IndexType;
+        using Element = const typename Bvh::Node*;
 
         Element elements[stack_size];
         size_t size = 0;
@@ -114,7 +114,7 @@ private:
         // This is generally beneficial for performance because intersections will likely be found which will
         // allow to cull more subtrees with the ray-box test of the traversal loop.
         Stack stack;
-        auto node = bvh.nodes.get();
+        auto node = &bvh.nodes[0];
         while (true) {
             statistics.traversal_steps++;
 
@@ -141,14 +141,14 @@ private:
 
             if (hit_left && hit_right) {
                 int order = distance_left.first < distance_right.first ? 0 : 1;
-                stack.push(first_child + (1 - order));
+                stack.push(&bvh.nodes[first_child + (1 - order)]);
                 node = &bvh.nodes[first_child + order];
             } else if (hit_left ^ hit_right) {
                 node = &bvh.nodes[first_child + (hit_left ? 0 : 1)];
             } else {
                 if (stack.empty())
                     break;
-                node = &bvh.nodes[stack.pop()];
+                node = stack.pop();
             }
         }
 
