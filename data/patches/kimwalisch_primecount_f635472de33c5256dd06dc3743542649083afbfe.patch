diff --git a/src/gourdon/AC.cpp b/src/gourdon/AC.cpp
index 3b3f0ca0..7e93d0e0 100644
--- a/src/gourdon/AC.cpp
+++ b/src/gourdon/AC.cpp
@@ -214,10 +214,9 @@ T AC_OpenMP(T x,
   int64_t xy = x / y;
   int64_t xz = x / z;
 
-  // These load balancing settings work well on my
-  // dual-socket AMD EPYC 7642 server with 192 CPU cores.
-  int64_t thread_threshold = 1000;
-  int max_threads = (int) std::pow(xz, 1 / 3.7);
+  // Tuned load balancing: more aggressive threading for large problems.
+  int64_t thread_threshold = 500;
+  int max_threads = (int) std::pow(xz, 1 / 3.4);
   threads = std::min(threads, max_threads);
   threads = ideal_num_threads(x13, threads, thread_threshold);
   LoadBalancerAC loadBalancer(sqrtx, y, threads, is_print);
diff --git a/src/gourdon/AC_libdivide.cpp b/src/gourdon/AC_libdivide.cpp
index 314f3e08..531be473 100644
--- a/src/gourdon/AC_libdivide.cpp
+++ b/src/gourdon/AC_libdivide.cpp
@@ -323,10 +323,9 @@ T AC_OpenMP(T x,
   int64_t xy = x / y;
   int64_t xz = x / z;
 
-  // These load balancing settings work well on my
-  // dual-socket AMD EPYC 7642 server with 192 CPU cores.
-  int64_t thread_threshold = 1000;
-  int max_threads = (int) std::pow(xz, 1 / 3.7);
+  // Tuned load balancing: more aggressive threading for large problems.
+  int64_t thread_threshold = 500;
+  int max_threads = (int) std::pow(xz, 1 / 3.4);
   threads = std::min(threads, max_threads);
   threads = ideal_num_threads(x13, threads, thread_threshold);
   LoadBalancerAC loadBalancer(sqrtx, y, threads, is_print);
diff --git a/src/gourdon/LoadBalancerAC.cpp b/src/gourdon/LoadBalancerAC.cpp
index df74f985..552de100 100644
--- a/src/gourdon/LoadBalancerAC.cpp
+++ b/src/gourdon/LoadBalancerAC.cpp
@@ -60,6 +60,10 @@ LoadBalancerAC::LoadBalancerAC(int64_t sqrtx,
   if (threads == 1 && !is_print)
     segment_size_ = std::max(x14, l2_segment_size);
 
+  // Enforce that segment_size_ is at least the minimum
+  // but no larger than max_segment_size_. This prevents
+  // creating excessively large segments that could cause
+  // load imbalance.
   segment_size_ = std::max(min_segment_size, segment_size_);
   segment_size_ = SegmentedPiTable::get_segment_size(segment_size_);
 
