diff --git a/src/quick-lint-js/container/vector-profiler-debug.cpp b/src/quick-lint-js/container/vector-profiler-debug.cpp
index ced40727..769dd35e 100644
--- a/src/quick-lint-js/container/vector-profiler-debug.cpp
+++ b/src/quick-lint-js/container/vector-profiler-debug.cpp
@@ -72,21 +72,38 @@ std::vector<vector_instrumentation::entry> vector_instrumentation::entries()
 std::map<std::string, std::map<std::size_t, int>>
 vector_instrumentation::max_size_histogram_by_owner() const {
   std::lock_guard lock(this->mutex_);
+
+  // We avoid constructing std::string keys on every access while processing
+  // entries. Instead, group by the owner pointer (const char*) which should
+  // be stable for a given owner over time. At the end we perform one
+  // std::string construction per owner when building the return value.
   std::map<std::string, std::map<std::size_t, int>> histogram;
-  std::map<std::pair<std::string, std::uintptr_t>, std::size_t> object_sizes;
+  std::map<const char *, std::map<std::size_t, int>> histogram_by_owner_ptr;
+  std::map<std::pair<const char *, std::uintptr_t>, std::size_t> object_sizes;
+
   for (const vector_instrumentation::entry &entry : this->entries_) {
-    std::pair key(entry.owner, entry.object_id);
+    std::pair<const char *, std::uintptr_t> key(entry.owner, entry.object_id);
     std::size_t &object_size = object_sizes[key];
     object_size = std::max(entry.size, object_size);
 
     if (entry.event == event::destroy) {
-      histogram[entry.owner][object_size] += 1;
+      histogram_by_owner_ptr[entry.owner][object_size] += 1;
       object_sizes.erase(key);
     }
   }
-  for (auto &[owner_and_object_id, size] : object_sizes) {
-    histogram[owner_and_object_id.first][size] += 1;
+
+  for (auto &owner_and_size : object_sizes) {
+    const char *owner_ptr = owner_and_size.first.first;
+    std::size_t size = owner_and_size.second;
+    histogram_by_owner_ptr[owner_ptr][size] += 1;
+  }
+
+  // Convert pointer-keyed histogram into the string-keyed result. This does
+  // a single std::string allocation/copy per distinct owner instead of many.
+  for (auto &p : histogram_by_owner_ptr) {
+    histogram.emplace(std::string(p.first), std::move(p.second));
   }
+
   return histogram;
 }
 
