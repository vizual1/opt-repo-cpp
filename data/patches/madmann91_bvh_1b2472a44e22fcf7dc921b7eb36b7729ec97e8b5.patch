diff --git a/include/bvh/sweep_sah_builder.hpp b/include/bvh/sweep_sah_builder.hpp
index b917ecd..5f1a015 100644
--- a/include/bvh/sweep_sah_builder.hpp
+++ b/include/bvh/sweep_sah_builder.hpp
@@ -3,6 +3,11 @@
 
 #include <numeric>
 #include <optional>
+#include <vector>
+#include <cstdint>
+#include <cstring>
+#include <type_traits>
+#include <algorithm>
 
 #include "bvh/bvh.hpp"
 #include "bvh/bounding_box.hpp"
@@ -11,6 +16,115 @@
 
 namespace bvh {
 
+// Radix sort implementation for sorting primitive indices by their center
+template <typename Scalar>
+static inline void radix_sort_indices(size_t* indices, size_t n, const Vector3<Scalar>* centers, int axis) {
+    if (n <= 1) return;
+    using Key32 = uint32_t;
+    using Key64 = uint64_t;
+    constexpr size_t scalar_size = sizeof(Scalar);
+    if constexpr (std::is_floating_point_v<Scalar>) {
+        if constexpr (scalar_size == 4) {
+            using Key = Key32;
+            std::vector<Key> keys(n);
+            for (size_t i = 0; i < n; ++i) {
+                float v = static_cast<float>(centers[indices[i]][axis]);
+                Key k; std::memcpy(&k, &v, sizeof(k));
+                const Key sign = static_cast<Key>(0x80000000u);
+                k = (k & sign) ? ~k : (k ^ sign);
+                keys[i] = k;
+            }
+            std::vector<size_t> tmp(n);
+            std::vector<Key> tmp_keys(n);
+            std::array<size_t, 256> counts{};
+            const size_t passes = sizeof(Key);
+            for (size_t pass = 0; pass < passes; ++pass) {
+                counts.fill(0);
+                size_t shift = pass * 8;
+                for (size_t i = 0; i < n; ++i)
+                    ++counts[(keys[i] >> shift) & 0xFFu];
+                size_t sum = 0;
+                for (size_t i = 0; i < 256; ++i) { size_t c = counts[i]; counts[i] = sum; sum += c; }
+                auto offsets = counts;
+                for (size_t i = 0; i < n; ++i) {
+                    uint8_t byte = static_cast<uint8_t>((keys[i] >> shift) & 0xFFu);
+                    size_t pos = offsets[byte]++;
+                    tmp[pos] = indices[i];
+                    tmp_keys[pos] = keys[i];
+                }
+                // copy back
+                for (size_t i = 0; i < n; ++i) {
+                    indices[i] = tmp[i];
+                    keys[i] = tmp_keys[i];
+                }
+            }
+            return;
+        } else {
+            using Key = Key64;
+            std::vector<Key> keys(n);
+            for (size_t i = 0; i < n; ++i) {
+                double v = static_cast<double>(centers[indices[i]][axis]);
+                Key k; std::memcpy(&k, &v, sizeof(k));
+                const Key sign = static_cast<Key>(0x8000000000000000ull);
+                k = (k & sign) ? ~k : (k ^ sign);
+                keys[i] = k;
+            }
+            std::vector<size_t> tmp(n);
+            std::vector<Key> tmp_keys(n);
+            std::array<size_t, 256> counts{};
+            const size_t passes = sizeof(Key);
+            for (size_t pass = 0; pass < passes; ++pass) {
+                counts.fill(0);
+                size_t shift = pass * 8;
+                for (size_t i = 0; i < n; ++i)
+                    ++counts[(keys[i] >> shift) & 0xFFu];
+                size_t sum = 0;
+                for (size_t i = 0; i < 256; ++i) { size_t c = counts[i]; counts[i] = sum; sum += c; }
+                auto offsets = counts;
+                for (size_t i = 0; i < n; ++i) {
+                    uint8_t byte = static_cast<uint8_t>((keys[i] >> shift) & 0xFFu);
+                    size_t pos = offsets[byte]++;
+                    tmp[pos] = indices[i];
+                    tmp_keys[pos] = keys[i];
+                }
+                for (size_t i = 0; i < n; ++i) {
+                    indices[i] = tmp[i];
+                    keys[i] = tmp_keys[i];
+                }
+            }
+            return;
+        }
+    } else {
+        using Unsigned = std::make_unsigned_t<Scalar>;
+        using Key = std::conditional_t<sizeof(Unsigned) <= 4, Key32, Key64>;
+        std::vector<Key> keys(n);
+        for (size_t i = 0; i < n; ++i) keys[i] = static_cast<Key>(static_cast<Unsigned>(centers[indices[i]][axis]));
+        std::vector<size_t> tmp(n);
+        std::vector<Key> tmp_keys(n);
+        std::array<size_t, 256> counts{};
+        const size_t passes = sizeof(Key);
+        for (size_t pass = 0; pass < passes; ++pass) {
+            counts.fill(0);
+            size_t shift = pass * 8;
+            for (size_t i = 0; i < n; ++i)
+                ++counts[(keys[i] >> shift) & 0xFFu];
+            size_t sum = 0;
+            for (size_t i = 0; i < 256; ++i) { size_t c = counts[i]; counts[i] = sum; sum += c; }
+            auto offsets = counts;
+            for (size_t i = 0; i < n; ++i) {
+                uint8_t byte = static_cast<uint8_t>((keys[i] >> shift) & 0xFFu);
+                size_t pos = offsets[byte]++;
+                tmp[pos] = indices[i];
+                tmp_keys[pos] = keys[i];
+            }
+            for (size_t i = 0; i < n; ++i) {
+                indices[i] = tmp[i];
+                keys[i] = tmp_keys[i];
+            }
+        }
+    }
+}
+
 template <typename> class SweepSahBuildTask;
 
 /// This is a top-down, full-sweep SAH-based BVH builder. Primitives are only
@@ -72,9 +186,8 @@ public:
             #pragma omp for
             for (int axis = 0; axis < 3; ++axis) {
                 std::iota(references[axis], references[axis] + primitive_count, 0);
-                std::sort(references[axis], references[axis] + primitive_count, [&] (size_t i, size_t j) {
-                    return centers[i][axis] < centers[j][axis];
-                });
+                // Radix-sort the indices by their center coordinate along `axis`.
+                radix_sort_indices<Scalar>(references[axis], primitive_count, centers, axis);
             }
 
             #pragma omp single
