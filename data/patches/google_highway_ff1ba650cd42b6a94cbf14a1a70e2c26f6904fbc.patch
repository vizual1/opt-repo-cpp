diff --git a/hwy/contrib/sort/sorting_networks-inl.h b/hwy/contrib/sort/sorting_networks-inl.h
index 3aff2f9d..36bd58fb 100644
--- a/hwy/contrib/sort/sorting_networks-inl.h
+++ b/hwy/contrib/sort/sorting_networks-inl.h
@@ -76,12 +76,12 @@ struct SharedTraits : public Base {
 // https://bertdobbelaere.github.io/sorting_networks.html.
 
 template <class D, class Traits, class V = Vec<D>>
-HWY_INLINE void Sort2(D d, Traits st, V& v0, V& v1) {
+HWY_INLINE void Sort2(D d, const Traits& st, V& v0, V& v1) {
   st.Sort2(d, v0, v1);
 }
 
 template <class D, class Traits, class V = Vec<D>>
-HWY_INLINE void Sort4(D d, Traits st, V& v0, V& v1, V& v2, V& v3) {
+HWY_INLINE void Sort4(D d, const Traits& st, V& v0, V& v1, V& v2, V& v3) {
   st.Sort2(d, v0, v2);
   st.Sort2(d, v1, v3);
   st.Sort2(d, v0, v1);
@@ -90,7 +90,7 @@ HWY_INLINE void Sort4(D d, Traits st, V& v0, V& v1, V& v2, V& v3) {
 }
 
 template <class D, class Traits, class V = Vec<D>>
-HWY_INLINE void Sort8(D d, Traits st, V& v0, V& v1, V& v2, V& v3, V& v4, V& v5,
+HWY_INLINE void Sort8(D d, const Traits& st, V& v0, V& v1, V& v2, V& v3, V& v4, V& v5,
                       V& v6, V& v7) {
   st.Sort2(d, v0, v2);
   st.Sort2(d, v1, v3);
@@ -120,7 +120,7 @@ HWY_INLINE void Sort8(D d, Traits st, V& v0, V& v1, V& v2, V& v3, V& v4, V& v5,
 
 // (Green's irregular) sorting network for independent columns in 16 vectors.
 template <class D, class Traits, class V = Vec<D>>
-HWY_INLINE void Sort16(D d, Traits st, V& v0, V& v1, V& v2, V& v3, V& v4, V& v5,
+HWY_INLINE void Sort16(D d, const Traits& st, V& v0, V& v1, V& v2, V& v3, V& v4, V& v5,
                        V& v6, V& v7, V& v8, V& v9, V& va, V& vb, V& vc, V& vd,
                        V& ve, V& vf) {
   st.Sort2(d, v0, v1);
@@ -190,7 +190,7 @@ HWY_INLINE void Sort16(D d, Traits st, V& v0, V& v1, V& v2, V& v3, V& v4, V& v5,
 // Blacher's hybrid bitonic/odd-even networks, generated by print_network.cc.
 
 template <class D, class Traits, class V = Vec<D>>
-HWY_INLINE void Merge8x2(D d, Traits st, V& v0, V& v1, V& v2, V& v3, V& v4,
+HWY_INLINE void Merge8x2(D d, const Traits& st, V& v0, V& v1, V& v2, V& v3, V& v4,
                          V& v5, V& v6, V& v7) {
   v7 = st.ReverseKeys2(d, v7);
   v6 = st.ReverseKeys2(d, v6);
@@ -230,7 +230,7 @@ HWY_INLINE void Merge8x2(D d, Traits st, V& v0, V& v1, V& v2, V& v3, V& v4,
 }
 
 template <class D, class Traits, class V = Vec<D>>
-HWY_INLINE void Merge8x4(D d, Traits st, V& v0, V& v1, V& v2, V& v3, V& v4,
+HWY_INLINE void Merge8x4(D d, const Traits& st, V& v0, V& v1, V& v2, V& v3, V& v4,
                          V& v5, V& v6, V& v7) {
   v7 = st.ReverseKeys4(d, v7);
   v6 = st.ReverseKeys4(d, v6);
@@ -279,7 +279,7 @@ HWY_INLINE void Merge8x4(D d, Traits st, V& v0, V& v1, V& v2, V& v3, V& v4,
 }
 
 template <class D, class Traits, class V = Vec<D>>
-HWY_INLINE void Merge16x2(D d, Traits st, V& v0, V& v1, V& v2, V& v3, V& v4,
+HWY_INLINE void Merge16x2(D d, const Traits& st, V& v0, V& v1, V& v2, V& v3, V& v4,
                           V& v5, V& v6, V& v7, V& v8, V& v9, V& va, V& vb,
                           V& vc, V& vd, V& ve, V& vf) {
   vf = st.ReverseKeys2(d, vf);
@@ -369,7 +369,7 @@ HWY_INLINE void Merge16x2(D d, Traits st, V& v0, V& v1, V& v2, V& v3, V& v4,
 }
 
 template <class D, class Traits, class V = Vec<D>>
-HWY_INLINE void Merge16x4(D d, Traits st, V& v0, V& v1, V& v2, V& v3, V& v4,
+HWY_INLINE void Merge16x4(D d, const Traits& st, V& v0, V& v1, V& v2, V& v3, V& v4,
                           V& v5, V& v6, V& v7, V& v8, V& v9, V& va, V& vb,
                           V& vc, V& vd, V& ve, V& vf) {
   vf = st.ReverseKeys4(d, vf);
@@ -476,7 +476,7 @@ HWY_INLINE void Merge16x4(D d, Traits st, V& v0, V& v1, V& v2, V& v3, V& v4,
 }
 
 template <class D, class Traits, class V = Vec<D>>
-HWY_INLINE void Merge16x8(D d, Traits st, V& v0, V& v1, V& v2, V& v3, V& v4,
+HWY_INLINE void Merge16x8(D d, const Traits& st, V& v0, V& v1, V& v2, V& v3, V& v4,
                           V& v5, V& v6, V& v7, V& v8, V& v9, V& va, V& vb,
                           V& vc, V& vd, V& ve, V& vf) {
   vf = st.ReverseKeys8(d, vf);
@@ -603,7 +603,7 @@ HWY_INLINE void Merge16x8(D d, Traits st, V& v0, V& v1, V& v2, V& v3, V& v4,
 #if !HWY_COMPILER_MSVC && !HWY_IS_DEBUG_BUILD
 
 template <class D, class Traits, class V = Vec<D>>
-HWY_INLINE void Merge16x16(D d, Traits st, V& v0, V& v1, V& v2, V& v3, V& v4,
+HWY_INLINE void Merge16x16(D d, const Traits& st, V& v0, V& v1, V& v2, V& v3, V& v4,
                            V& v5, V& v6, V& v7, V& v8, V& v9, V& va, V& vb,
                            V& vc, V& vd, V& ve, V& vf) {
   vf = st.ReverseKeys16(d, vf);
@@ -756,7 +756,7 @@ HWY_INLINE void Merge16x16(D d, Traits st, V& v0, V& v1, V& v2, V& v3, V& v4,
 // https://github.com/simd-sorting/fast-and-robust/blob/master/avx2_sort_demo/avx2sort.h
 // M. Blacher's thesis: https://github.com/mark-blacher/masterthesis
 template <class Traits, class V>
-HWY_INLINE void SortingNetwork(Traits st, size_t cols, V& v0, V& v1, V& v2,
+HWY_INLINE void SortingNetwork(const Traits& st, size_t cols, V& v0, V& v1, V& v2,
                                V& v3, V& v4, V& v5, V& v6, V& v7, V& v8, V& v9,
                                V& va, V& vb, V& vc, V& vd, V& ve, V& vf) {
   // traits*-inl assume 'full' vectors (but still capped to kMaxCols).
@@ -804,7 +804,7 @@ HWY_INLINE void SortingNetwork(Traits st, size_t cols, V& v0, V& v1, V& v2,
 //
 // NOINLINE because this is large and called twice from vqsort-inl.h.
 template <class Traits, typename T>
-HWY_NOINLINE void SortingNetwork(Traits st, T* HWY_RESTRICT buf, size_t cols) {
+HWY_NOINLINE void SortingNetwork(const Traits& st, T* HWY_RESTRICT buf, size_t cols) {
   // traits*-inl assume 'full' vectors (but still capped to kMaxCols).
   // However, for smaller arrays and sub-maximal `cols` we have overlapping
   // loads where only the lowest `cols` are valid, and we skip Merge16 etc.
diff --git a/hwy/contrib/sort/vqsort-inl.h b/hwy/contrib/sort/vqsort-inl.h
index eee809c3..6a3ec7bd 100644
--- a/hwy/contrib/sort/vqsort-inl.h
+++ b/hwy/contrib/sort/vqsort-inl.h
@@ -73,7 +73,7 @@ HWY_INLINE void MaybePrintVector(D d, const char* label, Vec<D> v,
 // ------------------------------ HeapSort
 
 template <class Traits, typename T>
-void SiftDown(Traits st, T* HWY_RESTRICT lanes, const size_t num_lanes,
+void SiftDown(const Traits& st, T* HWY_RESTRICT lanes, const size_t num_lanes,
               size_t start) {
   constexpr size_t N1 = st.LanesPerKey();
   const FixedTag<T, N1> d;
@@ -101,7 +101,7 @@ void SiftDown(Traits st, T* HWY_RESTRICT lanes, const size_t num_lanes,
 // Heapsort: O(1) space, O(N*logN) worst-case comparisons.
 // Based on LLVM sanitizer_common.h, licensed under Apache-2.0.
 template <class Traits, typename T>
-void HeapSort(Traits st, T* HWY_RESTRICT lanes, const size_t num_lanes) {
+void HeapSort(const Traits& st, T* HWY_RESTRICT lanes, const size_t num_lanes) {
   constexpr size_t N1 = st.LanesPerKey();
 
   if (num_lanes < 2 * N1) return;
@@ -126,7 +126,7 @@ void HeapSort(Traits st, T* HWY_RESTRICT lanes, const size_t num_lanes) {
 
 // Special cases where `num_lanes` is in the specified range (inclusive).
 template <class Traits, typename T>
-HWY_INLINE void Sort2To2(Traits st, T* HWY_RESTRICT keys, size_t num_lanes,
+HWY_INLINE void Sort2To2(const Traits& st, T* HWY_RESTRICT keys, size_t num_lanes,
                          size_t /* ceil_log2 */, T* HWY_RESTRICT /* buf */) {
   constexpr size_t kLPK = st.LanesPerKey();
   const size_t num_keys = num_lanes / kLPK;
@@ -147,7 +147,7 @@ HWY_INLINE void Sort2To2(Traits st, T* HWY_RESTRICT keys, size_t num_lanes,
 }
 
 template <class Traits, typename T>
-HWY_INLINE void Sort3To4(Traits st, T* HWY_RESTRICT keys, size_t num_lanes,
+HWY_INLINE void Sort3To4(const Traits& st, T* HWY_RESTRICT keys, size_t num_lanes,
                          size_t /* ceil_log2 */, T* HWY_RESTRICT buf) {
   constexpr size_t kLPK = st.LanesPerKey();
   const size_t num_keys = num_lanes / kLPK;
@@ -181,7 +181,7 @@ HWY_INLINE void Sort3To4(Traits st, T* HWY_RESTRICT keys, size_t num_lanes,
 }
 
 template <class Traits, typename T>
-HWY_NOINLINE void Sort8Rows(Traits st, T* HWY_RESTRICT keys, size_t num_lanes,
+HWY_NOINLINE void Sort8Rows(const Traits& st, T* HWY_RESTRICT keys, size_t num_lanes,
                             size_t ceil_log2, T* HWY_RESTRICT buf) {
   constexpr size_t kLPK = st.LanesPerKey();
   const size_t num_keys = num_lanes / kLPK;
@@ -330,7 +330,7 @@ HWY_NOINLINE void Sort8Rows(Traits st, T* HWY_RESTRICT keys, size_t num_lanes,
 }
 
 template <class Traits, typename T>
-HWY_NOINLINE void Sort16Rows(Traits st, T* HWY_RESTRICT keys, size_t num_lanes,
+HWY_NOINLINE void Sort16Rows(const Traits& st, T* HWY_RESTRICT keys, size_t num_lanes,
                              size_t ceil_log2, T* HWY_RESTRICT buf) {
   constexpr size_t kLPK = st.LanesPerKey();
   const size_t num_keys = num_lanes / kLPK;
@@ -528,7 +528,7 @@ HWY_NOINLINE void Sort16Rows(Traits st, T* HWY_RESTRICT keys, size_t num_lanes,
 //
 // See M. Blacher's thesis: https://github.com/mark-blacher/masterthesis
 template <class D, class Traits, typename T>
-HWY_NOINLINE void BaseCase(D d, Traits st, T* HWY_RESTRICT keys,
+HWY_NOINLINE void BaseCase(D d, const Traits& st, T* HWY_RESTRICT keys,
                            size_t num_lanes, T* buf) {
   constexpr size_t kLPK = st.LanesPerKey();
   HWY_DASSERT(num_lanes <= Constants::BaseCaseNumLanes<kLPK>(Lanes(d)));
@@ -568,7 +568,7 @@ HWY_NOINLINE void BaseCase(D d, Traits st, T* HWY_RESTRICT keys,
 // Temporarily stores the right side into `buf`, then moves behind `num`.
 // Returns the number of keys consumed from the left side.
 template <class D, class Traits, class T>
-HWY_INLINE size_t PartitionToMultipleOfUnroll(D d, Traits st,
+HWY_INLINE size_t PartitionToMultipleOfUnroll(D d, const Traits& st,
                                               T* HWY_RESTRICT keys, size_t& num,
                                               const Vec<D> pivot,
                                               T* HWY_RESTRICT buf) {
@@ -623,7 +623,7 @@ V OrXor(const V o, const V x1, const V x2) {
 // Note: we could track the OrXor of v and pivot to see if the entire left
 // partition is equal, but that happens rarely and thus is a net loss.
 template <class D, class Traits, typename T>
-HWY_INLINE void StoreLeftRight(D d, Traits st, const Vec<D> v,
+HWY_INLINE void StoreLeftRight(D d, const Traits& st, const Vec<D> v,
                                const Vec<D> pivot, T* HWY_RESTRICT keys,
                                size_t& writeL, size_t& remaining) {
   const size_t N = Lanes(d);
@@ -657,7 +657,7 @@ HWY_INLINE void StoreLeftRight(D d, Traits st, const Vec<D> v,
 }
 
 template <class D, class Traits, typename T>
-HWY_INLINE void StoreLeftRight4(D d, Traits st, const Vec<D> v0,
+HWY_INLINE void StoreLeftRight4(D d, const Traits& st, const Vec<D> v0,
                                 const Vec<D> v1, const Vec<D> v2,
                                 const Vec<D> v3, const Vec<D> pivot,
                                 T* HWY_RESTRICT keys, size_t& writeL,
@@ -673,7 +673,7 @@ HWY_INLINE void StoreLeftRight4(D d, Traits st, const Vec<D> v0,
 //
 // Aligned loads do not seem to be worthwhile (not bottlenecked by load ports).
 template <class D, class Traits, typename T>
-HWY_INLINE size_t Partition(D d, Traits st, T* HWY_RESTRICT keys, size_t num,
+HWY_INLINE size_t Partition(D d, const Traits& st, T* HWY_RESTRICT keys, size_t num,
                             const Vec<D> pivot, T* HWY_RESTRICT buf) {
   using V = decltype(Zero(d));
   const size_t N = Lanes(d);
@@ -824,7 +824,7 @@ HWY_INLINE size_t Partition(D d, Traits st, T* HWY_RESTRICT keys, size_t num,
 // been reordered and a regular Partition is still necessary.
 // Called from two locations, hence NOINLINE.
 template <class D, class Traits, typename T>
-HWY_NOINLINE bool MaybePartitionTwoValue(D d, Traits st, T* HWY_RESTRICT keys,
+HWY_NOINLINE bool MaybePartitionTwoValue(D d, const Traits& st, T* HWY_RESTRICT keys,
                                          size_t num, const Vec<D> valueL,
                                          const Vec<D> valueR, Vec<D>& third,
                                          T* HWY_RESTRICT buf) {
@@ -910,7 +910,7 @@ HWY_NOINLINE bool MaybePartitionTwoValue(D d, Traits st, T* HWY_RESTRICT keys,
 
 // Same as above, except that the pivot equals valueR, so scan right to left.
 template <class D, class Traits, typename T>
-HWY_INLINE bool MaybePartitionTwoValueR(D d, Traits st, T* HWY_RESTRICT keys,
+HWY_INLINE bool MaybePartitionTwoValueR(D d, const Traits& st, T* HWY_RESTRICT keys,
                                         size_t num, const Vec<D> valueL,
                                         const Vec<D> valueR, Vec<D>& third,
                                         T* HWY_RESTRICT buf) {
@@ -1014,7 +1014,7 @@ HWY_INLINE bool MaybePartitionTwoValueR(D d, Traits st, T* HWY_RESTRICT keys,
 // when all samples are equal. Returns false if there are at least a third
 // value and sets `third`. Otherwise, partitions the array and returns true.
 template <class D, class Traits, typename T>
-HWY_INLINE bool PartitionIfTwoKeys(D d, Traits st, const Vec<D> pivot,
+HWY_INLINE bool PartitionIfTwoKeys(D d, const Traits& st, const Vec<D> pivot,
                                    T* HWY_RESTRICT keys, size_t num,
                                    const size_t idx_second, const Vec<D> second,
                                    Vec<D>& third, T* HWY_RESTRICT buf) {
@@ -1038,7 +1038,7 @@ HWY_INLINE bool PartitionIfTwoKeys(D d, Traits st, const Vec<D> pivot,
 // Second path into `MaybePartitionTwoValue`, called when not all samples are
 // equal. `samples` is sorted.
 template <class D, class Traits, typename T>
-HWY_INLINE bool PartitionIfTwoSamples(D d, Traits st, T* HWY_RESTRICT keys,
+HWY_INLINE bool PartitionIfTwoSamples(D d, const Traits& st, T* HWY_RESTRICT keys,
                                       size_t num, T* HWY_RESTRICT samples) {
   constexpr size_t kSampleLanes = Constants::SampleLanes<T>();
   constexpr size_t N1 = st.LanesPerKey();
@@ -1063,7 +1063,7 @@ HWY_INLINE bool PartitionIfTwoSamples(D d, Traits st, T* HWY_RESTRICT keys,
 // ------------------------------ Pivot sampling
 
 template <class Traits, class V>
-HWY_INLINE V MedianOf3(Traits st, V v0, V v1, V v2) {
+HWY_INLINE V MedianOf3(const Traits& st, V v0, V v1, V v2) {
   const DFromV<V> d;
   // Slightly faster for 128-bit, apparently because not serially dependent.
   if (st.Is128()) {
@@ -1103,7 +1103,7 @@ HWY_INLINE size_t RandomChunkIndex(const uint32_t num_chunks, uint32_t bits) {
 
 // Writes samples from `keys[0, num)` into `buf`.
 template <class D, class Traits, typename T>
-HWY_INLINE void DrawSamples(D d, Traits st, T* HWY_RESTRICT keys, size_t num,
+HWY_INLINE void DrawSamples(D d, const Traits& st, T* HWY_RESTRICT keys, size_t num,
                             T* HWY_RESTRICT buf, uint64_t* HWY_RESTRICT state) {
   using V = decltype(Zero(d));
   const size_t N = Lanes(d);
@@ -1157,7 +1157,7 @@ HWY_INLINE void DrawSamples(D d, Traits st, T* HWY_RESTRICT keys, size_t num,
 
 // For detecting inputs where (almost) all keys are equal.
 template <class D, class Traits>
-HWY_INLINE bool UnsortedSampleEqual(D d, Traits st,
+HWY_INLINE bool UnsortedSampleEqual(D d, const Traits& st,
                                     const TFromD<D>* HWY_RESTRICT samples) {
   constexpr size_t kSampleLanes = Constants::SampleLanes<TFromD<D>>();
   const size_t N = Lanes(d);
@@ -1177,7 +1177,7 @@ HWY_INLINE bool UnsortedSampleEqual(D d, Traits st,
 }
 
 template <class D, class Traits, typename T>
-HWY_INLINE void SortSamples(D d, Traits st, T* HWY_RESTRICT buf) {
+HWY_INLINE void SortSamples(D d, const Traits& st, T* HWY_RESTRICT buf) {
   const size_t N = Lanes(d);
   constexpr size_t kSampleLanes = Constants::SampleLanes<T>();
   // Network must be large enough to sort two chunks.
@@ -1218,7 +1218,7 @@ HWY_INLINE const char* PivotResultString(PivotResult result) {
 
 // (Could vectorize, but only 0.2% of total time)
 template <class Traits, typename T>
-HWY_INLINE size_t PivotRank(Traits st, const T* HWY_RESTRICT samples) {
+HWY_INLINE size_t PivotRank(const Traits& st, const T* HWY_RESTRICT samples) {
   constexpr size_t kSampleLanes = Constants::SampleLanes<T>();
   constexpr size_t N1 = st.LanesPerKey();
 
@@ -1252,7 +1252,7 @@ HWY_INLINE size_t PivotRank(Traits st, const T* HWY_RESTRICT samples) {
 // Returns pivot chosen from `samples`. It will never be the largest key
 // (thus the right partition will never be empty).
 template <class D, class Traits, typename T>
-HWY_INLINE Vec<D> ChoosePivotByRank(D d, Traits st,
+HWY_INLINE Vec<D> ChoosePivotByRank(D d, const Traits& st,
                                     const T* HWY_RESTRICT samples) {
   const size_t pivot_rank = PivotRank(st, samples);
   const Vec<D> pivot = st.SetKey(d, samples + pivot_rank);
@@ -1273,7 +1273,7 @@ HWY_INLINE Vec<D> ChoosePivotByRank(D d, Traits st,
 // Returns true if all keys equal `pivot`, otherwise returns false and sets
 // `*first_mismatch' to the index of the first differing key.
 template <class D, class Traits, typename T>
-HWY_INLINE bool AllEqual(D d, Traits st, const Vec<D> pivot,
+HWY_INLINE bool AllEqual(D d, const Traits& st, const Vec<D> pivot,
                          const T* HWY_RESTRICT keys, size_t num,
                          size_t* HWY_RESTRICT first_mismatch) {
   const size_t N = Lanes(d);
@@ -1364,7 +1364,7 @@ HWY_INLINE bool AllEqual(D d, Traits st, const Vec<D> pivot,
 
 // Called from 'two locations', but only one is active (IsKV is constexpr).
 template <class D, class Traits, typename T>
-HWY_INLINE bool ExistsAnyBefore(D d, Traits st, const T* HWY_RESTRICT keys,
+HWY_INLINE bool ExistsAnyBefore(D d, const Traits& st, const T* HWY_RESTRICT keys,
                                 size_t num, const Vec<D> pivot) {
   const size_t N = Lanes(d);
   HWY_DASSERT(num >= N);  // See HandleSpecialCases
@@ -1422,7 +1422,7 @@ HWY_INLINE bool ExistsAnyBefore(D d, Traits st, const T* HWY_RESTRICT keys,
 
 // Called from 'two locations', but only one is active (IsKV is constexpr).
 template <class D, class Traits, typename T>
-HWY_INLINE bool ExistsAnyAfter(D d, Traits st, const T* HWY_RESTRICT keys,
+HWY_INLINE bool ExistsAnyAfter(D d, const Traits& st, const T* HWY_RESTRICT keys,
                                size_t num, const Vec<D> pivot) {
   const size_t N = Lanes(d);
   HWY_DASSERT(num >= N);  // See HandleSpecialCases
@@ -1481,7 +1481,7 @@ HWY_INLINE bool ExistsAnyAfter(D d, Traits st, const T* HWY_RESTRICT keys,
 // Returns pivot chosen from `keys[0, num)`. It will never be the largest key
 // (thus the right partition will never be empty).
 template <class D, class Traits, typename T>
-HWY_INLINE Vec<D> ChoosePivotForEqualSamples(D d, Traits st,
+HWY_INLINE Vec<D> ChoosePivotForEqualSamples(D d, const Traits& st,
                                              T* HWY_RESTRICT keys, size_t num,
                                              T* HWY_RESTRICT samples,
                                              Vec<D> second, Vec<D> third,
@@ -1569,7 +1569,7 @@ HWY_INLINE Vec<D> ChoosePivotForEqualSamples(D d, Traits st,
 // ------------------------------ Quicksort recursion
 
 template <class D, class Traits, typename T>
-HWY_NOINLINE void PrintMinMax(D d, Traits st, const T* HWY_RESTRICT keys,
+HWY_NOINLINE void PrintMinMax(D d, const Traits& st, const T* HWY_RESTRICT keys,
                               size_t num, T* HWY_RESTRICT buf) {
   if (VQSORT_PRINT >= 2) {
     const size_t N = Lanes(d);
@@ -1599,7 +1599,7 @@ HWY_NOINLINE void PrintMinMax(D d, Traits st, const T* HWY_RESTRICT keys,
 }
 
 template <class D, class Traits, typename T>
-HWY_NOINLINE void Recurse(D d, Traits st, T* HWY_RESTRICT keys,
+HWY_NOINLINE void Recurse(D d, const Traits& st, T* HWY_RESTRICT keys,
                           const size_t num, T* HWY_RESTRICT buf,
                           uint64_t* HWY_RESTRICT state,
                           const size_t remaining_levels) {
@@ -1699,7 +1699,7 @@ HWY_NOINLINE void Recurse(D d, Traits st, T* HWY_RESTRICT keys,
 
 // Returns true if sorting is finished.
 template <class D, class Traits, typename T>
-HWY_INLINE bool HandleSpecialCases(D d, Traits st, T* HWY_RESTRICT keys,
+HWY_INLINE bool HandleSpecialCases(D d, const Traits& st, T* HWY_RESTRICT keys,
                                    size_t num, T* HWY_RESTRICT buf) {
   const size_t N = Lanes(d);
   constexpr size_t kLPK = st.LanesPerKey();
@@ -1745,7 +1745,7 @@ HWY_INLINE bool HandleSpecialCases(D d, Traits st, T* HWY_RESTRICT keys,
 // `buf` must be vector-aligned and hold at least
 // SortConstants::BufBytes(HWY_MAX_BYTES, st.LanesPerKey()).
 template <class D, class Traits, typename T>
-void Sort(D d, Traits st, T* HWY_RESTRICT keys, size_t num,
+void Sort(D d, const Traits& st, T* HWY_RESTRICT keys, size_t num,
           T* HWY_RESTRICT buf) {
   if (VQSORT_PRINT >= 1) {
     fprintf(stderr, "=============== Sort num %zu\n", num);
@@ -1788,7 +1788,7 @@ void Sort(D d, Traits st, T* HWY_RESTRICT keys, size_t num,
 // `st` is SharedTraits<Traits*<Order*>>. This abstraction layer bridges
 //   differences in sort order and single-lane vs 128-bit keys.
 template <class D, class Traits, typename T>
-HWY_API void Sort(D d, Traits st, T* HWY_RESTRICT keys, size_t num) {
+HWY_API void Sort(D d, const Traits& st, T* HWY_RESTRICT keys, size_t num) {
   constexpr size_t kLPK = st.LanesPerKey();
   HWY_ALIGN T buf[SortConstants::BufBytes<T, kLPK>(HWY_MAX_BYTES) / sizeof(T)];
   return Sort(d, st, keys, num, buf);
