{
  "metadata": {
    "collection_date": "2026-01-14T18:41:20.684721",
    "repository": "https://github.com/google/highway",
    "repository_name": "google/highway"
  },
  "commit_info": {
    "old_sha": "57ebd2049335330a49901077bca7425336eb952b",
    "new_sha": "f3f08cff25b8882e6b0b9e90dc7c77471390d858",
    "commit_message": [
      "1.04x geomean, up to 1.2x: reduce scanning, support leftward 2value\n\nPiperOrigin-RevId: 480549350"
    ],
    "commit_date": "2022-10-12T07:35:51+00:00",
    "patch": [
      "--- hwy/contrib/sort/vqsort-inl.h\n@@ -460,12 +460,12 @@ HWY_NOINLINE size_t Partition(D d, Traits st, T* HWY_RESTRICT keys, size_t left,\n }\n \n // Returns true and partitions if [keys, keys + num) contains only {valueL,\n-// valueR}. Otherwise, keys may have been modified and a regular Partition is\n-// still necessary.\n+// valueR}. Otherwise, sets third to the first differing value; keys may have\n+// been reordered and a regular Partition is still necessary.\n template <class D, class Traits, typename T>\n HWY_NOINLINE bool MaybePartitionTwoValue(D d, Traits st, T* HWY_RESTRICT keys,\n                                          size_t num, const Vec<D> valueL,\n-                                         const Vec<D> valueR,\n+                                         const Vec<D> valueR, Vec<D>& third,\n                                          T* HWY_RESTRICT buf) {\n   const size_t N = Lanes(d);\n \n@@ -482,10 +482,14 @@ HWY_NOINLINE bool MaybePartitionTwoValue(D d, Traits st, T* HWY_RESTRICT keys,\n     const Mask<D> eqL = st.EqualKeys(d, v, valueL);\n     const Mask<D> eqR = st.EqualKeys(d, v, valueR);\n     // At least one other value present; will require a regular partition.\n-    // On AVX-512, Or + AllTrue are folded into a single kortest.\n+    // On AVX-512, Or + AllTrue are folded into a single kortest, but not if\n+    // `Or(eqL, eqR)` is an lvalue.\n     if (HWY_UNLIKELY(!AllTrue(d, Or(eqL, eqR)))) {\n+      const intptr_t lane = FindFirstTrue(d, Not(Or(eqL, eqR)));\n+      HWY_DASSERT(lane >= 0);\n+      third = st.SetKey(d, keys + i + static_cast<size_t>(lane));\n       if (VQSORT_PRINT >= 2) {\n-        fprintf(stderr, \"found 3rd value at %zu; writeL %zu\\n\", i, writeL);\n+        fprintf(stderr, \"found 3rd value at vec %zu; writeL %zu\\n\", i, writeL);\n       }\n       // 'Undo' what we did by filling the remainder of what we read with R.\n       for (; writeL + N <= i; writeL += N) {\n@@ -509,8 +513,11 @@ HWY_NOINLINE bool MaybePartitionTwoValue(D d, Traits st, T* HWY_RESTRICT keys,\n   const Mask<D> eq = Or(Or(eqL, eqR), Not(valid));\n   // At least one other value present; will require a regular partition.\n   if (HWY_UNLIKELY(!AllTrue(d, eq))) {\n+    const intptr_t lane = FindFirstTrue(d, Not(eq));\n+    HWY_DASSERT(lane >= 0);\n+    third = st.SetKey(d, keys + i + static_cast<size_t>(lane));\n     if (VQSORT_PRINT >= 2) {\n-      fprintf(stderr, \"found 3rd value at partial %zu; writeL %zu\\n\", i,\n+      fprintf(stderr, \"found 3rd value at partial vec %zu; writeL %zu\\n\", i,\n               writeL);\n     }\n     // 'Undo' what we did by filling the remainder of what we read with R.\n@@ -536,30 +543,136 @@ HWY_NOINLINE bool MaybePartitionTwoValue(D d, Traits st, T* HWY_RESTRICT keys,\n   return true;\n }\n \n+// Same as above, except that the pivot equals valueR, so scan right to left.\n+template <class D, class Traits, typename T>\n+HWY_NOINLINE bool MaybePartitionTwoValueR(D d, Traits st, T* HWY_RESTRICT keys,\n+                                          size_t num, const Vec<D> valueL,\n+                                          const Vec<D> valueR, Vec<D>& third,\n+                                          T* HWY_RESTRICT buf) {\n+  const size_t N = Lanes(d);\n+\n+  HWY_DASSERT(num >= N);\n+  size_t pos = num - N;  // current read/write position\n+  size_t countR = 0;     // number of valueR found\n+\n+  // For whole vectors, in descending address order: as long as all lanes are\n+  // equal to L or R, overwrite with valueR. This is faster than counting, then\n+  // filling both L and R. Loop terminates after unsigned wraparound.\n+  for (; pos < num; pos -= N) {\n+    const Vec<D> v = LoadU(d, keys + pos);\n+    // It is not clear how to apply OrXor here - that can check if *both*\n+    // comparisons are true, but here we want *either*. Comparing the unsigned\n+    // min of differences to zero works, but is expensive for u64 prior to AVX3.\n+    const Mask<D> eqL = st.EqualKeys(d, v, valueL);\n+    const Mask<D> eqR = st.EqualKeys(d, v, valueR);\n+    // If there is a third value, stop and undo what we've done. On AVX-512,\n+    // Or + AllTrue are folded into a single kortest, but not if `Or(eqL, eqR)\n+    // is an lvalue.\n+    if (HWY_UNLIKELY(!AllTrue(d, Or(eqL, eqR)))) {\n+      // We want Not(Or(eqL, eqR)), which is equivalent to AndNot(eqL,\n+      // Not(eqR)); the latter helps the compiler generate kortest above.\n+      // TODO(janwas): add FindFirstFalse.\n+      const intptr_t lane = FindFirstTrue(d, AndNot(eqL, Not(eqR)));\n+      HWY_DASSERT(lane >= 0);\n+      third = st.SetKey(d, keys + pos + static_cast<size_t>(lane));\n+      if (VQSORT_PRINT >= 2) {\n+        fprintf(stderr, \"found 3rd value at vec %zu; countR %zu\\n\", pos,\n+                countR);\n+        MaybePrintVector(d, \"third\", third, 0, st.LanesPerKey());\n+      }\n+      pos += N;  // rewind: we haven't yet committed changes in this iteration.\n+      // We have filled [pos, num) with R, but only countR of them should have\n+      // been written. Rewrite [pos, num - countR) to L.\n+      HWY_DASSERT(countR <= num - pos);\n+      const size_t endL = num - countR;\n+      for (; pos + N <= endL; pos += N) {\n+        StoreU(valueL, d, keys + pos);\n+      }\n+      BlendedStore(valueL, FirstN(d, endL - pos), d, keys + pos);\n+      return false;\n+    }\n+    StoreU(valueR, d, keys + pos);\n+    countR += CountTrue(d, eqR);\n+  }\n+\n+  // Final partial (or empty) vector, masked comparison.\n+  const size_t remaining = pos + N;\n+  HWY_DASSERT(remaining <= N);\n+  const Vec<D> v = LoadU(d, keys);  // Safe because num >= N.\n+  const Mask<D> valid = FirstN(d, remaining);\n+  const Mask<D> eqL = st.EqualKeys(d, v, valueL);\n+  const Mask<D> eqR = And(st.EqualKeys(d, v, valueR), valid);\n+  // Invalid lanes are considered equal.\n+  const Mask<D> eq = Or(Or(eqL, eqR), Not(valid));\n+  // At least one other value present; will require a regular partition.\n+  if (HWY_UNLIKELY(!AllTrue(d, eq))) {\n+    const intptr_t lane = FindFirstTrue(d, Not(eq));\n+    HWY_DASSERT(lane >= 0);\n+    third = st.SetKey(d, keys + static_cast<size_t>(lane));\n+    if (VQSORT_PRINT >= 2) {\n+      fprintf(stderr, \"found 3rd value at partial vec %zu; writeR %zu\\n\", pos,\n+              countR);\n+      MaybePrintVector(d, \"third\", third, 0, st.LanesPerKey());\n+    }\n+    pos += N;  // rewind: we haven't yet committed changes in this iteration.\n+    // We have filled [pos, num) with R, but only countR of them should have\n+    // been written. Rewrite [pos, num - countR) to L.\n+    HWY_DASSERT(countR <= num - pos);\n+    const size_t endL = num - countR;\n+    for (; pos + N <= endL; pos += N) {\n+      StoreU(valueL, d, keys + pos);\n+    }\n+    BlendedStore(valueL, FirstN(d, endL - pos), d, keys + pos);\n+    return false;\n+  }\n+  const size_t lastR = CountTrue(d, eqR);\n+  countR += lastR;\n+\n+  // First finish writing valueR - [0, N) lanes were not yet written.\n+  StoreU(valueR, d, keys);  // Safe because num >= N.\n+\n+  // Fill left side (ascending order for clarity)\n+  const size_t endL = num - countR;\n+  size_t i = 0;\n+  for (; i + N <= endL; i += N) {\n+    StoreU(valueL, d, keys + i);\n+  }\n+  Store(valueL, d, buf);\n+  SafeCopyN(endL - i, d, buf, keys + i);  // avoids asan overrun\n+\n+  if (VQSORT_PRINT >= 2) {\n+    fprintf(stderr,\n+            \"MaybePartitionTwoValueR countR %zu pos %zu i %zu endL %zu\\n\",\n+            countR, pos, i, endL);\n+  }\n+\n+  return true;\n+}\n+\n // `idx_second` is `first_mismatch` from `AllEqual` and thus the index of the\n // second key. This is the first path into `MaybePartitionTwoValue`, called\n-// when all samples are equal.\n+// when all samples are equal. Returns false if there are at least a third\n+// value and sets `third`. Otherwise, partitions the array and returns true.\n template <class D, class Traits, typename T>\n HWY_INLINE bool PartitionIfTwoKeys(D d, Traits st, const Vec<D> pivot,\n                                    T* HWY_RESTRICT keys, size_t num,\n-                                   size_t idx_second, T* HWY_RESTRICT buf) {\n-  const Vec<D> second = st.SetKey(d, keys + idx_second);\n+                                   const size_t idx_second, const Vec<D> second,\n+                                   Vec<D>& third, T* HWY_RESTRICT buf) {\n   // True if second comes before pivot.\n   const bool is_pivotR = AllFalse(d, st.Compare(d, pivot, second));\n   if (VQSORT_PRINT >= 1) {\n     fprintf(stderr, \"Samples all equal, diff at %zu, isPivotR %d\\n\", idx_second,\n             is_pivotR);\n-    MaybePrintVector(d, \"pivot\", pivot, 0, st.LanesPerKey());\n-    MaybePrintVector(d, \"second\", second, 0, st.LanesPerKey());\n   }\n   HWY_DASSERT(AllFalse(d, st.EqualKeys(d, second, pivot)));\n \n-  // If pivot is L, we scanned up to idx_second and can leave those in place.\n-  // Otherwise, we'd have to restart from the beginning, and fill most keys\n-  // with L, then overwrite most with R, which is not worthwhile.\n-  if (is_pivotR) return false;\n-  return MaybePartitionTwoValue(d, st, keys + idx_second, num - idx_second,\n-                                pivot, second, buf);\n+  // If pivot is R, we scan backwards over the entire array. Otherwise,\n+  // we already scanned up to idx_second and can leave those in place.\n+  return is_pivotR ? MaybePartitionTwoValueR(d, st, keys, num, second, pivot,\n+                                             third, buf)\n+                   : MaybePartitionTwoValue(d, st, keys + idx_second,\n+                                            num - idx_second, pivot, second,\n+                                            third, buf);\n }\n \n // Second path into `MaybePartitionTwoValue`, called when not all samples are\n@@ -583,7 +696,8 @@ HWY_INLINE bool PartitionIfTwoSamples(D d, Traits st, T* HWY_RESTRICT keys,\n   // Must not overwrite samples because if this returns false, caller wants to\n   // read the original samples again.\n   T* HWY_RESTRICT buf = samples + kSampleLanes;\n-  return MaybePartitionTwoValue(d, st, keys, num, valueL, valueR, buf);\n+  Vec<D> third;  // unused\n+  return MaybePartitionTwoValue(d, st, keys, num, valueL, valueR, third, buf);\n }\n \n // ------------------------------ Pivot sampling\n@@ -938,63 +1052,118 @@ HWY_NOINLINE bool AllEqual(D d, Traits st, const Vec<D> pivot,\n   return true;  // all equal\n }\n \n-// Scans for the first/last key from index `first_mismatch`.\n template <class D, class Traits, typename T>\n-HWY_NOINLINE void ScanFirstLast(D d, Traits st, const T* HWY_RESTRICT keys,\n-                                size_t num, const Vec<D> pivot,\n-                                T* HWY_RESTRICT buf,\n-                                Vec<D>* HWY_RESTRICT out_first,\n-                                Vec<D>* HWY_RESTRICT out_last) {\n+HWY_NOINLINE bool ExistsAnyBefore(D d, Traits st, const T* HWY_RESTRICT keys,\n+                                  size_t num, const Vec<D> pivot) {\n   const size_t N = Lanes(d);\n   HWY_DASSERT(num >= N);  // See HandleSpecialCases\n \n-  Vec<D> first = st.LastValue(d);\n-  Vec<D> last = st.FirstValue(d);\n+  if (VQSORT_PRINT >= 2) {\n+    fprintf(stderr, \"Scanning for before\\n\");\n+  }\n \n   size_t i = 0;\n \n   constexpr size_t kLoops = 16;\n   const size_t lanes_per_group = kLoops * N;\n \n+  Vec<D> first = pivot;\n+\n   // Whole group, unrolled\n   for (; i + lanes_per_group <= num; i += lanes_per_group) {\n     HWY_DEFAULT_UNROLL\n     for (size_t loop = 0; loop < kLoops; ++loop) {\n       const Vec<D> curr = LoadU(d, keys + i + loop * N);\n       first = st.First(d, first, curr);\n-      last = st.Last(d, last, curr);\n     }\n \n-    // We only care whether pivot is the first or last. If neither, i.e. there\n-    // are key(s) before and after pivot, we can stop scanning immediately.\n-    const Mask<D> before = st.Compare(d, first, pivot);\n-    const Mask<D> after = st.Compare(d, pivot, last);\n-    if (HWY_UNLIKELY(!AllFalse(d, And(before, after)))) {\n+    if (HWY_UNLIKELY(!AllFalse(d, st.Compare(d, first, pivot)))) {\n       if (VQSORT_PRINT >= 2) {\n-        fprintf(stderr, \"Stopped scanning at %zu\\n\", i + lanes_per_group);\n+        fprintf(stderr, \"Stopped scanning at end of group %zu\\n\",\n+                i + lanes_per_group);\n       }\n-      goto DONE;\n+      return true;\n     }\n   }\n   // Whole vectors, no unrolling\n   for (; i + N <= num; i += N) {\n     const Vec<D> curr = LoadU(d, keys + i);\n-    first = st.First(d, first, curr);\n-    last = st.Last(d, last, curr);\n+    if (HWY_UNLIKELY(!AllFalse(d, st.Compare(d, curr, pivot)))) {\n+      if (VQSORT_PRINT >= 2) {\n+        fprintf(stderr, \"Stopped scanning at %zu\\n\", i);\n+      }\n+      return true;\n+    }\n   }\n   // If there are remainders, re-check the last whole vector.\n   if (HWY_LIKELY(i != num)) {\n     const Vec<D> curr = LoadU(d, keys + num - N);\n-    first = st.First(d, first, curr);\n-    last = st.Last(d, last, curr);\n+    if (HWY_UNLIKELY(!AllFalse(d, st.Compare(d, curr, pivot)))) {\n+      if (VQSORT_PRINT >= 2) {\n+        fprintf(stderr, \"Stopped scanning at last %zu\\n\", num - N);\n+      }\n+      return true;\n+    }\n+  }\n+\n+  return false;  // pivot is the first\n+}\n+\n+template <class D, class Traits, typename T>\n+HWY_NOINLINE bool ExistsAnyAfter(D d, Traits st, const T* HWY_RESTRICT keys,\n+                                 size_t num, const Vec<D> pivot) {\n+  const size_t N = Lanes(d);\n+  HWY_DASSERT(num >= N);  // See HandleSpecialCases\n+\n+  if (VQSORT_PRINT >= 2) {\n+    fprintf(stderr, \"Scanning for after\\n\");\n   }\n \n-DONE:\n-  *out_first = st.FirstOfLanes(d, first, buf);\n-  *out_last = st.LastOfLanes(d, last, buf);\n+  size_t i = 0;\n+\n+  constexpr size_t kLoops = 16;\n+  const size_t lanes_per_group = kLoops * N;\n \n-  MaybePrintVector(d, \"first\", *out_first, 0, st.LanesPerKey());\n-  MaybePrintVector(d, \"last\", *out_last, 0, st.LanesPerKey());\n+  Vec<D> last = pivot;\n+\n+  // Whole group, unrolled\n+  for (; i + lanes_per_group <= num; i += lanes_per_group) {\n+    HWY_DEFAULT_UNROLL\n+    for (size_t loop = 0; loop < kLoops; ++loop) {\n+      const Vec<D> curr = LoadU(d, keys + i + loop * N);\n+      last = st.Last(d, last, curr);\n+    }\n+\n+    if (HWY_UNLIKELY(!AllFalse(d, st.Compare(d, pivot, last)))) {\n+      if (VQSORT_PRINT >= 2) {\n+        fprintf(stderr, \"Stopped scanning at end of group %zu\\n\",\n+                i + lanes_per_group);\n+      }\n+      return true;\n+    }\n+  }\n+  // Whole vectors, no unrolling\n+  for (; i + N <= num; i += N) {\n+    const Vec<D> curr = LoadU(d, keys + i);\n+    if (HWY_UNLIKELY(!AllFalse(d, st.Compare(d, pivot, curr)))) {\n+      if (VQSORT_PRINT >= 2) {\n+        fprintf(stderr, \"Stopped scanning at %zu\\n\", i);\n+      }\n+      return true;\n+    }\n+  }\n+  // If there are remainders, re-check the last whole vector.\n+  if (HWY_LIKELY(i != num)) {\n+    const Vec<D> curr = LoadU(d, keys + num - N);\n+    if (HWY_UNLIKELY(!AllFalse(d, st.Compare(d, pivot, curr)))) {\n+      if (VQSORT_PRINT >= 2) {\n+        fprintf(stderr, \"Stopped scanning at last %zu\\n\", num - N);\n+      }\n+      return true;\n+    }\n+  }\n+\n+  return false;  // pivot is the last\n }\n \n // Returns pivot chosen from `keys[0, num)`. It will never be the largest key\n@@ -1003,6 +1172,7 @@ template <class D, class Traits, typename T>\n HWY_INLINE Vec<D> ChoosePivotForEqualSamples(D d, Traits st,\n                                              T* HWY_RESTRICT keys, size_t num,\n                                              T* HWY_RESTRICT samples,\n+                                             Vec<D> second, Vec<D> third,\n                                              PivotResult& result) {\n   const Vec<D> pivot = st.SetKey(d, samples);  // the single unique sample\n \n@@ -1016,38 +1186,42 @@ HWY_INLINE Vec<D> ChoosePivotForEqualSamples(D d, Traits st,\n     return st.PrevValue(d, pivot);\n   }\n \n-  Vec<D> first, last;\n-  ScanFirstLast(d, st, keys, num, pivot, /*buf=*/samples, &first, &last);\n-\n-  // We only reach here if !AllEqual. Note that first might equal Prev(last)\n-  // because the 2-value special case is conditional and may be skipped.\n-  HWY_DASSERT(AllFalse(d, st.EqualKeys(d, first, last)));\n+  // Check if pivot is between two known values. If so, it is not the first nor\n+  // the last and we can avoid scanning.\n+  st.Sort2(d, second, third);\n+  HWY_DASSERT(AllTrue(d, st.Compare(d, second, third)));\n+  const bool before = !AllFalse(d, st.Compare(d, second, pivot));\n+  const bool after = !AllFalse(d, st.Compare(d, pivot, third));\n+  // Only reached if there are three keys, which means pivot is either first,\n+  // last, or in between. Thus there is another key that comes before or after.\n+  HWY_DASSERT(before || after);\n+  if (HWY_UNLIKELY(before)) {\n+    // Neither first nor last.\n+    if (HWY_UNLIKELY(after || ExistsAnyAfter(d, st, keys, num, pivot))) {\n+      result = PivotResult::kNormal;\n+      return pivot;\n+    }\n \n-  if (AllTrue(d, st.EqualKeys(d, first, pivot))) {\n-    // We could consider a special partition mode that only reads from and\n-    // writes to the right side, and later fills in the left side, which we know\n-    // is equal to the pivot. However, that leads to more cache misses if the\n-    // array is large, and doesn't save much, hence is a net loss.\n-    result = PivotResult::kIsFirst;\n-    return pivot;\n-  }\n-  // Fixup required because keys equal to the pivot go to the left partition,\n-  // and the pivot is the last, so Partition would not change anything.\n-  // Instead use the previous value in sort order, which is not necessarily an\n-  // actual key.\n-  if (AllTrue(d, st.EqualKeys(d, last, pivot))) {\n+    // We didn't find anything after pivot, so it is the last. Because keys\n+    // equal to the pivot go to the left partition, the right partition would be\n+    // empty and Partition will not have changed anything. Instead use the\n+    // previous value in sort order, which is not necessarily an actual key.\n     result = PivotResult::kWasLast;\n     return st.PrevValue(d, pivot);\n   }\n \n-  // `pivot` is very common but not the first/last. It is tempting to do a\n-  // 3-way partition (to avoid moving the =pivot keys a second time), but that\n-  // is a net loss due to the extra comparisons.\n-  result = PivotResult::kNormal;\n-  if (VQSORT_PRINT >= 2) {\n-    fprintf(stderr, \"  Pivot %.0f not minmax; normal\\n\",\n-            static_cast<double>(GetLane(pivot)));\n+  // Has after, and we found one before: in the middle.\n+  if (HWY_UNLIKELY(ExistsAnyBefore(d, st, keys, num, pivot))) {\n+    result = PivotResult::kNormal;\n+    return pivot;\n   }\n+\n+  // Pivot is first. We could consider a special partition mode that only\n+  // reads from and writes to the right side, and later fills in the left\n+  // side, which we know is equal to the pivot. However, that leads to more\n+  // cache misses if the array is large, and doesn't save much, hence is a\n+  // net loss.\n+  result = PivotResult::kIsFirst;\n   return pivot;\n }\n \n@@ -1114,15 +1288,24 @@ HWY_NOINLINE void Recurse(D d, Traits st, T* HWY_RESTRICT keys,\n       return;\n     }\n     HWY_DASSERT(idx_second % st.LanesPerKey() == 0);\n+    // Must capture the value before PartitionIfTwoKeys may overwrite it.\n+    const Vec<D> second = st.SetKey(d, keys + begin + idx_second);\n+    MaybePrintVector(d, \"pivot\", pivot, 0, st.LanesPerKey());\n+    MaybePrintVector(d, \"second\", second, 0, st.LanesPerKey());\n \n+    Vec<D> third;\n     if (HWY_UNLIKELY(PartitionIfTwoKeys(d, st, pivot, keys + begin, num,\n-                                        idx_second, buf))) {\n+                                        idx_second, second, third, buf))) {\n       return;  // Done, skip recursion because each side has all-equal keys.\n     }\n \n     // We can no longer start scanning from idx_second because\n     // PartitionIfTwoKeys may have reordered keys.\n-    pivot = ChoosePivotForEqualSamples(d, st, keys + begin, num, buf, result);\n+    pivot = ChoosePivotForEqualSamples(d, st, keys + begin, num, buf, second,\n+                                       third, result);\n+    // If kNormal, `pivot` is very common but not the first/last. It is\n+    // tempting to do a 3-way partition (to avoid moving the =pivot keys a\n+    // second time), but that is a net loss due to the extra comparisons.\n   } else {\n     SortSamples(d, st, buf);\n "
    ],
    "files_changed": [
      {
        "filename": "hwy/contrib/sort/vqsort-inl.h",
        "status": "modified",
        "additions": 254,
        "deletions": 71,
        "changes": 325,
        "patch": "@@ -460,12 +460,12 @@ HWY_NOINLINE size_t Partition(D d, Traits st, T* HWY_RESTRICT keys, size_t left,\n }\n \n // Returns true and partitions if [keys, keys + num) contains only {valueL,\n-// valueR}. Otherwise, keys may have been modified and a regular Partition is\n-// still necessary.\n+// valueR}. Otherwise, sets third to the first differing value; keys may have\n+// been reordered and a regular Partition is still necessary.\n template <class D, class Traits, typename T>\n HWY_NOINLINE bool MaybePartitionTwoValue(D d, Traits st, T* HWY_RESTRICT keys,\n                                          size_t num, const Vec<D> valueL,\n-                                         const Vec<D> valueR,\n+                                         const Vec<D> valueR, Vec<D>& third,\n                                          T* HWY_RESTRICT buf) {\n   const size_t N = Lanes(d);\n \n@@ -482,10 +482,14 @@ HWY_NOINLINE bool MaybePartitionTwoValue(D d, Traits st, T* HWY_RESTRICT keys,\n     const Mask<D> eqL = st.EqualKeys(d, v, valueL);\n     const Mask<D> eqR = st.EqualKeys(d, v, valueR);\n     // At least one other value present; will require a regular partition.\n-    // On AVX-512, Or + AllTrue are folded into a single kortest.\n+    // On AVX-512, Or + AllTrue are folded into a single kortest, but not if\n+    // `Or(eqL, eqR)` is an lvalue.\n     if (HWY_UNLIKELY(!AllTrue(d, Or(eqL, eqR)))) {\n+      const intptr_t lane = FindFirstTrue(d, Not(Or(eqL, eqR)));\n+      HWY_DASSERT(lane >= 0);\n+      third = st.SetKey(d, keys + i + static_cast<size_t>(lane));\n       if (VQSORT_PRINT >= 2) {\n-        fprintf(stderr, \"found 3rd value at %zu; writeL %zu\\n\", i, writeL);\n+        fprintf(stderr, \"found 3rd value at vec %zu; writeL %zu\\n\", i, writeL);\n       }\n       // 'Undo' what we did by filling the remainder of what we read with R.\n       for (; writeL + N <= i; writeL += N) {\n@@ -509,8 +513,11 @@ HWY_NOINLINE bool MaybePartitionTwoValue(D d, Traits st, T* HWY_RESTRICT keys,\n   const Mask<D> eq = Or(Or(eqL, eqR), Not(valid));\n   // At least one other value present; will require a regular partition.\n   if (HWY_UNLIKELY(!AllTrue(d, eq))) {\n+    const intptr_t lane = FindFirstTrue(d, Not(eq));\n+    HWY_DASSERT(lane >= 0);\n+    third = st.SetKey(d, keys + i + static_cast<size_t>(lane));\n     if (VQSORT_PRINT >= 2) {\n-      fprintf(stderr, \"found 3rd value at partial %zu; writeL %zu\\n\", i,\n+      fprintf(stderr, \"found 3rd value at partial vec %zu; writeL %zu\\n\", i,\n               writeL);\n     }\n     // 'Undo' what we did by filling the remainder of what we read with R.\n@@ -536,30 +543,136 @@ HWY_NOINLINE bool MaybePartitionTwoValue(D d, Traits st, T* HWY_RESTRICT keys,\n   return true;\n }\n \n+// Same as above, except that the pivot equals valueR, so scan right to left.\n+template <class D, class Traits, typename T>\n+HWY_NOINLINE bool MaybePartitionTwoValueR(D d, Traits st, T* HWY_RESTRICT keys,\n+                                          size_t num, const Vec<D> valueL,\n+                                          const Vec<D> valueR, Vec<D>& third,\n+                                          T* HWY_RESTRICT buf) {\n+  const size_t N = Lanes(d);\n+\n+  HWY_DASSERT(num >= N);\n+  size_t pos = num - N;  // current read/write position\n+  size_t countR = 0;     // number of valueR found\n+\n+  // For whole vectors, in descending address order: as long as all lanes are\n+  // equal to L or R, overwrite with valueR. This is faster than counting, then\n+  // filling both L and R. Loop terminates after unsigned wraparound.\n+  for (; pos < num; pos -= N) {\n+    const Vec<D> v = LoadU(d, keys + pos);\n+    // It is not clear how to apply OrXor here - that can check if *both*\n+    // comparisons are true, but here we want *either*. Comparing the unsigned\n+    // min of differences to zero works, but is expensive for u64 prior to AVX3.\n+    const Mask<D> eqL = st.EqualKeys(d, v, valueL);\n+    const Mask<D> eqR = st.EqualKeys(d, v, valueR);\n+    // If there is a third value, stop and undo what we've done. On AVX-512,\n+    // Or + AllTrue are folded into a single kortest, but not if `Or(eqL, eqR)\n+    // is an lvalue.\n+    if (HWY_UNLIKELY(!AllTrue(d, Or(eqL, eqR)))) {\n+      // We want Not(Or(eqL, eqR)), which is equivalent to AndNot(eqL,\n+      // Not(eqR)); the latter helps the compiler generate kortest above.\n+      // TODO(janwas): add FindFirstFalse.\n+      const intptr_t lane = FindFirstTrue(d, AndNot(eqL, Not(eqR)));\n+      HWY_DASSERT(lane >= 0);\n+      third = st.SetKey(d, keys + pos + static_cast<size_t>(lane));\n+      if (VQSORT_PRINT >= 2) {\n+        fprintf(stderr, \"found 3rd value at vec %zu; countR %zu\\n\", pos,\n+                countR);\n+        MaybePrintVector(d, \"third\", third, 0, st.LanesPerKey());\n+      }\n+      pos += N;  // rewind: we haven't yet committed changes in this iteration.\n+      // We have filled [pos, num) with R, but only countR of them should have\n+      // been written. Rewrite [pos, num - countR) to L.\n+      HWY_DASSERT(countR <= num - pos);\n+      const size_t endL = num - countR;\n+      for (; pos + N <= endL; pos += N) {\n+        StoreU(valueL, d, keys + pos);\n+      }\n+      BlendedStore(valueL, FirstN(d, endL - pos), d, keys + pos);\n+      return false;\n+    }\n+    StoreU(valueR, d, keys + pos);\n+    countR += CountTrue(d, eqR);\n+  }\n+\n+  // Final partial (or empty) vector, masked comparison.\n+  const size_t remaining = pos + N;\n+  HWY_DASSERT(remaining <= N);\n+  const Vec<D> v = LoadU(d, keys);  // Safe because num >= N.\n+  const Mask<D> valid = FirstN(d, remaining);\n+  const Mask<D> eqL = st.EqualKeys(d, v, valueL);\n+  const Mask<D> eqR = And(st.EqualKeys(d, v, valueR), valid);\n+  // Invalid lanes are considered equal.\n+  const Mask<D> eq = Or(Or(eqL, eqR), Not(valid));\n+  // At least one other value present; will require a regular partition.\n+  if (HWY_UNLIKELY(!AllTrue(d, eq))) {\n+    const intptr_t lane = FindFirstTrue(d, Not(eq));\n+    HWY_DASSERT(lane >= 0);\n+    third = st.SetKey(d, keys + static_cast<size_t>(lane));\n+    if (VQSORT_PRINT >= 2) {\n+      fprintf(stderr, \"found 3rd value at partial vec %zu; writeR %zu\\n\", pos,\n+              countR);\n+      MaybePrintVector(d, \"third\", third, 0, st.LanesPerKey());\n+    }\n+    pos += N;  // rewind: we haven't yet committed changes in this iteration.\n+    // We have filled [pos, num) with R, but only countR of them should have\n+    // been written. Rewrite [pos, num - countR) to L.\n+    HWY_DASSERT(countR <= num - pos);\n+    const size_t endL = num - countR;\n+    for (; pos + N <= endL; pos += N) {\n+      StoreU(valueL, d, keys + pos);\n+    }\n+    BlendedStore(valueL, FirstN(d, endL - pos), d, keys + pos);\n+    return false;\n+  }\n+  const size_t lastR = CountTrue(d, eqR);\n+  countR += lastR;\n+\n+  // First finish writing valueR - [0, N) lanes were not yet written.\n+  StoreU(valueR, d, keys);  // Safe because num >= N.\n+\n+  // Fill left side (ascending order for clarity)\n+  const size_t endL = num - countR;\n+  size_t i = 0;\n+  for (; i + N <= endL; i += N) {\n+    StoreU(valueL, d, keys + i);\n+  }\n+  Store(valueL, d, buf);\n+  SafeCopyN(endL - i, d, buf, keys + i);  // avoids asan overrun\n+\n+  if (VQSORT_PRINT >= 2) {\n+    fprintf(stderr,\n+            \"MaybePartitionTwoValueR countR %zu pos %zu i %zu endL %zu\\n\",\n+            countR, pos, i, endL);\n+  }\n+\n+  return true;\n+}\n+\n // `idx_second` is `first_mismatch` from `AllEqual` and thus the index of the\n // second key. This is the first path into `MaybePartitionTwoValue`, called\n-// when all samples are equal.\n+// when all samples are equal. Returns false if there are at least a third\n+// value and sets `third`. Otherwise, partitions the array and returns true.\n template <class D, class Traits, typename T>\n HWY_INLINE bool PartitionIfTwoKeys(D d, Traits st, const Vec<D> pivot,\n                                    T* HWY_RESTRICT keys, size_t num,\n-                                   size_t idx_second, T* HWY_RESTRICT buf) {\n-  const Vec<D> second = st.SetKey(d, keys + idx_second);\n+                                   const size_t idx_second, const Vec<D> second,\n+                                   Vec<D>& third, T* HWY_RESTRICT buf) {\n   // True if second comes before pivot.\n   const bool is_pivotR = AllFalse(d, st.Compare(d, pivot, second));\n   if (VQSORT_PRINT >= 1) {\n     fprintf(stderr, \"Samples all equal, diff at %zu, isPivotR %d\\n\", idx_second,\n             is_pivotR);\n-    MaybePrintVector(d, \"pivot\", pivot, 0, st.LanesPerKey());\n-    MaybePrintVector(d, \"second\", second, 0, st.LanesPerKey());\n   }\n   HWY_DASSERT(AllFalse(d, st.EqualKeys(d, second, pivot)));\n \n-  // If pivot is L, we scanned up to idx_second and can leave those in place.\n-  // Otherwise, we'd have to restart from the beginning, and fill most keys\n-  // with L, then overwrite most with R, which is not worthwhile.\n-  if (is_pivotR) return false;\n-  return MaybePartitionTwoValue(d, st, keys + idx_second, num - idx_second,\n-                                pivot, second, buf);\n+  // If pivot is R, we scan backwards over the entire array. Otherwise,\n+  // we already scanned up to idx_second and can leave those in place.\n+  return is_pivotR ? MaybePartitionTwoValueR(d, st, keys, num, second, pivot,\n+                                             third, buf)\n+                   : MaybePartitionTwoValue(d, st, keys + idx_second,\n+                                            num - idx_second, pivot, second,\n+                                            third, buf);\n }\n \n // Second path into `MaybePartitionTwoValue`, called when not all samples are\n@@ -583,7 +696,8 @@ HWY_INLINE bool PartitionIfTwoSamples(D d, Traits st, T* HWY_RESTRICT keys,\n   // Must not overwrite samples because if this returns false, caller wants to\n   // read the original samples again.\n   T* HWY_RESTRICT buf = samples + kSampleLanes;\n-  return MaybePartitionTwoValue(d, st, keys, num, valueL, valueR, buf);\n+  Vec<D> third;  // unused\n+  return MaybePartitionTwoValue(d, st, keys, num, valueL, valueR, third, buf);\n }\n \n // ------------------------------ Pivot sampling\n@@ -938,63 +1052,118 @@ HWY_NOINLINE bool AllEqual(D d, Traits st, const Vec<D> pivot,\n   return true;  // all equal\n }\n \n-// Scans for the first/last key from index `first_mismatch`.\n template <class D, class Traits, typename T>\n-HWY_NOINLINE void ScanFirstLast(D d, Traits st, const T* HWY_RESTRICT keys,\n-                                size_t num, const Vec<D> pivot,\n-                                T* HWY_RESTRICT buf,\n-                                Vec<D>* HWY_RESTRICT out_first,\n-                                Vec<D>* HWY_RESTRICT out_last) {\n+HWY_NOINLINE bool ExistsAnyBefore(D d, Traits st, const T* HWY_RESTRICT keys,\n+                                  size_t num, const Vec<D> pivot) {\n   const size_t N = Lanes(d);\n   HWY_DASSERT(num >= N);  // See HandleSpecialCases\n \n-  Vec<D> first = st.LastValue(d);\n-  Vec<D> last = st.FirstValue(d);\n+  if (VQSORT_PRINT >= 2) {\n+    fprintf(stderr, \"Scanning for before\\n\");\n+  }\n \n   size_t i = 0;\n \n   constexpr size_t kLoops = 16;\n   const size_t lanes_per_group = kLoops * N;\n \n+  Vec<D> first = pivot;\n+\n   // Whole group, unrolled\n   for (; i + lanes_per_group <= num; i += lanes_per_group) {\n     HWY_DEFAULT_UNROLL\n     for (size_t loop = 0; loop < kLoops; ++loop) {\n       const Vec<D> curr = LoadU(d, keys + i + loop * N);\n       first = st.First(d, first, curr);\n-      last = st.Last(d, last, curr);\n     }\n \n-    // We only care whether pivot is the first or last. If neither, i.e. there\n-    // are key(s) before and after pivot, we can stop scanning immediately.\n-    const Mask<D> before = st.Compare(d, first, pivot);\n-    const Mask<D> after = st.Compare(d, pivot, last);\n-    if (HWY_UNLIKELY(!AllFalse(d, And(before, after)))) {\n+    if (HWY_UNLIKELY(!AllFalse(d, st.Compare(d, first, pivot)))) {\n       if (VQSORT_PRINT >= 2) {\n-        fprintf(stderr, \"Stopped scanning at %zu\\n\", i + lanes_per_group);\n+        fprintf(stderr, \"Stopped scanning at end of group %zu\\n\",\n+                i + lanes_per_group);\n       }\n-      goto DONE;\n+      return true;\n     }\n   }\n   // Whole vectors, no unrolling\n   for (; i + N <= num; i += N) {\n     const Vec<D> curr = LoadU(d, keys + i);\n-    first = st.First(d, first, curr);\n-    last = st.Last(d, last, curr);\n+    if (HWY_UNLIKELY(!AllFalse(d, st.Compare(d, curr, pivot)))) {\n+      if (VQSORT_PRINT >= 2) {\n+        fprintf(stderr, \"Stopped scanning at %zu\\n\", i);\n+      }\n+      return true;\n+    }\n   }\n   // If there are remainders, re-check the last whole vector.\n   if (HWY_LIKELY(i != num)) {\n     const Vec<D> curr = LoadU(d, keys + num - N);\n-    first = st.First(d, first, curr);\n-    last = st.Last(d, last, curr);\n+    if (HWY_UNLIKELY(!AllFalse(d, st.Compare(d, curr, pivot)))) {\n+      if (VQSORT_PRINT >= 2) {\n+        fprintf(stderr, \"Stopped scanning at last %zu\\n\", num - N);\n+      }\n+      return true;\n+    }\n+  }\n+\n+  return false;  // pivot is the first\n+}\n+\n+template <class D, class Traits, typename T>\n+HWY_NOINLINE bool ExistsAnyAfter(D d, Traits st, const T* HWY_RESTRICT keys,\n+                                 size_t num, const Vec<D> pivot) {\n+  const size_t N = Lanes(d);\n+  HWY_DASSERT(num >= N);  // See HandleSpecialCases\n+\n+  if (VQSORT_PRINT >= 2) {\n+    fprintf(stderr, \"Scanning for after\\n\");\n   }\n \n-DONE:\n-  *out_first = st.FirstOfLanes(d, first, buf);\n-  *out_last = st.LastOfLanes(d, last, buf);\n+  size_t i = 0;\n+\n+  constexpr size_t kLoops = 16;\n+  const size_t lanes_per_group = kLoops * N;\n \n-  MaybePrintVector(d, \"first\", *out_first, 0, st.LanesPerKey());\n-  MaybePrintVector(d, \"last\", *out_last, 0, st.LanesPerKey());\n+  Vec<D> last = pivot;\n+\n+  // Whole group, unrolled\n+  for (; i + lanes_per_group <= num; i += lanes_per_group) {\n+    HWY_DEFAULT_UNROLL\n+    for (size_t loop = 0; loop < kLoops; ++loop) {\n+      const Vec<D> curr = LoadU(d, keys + i + loop * N);\n+      last = st.Last(d, last, curr);\n+    }\n+\n+    if (HWY_UNLIKELY(!AllFalse(d, st.Compare(d, pivot, last)))) {\n+      if (VQSORT_PRINT >= 2) {\n+        fprintf(stderr, \"Stopped scanning at end of group %zu\\n\",\n+                i + lanes_per_group);\n+      }\n+      return true;\n+    }\n+  }\n+  // Whole vectors, no unrolling\n+  for (; i + N <= num; i += N) {\n+    const Vec<D> curr = LoadU(d, keys + i);\n+    if (HWY_UNLIKELY(!AllFalse(d, st.Compare(d, pivot, curr)))) {\n+      if (VQSORT_PRINT >= 2) {\n+        fprintf(stderr, \"Stopped scanning at %zu\\n\", i);\n+      }\n+      return true;\n+    }\n+  }\n+  // If there are remainders, re-check the last whole vector.\n+  if (HWY_LIKELY(i != num)) {\n+    const Vec<D> curr = LoadU(d, keys + num - N);\n+    if (HWY_UNLIKELY(!AllFalse(d, st.Compare(d, pivot, curr)))) {\n+      if (VQSORT_PRINT >= 2) {\n+        fprintf(stderr, \"Stopped scanning at last %zu\\n\", num - N);\n+      }\n+      return true;\n+    }\n+  }\n+\n+  return false;  // pivot is the last\n }\n \n // Returns pivot chosen from `keys[0, num)`. It will never be the largest key\n@@ -1003,6 +1172,7 @@ template <class D, class Traits, typename T>\n HWY_INLINE Vec<D> ChoosePivotForEqualSamples(D d, Traits st,\n                                              T* HWY_RESTRICT keys, size_t num,\n                                              T* HWY_RESTRICT samples,\n+                                             Vec<D> second, Vec<D> third,\n                                              PivotResult& result) {\n   const Vec<D> pivot = st.SetKey(d, samples);  // the single unique sample\n \n@@ -1016,38 +1186,42 @@ HWY_INLINE Vec<D> ChoosePivotForEqualSamples(D d, Traits st,\n     return st.PrevValue(d, pivot);\n   }\n \n-  Vec<D> first, last;\n-  ScanFirstLast(d, st, keys, num, pivot, /*buf=*/samples, &first, &last);\n-\n-  // We only reach here if !AllEqual. Note that first might equal Prev(last)\n-  // because the 2-value special case is conditional and may be skipped.\n-  HWY_DASSERT(AllFalse(d, st.EqualKeys(d, first, last)));\n+  // Check if pivot is between two known values. If so, it is not the first nor\n+  // the last and we can avoid scanning.\n+  st.Sort2(d, second, third);\n+  HWY_DASSERT(AllTrue(d, st.Compare(d, second, third)));\n+  const bool before = !AllFalse(d, st.Compare(d, second, pivot));\n+  const bool after = !AllFalse(d, st.Compare(d, pivot, third));\n+  // Only reached if there are three keys, which means pivot is either first,\n+  // last, or in between. Thus there is another key that comes before or after.\n+  HWY_DASSERT(before || after);\n+  if (HWY_UNLIKELY(before)) {\n+    // Neither first nor last.\n+    if (HWY_UNLIKELY(after || ExistsAnyAfter(d, st, keys, num, pivot))) {\n+      result = PivotResult::kNormal;\n+      return pivot;\n+    }\n \n-  if (AllTrue(d, st.EqualKeys(d, first, pivot))) {\n-    // We could consider a special partition mode that only reads from and\n-    // writes to the right side, and later fills in the left side, which we know\n-    // is equal to the pivot. However, that leads to more cache misses if the\n-    // array is large, and doesn't save much, hence is a net loss.\n-    result = PivotResult::kIsFirst;\n-    return pivot;\n-  }\n-  // Fixup required because keys equal to the pivot go to the left partition,\n-  // and the pivot is the last, so Partition would not change anything.\n-  // Instead use the previous value in sort order, which is not necessarily an\n-  // actual key.\n-  if (AllTrue(d, st.EqualKeys(d, last, pivot))) {\n+    // We didn't find anything after pivot, so it is the last. Because keys\n+    // equal to the pivot go to the left partition, the right partition would be\n+    // empty and Partition will not have changed anything. Instead use the\n+    // previous value in sort order, which is not necessarily an actual key.\n     result = PivotResult::kWasLast;\n     return st.PrevValue(d, pivot);\n   }\n \n-  // `pivot` is very common but not the first/last. It is tempting to do a\n-  // 3-way partition (to avoid moving the =pivot keys a second time), but that\n-  // is a net loss due to the extra comparisons.\n-  result = PivotResult::kNormal;\n-  if (VQSORT_PRINT >= 2) {\n-    fprintf(stderr, \"  Pivot %.0f not minmax; normal\\n\",\n-            static_cast<double>(GetLane(pivot)));\n+  // Has after, and we found one before: in the middle.\n+  if (HWY_UNLIKELY(ExistsAnyBefore(d, st, keys, num, pivot))) {\n+    result = PivotResult::kNormal;\n+    return pivot;\n   }\n+\n+  // Pivot is first. We could consider a special partition mode that only\n+  // reads from and writes to the right side, and later fills in the left\n+  // side, which we know is equal to the pivot. However, that leads to more\n+  // cache misses if the array is large, and doesn't save much, hence is a\n+  // net loss.\n+  result = PivotResult::kIsFirst;\n   return pivot;\n }\n \n@@ -1114,15 +1288,24 @@ HWY_NOINLINE void Recurse(D d, Traits st, T* HWY_RESTRICT keys,\n       return;\n     }\n     HWY_DASSERT(idx_second % st.LanesPerKey() == 0);\n+    // Must capture the value before PartitionIfTwoKeys may overwrite it.\n+    const Vec<D> second = st.SetKey(d, keys + begin + idx_second);\n+    MaybePrintVector(d, \"pivot\", pivot, 0, st.LanesPerKey());\n+    MaybePrintVector(d, \"second\", second, 0, st.LanesPerKey());\n \n+    Vec<D> third;\n     if (HWY_UNLIKELY(PartitionIfTwoKeys(d, st, pivot, keys + begin, num,\n-                                        idx_second, buf))) {\n+                                        idx_second, second, third, buf))) {\n       return;  // Done, skip recursion because each side has all-equal keys.\n     }\n \n     // We can no longer start scanning from idx_second because\n     // PartitionIfTwoKeys may have reordered keys.\n-    pivot = ChoosePivotForEqualSamples(d, st, keys + begin, num, buf, result);\n+    pivot = ChoosePivotForEqualSamples(d, st, keys + begin, num, buf, second,\n+                                       third, result);\n+    // If kNormal, `pivot` is very common but not the first/last. It is\n+    // tempting to do a 3-way partition (to avoid moving the =pivot keys a\n+    // second time), but that is a net loss due to the extra comparisons.\n   } else {\n     SortSamples(d, st, buf);\n "
      }
    ],
    "lines_added": 254,
    "lines_removed": 71
  },
  "issues": [],
  "pull_requests": [],
  "build_info": {
    "old_build_script": "#!/bin/bash\n#!/bin/bash\ncmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON -DHWY_ENABLE_TESTS=ON",
    "new_build_script": "#!/bin/bash\n#!/bin/bash\ncmake -S /test_workspace/workspace/new -B /test_workspace/workspace/new/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON -DHWY_ENABLE_TESTS=ON",
    "old_test_script": "#!/bin/bash\ncmake --build /test_workspace/workspace/old/build -- -j 1",
    "new_test_script": "#!/bin/bash\ncmake --build /test_workspace/workspace/new/build -- -j 1",
    "build_system": "cmake"
  },
  "performance_analysis": {
    "is_significant": false,
    "p_value": 0.9999999999999997,
    "is_pair_significant": false,
    "pair_p_value": 0.9999999999949492,
    "is_binom_significant": false,
    "binom_p_value": 1.0,
    "is_wilcoxon_significant": false,
    "wilcoxon_p_value": 0.999999135525782,
    "is_mannwhitney_significant": false,
    "mannwhitney_p_value": 0.035592019363041724,
    "relative_improvement": 0.006585346085265035,
    "absolute_improvement_ms": 108.33333333333428,
    "old_mean_ms": 16450.666666666668,
    "new_mean_ms": 16342.333333333332,
    "old_std_ms": 292.44431634230745,
    "new_std_ms": 197.91470355953237,
    "effect_size_cohens_d": 0.43386486911270955,
    "old_ci95_ms": [
      16341.466164284422,
      16559.86716904891
    ],
    "new_ci95_ms": [
      16268.430768469543,
      16416.235898197123
    ],
    "old_ci99_ms": [
      16303.495552362716,
      16597.837780970618
    ],
    "new_ci99_ms": [
      16242.733765715482,
      16441.932900951182
    ],
    "new_times_s": [
      16.38,
      16.51,
      16.26,
      15.93,
      16.69,
      16.38,
      16.09,
      16.46,
      15.94,
      16.51,
      16.42,
      16.36,
      16.44,
      16.11,
      16.45,
      16.54,
      16.48,
      16.41,
      16.26,
      16.36,
      16.58,
      15.99,
      16.76,
      16.24,
      16.31,
      16.26,
      16.31,
      16.25,
      16.32,
      16.27,
      16.38
    ],
    "old_times_s": [
      16.46,
      16.28,
      16.7,
      16.69,
      16.27,
      16.3,
      16.55,
      16.73,
      16.59,
      16.69,
      16.77,
      16.61,
      16.37,
      15.87,
      16.85,
      16.83,
      16.49,
      16.68,
      16.01,
      16.28,
      16.31,
      16.38,
      15.86,
      16.42,
      16.8,
      16.13,
      16.23,
      15.93,
      16.73,
      16.47,
      16.7
    ]
  },
  "tests": {
    "total_tests": 1,
    "significant_improvements": 0,
    "significant_improvements_tests": [],
    "significant_regressions": 0,
    "significant_regressions_tests": [],
    "significant_pair_improvements": 0,
    "significant_pair_improvements_tests": [],
    "significant_pair_regressions": 0,
    "significant_pair_regressions_tests": [],
    "significant_binom_improvements": 0,
    "significant_binom_improvements_tests": [],
    "significant_binom_regressions": 0,
    "significant_binom_regressions_tests": [],
    "significant_wilcoxon_improvements": 0,
    "significant_wilcoxon_improvements_tests": [],
    "significant_wilcoxon_regressions": 0,
    "significant_wilcoxon_regressions_tests": [],
    "significant_mannwhitney_improvements": 0,
    "significant_mannwhitney_improvements_tests": [],
    "significant_mannwhitney_regressions": 0,
    "significant_mannwhitney_regressions_tests": [],
    "tests": [
      {
        "test_name": "NanobenchmarkTest.RunAll",
        "is_significant": false,
        "p_value": 0.7790241044438091,
        "is_pair_significant": false,
        "pair_p_value": 0.7916265707696316,
        "is_binom_significant": false,
        "binom_p_value": 0.644464448094368,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.8374774673109868,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.3229710662862404,
        "relative_improvement": 0.0072639225181597945,
        "absolute_improvement_ms": 3.1034482758621196,
        "old_mean_ms": 427.2413793103448,
        "new_mean_ms": 424.13793103448273,
        "old_std_ms": 93.53748491243414,
        "new_std_ms": 90.6924646964088,
        "effect_size_cohens_d": 0.0336870122899657,
        "old_ci95_ms": [
          391.6616228901976,
          462.82113573049213
        ],
        "new_ci95_ms": [
          389.6403624280375,
          458.63549964092795
        ],
        "old_ci99_ms": [
          379.244961467319,
          475.23779715337065
        ],
        "new_ci99_ms": [
          377.60136406501886,
          470.67449800394655
        ],
        "new_times": [
          0.44,
          0.34,
          0.2,
          0.38,
          0.26,
          0.52,
          0.36,
          0.43,
          0.38,
          0.58,
          0.47,
          0.59,
          0.39,
          0.43,
          0.44,
          0.36,
          0.46,
          0.38,
          0.36,
          0.42,
          0.38,
          0.56,
          0.61,
          0.44,
          0.42,
          0.41,
          0.48,
          0.37,
          0.44
        ],
        "old_times": [
          0.5,
          0.27,
          0.39,
          0.43,
          0.25,
          0.47,
          0.53,
          0.36,
          0.68,
          0.42,
          0.47,
          0.35,
          0.48,
          0.47,
          0.47,
          0.46,
          0.5,
          0.45,
          0.46,
          0.35,
          0.24,
          0.52,
          0.4,
          0.39,
          0.32,
          0.38,
          0.4,
          0.44,
          0.54
        ]
      }
    ]
  },
  "logs": {
    "full_log_path": "/logs/full.log",
    "config_log_path": "/logs/config.log",
    "build_log_path": "/logs/build.log",
    "test_log_path": "/logs/test.log",
    "build_success": true,
    "test_success": true
  },
  "raw_timing_data": {
    "warmup_runs": 1,
    "measurement_runs": 30,
    "min_exec_time_improvement": 0.05,
    "min_p_value": 0.05
  }
}