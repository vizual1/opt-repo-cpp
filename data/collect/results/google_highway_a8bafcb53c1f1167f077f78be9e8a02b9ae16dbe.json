{
  "metadata": {
    "collection_date": "2026-01-14T18:41:09.988356",
    "repository": "https://github.com/google/highway",
    "repository_name": "google/highway"
  },
  "commit_info": {
    "old_sha": "ac68e2eb8a1e80d997cc3b739590c04e510cc651",
    "new_sha": "a8bafcb53c1f1167f077f78be9e8a02b9ae16dbe",
    "commit_message": [
      "1.035x speedup for many repeated keys: align, return position in ScanEqual\n\nPiperOrigin-RevId: 467956585"
    ],
    "commit_date": "2022-08-16T17:14:10+00:00",
    "patch": [
      "--- hwy/contrib/sort/vqsort-inl.h\n@@ -573,9 +573,17 @@ HWY_NOINLINE void ScanMinMax(D d, Traits st, const T* HWY_RESTRICT keys,\n }\n #endif  // VQSORT_PRINT\n \n+template <class V>\n+V OrXor(const V o, const V x1, const V x2) {\n+  // TODO(janwas): ternlog?\n+  return Or(o, Xor(x1, x2));\n+}\n+\n+// Returns a lower bound on the index of the first difference, or `num` if all\n+// are equal.\n template <class D, class Traits, typename T>\n-HWY_INLINE bool ScanEqual(D d, Traits st, const T* HWY_RESTRICT keys,\n-                          size_t num) {\n+HWY_INLINE size_t ScanEqual(D d, Traits st, const T* HWY_RESTRICT keys,\n+                            size_t num) {\n   using V = Vec<decltype(d)>;\n   const size_t N = Lanes(d);\n   HWY_DASSERT(num >= N);  // See HandleSpecialCases\n@@ -587,59 +595,78 @@ HWY_INLINE bool ScanEqual(D d, Traits st, const T* HWY_RESTRICT keys,\n   V diff0 = zero;\n   V diff1 = zero;\n \n+  size_t i = 0;\n+\n+  // Vector-align keys + i.\n+  const size_t misalign =\n+      (reinterpret_cast<uintptr_t>(keys) / sizeof(T)) & (N - 1);\n+  if (HWY_LIKELY(misalign != 0)) {\n+    HWY_DASSERT(misalign % st.LanesPerKey() == 0);\n+    const size_t consume = N - misalign;\n+    const auto mask = FirstN(d, consume);\n+    const V v0 = MaskedLoad(mask, d, keys);\n+    diff0 = OrXor(diff0, v0, IfThenElseZero(mask, reference));\n+    if (!AllTrue(d, Eq(diff0, zero))) {\n+      return i;\n+    }\n+    i = consume;\n+  }\n+  HWY_DASSERT(((reinterpret_cast<uintptr_t>(keys + i) / sizeof(T)) & (N - 1)) ==\n+              0);\n+\n   // We want to stop once a difference has been found, but without slowing down\n   // the loop by comparing during each iteration. The compromise is to compare\n   // after a 'group', which consists of kLoops times two vectors.\n   constexpr size_t kLoops = 4;\n   const size_t lanes_per_group = kLoops * 2 * N;\n-  size_t i = 0;\n+\n   for (; i + lanes_per_group <= num; i += lanes_per_group) {\n+#pragma unroll\n     for (size_t loop = 0; loop < kLoops; ++loop) {\n-      const V v0 = LoadU(d, keys + i + loop * 2 * N);\n-      const V v1 = LoadU(d, keys + i + loop * 2 * N + N);\n-      // TODO(janwas): ternlog\n-      diff0 = Or(diff0, Xor(v0, reference));\n-      diff1 = Or(diff1, Xor(v1, reference));\n+      const V v0 = Load(d, keys + i + loop * 2 * N);\n+      const V v1 = Load(d, keys + i + loop * 2 * N + N);\n+      diff0 = OrXor(diff0, v0, reference);\n+      diff1 = OrXor(diff1, v1, reference);\n     }\n     diff0 = Or(diff0, diff1);\n     if (!AllTrue(d, Eq(diff0, zero))) {\n-      return false;\n+      return i;\n     }\n   }\n   // Whole vectors, no unrolling\n   for (; i + N <= num; i += N) {\n     const V v0 = LoadU(d, keys + i);\n-    // TODO(janwas): ternlog\n-    diff0 = Or(diff0, Xor(v0, reference));\n+    diff0 = OrXor(diff0, v0, reference);\n     if (!AllTrue(d, Eq(diff0, zero))) {\n-      return false;\n+      return i;\n     }\n   }\n   // If there are remainders, re-check the last whole vector.\n   if (HWY_LIKELY(i != num)) {\n     const V v0 = LoadU(d, keys + num - N);\n-    // TODO(janwas): ternlog\n-    diff0 = Or(diff0, Xor(v0, reference));\n+    diff0 = OrXor(diff0, v0, reference);\n     if (!AllTrue(d, Eq(diff0, zero))) {\n-      return false;\n+      return i;\n     }\n   }\n \n-  return true;\n+  return num;\n }\n \n-// Returns key prior to reference in sort order.\n+// Returns key prior to reference in sort order. Starts scanning at index\n+// `start`, which is less than `num`.\n template <class D, class Traits, typename T>\n HWY_INLINE Vec<D> ScanForPrev(D d, Traits st, const T* HWY_RESTRICT keys,\n-                              size_t num, Vec<D> reference,\n+                              size_t num, size_t start, Vec<D> reference,\n                               T* HWY_RESTRICT buf) {\n   const size_t N = Lanes(d);\n   HWY_DASSERT(num >= N);  // See HandleSpecialCases\n+  HWY_DASSERT(start < num);\n \n   Vec<D> prev = st.FirstValue(d);\n   Mask<D> any_found = st.Compare(d, prev, prev);  // false\n \n-  size_t i = 0;\n+  size_t i = start;\n   // Whole vectors, no unrolling\n   for (; i + N <= num; i += N) {\n     const Vec<D> curr = LoadU(d, keys + i);\n@@ -759,7 +786,8 @@ HWY_NOINLINE Vec<D> ChoosePivot(D d, Traits st, T* HWY_RESTRICT keys,\n \n   // All samples are equal.\n   if (st.Equal1(buf, buf + kSampleLanes - N1)) {\n-    const bool all_eq = ScanEqual(d, st, keys, num);\n+    const size_t idx_diff = ScanEqual(d, st, keys, num);\n+    const bool all_eq = idx_diff == num;\n #if VQSORT_PRINT\n     fprintf(stderr, \"Pivot num=%zu all eq samples, keys also: %d\\n\", num,\n             all_eq);\n@@ -777,7 +805,7 @@ HWY_NOINLINE Vec<D> ChoosePivot(D d, Traits st, T* HWY_RESTRICT keys,\n     // precede the most common key.\n     result = PivotResult::kNormal;\n     const V reference = st.SetKey(d, buf);\n-    const V pivot = ScanForPrev(d, st, keys, num, reference, buf);\n+    const V pivot = ScanForPrev(d, st, keys, num, idx_diff, reference, buf);\n #if VQSORT_PRINT\n     Print(d, \"PREV pivot\", pivot, 0, st.LanesPerKey());\n #endif\n@@ -795,9 +823,10 @@ HWY_NOINLINE Vec<D> ChoosePivot(D d, Traits st, T* HWY_RESTRICT keys,\n }\n \n template <class D, class Traits, typename T>\n-void Recurse(D d, Traits st, T* HWY_RESTRICT keys, T* HWY_RESTRICT keys_end,\n-             const size_t begin, const size_t end, T* HWY_RESTRICT buf,\n-             Generator& rng, size_t remaining_levels) {\n+HWY_NOINLINE void Recurse(D d, Traits st, T* HWY_RESTRICT keys,\n+                          T* HWY_RESTRICT keys_end, const size_t begin,\n+                          const size_t end, T* HWY_RESTRICT buf, Generator& rng,\n+                          size_t remaining_levels) {\n   HWY_DASSERT(begin + 1 < end);\n   const size_t num = end - begin;  // >= 2\n #if VQSORT_PRINT\n@@ -839,7 +868,8 @@ void Recurse(D d, Traits st, T* HWY_RESTRICT keys, T* HWY_RESTRICT keys_end,\n \n // Returns true if sorting is finished.\n template <class D, class Traits, typename T>\n-bool HandleSpecialCases(D d, Traits st, T* HWY_RESTRICT keys, size_t num) {\n+HWY_INLINE bool HandleSpecialCases(D d, Traits st, T* HWY_RESTRICT keys,\n+                                   size_t num) {\n   const size_t N = Lanes(d);\n   const size_t base_case_num = Constants::BaseCaseNum(N);\n "
    ],
    "files_changed": [
      {
        "filename": "hwy/contrib/sort/vqsort-inl.h",
        "status": "modified",
        "additions": 55,
        "deletions": 25,
        "changes": 80,
        "patch": "@@ -573,9 +573,17 @@ HWY_NOINLINE void ScanMinMax(D d, Traits st, const T* HWY_RESTRICT keys,\n }\n #endif  // VQSORT_PRINT\n \n+template <class V>\n+V OrXor(const V o, const V x1, const V x2) {\n+  // TODO(janwas): ternlog?\n+  return Or(o, Xor(x1, x2));\n+}\n+\n+// Returns a lower bound on the index of the first difference, or `num` if all\n+// are equal.\n template <class D, class Traits, typename T>\n-HWY_INLINE bool ScanEqual(D d, Traits st, const T* HWY_RESTRICT keys,\n-                          size_t num) {\n+HWY_INLINE size_t ScanEqual(D d, Traits st, const T* HWY_RESTRICT keys,\n+                            size_t num) {\n   using V = Vec<decltype(d)>;\n   const size_t N = Lanes(d);\n   HWY_DASSERT(num >= N);  // See HandleSpecialCases\n@@ -587,59 +595,78 @@ HWY_INLINE bool ScanEqual(D d, Traits st, const T* HWY_RESTRICT keys,\n   V diff0 = zero;\n   V diff1 = zero;\n \n+  size_t i = 0;\n+\n+  // Vector-align keys + i.\n+  const size_t misalign =\n+      (reinterpret_cast<uintptr_t>(keys) / sizeof(T)) & (N - 1);\n+  if (HWY_LIKELY(misalign != 0)) {\n+    HWY_DASSERT(misalign % st.LanesPerKey() == 0);\n+    const size_t consume = N - misalign;\n+    const auto mask = FirstN(d, consume);\n+    const V v0 = MaskedLoad(mask, d, keys);\n+    diff0 = OrXor(diff0, v0, IfThenElseZero(mask, reference));\n+    if (!AllTrue(d, Eq(diff0, zero))) {\n+      return i;\n+    }\n+    i = consume;\n+  }\n+  HWY_DASSERT(((reinterpret_cast<uintptr_t>(keys + i) / sizeof(T)) & (N - 1)) ==\n+              0);\n+\n   // We want to stop once a difference has been found, but without slowing down\n   // the loop by comparing during each iteration. The compromise is to compare\n   // after a 'group', which consists of kLoops times two vectors.\n   constexpr size_t kLoops = 4;\n   const size_t lanes_per_group = kLoops * 2 * N;\n-  size_t i = 0;\n+\n   for (; i + lanes_per_group <= num; i += lanes_per_group) {\n+#pragma unroll\n     for (size_t loop = 0; loop < kLoops; ++loop) {\n-      const V v0 = LoadU(d, keys + i + loop * 2 * N);\n-      const V v1 = LoadU(d, keys + i + loop * 2 * N + N);\n-      // TODO(janwas): ternlog\n-      diff0 = Or(diff0, Xor(v0, reference));\n-      diff1 = Or(diff1, Xor(v1, reference));\n+      const V v0 = Load(d, keys + i + loop * 2 * N);\n+      const V v1 = Load(d, keys + i + loop * 2 * N + N);\n+      diff0 = OrXor(diff0, v0, reference);\n+      diff1 = OrXor(diff1, v1, reference);\n     }\n     diff0 = Or(diff0, diff1);\n     if (!AllTrue(d, Eq(diff0, zero))) {\n-      return false;\n+      return i;\n     }\n   }\n   // Whole vectors, no unrolling\n   for (; i + N <= num; i += N) {\n     const V v0 = LoadU(d, keys + i);\n-    // TODO(janwas): ternlog\n-    diff0 = Or(diff0, Xor(v0, reference));\n+    diff0 = OrXor(diff0, v0, reference);\n     if (!AllTrue(d, Eq(diff0, zero))) {\n-      return false;\n+      return i;\n     }\n   }\n   // If there are remainders, re-check the last whole vector.\n   if (HWY_LIKELY(i != num)) {\n     const V v0 = LoadU(d, keys + num - N);\n-    // TODO(janwas): ternlog\n-    diff0 = Or(diff0, Xor(v0, reference));\n+    diff0 = OrXor(diff0, v0, reference);\n     if (!AllTrue(d, Eq(diff0, zero))) {\n-      return false;\n+      return i;\n     }\n   }\n \n-  return true;\n+  return num;\n }\n \n-// Returns key prior to reference in sort order.\n+// Returns key prior to reference in sort order. Starts scanning at index\n+// `start`, which is less than `num`.\n template <class D, class Traits, typename T>\n HWY_INLINE Vec<D> ScanForPrev(D d, Traits st, const T* HWY_RESTRICT keys,\n-                              size_t num, Vec<D> reference,\n+                              size_t num, size_t start, Vec<D> reference,\n                               T* HWY_RESTRICT buf) {\n   const size_t N = Lanes(d);\n   HWY_DASSERT(num >= N);  // See HandleSpecialCases\n+  HWY_DASSERT(start < num);\n \n   Vec<D> prev = st.FirstValue(d);\n   Mask<D> any_found = st.Compare(d, prev, prev);  // false\n \n-  size_t i = 0;\n+  size_t i = start;\n   // Whole vectors, no unrolling\n   for (; i + N <= num; i += N) {\n     const Vec<D> curr = LoadU(d, keys + i);\n@@ -759,7 +786,8 @@ HWY_NOINLINE Vec<D> ChoosePivot(D d, Traits st, T* HWY_RESTRICT keys,\n \n   // All samples are equal.\n   if (st.Equal1(buf, buf + kSampleLanes - N1)) {\n-    const bool all_eq = ScanEqual(d, st, keys, num);\n+    const size_t idx_diff = ScanEqual(d, st, keys, num);\n+    const bool all_eq = idx_diff == num;\n #if VQSORT_PRINT\n     fprintf(stderr, \"Pivot num=%zu all eq samples, keys also: %d\\n\", num,\n             all_eq);\n@@ -777,7 +805,7 @@ HWY_NOINLINE Vec<D> ChoosePivot(D d, Traits st, T* HWY_RESTRICT keys,\n     // precede the most common key.\n     result = PivotResult::kNormal;\n     const V reference = st.SetKey(d, buf);\n-    const V pivot = ScanForPrev(d, st, keys, num, reference, buf);\n+    const V pivot = ScanForPrev(d, st, keys, num, idx_diff, reference, buf);\n #if VQSORT_PRINT\n     Print(d, \"PREV pivot\", pivot, 0, st.LanesPerKey());\n #endif\n@@ -795,9 +823,10 @@ HWY_NOINLINE Vec<D> ChoosePivot(D d, Traits st, T* HWY_RESTRICT keys,\n }\n \n template <class D, class Traits, typename T>\n-void Recurse(D d, Traits st, T* HWY_RESTRICT keys, T* HWY_RESTRICT keys_end,\n-             const size_t begin, const size_t end, T* HWY_RESTRICT buf,\n-             Generator& rng, size_t remaining_levels) {\n+HWY_NOINLINE void Recurse(D d, Traits st, T* HWY_RESTRICT keys,\n+                          T* HWY_RESTRICT keys_end, const size_t begin,\n+                          const size_t end, T* HWY_RESTRICT buf, Generator& rng,\n+                          size_t remaining_levels) {\n   HWY_DASSERT(begin + 1 < end);\n   const size_t num = end - begin;  // >= 2\n #if VQSORT_PRINT\n@@ -839,7 +868,8 @@ void Recurse(D d, Traits st, T* HWY_RESTRICT keys, T* HWY_RESTRICT keys_end,\n \n // Returns true if sorting is finished.\n template <class D, class Traits, typename T>\n-bool HandleSpecialCases(D d, Traits st, T* HWY_RESTRICT keys, size_t num) {\n+HWY_INLINE bool HandleSpecialCases(D d, Traits st, T* HWY_RESTRICT keys,\n+                                   size_t num) {\n   const size_t N = Lanes(d);\n   const size_t base_case_num = Constants::BaseCaseNum(N);\n "
      }
    ],
    "lines_added": 55,
    "lines_removed": 25
  },
  "issues": [],
  "pull_requests": [],
  "build_info": {
    "old_build_script": "#!/bin/bash\n#!/bin/bash\ncmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON",
    "new_build_script": "#!/bin/bash\n#!/bin/bash\ncmake -S /test_workspace/workspace/new -B /test_workspace/workspace/new/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON",
    "old_test_script": "#!/bin/bash\ncmake --build /test_workspace/workspace/old/build -- -j 1",
    "new_test_script": "#!/bin/bash\ncmake --build /test_workspace/workspace/new/build -- -j 1",
    "build_system": "cmake"
  },
  "performance_analysis": {
    "is_significant": false,
    "p_value": 1.0,
    "is_pair_significant": false,
    "pair_p_value": 1.0,
    "is_binom_significant": false,
    "binom_p_value": 1.0,
    "is_wilcoxon_significant": false,
    "wilcoxon_p_value": 0.9999991333466779,
    "is_mannwhitney_significant": false,
    "mannwhitney_p_value": 0.5088545948206764,
    "relative_improvement": -0.0006735931089383439,
    "absolute_improvement_ms": -10.999999999999233,
    "old_mean_ms": 16330.333333333332,
    "new_mean_ms": 16341.333333333332,
    "old_std_ms": 80.23600246743386,
    "new_std_ms": 117.05387304742331,
    "effect_size_cohens_d": -0.10961857357357706,
    "old_ci95_ms": [
      16300.372717623055,
      16360.29394904361
    ],
    "new_ci95_ms": [
      16297.624698806121,
      16385.04196786054
    ],
    "old_ci99_ms": [
      16289.954973315542,
      16370.711693351122
    ],
    "new_ci99_ms": [
      16282.42656726776,
      16400.240099398903
    ],
    "new_times_s": [
      16.33,
      16.14,
      16.16,
      16.36,
      16.34,
      16.39,
      16.26,
      16.45,
      16.24,
      16.25,
      16.24,
      16.26,
      16.68,
      16.27,
      16.37,
      16.25,
      16.23,
      16.35,
      16.22,
      16.33,
      16.29,
      16.31,
      16.5,
      16.38,
      16.26,
      16.47,
      16.46,
      16.43,
      16.44,
      16.45,
      16.46
    ],
    "old_times_s": [
      16.25,
      16.2,
      16.34,
      16.34,
      16.26,
      16.31,
      16.29,
      16.15,
      16.32,
      16.28,
      16.42,
      16.26,
      16.15,
      16.47,
      16.35,
      16.33,
      16.38,
      16.3,
      16.42,
      16.5,
      16.33,
      16.28,
      16.36,
      16.32,
      16.39,
      16.34,
      16.43,
      16.32,
      16.32,
      16.36,
      16.39
    ]
  },
  "tests": {
    "total_tests": 1,
    "significant_improvements": 0,
    "significant_improvements_tests": [],
    "significant_regressions": 0,
    "significant_regressions_tests": [],
    "significant_pair_improvements": 0,
    "significant_pair_improvements_tests": [],
    "significant_pair_regressions": 0,
    "significant_pair_regressions_tests": [],
    "significant_binom_improvements": 0,
    "significant_binom_improvements_tests": [],
    "significant_binom_regressions": 0,
    "significant_binom_regressions_tests": [],
    "significant_wilcoxon_improvements": 0,
    "significant_wilcoxon_improvements_tests": [],
    "significant_wilcoxon_regressions": 0,
    "significant_wilcoxon_regressions_tests": [],
    "significant_mannwhitney_improvements": 0,
    "significant_mannwhitney_improvements_tests": [],
    "significant_mannwhitney_regressions": 0,
    "significant_mannwhitney_regressions_tests": [],
    "tests": [
      {
        "test_name": "NanobenchmarkTest.RunAll",
        "is_significant": false,
        "p_value": 0.9232761641233209,
        "is_pair_significant": false,
        "pair_p_value": 0.8877544974938036,
        "is_binom_significant": false,
        "binom_p_value": 0.9319770261645317,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9046302922081206,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.4937852747744425,
        "relative_improvement": -0.009399855386840258,
        "absolute_improvement_ms": -4.482758620689475,
        "old_mean_ms": 476.896551724138,
        "new_mean_ms": 481.3793103448275,
        "old_std_ms": 60.0656455338575,
        "new_std_ms": 88.34688683701935,
        "effect_size_cohens_d": -0.05934162197266506,
        "old_ci95_ms": [
          454.04880208329365,
          499.74430136498245
        ],
        "new_ci95_ms": [
          447.7739518398159,
          514.9846688498391
        ],
        "old_ci99_ms": [
          446.0753699941291,
          507.7177334541469
        ],
        "new_ci99_ms": [
          436.046317911583,
          526.7123027780721
        ],
        "new_times": [
          0.39,
          0.48,
          0.57,
          0.53,
          0.4,
          0.52,
          0.46,
          0.41,
          0.42,
          0.46,
          0.74,
          0.32,
          0.45,
          0.32,
          0.45,
          0.48,
          0.44,
          0.51,
          0.42,
          0.5,
          0.54,
          0.53,
          0.4,
          0.62,
          0.59,
          0.54,
          0.52,
          0.42,
          0.53
        ],
        "old_times": [
          0.44,
          0.55,
          0.47,
          0.43,
          0.43,
          0.38,
          0.46,
          0.43,
          0.39,
          0.47,
          0.37,
          0.62,
          0.47,
          0.54,
          0.54,
          0.49,
          0.57,
          0.56,
          0.48,
          0.4,
          0.5,
          0.43,
          0.47,
          0.5,
          0.47,
          0.47,
          0.47,
          0.48,
          0.55
        ]
      }
    ]
  },
  "logs": {
    "full_log_path": "/logs/full.log",
    "config_log_path": "/logs/config.log",
    "build_log_path": "/logs/build.log",
    "test_log_path": "/logs/test.log",
    "build_success": true,
    "test_success": true
  },
  "raw_timing_data": {
    "warmup_runs": 1,
    "measurement_runs": 30,
    "min_exec_time_improvement": 0.05,
    "min_p_value": 0.05
  }
}