{
    "metadata": {
        "collection_date": "2026-01-14T18:41:03.163815",
        "repository": "https://github.com/google/highway",
        "repository_name": "google/highway"
    },
    "commit_info": {
        "old_sha": "2600cd247399cd2334cef8167eaf197d130b2e8c",
        "new_sha": "774b546cd93411f2fdea8454b49340dcc2ebf420",
        "commit_message": [
            "improved codegen: CompressNot for SVE2_128 and i64 Gt for S-SSE3\n\nPiperOrigin-RevId: 456976164"
        ],
        "commit_date": "2022-06-24T10:44:47+00:00",
        "patch": [
            "--- hwy/ops/arm_sve-inl.h\n@@ -2136,6 +2136,15 @@ HWY_API V CompressNot(V v, const svbool_t mask) {\n \n template <class V, HWY_IF_LANE_SIZE_V(V, 8)>\n HWY_API V CompressNot(V v, svbool_t mask) {\n+#if HWY_TARGET == HWY_SVE2_128 || HWY_IDE\n+  const DFromV<V> d;\n+  // If mask[1] = 0 and mask[0] = 1, then swap both halves, otherwise keep\n+  // unchanged. The predicate functions such as BRK do not seem to help.\n+  const svbool_t maskL = svtrn1_b64(mask, mask);\n+  const svbool_t maskH = svtrn2_b64(mask, mask);\n+  const svbool_t swap = AndNot(maskH, maskL);  // swapped vs Compress()\n+  return IfThenElse(swap, Reverse2(d, v), v);\n+#endif\n #if HWY_TARGET == HWY_SVE_256 || HWY_IDE\n   const DFromV<V> d;\n   const RebindToUnsigned<decltype(d)> du64;\n@@ -2153,9 +2162,9 @@ HWY_API V CompressNot(V v, svbool_t mask) {\n       0, 2, 0, 3, 1, 2, 3, 0, 1, 2, 0, 1, 2, 3, 1, 2, 0, 3, 0, 2, 1, 3,\n       2, 0, 1, 3, 0, 1, 2, 3, 1, 0, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3};\n   return TableLookupLanes(v, SetTableIndices(d, table + offset));\n-#else\n-  return Compress(v, Not(mask));\n #endif  // HWY_TARGET == HWY_SVE_256\n+\n+  return Compress(v, Not(mask));\n }\n \n // ------------------------------ CompressBlocksNot\n--- hwy/ops/x86_128-inl.h\n@@ -1783,21 +1783,16 @@ template <size_t N>\n HWY_API Mask128<int64_t, N> operator>(const Vec128<int64_t, N> a,\n                                       const Vec128<int64_t, N> b) {\n #if HWY_TARGET == HWY_SSSE3\n-  // We want unsigned comparison but only for the lower 32 bits, so we cannot\n-  // just cast to uint64_t. Instead flip the lower sign bit.\n+  // See https://stackoverflow.com/questions/65166174/:\n   const Simd<int64_t, N, 0> d;\n-  const Vec128<int64_t, N> bit31 = Set(d, 0x80000000LL);\n-  // If the upper half is less than or greater, this is the answer.\n-  const __m128i m_gt = _mm_cmpgt_epi32(Xor(a, bit31).raw, Xor(b, bit31).raw);\n-\n-  // Otherwise, the lower half decides.\n-  const __m128i m_eq = _mm_cmpeq_epi32(a.raw, b.raw);\n-  const __m128i lo_in_hi = _mm_shuffle_epi32(m_gt, _MM_SHUFFLE(2, 2, 0, 0));\n-  const __m128i lo_gt = _mm_and_si128(m_eq, lo_in_hi);\n-\n-  const __m128i gt = _mm_or_si128(lo_gt, m_gt);\n-  // Copy result in upper 32 bits to lower 32 bits.\n-  return Mask128<int64_t, N>{_mm_shuffle_epi32(gt, _MM_SHUFFLE(3, 3, 1, 1))};\n+  const RepartitionToNarrow<decltype(d)> d32;\n+  const Vec128<int64_t, N> m_eq32{Eq(BitCast(d32, a), BitCast(d32, b)).raw};\n+  const Vec128<int64_t, N> m_gt32{Gt(BitCast(d32, a), BitCast(d32, b)).raw};\n+  // If a.upper is greater, upper := true. Otherwise, if a.upper == b.upper:\n+  // upper := b-a (unsigned comparison result of lower). Otherwise: upper := 0.\n+  const __m128i upper = OrAnd(m_gt32, m_eq32, Sub(b, a)).raw;\n+  // Duplicate upper to lower half.\n+  return Mask128<int64_t, N>{_mm_shuffle_epi32(upper, _MM_SHUFFLE(3, 3, 1, 1))};\n #else\n   return Mask128<int64_t, N>{_mm_cmpgt_epi64(a.raw, b.raw)};  // SSE4.2\n #endif"
        ],
        "files_changed": [
            {
                "filename": "hwy/ops/arm_sve-inl.h",
                "status": "modified",
                "additions": 11,
                "deletions": 2,
                "changes": 13,
                "patch": "@@ -2136,6 +2136,15 @@ HWY_API V CompressNot(V v, const svbool_t mask) {\n \n template <class V, HWY_IF_LANE_SIZE_V(V, 8)>\n HWY_API V CompressNot(V v, svbool_t mask) {\n+#if HWY_TARGET == HWY_SVE2_128 || HWY_IDE\n+  const DFromV<V> d;\n+  // If mask[1] = 0 and mask[0] = 1, then swap both halves, otherwise keep\n+  // unchanged. The predicate functions such as BRK do not seem to help.\n+  const svbool_t maskL = svtrn1_b64(mask, mask);\n+  const svbool_t maskH = svtrn2_b64(mask, mask);\n+  const svbool_t swap = AndNot(maskH, maskL);  // swapped vs Compress()\n+  return IfThenElse(swap, Reverse2(d, v), v);\n+#endif\n #if HWY_TARGET == HWY_SVE_256 || HWY_IDE\n   const DFromV<V> d;\n   const RebindToUnsigned<decltype(d)> du64;\n@@ -2153,9 +2162,9 @@ HWY_API V CompressNot(V v, svbool_t mask) {\n       0, 2, 0, 3, 1, 2, 3, 0, 1, 2, 0, 1, 2, 3, 1, 2, 0, 3, 0, 2, 1, 3,\n       2, 0, 1, 3, 0, 1, 2, 3, 1, 0, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3};\n   return TableLookupLanes(v, SetTableIndices(d, table + offset));\n-#else\n-  return Compress(v, Not(mask));\n #endif  // HWY_TARGET == HWY_SVE_256\n+\n+  return Compress(v, Not(mask));\n }\n \n // ------------------------------ CompressBlocksNot"
            },
            {
                "filename": "hwy/ops/x86_128-inl.h",
                "status": "modified",
                "additions": 9,
                "deletions": 14,
                "changes": 23,
                "patch": "@@ -1783,21 +1783,16 @@ template <size_t N>\n HWY_API Mask128<int64_t, N> operator>(const Vec128<int64_t, N> a,\n                                       const Vec128<int64_t, N> b) {\n #if HWY_TARGET == HWY_SSSE3\n-  // We want unsigned comparison but only for the lower 32 bits, so we cannot\n-  // just cast to uint64_t. Instead flip the lower sign bit.\n+  // See https://stackoverflow.com/questions/65166174/:\n   const Simd<int64_t, N, 0> d;\n-  const Vec128<int64_t, N> bit31 = Set(d, 0x80000000LL);\n-  // If the upper half is less than or greater, this is the answer.\n-  const __m128i m_gt = _mm_cmpgt_epi32(Xor(a, bit31).raw, Xor(b, bit31).raw);\n-\n-  // Otherwise, the lower half decides.\n-  const __m128i m_eq = _mm_cmpeq_epi32(a.raw, b.raw);\n-  const __m128i lo_in_hi = _mm_shuffle_epi32(m_gt, _MM_SHUFFLE(2, 2, 0, 0));\n-  const __m128i lo_gt = _mm_and_si128(m_eq, lo_in_hi);\n-\n-  const __m128i gt = _mm_or_si128(lo_gt, m_gt);\n-  // Copy result in upper 32 bits to lower 32 bits.\n-  return Mask128<int64_t, N>{_mm_shuffle_epi32(gt, _MM_SHUFFLE(3, 3, 1, 1))};\n+  const RepartitionToNarrow<decltype(d)> d32;\n+  const Vec128<int64_t, N> m_eq32{Eq(BitCast(d32, a), BitCast(d32, b)).raw};\n+  const Vec128<int64_t, N> m_gt32{Gt(BitCast(d32, a), BitCast(d32, b)).raw};\n+  // If a.upper is greater, upper := true. Otherwise, if a.upper == b.upper:\n+  // upper := b-a (unsigned comparison result of lower). Otherwise: upper := 0.\n+  const __m128i upper = OrAnd(m_gt32, m_eq32, Sub(b, a)).raw;\n+  // Duplicate upper to lower half.\n+  return Mask128<int64_t, N>{_mm_shuffle_epi32(upper, _MM_SHUFFLE(3, 3, 1, 1))};\n #else\n   return Mask128<int64_t, N>{_mm_cmpgt_epi64(a.raw, b.raw)};  // SSE4.2\n #endif"
            }
        ],
        "lines_added": 20,
        "lines_removed": 16
    },
    "issues": [],
    "pull_requests": [],
    "build_info": {
        "old_build_script": [
            "apt-get update",
            "cmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON",
            "cmake --build /test_workspace/workspace/old/build -- -j 1"
        ],
        "new_build_script": [
            "apt-get update",
            "cmake -S /test_workspace/workspace/new -B /test_workspace/workspace/new/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON",
            "cmake --build /test_workspace/workspace/new/build -- -j 1"
        ],
        "old_test_script": [
            "cd /test_workspace/workspace/old/build",
            "ctest --output-on-failure"
        ],
        "new_test_script": [
            "cd /test_workspace/workspace/new/build",
            "ctest --output-on-failure"
        ],
        "build_system": "cmake"
    },
    "performance_analysis": {
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999991349814353,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.9991686075776081,
        "relative_improvement": -0.011558645734151083,
        "absolute_improvement_ms": -173.9999999999995,
        "old_mean_ms": 15053.666666666666,
        "new_mean_ms": 15227.666666666666,
        "old_std_ms": 202.5438791682082,
        "new_std_ms": 176.45324345683423,
        "effect_size_cohens_d": -0.9160447195896698,
        "old_ci95_ms": [
            14978.035539222466,
            15129.297794110867
        ],
        "new_ci95_ms": [
            15161.777942709014,
            15293.555390624319
        ],
        "old_ci99_ms": [
            14951.737489976022,
            15155.59584335731
        ],
        "new_ci99_ms": [
            15138.867469654091,
            15316.465863679241
        ],
        "new_times_s": [
            15.34,
            15.19,
            15.04,
            15.27,
            15.21,
            15.27,
            15.27,
            15.18,
            15.03,
            15.47,
            15.27,
            15.41,
            15.33,
            15.43,
            15.21,
            15.29,
            14.91,
            15.08,
            15.1,
            15.37,
            15.07,
            15.27,
            15.21,
            15.3,
            14.87,
            15.42,
            15.41,
            15.11,
            15.69,
            15.13,
            15.02
        ],
        "old_times_s": [
            15.24,
            14.76,
            15.3,
            14.81,
            15.21,
            14.98,
            14.77,
            15.08,
            15.21,
            15.2,
            15.11,
            15.19,
            14.88,
            15.0,
            14.88,
            14.89,
            15.01,
            15.25,
            15.3,
            14.94,
            15.44,
            15.21,
            15.06,
            15.31,
            14.89,
            15.02,
            15.45,
            14.99,
            14.81,
            14.75,
            14.91
        ]
    },
    "tests": {
        "total_tests": 1,
        "significant_improvements": 0,
        "significant_improvements_tests": [],
        "significant_regressions": 0,
        "significant_regressions_tests": [],
        "significant_pair_improvements": 0,
        "significant_pair_improvements_tests": [],
        "significant_pair_regressions": 0,
        "significant_pair_regressions_tests": [],
        "significant_binom_improvements": 0,
        "significant_binom_improvements_tests": [],
        "significant_binom_regressions": 0,
        "significant_binom_regressions_tests": [],
        "significant_wilcoxon_improvements": 0,
        "significant_wilcoxon_improvements_tests": [],
        "significant_wilcoxon_regressions": 0,
        "significant_wilcoxon_regressions_tests": [],
        "significant_mannwhitney_improvements": 0,
        "significant_mannwhitney_improvements_tests": [],
        "significant_mannwhitney_regressions": 0,
        "significant_mannwhitney_regressions_tests": [],
        "tests": [
            {
                "test_name": "NanobenchmarkTest.RunAll",
                "is_significant": false,
                "p_value": 0.7567082176170734,
                "is_pair_significant": false,
                "pair_p_value": 0.7431095557481613,
                "is_binom_significant": false,
                "binom_p_value": 0.867534551769495,
                "is_wilcoxon_significant": false,
                "wilcoxon_p_value": 0.7417509511918432,
                "is_mannwhitney_significant": false,
                "mannwhitney_p_value": 0.5155280058769296,
                "relative_improvement": 0.006034482758620715,
                "absolute_improvement_ms": 2.413793103448192,
                "old_mean_ms": 399.9999999999999,
                "new_mean_ms": 397.58620689655174,
                "old_std_ms": 97.97958971132712,
                "new_std_ms": 98.0763249578683,
                "effect_size_cohens_d": 0.02462351430409223,
                "old_ci95_ms": [
                    362.7305572804472,
                    437.2694427195526
                ],
                "new_ci95_ms": [
                    360.2799680571077,
                    434.8924457359958
                ],
                "old_ci99_ms": [
                    349.7242273268782,
                    450.27577267312165
                ],
                "new_ci99_ms": [
                    347.2607969542915,
                    447.91161683881194
                ],
                "new_times": [
                    0.19,
                    0.42,
                    0.19,
                    0.23,
                    0.48,
                    0.36,
                    0.37,
                    0.49,
                    0.37,
                    0.49,
                    0.51,
                    0.48,
                    0.44,
                    0.42,
                    0.41,
                    0.31,
                    0.45,
                    0.45,
                    0.19,
                    0.47,
                    0.32,
                    0.43,
                    0.5,
                    0.47,
                    0.33,
                    0.47,
                    0.37,
                    0.5,
                    0.42
                ],
                "old_times": [
                    0.53,
                    0.42,
                    0.23,
                    0.42,
                    0.37,
                    0.48,
                    0.46,
                    0.4,
                    0.55,
                    0.39,
                    0.38,
                    0.17,
                    0.41,
                    0.4,
                    0.48,
                    0.46,
                    0.49,
                    0.36,
                    0.3,
                    0.48,
                    0.52,
                    0.25,
                    0.39,
                    0.4,
                    0.24,
                    0.25,
                    0.51,
                    0.42,
                    0.44
                ]
            }
        ]
    },
    "logs": {
        "full_log_path": "/logs/full.log",
        "config_log_path": "/logs/config.log",
        "build_log_path": "/logs/build.log",
        "test_log_path": "/logs/test.log",
        "build_success": true,
        "test_success": true
    },
    "raw_timing_data": {
        "warmup_runs": 1,
        "measurement_runs": 30,
        "min_exec_time_improvement": 0.05,
        "min_p_value": 0.05
    }
}