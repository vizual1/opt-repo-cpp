{
  "metadata": {
    "collection_date": "2026-01-11T17:49:45.794347",
    "repository": "https://github.com/chris2511/xca",
    "repository_name": "chris2511/xca"
  },
  "commit_info": {
    "old_sha": "6b9c16a36aaa7bf1d72d35bf58a09324cd2d4c59",
    "new_sha": "a25b6c740251881c05768efdbb80e75b9d706f54",
    "commit_message": [
      "Close #520: permanent processor load\n\nImprove the timer interval maintenance process:\n - Do not fire every second,\n   but at most 1 second after the last run\n - Reduce the fired events.\n - Every container now only evaluates its own elements\n   (keys, certs,etc.) instead of each container evaluating all\n   items and duplicating work\n\nDisable sorting and resizing in the view during initialization,\nto speed up opening the database"
    ],
    "commit_date": "2024-02-23T08:58:32+00:00",
    "patch": [
      "--- lib/db_base.cpp\n@@ -19,13 +19,11 @@ void db_base::restart_timer()\n {\n \tif (!IS_GUI_APP)\n \t\treturn;\n-\tkillTimer(secondsTimer);\n-\tkillTimer(minutesTimer);\n-\tkillTimer(hoursTimer);\n \n-\tsecondsTimer = startTimer(1000);\n-\tminutesTimer = startTimer(MSECS_PER_MINUTE);\n-\thoursTimer = startTimer(MSECS_PER_HOUR);\n+\tmaintenanceTimer.setSingleShot(true);\n+\n+\tmaintenanceTimer.setInterval(1000);\n+\tmaintenanceTimer.start();\n }\n \n db_base::db_base(const char *classname)\n@@ -34,6 +32,8 @@ db_base::db_base(const char *classname)\n \trootItem = new pki_base(QString(\"ROOTitem(%1)\").arg(classname));\n \ttreeItem = new pki_base(QString(\"TREEitem(%1)\").arg(classname));\n \tclass_name = classname;\n+\tconnect(&maintenanceTimer, SIGNAL(timeout()),\n+\t\tthis, SLOT(timerMaintenance()));\n \trestart_timer();\n }\n \n@@ -559,12 +559,27 @@ void db_base::updateItem(pki_base *pki)\n \trestart_timer();\n }\n \n-void db_base::timerEvent(QTimerEvent *event)\n+void db_base::timerMaintenance()\n {\n \tint youngest = SECS_PER_DAY;\n-\tint id = event->timerId();\n+\tbool minuteElapsed = false, hourElapsed = false;\n+\n+\tif (!rootItem)\n+\t\treturn;\n+\n+\tif (minuteMarker.age() > SECS_PER_MINUTE) {\n+\t\tminuteElapsed = true;\n+\t\tminuteMarker = a1time::now();\n+\t}\n+\tif (hourMarker.age() > SECS_PER_HOUR) {\n+\t\thourElapsed = true;\n+\t\thourMarker = a1time::now();\n+\t}\n \n-\tforeach(pki_base *pki, Store.getAll<pki_base>()) {\n+\tqDebug() << \"Maintenance start\" << class_name << minuteElapsed\n+\t\t\t<< hourElapsed << rootItem->getChildItems().count();\n+\n+\tforeach(pki_base *pki, rootItem->getChildItems()) {\n \t\tfor (int idx=0; idx < allHeaders.count(); idx++) {\n \t\t\tdbheader *hd = allHeaders[idx];\n \t\t\tif (hd->type != dbheader::hd_asn1time)\n@@ -580,14 +595,14 @@ void db_base::timerEvent(QTimerEvent *event)\n \t\t\t\tyoungest = age;\n \t\t\tif (!hd->show)\n \t\t\t\tcontinue;\n-\t\t\tif (id == secondsTimer && (age < SECS_PER_MINUTE *2 ||\n-\t\t\t\t\t\t   age % SECS_PER_MINUTE < 2))\n+\n+\t\t\tif ((age < SECS_PER_MINUTE *2 || age % SECS_PER_MINUTE < 2))\n \t\t\t\tdo_emit = true;\n-\t\t\tif (id == minutesTimer && (age % SECS_PER_HOUR < 60))\n+\t\t\tif (minuteElapsed && (age % SECS_PER_HOUR < SECS_PER_MINUTE *2))\n \t\t\t\tdo_emit = true;\n-\t\t\tif (id == hoursTimer &&\n-\t\t\t\t\t (age % SECS_PER_DAY < SECS_PER_HOUR))\n+\t\t\tif (hourElapsed && (age % SECS_PER_DAY < SECS_PER_HOUR *2))\n \t\t\t\tdo_emit = true;\n+\n \t\t\tif (do_emit) {\n \t\t\t\tqDebug() << \"Date changed for\" << pki->getIntName() << \":\" << hd->getName() << \"Col:\" << idx << t.toSortable();\n \t\t\t\tQModelIndex i;\n@@ -601,14 +616,15 @@ void db_base::timerEvent(QTimerEvent *event)\n \t\t\t}\n \t\t}\n \t}\n-\tif (secondsTimer && youngest > SECS_PER_HOUR *2) {\n-\t\tkillTimer(secondsTimer);\n-\t\tsecondsTimer = 0;\n-\t}\n-\tif (minutesTimer && youngest > SECS_PER_DAY *2) {\n-\t\tkillTimer(minutesTimer);\n-\t\tminutesTimer = 0;\n-\t}\n+\tint delay = youngest * 100;\n+\tif (delay < 1000)\n+\t\tdelay = 1000;\n+\tif (delay > SECS_PER_HOUR *1000)\n+\t\tdelay = SECS_PER_HOUR *1000;\n+\n+\tmaintenanceTimer.setInterval(delay);\n+\tmaintenanceTimer.start();\n+\tqDebug() << \"Maintenance end\" << class_name << delay << youngest;\n }\n \n bool db_base::columnHidden(int col) const\n--- lib/db_base.h\n@@ -28,7 +28,8 @@ class db_base: public QAbstractItemModel\n \tQ_OBJECT\n \n \tprotected:\n-\t\tint secondsTimer{}, minutesTimer{}, hoursTimer{};\n+\t\ta1time minuteMarker{}, hourMarker{};\n+\t\tQTimer maintenanceTimer{};\n \t\tQList<enum pki_type> pkitype{};\n \t\tQList<enum pki_type> pkitype_depends{};\n \t\tQString class_name{};\n@@ -45,7 +46,6 @@ class db_base: public QAbstractItemModel\n \t\tvirtual dbheaderList getHeaders();\n \t\tQString sqlItemSelector();\n \t\tbool isValidCol(int col) const;\n-\t\tvoid timerEvent(QTimerEvent *event);\n \n \tpublic:\n \t\tvoid restart_timer();\n@@ -139,6 +139,7 @@ class db_base: public QAbstractItemModel\n \t\tvoid sectionResized(int i, int, int newSize);\n \t\tvoid sortIndicatorChanged(int, Qt::SortOrder);\n \t\tvoid setSelected(const QVariant &v);\n+\t\tvoid timerMaintenance();\n \n \tsignals:\n \t\tvoid resetHeader() const;\n--- widgets/XcaTreeView.cpp\n@@ -41,7 +41,6 @@ XcaTreeView::XcaTreeView(QWidget *parent)\n \t//setAnimated(true);\n \n \tproxy = new XcaProxyModel(this);\n-\tsetSortingEnabled(true);\n \tproxy->setDynamicSortFilter(true);\n \tsortByColumn(0, Qt::AscendingOrder);\n \tconnect(header(), SIGNAL(sectionHandleDoubleClicked(int)),\n@@ -99,9 +98,12 @@ void XcaTreeView::setModel(QAbstractItemModel *model)\n {\n \tQByteArray ba;\n \n+\theader()->setStretchLastSection(false);\n+\tsetSortingEnabled(false);\n+\n \tbasemodel = dynamic_cast<db_base*>(model);\n \tproxy->setSourceModel(model);\n-\tQTreeView::setModel(model ? proxy : NULL);\n+\tQTreeView::setModel(model ? proxy : nullptr);\n \n \tif (basemodel) {\n \t\tsetRootIsDecorated(basemodel->treeViewMode());\n@@ -123,6 +125,9 @@ void XcaTreeView::setModel(QAbstractItemModel *model)\n \t\t\t\t\t\t\t\t\t\tconst QModelIndex &)));\n \n \t\tbasemodel->initHeaderView(header());\n+\t\tsetSortingEnabled(true);\n+\t\theader()->setStretchLastSection(true);\n+\n \t}\n \tshowHideSections();\n }"
    ],
    "files_changed": [
      {
        "filename": "lib/db_base.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 22,
        "changes": 60,
        "patch": "@@ -19,13 +19,11 @@ void db_base::restart_timer()\n {\n \tif (!IS_GUI_APP)\n \t\treturn;\n-\tkillTimer(secondsTimer);\n-\tkillTimer(minutesTimer);\n-\tkillTimer(hoursTimer);\n \n-\tsecondsTimer = startTimer(1000);\n-\tminutesTimer = startTimer(MSECS_PER_MINUTE);\n-\thoursTimer = startTimer(MSECS_PER_HOUR);\n+\tmaintenanceTimer.setSingleShot(true);\n+\n+\tmaintenanceTimer.setInterval(1000);\n+\tmaintenanceTimer.start();\n }\n \n db_base::db_base(const char *classname)\n@@ -34,6 +32,8 @@ db_base::db_base(const char *classname)\n \trootItem = new pki_base(QString(\"ROOTitem(%1)\").arg(classname));\n \ttreeItem = new pki_base(QString(\"TREEitem(%1)\").arg(classname));\n \tclass_name = classname;\n+\tconnect(&maintenanceTimer, SIGNAL(timeout()),\n+\t\tthis, SLOT(timerMaintenance()));\n \trestart_timer();\n }\n \n@@ -559,12 +559,27 @@ void db_base::updateItem(pki_base *pki)\n \trestart_timer();\n }\n \n-void db_base::timerEvent(QTimerEvent *event)\n+void db_base::timerMaintenance()\n {\n \tint youngest = SECS_PER_DAY;\n-\tint id = event->timerId();\n+\tbool minuteElapsed = false, hourElapsed = false;\n+\n+\tif (!rootItem)\n+\t\treturn;\n+\n+\tif (minuteMarker.age() > SECS_PER_MINUTE) {\n+\t\tminuteElapsed = true;\n+\t\tminuteMarker = a1time::now();\n+\t}\n+\tif (hourMarker.age() > SECS_PER_HOUR) {\n+\t\thourElapsed = true;\n+\t\thourMarker = a1time::now();\n+\t}\n \n-\tforeach(pki_base *pki, Store.getAll<pki_base>()) {\n+\tqDebug() << \"Maintenance start\" << class_name << minuteElapsed\n+\t\t\t<< hourElapsed << rootItem->getChildItems().count();\n+\n+\tforeach(pki_base *pki, rootItem->getChildItems()) {\n \t\tfor (int idx=0; idx < allHeaders.count(); idx++) {\n \t\t\tdbheader *hd = allHeaders[idx];\n \t\t\tif (hd->type != dbheader::hd_asn1time)\n@@ -580,14 +595,14 @@ void db_base::timerEvent(QTimerEvent *event)\n \t\t\t\tyoungest = age;\n \t\t\tif (!hd->show)\n \t\t\t\tcontinue;\n-\t\t\tif (id == secondsTimer && (age < SECS_PER_MINUTE *2 ||\n-\t\t\t\t\t\t   age % SECS_PER_MINUTE < 2))\n+\n+\t\t\tif ((age < SECS_PER_MINUTE *2 || age % SECS_PER_MINUTE < 2))\n \t\t\t\tdo_emit = true;\n-\t\t\tif (id == minutesTimer && (age % SECS_PER_HOUR < 60))\n+\t\t\tif (minuteElapsed && (age % SECS_PER_HOUR < SECS_PER_MINUTE *2))\n \t\t\t\tdo_emit = true;\n-\t\t\tif (id == hoursTimer &&\n-\t\t\t\t\t (age % SECS_PER_DAY < SECS_PER_HOUR))\n+\t\t\tif (hourElapsed && (age % SECS_PER_DAY < SECS_PER_HOUR *2))\n \t\t\t\tdo_emit = true;\n+\n \t\t\tif (do_emit) {\n \t\t\t\tqDebug() << \"Date changed for\" << pki->getIntName() << \":\" << hd->getName() << \"Col:\" << idx << t.toSortable();\n \t\t\t\tQModelIndex i;\n@@ -601,14 +616,15 @@ void db_base::timerEvent(QTimerEvent *event)\n \t\t\t}\n \t\t}\n \t}\n-\tif (secondsTimer && youngest > SECS_PER_HOUR *2) {\n-\t\tkillTimer(secondsTimer);\n-\t\tsecondsTimer = 0;\n-\t}\n-\tif (minutesTimer && youngest > SECS_PER_DAY *2) {\n-\t\tkillTimer(minutesTimer);\n-\t\tminutesTimer = 0;\n-\t}\n+\tint delay = youngest * 100;\n+\tif (delay < 1000)\n+\t\tdelay = 1000;\n+\tif (delay > SECS_PER_HOUR *1000)\n+\t\tdelay = SECS_PER_HOUR *1000;\n+\n+\tmaintenanceTimer.setInterval(delay);\n+\tmaintenanceTimer.start();\n+\tqDebug() << \"Maintenance end\" << class_name << delay << youngest;\n }\n \n bool db_base::columnHidden(int col) const"
      },
      {
        "filename": "lib/db_base.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "patch": "@@ -28,7 +28,8 @@ class db_base: public QAbstractItemModel\n \tQ_OBJECT\n \n \tprotected:\n-\t\tint secondsTimer{}, minutesTimer{}, hoursTimer{};\n+\t\ta1time minuteMarker{}, hourMarker{};\n+\t\tQTimer maintenanceTimer{};\n \t\tQList<enum pki_type> pkitype{};\n \t\tQList<enum pki_type> pkitype_depends{};\n \t\tQString class_name{};\n@@ -45,7 +46,6 @@ class db_base: public QAbstractItemModel\n \t\tvirtual dbheaderList getHeaders();\n \t\tQString sqlItemSelector();\n \t\tbool isValidCol(int col) const;\n-\t\tvoid timerEvent(QTimerEvent *event);\n \n \tpublic:\n \t\tvoid restart_timer();\n@@ -139,6 +139,7 @@ class db_base: public QAbstractItemModel\n \t\tvoid sectionResized(int i, int, int newSize);\n \t\tvoid sortIndicatorChanged(int, Qt::SortOrder);\n \t\tvoid setSelected(const QVariant &v);\n+\t\tvoid timerMaintenance();\n \n \tsignals:\n \t\tvoid resetHeader() const;"
      },
      {
        "filename": "widgets/XcaTreeView.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 2,
        "changes": 9,
        "patch": "@@ -41,7 +41,6 @@ XcaTreeView::XcaTreeView(QWidget *parent)\n \t//setAnimated(true);\n \n \tproxy = new XcaProxyModel(this);\n-\tsetSortingEnabled(true);\n \tproxy->setDynamicSortFilter(true);\n \tsortByColumn(0, Qt::AscendingOrder);\n \tconnect(header(), SIGNAL(sectionHandleDoubleClicked(int)),\n@@ -99,9 +98,12 @@ void XcaTreeView::setModel(QAbstractItemModel *model)\n {\n \tQByteArray ba;\n \n+\theader()->setStretchLastSection(false);\n+\tsetSortingEnabled(false);\n+\n \tbasemodel = dynamic_cast<db_base*>(model);\n \tproxy->setSourceModel(model);\n-\tQTreeView::setModel(model ? proxy : NULL);\n+\tQTreeView::setModel(model ? proxy : nullptr);\n \n \tif (basemodel) {\n \t\tsetRootIsDecorated(basemodel->treeViewMode());\n@@ -123,6 +125,9 @@ void XcaTreeView::setModel(QAbstractItemModel *model)\n \t\t\t\t\t\t\t\t\t\tconst QModelIndex &)));\n \n \t\tbasemodel->initHeaderView(header());\n+\t\tsetSortingEnabled(true);\n+\t\theader()->setStretchLastSection(true);\n+\n \t}\n \tshowHideSections();\n }"
      }
    ],
    "lines_added": 48,
    "lines_removed": 26
  },
  "issues": [
    {
      "number": 520,
      "url": "https://github.com/chris2511/xca/issues/520",
      "title": "permanent processor load / stucked instances as background process",
      "body": "With xca 2.5.0 Win64 and a rather big CA (1300 certs) work became slower every day.\r\nIn the end one core was at 50% load for several minutes after one removed old cert. Removal took several seconds.\r\n\r\nInvestigation first pointed to MariaDB via Network. Local MariaDB looked fine but became slower with working.\r\nThen i found in the category \"Hintergrundprozesse\" (not shure background process) of the taskmanager stucked XCA processes with normal 25MB memory but no CPU load.\r\nIn the end this processes seam to slow down the active process - how i can\u00b4t imagine.\r\n\r\nCheck with local sqlite database, newer libssl/libcrypto (3.0.13.0/3.1.5) brought some speed but not for long.\r\nI used the portabel package and checked against the app - only to find the app as background process after closing.\r\n\r\nLob f\u00fcr das tolle Programm, das ich schon seit 2006 benutze auf deutsch - DANKE!",
      "created_at": "2024-02-14T18:03:01+00:00"
    }
  ],
  "pull_requests": [],
  "build_info": {
    "old_build_script": "#!/bin/bash\n#!/bin/bash\ncmake --build /test_workspace/workspace/old/build -- -j 1",
    "new_build_script": "#!/bin/bash\n#!/bin/bash\ncmake --build /test_workspace/workspace/old/build -- -j 1",
    "old_test_script": "#!/bin/bash\ncmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON",
    "new_test_script": "#!/bin/bash\ncmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON",
    "build_system": "cmake"
  },
  "performance_analysis": {
    "is_significant": false,
    "p_value": 0.9999952958451719,
    "is_pair_significant": false,
    "pair_p_value": 0.9999999968873089,
    "is_binom_significant": false,
    "binom_p_value": 0.9999999990686774,
    "is_wilcoxon_significant": false,
    "wilcoxon_p_value": 0.999998699808437,
    "is_mannwhitney_significant": false,
    "mannwhitney_p_value": 0.28508125885414476,
    "relative_improvement": 0.005494505494505378,
    "absolute_improvement_ms": 0.3333333333333313,
    "old_mean_ms": 60.66666666666667,
    "new_mean_ms": 60.33333333333334,
    "old_std_ms": 2.5370813170246267,
    "new_std_ms": 1.825741858350555,
    "effect_size_cohens_d": 0.15081478057277864,
    "old_ci95_ms": [
      59.71930493343536,
      61.61402839989799
    ],
    "new_ci95_ms": [
      59.65159011928911,
      61.015076547377575
    ],
    "old_ci99_ms": [
      59.3898934020114,
      61.94343993132195
    ],
    "new_ci99_ms": [
      59.4145380321099,
      61.25212863455678
    ],
    "new_times_s": [
      0.07,
      0.06,
      0.06,
      0.06,
      0.07,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06
    ],
    "old_times_s": [
      0.07,
      0.06,
      0.06,
      0.06,
      0.07,
      0.07,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06,
      0.06
    ]
  },
  "tests": {
    "total_tests": 0,
    "significant_improvements": 0,
    "significant_improvements_tests": [],
    "significant_regressions": 0,
    "significant_regressions_tests": [],
    "significant_pair_improvements": 0,
    "significant_pair_improvements_tests": [],
    "significant_pair_regressions": 0,
    "significant_pair_regressions_tests": [],
    "significant_binom_improvements": 0,
    "significant_binom_improvements_tests": [],
    "significant_binom_regressions": 0,
    "significant_binom_regressions_tests": [],
    "significant_wilcoxon_improvements": 0,
    "significant_wilcoxon_improvements_tests": [],
    "significant_wilcoxon_regressions": 0,
    "significant_wilcoxon_regressions_tests": [],
    "significant_mannwhitney_improvements": 0,
    "significant_mannwhitney_improvements_tests": [],
    "significant_mannwhitney_regressions": 0,
    "significant_mannwhitney_regressions_tests": [],
    "tests": []
  },
  "logs": {
    "full_log_path": "/logs/full.log",
    "config_log_path": "/logs/config.log",
    "build_log_path": "/logs/build.log",
    "test_log_path": "/logs/test.log",
    "build_success": true,
    "test_success": true
  },
  "raw_timing_data": {
    "warmup_runs": 1,
    "measurement_runs": 30,
    "min_exec_time_improvement": 0.05,
    "min_p_value": 0.05
  }
}