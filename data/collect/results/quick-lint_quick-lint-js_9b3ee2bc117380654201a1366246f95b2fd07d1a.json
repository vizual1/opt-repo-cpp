{
  "metadata": {
    "collection_date": "2026-01-14T18:38:13.085400",
    "repository": "https://github.com/quick-lint/quick-lint-js",
    "repository_name": "quick-lint/quick-lint-js"
  },
  "commit_info": {
    "old_sha": "c59e7aba527ff88fd17e681ffee338f5947cc4d3",
    "new_sha": "9b3ee2bc117380654201a1366246f95b2fd07d1a",
    "commit_message": [
      "Upgrade simdjson to version 1.0.0"
    ],
    "commit_date": "2021-09-28T23:16:53+00:00",
    "patch": [
      "--- vendor/README.txt\n@@ -169,17 +169,15 @@ consumption:\n The following patches have been manually applied:\n \n * simdjson-cmake-version.patch\n-* simdjson-iostream.patch\n-* simdjson-reenter-child-ub.patch\n \n Copyright: Copyright 2018-2019 The simdjson authors; various\n-Download URL: https://github.com/simdjson/simdjson/archive/refs/tags/v0.9.6.tar.gz\n-Download date: July 17, 2021\n-Git commit: e9b893ff1b13c6a70135827c62b3f3d65938d135\n-License file: simdjson/LICENSE; simdjson/src/to_chars.cpp; simdjson/windows/toni_ronnko_dirent.h; simdjson/windows/getopt.h; simdjson/include/simdjson/internal/isadetection.h\n-License type: Apache-2.0; MIT; MIT; MIT(Old Style with legal disclaimer 2)/BSD-2-Clause; BSD-3-Clause\n+Download URL: https://codeload.github.com/simdjson/simdjson/tar.gz/refs/tags/v1.0.0\n+Download date: September 28, 2021\n+Git commit: 3bd8b0b575f43403705dcce57d427944c11421f8\n+License file: simdjson/LICENSE; simdjson/src/to_chars.cpp; simdjson/windows/toni_ronnko_dirent.h; simdjson/windows/getopt.h; simdjson/include/simdjson/internal/isadetection.h; simdjson/include/simdjson/nonstd/string_view.hpp\n+License type: Apache-2.0; MIT; MIT; MIT(Old Style with legal disclaimer 2)/BSD-2-Clause; BSD-3-Clause; BSL-1.0\n Location: simdjson\n Project URL: https://github.com/simdjson/simdjson\n-Release URL: https://github.com/simdjson/simdjson/releases/tag/v0.9.6\n-Release date: June 6, 2021\n-Version: 0.9.6\n+Release URL: https://github.com/simdjson/simdjson/releases/tag/v1.0.0\n+Release date: September 7, 2021\n+Version: 1.0.0\n--- vendor/simdjson-cmake-version.patch\n@@ -3,23 +3,54 @@ CMake version 3.10.2 on Ubuntu 18.04 Bionic.\n \n --- a/CMakeLists.txt\n +++ b/CMakeLists.txt\n-@@ -1,4 +1,4 @@\n--cmake_minimum_required(VERSION 3.13)\n+@@ -1,11 +1,10 @@\n+-cmake_minimum_required(VERSION 3.14)\n +cmake_minimum_required(VERSION 3.9)\n- # CMP0025: Compiler id for Apple Clang is now AppleClang.\n- # https://cmake.org/cmake/help/v3.17/policy/CMP0025.html\n- cmake_policy(SET CMP0025 NEW)\n-@@ -52,13 +52,6 @@ configure_package_config_file(\"${PROJECT_SOURCE_DIR}/cmake/simdjson-config.cmake\n-       INSTALL_DESTINATION \"${CMAKE_INSTALL_LIBDIR}/cmake/simdjson\"\n-       NO_SET_AND_CHECK_MACRO\n-       NO_CHECK_REQUIRED_COMPONENTS_MACRO)\n+\n+ project(\n+     simdjson\n+     # The version number is modified by tools/release.py\n+     VERSION 1.0.0\n+     DESCRIPTION \"Parsing gigabytes of JSON per second\"\n+-    HOMEPAGE_URL \"https://simdjson.org/\"\n+     LANGUAGES CXX C\n+ )\n+\n+@@ -123,23 +122,8 @@ install(\n+     COMPONENT simdjson_Development\n+ )\n+\n+-install(\n+-    TARGETS simdjson\n+-    EXPORT simdjsonTargets\n+-    RUNTIME COMPONENT simdjson_Runtime\n+-    LIBRARY COMPONENT simdjson_Runtime\n+-    NAMELINK_COMPONENT simdjson_Development\n+-    ARCHIVE COMPONENT simdjson_Development\n+-    INCLUDES DESTINATION \"${CMAKE_INSTALL_INCLUDEDIR}\"\n+-)\n+-\n+ configure_file(cmake/simdjson-config.cmake.in simdjson-config.cmake @ONLY)\n+\n -write_basic_package_version_file(\n--      \"${PROJECT_BINARY_DIR}/simdjson-config-version.cmake\"\n--      VERSION ${SIMDJSON_SEMANTIC_VERSION}\n--      COMPATIBILITY SameMinorVersion)\n--install(FILES \"${PROJECT_BINARY_DIR}/simdjson-config.cmake\"\n--              \"${PROJECT_BINARY_DIR}/simdjson-config-version.cmake\"\n--        DESTINATION \"${CMAKE_INSTALL_LIBDIR}/cmake/simdjson\")\n+-    simdjson-config-version.cmake\n+-    COMPATIBILITY SameMinorVersion\n+-)\n+-\n+ set(\n+     SIMDJSON_INSTALL_CMAKEDIR \"${CMAKE_INSTALL_LIBDIR}/cmake/simdjson\"\n+     CACHE STRING \"CMake package config location relative to the install prefix\"\n+@@ -154,13 +138,6 @@ install(\n+     COMPONENT simdjson_Development\n+ )\n \n+-install(\n+-    EXPORT simdjsonTargets\n+-    NAMESPACE simdjson::\n+-    DESTINATION \"${SIMDJSON_INSTALL_CMAKEDIR}\"\n+-    COMPONENT example_Development\n+-)\n+-\n+ #\n+ # CPack\n  #\n- # Compile tools / tests / benchmarks\n--- vendor/simdjson-iostream.patch\n@@ -1,213 +0,0 @@\n-commit 727ddcba86ee7fc7b2b4ebb8e5b2d3314cdc9c98\n-Author: Matthew \"strager\" Glazar <strager.nds@gmail.com>\n-Date:   Wed Aug 11 22:12:50 2021 -0700\n-\n-    Reduce #include bloat (<iostream>)\n-\n-    Including <iostream> has two problems:\n-\n-    * Compile times are worse because of over-inclusion\n-    * Binary sizes are worse when statically linking libstdc++ because\n-      iostreams cannot be dead-code-stripped\n-\n-    simdjson only needs std::ostream. Include the header declaring only what\n-    we need (<ostream>), omitting stuff we don't need (std::cout and its\n-    initialization, for example).\n-\n-    This commit should not change behavior, but it might break users who\n-    assume that including <simdjson/simdjson.h> will make std::cout\n-    available (such as many of simdjson's own files).\n-\n-diff --git a/benchmark/bench_dom_api.cpp b/benchmark/bench_dom_api.cpp\n-index b8f5937b..7224f88c 100644\n---- a/benchmark/bench_dom_api.cpp\n-+++ b/benchmark/bench_dom_api.cpp\n-@@ -1,4 +1,5 @@\n- #include <benchmark/benchmark.h>\n-+#include <iostream>\n- #include \"simdjson.h\"\n- #include <sstream>\n-\n-diff --git a/benchmark/bench_parse_call.cpp b/benchmark/bench_parse_call.cpp\n-index 514d4796..d98a5d47 100644\n---- a/benchmark/bench_parse_call.cpp\n-+++ b/benchmark/bench_parse_call.cpp\n-@@ -1,4 +1,5 @@\n- #include <benchmark/benchmark.h>\n-+#include <iostream>\n- #include \"simdjson.h\"\n- using namespace simdjson;\n- using namespace benchmark;\n-diff --git a/fuzz/fuzz_implementations.cpp b/fuzz/fuzz_implementations.cpp\n-index c1525aa7..bfbe3b1a 100644\n---- a/fuzz/fuzz_implementations.cpp\n-+++ b/fuzz/fuzz_implementations.cpp\n-@@ -11,6 +11,7 @@\n- #include <cstddef>\n- #include <cstdint>\n- #include <cstdlib>\n-+#include <iostream>\n- #include <string>\n- #include <array>\n- #include \"supported_implementations.h\"\n-diff --git a/fuzz/fuzz_minifyimpl.cpp b/fuzz/fuzz_minifyimpl.cpp\n-index 444d5030..d8750086 100644\n---- a/fuzz/fuzz_minifyimpl.cpp\n-+++ b/fuzz/fuzz_minifyimpl.cpp\n-@@ -12,6 +12,7 @@\n- #include \"simdjson.h\"\n- #include <cstddef>\n- #include <cstdlib>\n-+#include <iostream>\n- #include <vector>\n- #include \"supported_implementations.h\"\n-\n-diff --git a/fuzz/fuzz_utf8.cpp b/fuzz/fuzz_utf8.cpp\n-index 397b39a1..d83db7e0 100644\n---- a/fuzz/fuzz_utf8.cpp\n-+++ b/fuzz/fuzz_utf8.cpp\n-@@ -10,6 +10,7 @@\n- #include \"simdjson.h\"\n- #include <cstddef>\n- #include <cstdlib>\n-+#include <iostream>\n- #include \"supported_implementations.h\"\n-\n- extern \"C\" int VerboseTestOneInput(const uint8_t *Data, size_t Size) {\n-diff --git a/include/simdjson/dom/parsedjson_iterator.h b/include/simdjson/dom/parsedjson_iterator.h\n-index b5846048..667875a4 100644\n---- a/include/simdjson/dom/parsedjson_iterator.h\n-+++ b/include/simdjson/dom/parsedjson_iterator.h\n-@@ -5,7 +5,7 @@\n-\n- #include <cstring>\n- #include <string>\n--#include <iostream>\n-+#include <ostream>\n- #include <iterator>\n- #include <limits>\n- #include <stdexcept>\n-diff --git a/include/simdjson/internal/jsonformatutils.h b/include/simdjson/internal/jsonformatutils.h\n-index c87c6445..b30e1c5d 100644\n---- a/include/simdjson/internal/jsonformatutils.h\n-+++ b/include/simdjson/internal/jsonformatutils.h\n-@@ -2,7 +2,7 @@\n- #define SIMDJSON_INTERNAL_JSONFORMATUTILS_H\n-\n- #include <iomanip>\n--#include <iostream>\n-+#include <ostream>\n- #include <sstream>\n-\n- namespace simdjson {\n-diff --git a/tests/dom/jsoncheck.cpp b/tests/dom/jsoncheck.cpp\n-index 6c15a007..0d37833b 100644\n---- a/tests/dom/jsoncheck.cpp\n-+++ b/tests/dom/jsoncheck.cpp\n-@@ -10,6 +10,7 @@\n-\n- #include <cstdio>\n- #include <cstdlib>\n-+#include <iostream>\n-\n- #include \"simdjson.h\"\n-\n-diff --git a/tests/dom/minefieldcheck.cpp b/tests/dom/minefieldcheck.cpp\n-index cc53096d..50bc4fba 100644\n---- a/tests/dom/minefieldcheck.cpp\n-+++ b/tests/dom/minefieldcheck.cpp\n-@@ -10,6 +10,7 @@\n-\n- #include <cstdio>\n- #include <cstdlib>\n-+#include <iostream>\n-\n- #include \"simdjson.h\"\n- /**\n-diff --git a/tests/dom/numberparsingcheck.cpp b/tests/dom/numberparsingcheck.cpp\n-index 14a8fb80..6be7e59e 100644\n---- a/tests/dom/numberparsingcheck.cpp\n-+++ b/tests/dom/numberparsingcheck.cpp\n-@@ -3,6 +3,7 @@\n- #include <cmath>\n- #include <cstdio>\n- #include <cstdlib>\n-+#include <iostream>\n-\n- #ifndef JSON_TEST_NUMBERS\n- #define JSON_TEST_NUMBERS\n-diff --git a/tests/dom/parse_many_test.cpp b/tests/dom/parse_many_test.cpp\n-index 96affa00..e7bc7143 100644\n---- a/tests/dom/parse_many_test.cpp\n-+++ b/tests/dom/parse_many_test.cpp\n-@@ -10,6 +10,7 @@\n-\n- #include <cstdio>\n- #include <cstdlib>\n-+#include <iostream>\n-\n- #include \"simdjson.h\"\n-\n-diff --git a/tests/dom/random_string_number_tests.cpp b/tests/dom/random_string_number_tests.cpp\n-index d269f9a7..af2260b5 100644\n---- a/tests/dom/random_string_number_tests.cpp\n-+++ b/tests/dom/random_string_number_tests.cpp\n-@@ -4,6 +4,7 @@\n- #include <cstdio>\n- #include <cstdlib>\n- #include <cstdint>\n-+#include <iostream>\n- #include <random>\n- #include <climits>\n- #include <unistd.h>\n-@@ -194,4 +195,4 @@ int main(int argc, char *argv[]) {\n-   }\n-   std::cout << \"Failure.\" << std::endl;\n-   return EXIT_FAILURE;\n--}\n-\\ No newline at end of file\n-+}\n-diff --git a/tests/ondemand/test_ondemand.h b/tests/ondemand/test_ondemand.h\n-index 3ddec316..2ef2e8a7 100644\n---- a/tests/ondemand/test_ondemand.h\n-+++ b/tests/ondemand/test_ondemand.h\n-@@ -1,6 +1,7 @@\n- #ifndef ONDEMAND_TEST_ONDEMAND_H\n- #define ONDEMAND_TEST_ONDEMAND_H\n-\n-+#include <iostream>\n- #include <unistd.h>\n- #include \"simdjson.h\"\n- #include \"cast_tester.h\"\n-diff --git a/tests/test_macros.h b/tests/test_macros.h\n-index 322e4a5b..80472458 100644\n---- a/tests/test_macros.h\n-+++ b/tests/test_macros.h\n-@@ -1,6 +1,8 @@\n- #ifndef TEST_MACROS_H\n- #define TEST_MACROS_H\n-\n-+#include <iostream>\n-+\n- #ifndef SIMDJSON_BENCHMARK_DATA_DIR\n- #define SIMDJSON_BENCHMARK_DATA_DIR \"jsonexamples/\"\n- #endif\n-@@ -121,4 +123,4 @@ simdjson_really_inline bool assert_iterate_error(T &arr, simdjson::error_code ex\n- #define TEST_FAIL(MESSAGE)              do { std::cerr << \"FAIL: \" << (MESSAGE) << std::endl; return false; } while (0);\n- #define TEST_SUCCEED()                  do { return true; } while (0);\n-\n--#endif // TEST_MACROS_H\n-\\ No newline at end of file\n-+#endif // TEST_MACROS_H\n-diff --git a/tests/unicode_tests.cpp b/tests/unicode_tests.cpp\n-index 065f4ef9..47e9410c 100644\n---- a/tests/unicode_tests.cpp\n-+++ b/tests/unicode_tests.cpp\n-@@ -1,6 +1,7 @@\n- #include \"simdjson.h\"\n- #include <cstddef>\n- #include <cstdint>\n-+#include <iostream>\n- #include <random>\n-\n- class RandomUTF8 final {\n--- vendor/simdjson-reenter-child-ub.patch\n@@ -1,96 +0,0 @@\n-commit 16e23231537d9415aec71b94f8a266076452380b\n-Author: strager <strager.nds@gmail.com>\n-Date:   Thu May 27 05:34:28 2021 -0700\n-\n-    Fix UB in dev checks when iterating empty object (#1587)\n-\n-    When find_field_unordered is used on an empty object, it calls\n-    json_iterator::reenter_child. reenter_child asserts that it doesn't\n-    rewind too far back by consulting parser->start_positions.\n-\n-    When the On Demand parser sees an empty object, it fails to update\n-    parser->start_positions. This means that the assertion in\n-    json_iterator::reenter_child reads stale data, or potentially\n-    uninitialized memory. Reading uninitialized memory can cause spurious\n-    assertion failures and Valgrind memcheck reports:\n-\n-        Running missing_keys_for_empty_top_level_object ...\n-        ==170679== Conditional jump or move depends on uninitialised value(s)\n-        ==170679==    at 0x4943D7: reenter_child (json_iterator-inl.h:208)\n-        ==170679==    by 0x4943D7: find_field_unordered_raw (value_iterator-inl.h:197)\n-        ==170679==    by 0x4943D7: find_field_unordered (object-inl.h:13)\n-        ==170679==    by 0x4943D7: find_field_unordered (object-inl.h:96)\n-        ==170679==    by 0x4943D7: find_field_unordered (value-inl.h:110)\n-        ==170679==    by 0x4943D7: find_field_unordered (document-inl.h:105)\n-        ==170679==    by 0x4943D7: object_tests::missing_keys_for_empty_top_level_object() (ondemand_object_tests.cpp:117)\n-        ==170679==    by 0x4CA761: object_tests::run() (ondemand_object_tests.cpp:1085)\n-        ==170679==    by 0x8BA314: int test_main<bool ()>(int, char**, bool ( const&)()) (test_ondemand.h:81)\n-        ==170679==    by 0x4CA9C8: main (ondemand_object_tests.cpp:1119)\n-        ==170679==\n-\n-    Fix the read of uninitialized or stale memory by updating\n-    parser->start_positions regardless of whether we see an empty object or\n-    an object with some keys.\n-\n-    This commit only affects builds where development checks\n-    (SIMDJSON_DEVELOPMENT_CHECKS) are enabled. Builds where development\n-    checks are disabled are unaffected by this bug.\n-\n-diff --git a/include/simdjson/generic/ondemand/value_iterator-inl.h b/include/simdjson/generic/ondemand/value_iterator-inl.h\n-index e97cb265..007c6d4b 100644\n---- a/include/simdjson/generic/ondemand/value_iterator-inl.h\n-+++ b/include/simdjson/generic/ondemand/value_iterator-inl.h\n-@@ -25,6 +25,9 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator\n-\n- simdjson_warn_unused simdjson_really_inline bool value_iterator::started_object() noexcept {\n-   assert_at_container_start();\n-+#ifdef SIMDJSON_DEVELOPMENT_CHECKS\n-+  _json_iter->set_start_position(_depth, _start_position);\n-+#endif\n-   if (*_json_iter->peek() == '}') {\n-     logger::log_value(*_json_iter, \"empty object\");\n-     _json_iter->advance();\n-@@ -32,9 +35,6 @@ simdjson_warn_unused simdjson_really_inline bool value_iterator::started_object(\n-     return false;\n-   }\n-   logger::log_start_value(*_json_iter, \"object\");\n--#ifdef SIMDJSON_DEVELOPMENT_CHECKS\n--  _json_iter->set_start_position(_depth, _start_position);\n--#endif\n-   return true;\n- }\n-\n-diff --git a/tests/ondemand/ondemand_object_tests.cpp b/tests/ondemand/ondemand_object_tests.cpp\n-index 78210a47..b405d493 100644\n---- a/tests/ondemand/ondemand_object_tests.cpp\n-+++ b/tests/ondemand/ondemand_object_tests.cpp\n-@@ -107,6 +107,21 @@ namespace object_tests {\n-     return true;\n-   }\n-\n-+  bool missing_keys_for_empty_top_level_object() {\n-+    TEST_START();\n-+    simdjson::ondemand::parser parser;\n-+    simdjson::padded_string docdata = \"{}\"_padded;\n-+    simdjson::ondemand::document doc;\n-+    auto error = parser.iterate(docdata).get(doc);\n-+    if(error != simdjson::SUCCESS) { return false; }\n-+    error = doc.find_field_unordered(\"keynotfound\").error();\n-+    if(error != simdjson::NO_SUCH_FIELD) {\n-+      std::cout << error << std::endl;\n-+      return false;\n-+    }\n-+    return true;\n-+  }\n-+\n- #if SIMDJSON_EXCEPTIONS\n-   // used in issue_1521\n-   // difficult to use as a lambda because it is recursive.\n-@@ -1067,6 +1082,7 @@ namespace object_tests {\n-            missing_key_continue() &&\n-            no_missing_keys() &&\n-            missing_keys() &&\n-+           missing_keys_for_empty_top_level_object() &&\n- #if SIMDJSON_EXCEPTIONS\n-            fixed_broken_issue_1521() &&\n-            issue_1521() &&\n--- vendor/simdjson.cmake\n@@ -1,8 +1,8 @@\n # Copyright (C) 2020  Matthew \"strager\" Glazar\n # See end of file for extended copyright information.\n \n-set(SIMDJSON_JUST_LIBRARY ON CACHE INTERNAL \"\")\n-set(SIMDJSON_BUILD_STATIC ON CACHE INTERNAL \"\")\n+set(SIMDJSON_DEVELOPER_MODE OFF CACHE INTERNAL \"\")\n+set(BUILD_SHARED_LIBS OFF)\n \n add_subdirectory(simdjson EXCLUDE_FROM_ALL)\n \n@@ -11,11 +11,11 @@ target_compile_definitions(simdjson PUBLIC SIMDJSON_EXCEPTIONS=0)\n # HACK(strager): Avoid various warnings when including <simdjson.h>.\n get_property(\n   SIMDJSON_INCLUDE_DIRECTORIES\n-  TARGET simdjson-headers\n+  TARGET simdjson\n   PROPERTY INTERFACE_INCLUDE_DIRECTORIES\n )\n set_property(\n-  TARGET simdjson-headers\n+  TARGET simdjson\n   APPEND PROPERTY\n   INTERFACE_SYSTEM_INCLUDE_DIRECTORIES\n   \"${SIMDJSON_INCLUDE_DIRECTORIES}\"\n--- vendor/simdjson/.appveyor.yml\n@@ -15,29 +15,29 @@ environment:\n     - job_name: VS2019\n       CMAKE_ARGS: -A %Platform%\n     - job_name: VS2019ARM\n-      CMAKE_ARGS: -A ARM64 -DCMAKE_CROSSCOMPILING=1 -D SIMDJSON_GOOGLE_BENCHMARKS=OFF # Does Google Benchmark builds under VS ARM?\n+      CMAKE_ARGS: -A ARM64   -DSIMDJSON_DEVELOPER_MODE=ON -DCMAKE_CROSSCOMPILING=1 -D SIMDJSON_GOOGLE_BENCHMARKS=OFF # Does Google Benchmark builds under VS ARM?\n     - job_name: VS2017 (Static, No Threads)\n       image: Visual Studio 2017\n-      CMAKE_ARGS: -A %Platform% -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_ENABLE_THREADS=OFF\n+      CMAKE_ARGS: -A %Platform%   -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF -DSIMDJSON_ENABLE_THREADS=OFF\n       CTEST_ARGS: -LE explicitonly\n     - job_name: VS2019 (Win32)\n       platform: Win32\n-      CMAKE_ARGS: -A %Platform% -DSIMDJSON_BUILD_STATIC=OFF -DSIMDJSON_ENABLE_THREADS=ON # This should be the default. Testing anyway.\n+      CMAKE_ARGS: -A %Platform%   -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=ON -DSIMDJSON_ENABLE_THREADS=ON # This should be the default. Testing anyway.\n       CTEST_ARGS: -LE explicitonly\n     - job_name: VS2019 (Win32, No Exceptions)\n       platform: Win32\n-      CMAKE_ARGS: -A %Platform% -DSIMDJSON_BUILD_STATIC=OFF -DSIMDJSON_ENABLE_THREADS=ON -DSIMDJSON_EXCEPTIONS=OFF\n+      CMAKE_ARGS: -A %Platform%   -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=ON -DSIMDJSON_ENABLE_THREADS=ON -DSIMDJSON_EXCEPTIONS=OFF\n       CTEST_ARGS: -LE explicitonly\n     - job_name: VS2015\n       image: Visual Studio 2015\n-      CMAKE_ARGS: -A %Platform% -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_ENABLE_THREADS=OFF\n+      CMAKE_ARGS: -A %Platform%   -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF -DSIMDJSON_ENABLE_THREADS=OFF\n       CTEST_ARGS: -LE explicitonly\n \n build_script:\n   - mkdir build\n   - cd build\n   - cmake --version\n-  - cmake %CMAKE_ARGS% --parallel ..\n+  - cmake %CMAKE_ARGS% ..\n   - cmake -LH ..\n   - cmake --build . --config %Configuration% --verbose --parallel\n \n--- vendor/simdjson/.circleci/config.yml\n@@ -1,7 +1,7 @@\n version: 2.1\n \n \n-# We constantly run out of memory so please do not use parallelism (-j, -j4). \n+# We constantly run out of memory so please do not use parallelism (-j, -j4).\n \n # Reusable image / compiler definitions\n executors:\n@@ -11,7 +11,7 @@ executors:\n         environment:\n           CXX: g++-8\n           CC: gcc-8\n-          BUILD_FLAGS: \n+          CMAKE_BUILD_FLAGS:\n           CTEST_FLAGS: --output-on-failure\n \n   gcc9:\n@@ -20,7 +20,7 @@ executors:\n         environment:\n           CXX: g++-9\n           CC: gcc-9\n-          BUILD_FLAGS:\n+          CMAKE_BUILD_FLAGS:\n           CTEST_FLAGS: --output-on-failure\n \n   gcc10:\n@@ -29,7 +29,7 @@ executors:\n         environment:\n           CXX: g++-10\n           CC: gcc-10\n-          BUILD_FLAGS:\n+          CMAKE_BUILD_FLAGS:\n           CTEST_FLAGS: --output-on-failure\n \n   clang10:\n@@ -38,7 +38,7 @@ executors:\n         environment:\n           CXX: clang++-10\n           CC: clang-10\n-          BUILD_FLAGS:\n+          CMAKE_BUILD_FLAGS:\n           CTEST_FLAGS: --output-on-failure\n \n   clang9:\n@@ -47,16 +47,16 @@ executors:\n         environment:\n           CXX: clang++-9\n           CC: clang-9\n-          BUILD_FLAGS:\n-          CTEST_FLAGS: --output-on-failure \n+          CMAKE_BUILD_FLAGS:\n+          CTEST_FLAGS: --output-on-failure\n \n   clang6:\n     docker:\n       - image: conanio/clang60\n         environment:\n           CXX: clang++-6.0\n           CC: clang-6.0\n-          BUILD_FLAGS:\n+          CMAKE_BUILD_FLAGS:\n           CTEST_FLAGS: --output-on-failure\n \n # Reusable test commands (and initializer for clang 6)\n@@ -88,13 +88,13 @@ commands:\n     steps:\n       - cmake_prep\n       - dependency_restore\n-      - run: cmake $CMAKE_FLAGS -DCMAKE_INSTALL_PREFIX:PATH=destination -B build . \n+      - run: cmake  -DSIMDJSON_DEVELOPER_MODE=ON $CMAKE_FLAGS -DCMAKE_INSTALL_PREFIX:PATH=destination -B build .\n       - dependency_cache # dependencies are produced in the configure step\n \n   cmake_build:\n     steps:\n       - cmake_build_cache\n-      - run: cmake --build build\n+      - run: cmake  --build build\n \n   cmake_test:\n     steps:\n@@ -129,8 +129,8 @@ commands:\n     steps:\n       - cmake_build_cache\n       - run: |\n-          cmake --build  build --target checkperf &&\n-          cd build && \n+          cmake -DSIMDJSON_ENABLE_DOM_CHECKPERF=ON --build  build --target checkperf &&\n+          cd build &&\n           ctest --output-on-failure -R checkperf\n \n   # we not only want cmake to build and run tests, but we want also a successful installation from which we can build, link and run programs\n@@ -164,60 +164,60 @@ jobs:\n   gcc10-perftest:\n     description: Build and run performance tests on GCC 10 and AVX 2 with a cmake static build, this test performance regression\n     executor: gcc10\n-    environment: { CMAKE_FLAGS: -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_BUILD_STATIC=ON }\n+    environment: { CMAKE_FLAGS: -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DBUILD_SHARED_LIBS=OFF }\n     steps: [ cmake_perftest ]\n   gcc10:\n     description: Build and run tests on GCC 10 and AVX 2 with a cmake static build\n     executor: gcc10\n-    environment: { CMAKE_FLAGS: -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_BUILD_STATIC=ON }\n+    environment: { CMAKE_FLAGS: -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DBUILD_SHARED_LIBS=OFF }\n     steps: [ cmake_test, cmake_install_test, cmake_installed_test_cxx20 ]\n   clang6:\n     description: Build and run tests on clang 6 and AVX 2 with a cmake static build\n     executor: clang6\n-    environment: { CMAKE_FLAGS: -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_BUILD_STATIC=ON }\n+    environment: { CMAKE_FLAGS: -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DBUILD_SHARED_LIBS=OFF }\n     steps: [ cmake_test, cmake_install_test ]\n   clang10:\n     description: Build and run tests on clang 10 and AVX 2 with a cmake static build\n     executor: clang10\n-    environment: { CMAKE_FLAGS: -DSIMDJSON_GOOGLE_BENCHMARKS=ON  -DSIMDJSON_BUILD_STATIC=ON }\n+    environment: { CMAKE_FLAGS: -DSIMDJSON_GOOGLE_BENCHMARKS=ON  -DBUILD_SHARED_LIBS=OFF }\n     steps: [ cmake_test, cmake_install_test, cmake_installed_test_cxx20 ]\n   # libcpp\n   libcpp-clang10:\n     description: Build and run tests on clang 10 and AVX 2 with a cmake static build and libc++\n     executor: clang10\n-    environment: { CMAKE_FLAGS: -DSIMDJSON_USE_LIBCPP=ON  -DSIMDJSON_BUILD_STATIC=ON }\n+    environment: { CMAKE_FLAGS: -DSIMDJSON_USE_LIBCPP=ON  -DBUILD_SHARED_LIBS=OFF }\n     steps: [ cmake_test, cmake_install_test, cmake_installed_test_cxx20 ]\n   # sanitize\n   sanitize-gcc10:\n     description: Build and run tests on GCC 10 and AVX 2 with a cmake sanitize build\n     executor: gcc10\n-    environment: { CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF -DSIMDJSON_SANITIZE=ON, BUILD_FLAGS: \"\", CTEST_FLAGS: --output-on-failure -LE explicitonly }\n+    environment: { CMAKE_FLAGS: -DCMAKE_BUILD_TYPE=Debug -DBUILD_SHARED_LIBS=ON -DSIMDJSON_SANITIZE=ON, CTEST_FLAGS: --output-on-failure -LE explicitonly }\n     steps: [ cmake_test ]\n   sanitize-clang10:\n     description: Build and run tests on clang 10 and AVX 2 with a cmake sanitize build\n     executor: clang10\n-    environment: { CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF -DSIMDJSON_SANITIZE=ON, CTEST_FLAGS: --output-on-failure -LE explicitonly }\n+    environment: { CMAKE_FLAGS: -DBUILD_SHARED_LIBS=ON -DSIMDJSON_NO_FORCE_INLINING=ON -DSIMDJSON_SANITIZE=ON, CTEST_FLAGS: --output-on-failure -LE explicitonly }\n     steps: [ cmake_test ]\n   threadsanitize-gcc10:\n     description: Build and run tests on GCC 10 and AVX 2 with a cmake sanitize build\n     executor: gcc10\n-    environment: { CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF -DSIMDJSON_SANITIZE_THREADS=ON, BUILD_FLAGS: \"\", CTEST_FLAGS: --output-on-failure -LE explicitonly }\n+    environment: { CMAKE_FLAGS: -DBUILD_SHARED_LIBS=ON -DSIMDJSON_SANITIZE_THREADS=ON, CTEST_FLAGS: --output-on-failure -LE explicitonly }\n     steps: [ cmake_test ]\n   threadsanitize-clang10:\n     description: Build and run tests on clang 10 and AVX 2 with a cmake sanitize build\n     executor: clang10\n-    environment: { CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF -DSIMDJSON_SANITIZE_THREADS=ON, CTEST_FLAGS: --output-on-failure -LE explicitonly }\n+    environment: { CMAKE_FLAGS: -DBUILD_SHARED_LIBS=ON  -DSIMDJSON_NO_FORCE_INLINING=ON -DSIMDJSON_SANITIZE_THREADS=ON, CTEST_FLAGS: --output-on-failure -LE explicitonly }\n     steps: [ cmake_test ]\n   # dynamic\n   dynamic-gcc10:\n     description: Build and run tests on GCC 10 and AVX 2 with a cmake dynamic build\n     executor: gcc10\n-    environment: { CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF }\n+    environment: { CMAKE_FLAGS: -DBUILD_SHARED_LIBS=ON }\n     steps: [ cmake_test, cmake_install_test ]\n   dynamic-clang10:\n     description: Build and run tests on clang 10 and AVX 2 with a cmake dynamic build\n     executor: clang10\n-    environment: { CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF }\n+    environment: { CMAKE_FLAGS: -DBUILD_SHARED_LIBS=ON }\n     steps: [ cmake_test, cmake_install_test ]\n \n   # unthreaded\n@@ -262,12 +262,12 @@ jobs:\n   sanitize-haswell-gcc10:\n     description: Build and run tests on GCC 10 and AVX 2 with a cmake sanitize build\n     executor: gcc10\n-    environment: {  CXXFLAGS: -march=haswell, CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF -DSIMDJSON_SANITIZE=ON, BUILD_FLAGS: \"\", CTEST_FLAGS: --output-on-failure -LE explicitonly }\n+    environment: {  CXXFLAGS: -march=haswell, CMAKE_FLAGS: -DCMAKE_BUILD_TYPE=Debug -DBUILD_SHARED_LIBS=ON -DSIMDJSON_SANITIZE=ON, CTEST_FLAGS: --output-on-failure -LE explicitonly }\n     steps: [ cmake_test ]\n   sanitize-haswell-clang10:\n     description: Build and run tests on clang 10 and AVX 2 with a cmake sanitize build\n     executor: clang10\n-    environment: { CXXFLAGS: -march=haswell, CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF -DSIMDJSON_SANITIZE=ON, CTEST_FLAGS: --output-on-failure -LE explicitonly }\n+    environment: { CXXFLAGS: -march=haswell, CMAKE_FLAGS: -DBUILD_SHARED_LIBS=ON  -DSIMDJSON_NO_FORCE_INLINING=ON -DSIMDJSON_SANITIZE=ON, CTEST_FLAGS: --output-on-failure -LE explicitonly }\n     steps: [ cmake_test ]\n \n workflows:\n--- vendor/simdjson/.drone.yml\n@@ -8,7 +8,7 @@ steps:\n     CC: gcc\n     CXX: g++\n     BUILD_FLAGS: -- -j\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=ON\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=OFF\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly \n   commands:\n     - scripts/addcmakeppa.sh \"$(env -i sh -c '. /etc/os-release; echo $VERSION_CODENAME')\"\n@@ -29,7 +29,7 @@ steps:\n     CC: clang-6.0\n     CXX: clang++-6.0\n     BUILD_FLAGS: -- -j\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=ON\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=OFF\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly \n   commands:\n     - scripts/addcmakeppa.sh \"$(env -i sh -c '. /etc/os-release; echo $VERSION_CODENAME')\"\n@@ -50,7 +50,7 @@ steps:\n     CC: gcc\n     CXX: g++\n     BUILD_FLAGS: -- -j\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_IMPLEMENTATION=haswell;westmere;fallback\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=OFF -DSIMDJSON_IMPLEMENTATION=haswell;westmere;fallback\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n   commands:\n     - echo \"deb http://deb.debian.org/debian buster-backports main\" >> /etc/apt/sources.list\n@@ -77,7 +77,7 @@ steps:\n     CC: clang-6.0\n     CXX: clang++-6.0\n     BUILD_FLAGS: -- -j\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_IMPLEMENTATION=haswell;westmere;fallback\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=OFF -DSIMDJSON_IMPLEMENTATION=haswell;westmere;fallback\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n   commands:\n     - mkdir build\n@@ -100,7 +100,7 @@ steps:\n     CC: gcc\n     CXX: g++\n     BUILD_FLAGS: -- -j\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=ON\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n   commands:\n     - echo \"deb http://deb.debian.org/debian buster-backports main\" >> /etc/apt/sources.list\n@@ -122,7 +122,7 @@ steps:\n   environment:\n     CC: clang-9\n     CXX: clang++-9\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=ON\n     BUILD_FLAGS: -- -j\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n   commands:\n@@ -142,7 +142,7 @@ steps:\n     CC: gcc\n     CXX: g++\n     BUILD_FLAGS: -- -j\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_IMPLEMENTATION=haswell;westmere;fallback\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=OFF -DSIMDJSON_IMPLEMENTATION=haswell;westmere;fallback\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n   commands:\n     - echo \"deb http://deb.debian.org/debian buster-backports main\" >> /etc/apt/sources.list\n@@ -213,7 +213,7 @@ steps:\n     CC: gcc\n     CXX: g++\n     BUILD_FLAGS: -- -j\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_IMPLEMENTATION=arm64;fallback\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=OFF -DSIMDJSON_IMPLEMENTATION=arm64;fallback\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n   commands:\n     - echo \"deb http://deb.debian.org/debian buster-backports main\" >> /etc/apt/sources.list\n@@ -237,7 +237,7 @@ steps:\n   environment:\n     CC: clang-6.0\n     CXX: clang++-6.0\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=ON\n     BUILD_FLAGS: -- -j\n     CTEST_FLAGS: -j4 --output-on-failure  -LE explicitonly\n   commands:\n@@ -260,7 +260,7 @@ steps:\n     CC: gcc\n     CXX: g++\n     BUILD_FLAGS: -- -j\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=ON\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n   commands:\n     - echo \"deb http://deb.debian.org/debian buster-backports main\" >> /etc/apt/sources.list\n@@ -281,7 +281,7 @@ steps:\n   environment:\n     CC: clang-6.0\n     CXX: clang++-6.0\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=ON\n     BUILD_FLAGS: -- -j\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n   commands:\n@@ -302,7 +302,7 @@ steps:\n   image: gcc:8\n   environment:\n     BUILD_FLAGS: -- -j\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_IMPLEMENTATION=arm64;fallback\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=OFF -DSIMDJSON_IMPLEMENTATION=arm64;fallback\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n     CC: gcc\n     CXX: g++\n@@ -356,7 +356,7 @@ steps:\n     CC: clang-9\n     CXX: clang++-9\n     BUILD_FLAGS: -- -j 4\n-    CMAKE_FLAGS: -GNinja -DSIMDJSON_BUILD_STATIC=ON\n+    CMAKE_FLAGS: -GNinja -DBUILD_SHARED_LIBS=OFF\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n     CXXFLAGS: -stdlib=libc++\n   commands:\n@@ -377,7 +377,7 @@ steps:\n     CC: clang-9\n     CXX: clang++-9\n     BUILD_FLAGS: -- -j\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=ON\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=OFF\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n     CXXFLAGS: -stdlib=libc++\n   commands:\n@@ -398,7 +398,7 @@ steps:\n     CC: clang-7\n     CXX: clang++-7\n     BUILD_FLAGS: -- -j\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=ON\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=OFF\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n     CXXFLAGS: -stdlib=libc++\n   commands:\n@@ -444,8 +444,8 @@ steps:\n   commands:\n     - apt-get -qq update\n     - apt-get install -q -y clang cmake git wget zip ninja-build\n-    - wget --quiet https://dl.bintray.com/pauldreik/simdjson-fuzz-corpus/corpus/corpus.tar\n-    - tar xf corpus.tar && rm corpus.tar\n+    - wget -O corpus.tar.gz https://readonly:readonly@www.pauldreik.se/fuzzdata/index.php?project=simdjson\n+    - tar xf corpus.tar.gz && rm corpus.tar.gz\n     - fuzz/build_like_ossfuzz.sh\n     - mkdir -p common_out\n     - for fuzzer in build/fuzz/fuzz_* ; do echo $fuzzer;$fuzzer common_out out/* -max_total_time=40; done\n--- vendor/simdjson/.github/ISSUE_TEMPLATE/bug_report.md\n@@ -18,19 +18,34 @@ Before submitting an issue, please ensure that you have read the documentation:\n **Describe the bug**\n A clear and concise description of what the bug is.\n \n-Note that a compiler warning is not a bug.\n+A compiler or static-analyzer warning is not a bug.\n+\n+We are committed to providing good documentation. We accept the lack of documentation or a misleading documentation as a bug (a 'documentation bug').\n+\n+We accept the identification of an issue by a sanitizer or some checker tool (e.g., valgrind) as a bug, but you must first ensure that it is not a false positive.\n+\n+We recommend that you run your tests using different optimization levels.\n+\n+Before reporting a bug, please ensure that you have read our documentation.\n \n **To Reproduce**\n Steps to reproduce the behaviour: provide a code sample if possible.\n \n-If we cannot reproduce the issue, then we cannot address it.\n+If we cannot reproduce the issue, then we cannot address it. Note that a stack trace from your own program is not enough. A sample of your source code is insufficient: please provide a complete test for us to reproduce the issue. Please reduce the issue: use as small and as simple an example of the bug as possible.\n+\n+It should be possible to trigger the bug by using solely simdjson with our default build setup. If you can only observe the bug within some specific context, with some other software, please reduce the issue first.\n+\n+**simjson release**\n+\n+Unless you plan to contribute to simdjson, you should only work from releases. Please be mindful that our main branch may have additional features, bugs and documentation items.\n \n-Note that a stack trace from your own program is not enough.\n+It is fine to report bugs against our main branch, but if that is what you are doing, please be explicit.\n \n-**Configuration (please complete the following information if relevant):**\n+**Configuration (please complete the following information if relevant)**\n  - OS: [e.g. Ubuntu 16.04.6 LTS]\n  - Compiler [e.g. Apple clang version 11.0.3 (clang-1103.0.32.59) x86_64-apple-darwin19.4.0]\n  - Version [e.g. 22]\n+ - Optimization setting (e.g., -O3)\n \n We support up-to-date 64-bit ARM and x64 FreeBSD, macOS, Windows and Linux systems. Please ensure that your configuration is supported before labelling the issue as a bug. In particular, we do not support legacy 32-bit systems.\n \n--- vendor/simdjson/.github/workflows/alpine.yml\n@@ -1,12 +1,6 @@\n name: Alpine Linux\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   ubuntu-build:\n@@ -31,7 +25,7 @@ jobs:\n           ./alpine.sh apk add build-base cmake g++ linux-headers git bash\n       - name: cmake\n         run: |\n-          ./alpine.sh cmake -B build_for_alpine\n+          ./alpine.sh cmake -DSIMDJSON_DEVELOPER_MODE=ON -B build_for_alpine\n       - name: build\n         run: |\n           ./alpine.sh cmake --build build_for_alpine\n--- vendor/simdjson/.github/workflows/fix-trailing-whitespace.yml\n@@ -1,9 +1,6 @@\n name: Detect trailing whitespace\n \n-on:\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   whitespace:\n--- vendor/simdjson/.github/workflows/fuzzers.yml\n@@ -44,19 +44,25 @@ jobs:\n         path: dependencies/.cache\n         key: ${{ hashFiles('dependencies/CMakeLists.txt') }}\n \n+    - uses: actions/cache@v2\n+      id: cache-corpus\n+      with:\n+        path: out/\n+        key: corpus-${{ github.run_id }}\n+        restore-keys: corpus-\n+    \n+    - name: show statistics for the cached corpus\n+      run: |\n+        echo number of files in github action corpus cache:\n+        find out -type f |wc -l\n+    \n     - name: Create and prepare the initial seed corpus\n       run: |\n         fuzz/build_corpus.sh\n         mv corpus.zip seed_corpus.zip\n         mkdir seedcorpus\n         unzip -q -d seedcorpus seed_corpus.zip\n \n-    - name: Download the corpus from the last run\n-      run: |\n-        wget --quiet https://dl.bintray.com/pauldreik/simdjson-fuzz-corpus/corpus/corpus.tar\n-        tar xf corpus.tar\n-        rm corpus.tar\n-\n     - name: List clang versions\n       run: |\n         ls /usr/bin/clang*\n@@ -70,7 +76,7 @@ jobs:\n       run: |\n         set -eux\n         for fuzzer in $defaultimplfuzzers $implfuzzers; do\n-          mkdir -p out/$fuzzer # in case this is a new fuzzer, or corpus.tar is broken\n+          mkdir -p out/$fuzzer # in case this is a new fuzzer, or the github action cached corpus is broken\n           # get input from everyone else (corpus cross pollination)\n           others=$(find out -type d -not -name $fuzzer -not -name out -not -name cmin)\n           build-fast/fuzz/fuzz_$fuzzer out/$fuzzer $others seedcorpus -max_total_time=30 $MAXLEN\n@@ -123,6 +129,11 @@ jobs:\n         name: corpus\n         path: corpus.tar\n \n+    - name: Store the corpus externally\n+      run: |\n+        gzip --keep corpus.tar\n+        curl -F\"filedata=@corpus.tar.gz\" https://simdjson:${{ secrets.fuzzdatapassword }}@www.pauldreik.se/fuzzdata/index.php\n+\n     # This takes a subset of the minimized corpus and run it through valgrind. It is slow,\n     # therefore take a \"random\" subset. The random selection is accomplished by sorting on filenames,\n     # which are hashes of the content.\n@@ -143,15 +154,6 @@ jobs:\n         path: valgrind.tar\n         if-no-files-found: ignore\n \n-    - name: Upload the corpus and results to bintray if we are on master\n-      if: ${{ github.event_name == 'schedule' }} \n-      run: |\n-        echo uploading each artifact twice, otherwise it will not be published\n-        curl -T corpus.tar -upauldreik:${{ secrets.bintrayApiKey }} https://api.bintray.com/content/pauldreik/simdjson-fuzz-corpus/corpus/0/corpus/corpus.tar\";publish=1;override=1\"\n-        curl -T corpus.tar -upauldreik:${{ secrets.bintrayApiKey }} https://api.bintray.com/content/pauldreik/simdjson-fuzz-corpus/corpus/0/corpus/corpus.tar\";publish=1;override=1\"\n-        curl -T valgrind.tar -upauldreik:${{ secrets.bintrayApiKey }} https://api.bintray.com/content/pauldreik/simdjson-fuzz-corpus/corpus/0/corpus/valgrind.tar\";publish=1;override=1\"\n-        curl -T valgrind.tar -upauldreik:${{ secrets.bintrayApiKey }} https://api.bintray.com/content/pauldreik/simdjson-fuzz-corpus/corpus/0/corpus/valgrind.tar\";publish=1;override=1\"\n-\n     - name: Archive any crashes as an artifact\n       uses: actions/upload-artifact@v2\n       if: always()\n--- vendor/simdjson/.github/workflows/macos-11.yml\n@@ -0,0 +1,34 @@\n+name: Macos (Xcode 11)\n+\n+on: [push, pull_request]\n+\n+jobs:\n+  macos-build:\n+    if: >-\n+      ! contains(toJSON(github.event.commits.*.message), '[skip ci]') &&\n+      ! contains(toJSON(github.event.commits.*.message), '[skip github]')\n+    runs-on: macos-latest\n+    steps:\n+      - uses: actions/checkout@v2\n+      - uses: actions/cache@v2\n+        with:\n+          path: dependencies/.cache\n+          key: ${{ hashFiles('dependencies/CMakeLists.txt') }}\n+      - name: Use cmake\n+        run: |\n+          xcversion select 11.2.1\n+          mkdir builddebug &&\n+          cd builddebug &&\n+          cmake -DCMAKE_BUILD_TYPE=Debug -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF ..  &&\n+          cmake --build .   &&\n+          ctest -j --output-on-failure -LE explicitonly   &&\n+          cd .. &&\n+          mkdir build &&\n+          cd build &&\n+          cmake  -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n+          cmake --build .   &&\n+          ctest -j --output-on-failure -LE explicitonly   &&\n+          cmake --install . &&\n+          echo -e '#include <simdjson.h>\\nint main(int argc,char**argv) {simdjson::dom::parser parser;simdjson::dom::element tweets = parser.load(argv[1]); }' > tmp.cpp && c++ -Idestination/include -Ldestination/lib -std=c++17 -Wl,-rpath,destination/lib -o linkandrun tmp.cpp -lsimdjson && ./linkandrun jsonexamples/twitter.json &&\n+          cd ../tests/installation_tests/find &&\n+          mkdir build && cd build && cmake -DCMAKE_INSTALL_PREFIX:PATH=../../../build/destination .. &&  cmake --build .\n--- vendor/simdjson/.github/workflows/macos.yml\n@@ -0,0 +1,33 @@\n+name: Macos\n+\n+on: [push, pull_request]\n+\n+jobs:\n+  macos-build:\n+    if: >-\n+      ! contains(toJSON(github.event.commits.*.message), '[skip ci]') &&\n+      ! contains(toJSON(github.event.commits.*.message), '[skip github]')\n+    runs-on: macos-latest\n+    steps:\n+      - uses: actions/checkout@v2\n+      - uses: actions/cache@v2\n+        with:\n+          path: dependencies/.cache\n+          key: ${{ hashFiles('dependencies/CMakeLists.txt') }}\n+      - name: Use cmake\n+        run: |\n+          mkdir builddebug &&\n+          cd builddebug &&\n+          cmake -DCMAKE_BUILD_TYPE=Debug -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF ..  &&\n+          cmake --build .   &&\n+          ctest -j --output-on-failure -LE explicitonly   &&\n+          cd .. &&\n+          mkdir build &&\n+          cd build &&\n+          cmake  -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n+          cmake --build .   &&\n+          ctest -j --output-on-failure -LE explicitonly   &&\n+          cmake --install . &&\n+          echo -e '#include <simdjson.h>\\nint main(int argc,char**argv) {simdjson::dom::parser parser;simdjson::dom::element tweets = parser.load(argv[1]); }' > tmp.cpp && c++ -Idestination/include -Ldestination/lib -std=c++17 -Wl,-rpath,destination/lib -o linkandrun tmp.cpp -lsimdjson && ./linkandrun jsonexamples/twitter.json &&\n+          cd ../tests/installation_tests/find &&\n+          mkdir build && cd build && cmake -DCMAKE_INSTALL_PREFIX:PATH=../../../build/destination .. &&  cmake --build .\n--- vendor/simdjson/.github/workflows/mingw-ci.yml\n@@ -1,12 +1,7 @@\n name: MinGW32-CI\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n+\n \n # Important: scoop will either install 32-bit GCC or 64-bit GCC, not both.\n \n@@ -22,7 +17,7 @@ jobs:\n     runs-on: windows-2016\n \n     env:\n-      CMAKE_GENERATOR: Ninja # This is critical, try ' cmake  -GNinja-DSIMDJSON_BUILD_STATIC=ON .. ' if using the command line\n+      CMAKE_GENERATOR: Ninja # This is critical, try ' cmake  -GNinja-DBUILD_SHARED_LIBS=OFF .. ' if using the command line\n       CC: gcc\n       CXX: g++\n \n@@ -47,7 +42,7 @@ jobs:\n         run: |\n           Invoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh')\n           scoop install sudo --global\n-          sudo scoop install git --global \n+          sudo scoop install git --global\n           sudo scoop install ninja --global\n           sudo scoop install cmake --global\n           sudo scoop install gcc --arch 32bit --global\n@@ -63,6 +58,6 @@ jobs:\n           git --version\n           mkdir build32\n           cd build32\n-          cmake -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_ENABLE_THREADS=OFF ..\n+          cmake -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_ENABLE_THREADS=OFF ..\n           cmake --build . --target acceptance_tests --verbose\n           ctest -L acceptance --output-on-failure\n--- vendor/simdjson/.github/workflows/mingw64-ci.yml\n@@ -1,12 +1,7 @@\n name: MinGW64-CI\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n+\n \n # Important: scoop will either install 32-bit GCC or 64-bit GCC, not both.\n \n@@ -22,7 +17,7 @@ jobs:\n     runs-on: windows-2016\n \n     env:\n-      CMAKE_GENERATOR: Ninja # This is critical, try ' cmake  -GNinja-DSIMDJSON_BUILD_STATIC=ON .. ' if using the command line\n+      CMAKE_GENERATOR: Ninja # This is critical, try ' cmake  -GNinja-DBUILD_SHARED_LIBS=OFF .. ' if using the command line\n       CC: gcc\n       CXX: g++\n \n@@ -63,12 +58,12 @@ jobs:\n           git --version\n           mkdir build64\n           cd build64\n-          cmake -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_ENABLE_THREADS=OFF ..\n+          cmake -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_ENABLE_THREADS=OFF ..\n           cmake --build . --target acceptance_tests --verbose\n           ctest -L acceptance --output-on-failure\n           cd ..\n           mkdir build64debug\n           cd build64debug\n-          cmake -DCMAKE_BUILD_TYPE=Debug -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_ENABLE_THREADS=OFF ..\n+          cmake -DSIMDJSON_DEVELOPER_MODE=ON -DCMAKE_BUILD_TYPE=Debug -DBUILD_SHARED_LIBS=OFF -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_ENABLE_THREADS=OFF ..\n           cmake --build . --target acceptance_tests --verbose\n           ctest -L acceptance --output-on-failure\n--- vendor/simdjson/.github/workflows/msys2-clang.yml\n@@ -1,12 +1,7 @@\n name: MSYS2-CLANG-CI\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n+\n \n jobs:\n   windows-mingw:\n@@ -20,16 +15,16 @@ jobs:\n       matrix:\n         include:\n           - msystem: \"MINGW64\"\n-            install: mingw-w64-x86_64-cmake mingw-w64-x86_64-ninja mingw-w64-x86_64-clang\n+            install: mingw-w64-x86_64-libxml2 mingw-w64-x86_64-cmake mingw-w64-x86_64-ninja mingw-w64-x86_64-clang\n             type: Release\n           - msystem: \"MINGW32\"\n-            install: mingw-w64-i686-cmake mingw-w64-i686-ninja mingw-w64-i686-clang\n+            install: mingw-w64-i686-libxml2 mingw-w64-i686-cmake mingw-w64-i686-ninja mingw-w64-i686-clang\n             type: Release\n           - msystem: \"MINGW64\"\n-            install: mingw-w64-x86_64-cmake mingw-w64-x86_64-ninja mingw-w64-x86_64-clang\n+            install: mingw-w64-x86_64-libxml2 mingw-w64-x86_64-cmake mingw-w64-x86_64-ninja mingw-w64-x86_64-clang\n             type: Debug\n           - msystem: \"MINGW32\"\n-            install: mingw-w64-i686-cmake mingw-w64-i686-ninja mingw-w64-i686-clang\n+            install: mingw-w64-i686-libxml2 mingw-w64-i686-cmake mingw-w64-i686-ninja mingw-w64-i686-clang\n             type: Debug\n     env:\n       CMAKE_GENERATOR: Ninja\n@@ -49,6 +44,6 @@ jobs:\n         run: |\n           mkdir build\n           cd build\n-          cmake -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_BUILD_TYPE=${{ matrix.type }} -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_DO_NOT_USE_THREADS_NO_MATTER_WHAT=ON ..\n+          cmake -DSIMDJSON_DEVELOPER_MODE=ON -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_BUILD_TYPE=${{ matrix.type }} -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_DO_NOT_USE_THREADS_NO_MATTER_WHAT=ON ..\n           cmake --build . --verbose\n           ctest -j4 --output-on-failure -LE explicitonly\n--- vendor/simdjson/.github/workflows/msys2.yml\n@@ -1,12 +1,6 @@\n name: MSYS2-CI\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   windows-mingw:\n@@ -52,6 +46,6 @@ jobs:\n         run: |\n           mkdir build\n           cd build\n-          cmake -DCMAKE_BUILD_TYPE=${{ matrix.type }} -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_DO_NOT_USE_THREADS_NO_MATTER_WHAT=ON ..\n+          cmake -DSIMDJSON_DEVELOPER_MODE=ON -DCMAKE_BUILD_TYPE=${{ matrix.type }} -DBUILD_SHARED_LIBS=OFF -DSIMDJSON_DO_NOT_USE_THREADS_NO_MATTER_WHAT=ON ..\n           cmake --build . --verbose\n           ctest -j4 --output-on-failure -LE explicitonly\n--- vendor/simdjson/.github/workflows/power-fuzz.yml\n@@ -32,13 +32,19 @@ jobs:\n           run: |\n             export CLANGSUFFIX=\"-7\"\n             apt-get -qq update\n-            apt-get install -q -y clang-7 libfuzzer-7-dev cmake git wget zip ninja-build\n+            apt-get install -q -y clang-7 libfuzzer-7-dev git wget zip ninja-build gnupg software-properties-common\n+            wget -q -O - \"https://raw.githubusercontent.com/simdjson/debian-ppa/master/key.gpg\" | apt-key add -\n+            apt-add-repository \"deb https://raw.githubusercontent.com/simdjson/debian-ppa/master simdjson main\"\n+            apt-get -qq update\n+            apt-get purge cmake cmake-data\n+            apt-get -t simdjson -y install cmake\n             mkdir -p build ; cd build\n             cmake .. -GNinja \\\n                   -DCMAKE_CXX_COMPILER=clang++$CLANGSUFFIX \\\n                   -DCMAKE_C_COMPILER=clang$CLANGSUFFIX \\\n-                  -DSIMDJSON_BUILD_STATIC=Off \\\n-                  -DENABLE_FUZZING=On \\\n+                  -DBUILD_SHARED_LIBS=OFF \\\n+                  -DSIMDJSON_DEVELOPER_MODE=ON \\\n+                  -DSIMDJSON_ENABLE_FUZZING=On \\\n                   -DSIMDJSON_COMPETITION=OFF \\\n                   -DSIMDJSON_GOOGLE_BENCHMARKS=OFF \\\n                   -DSIMDJSON_DISABLE_DEPRECATED_API=On \\\n@@ -50,8 +56,8 @@ jobs:\n             cd ..\n             builddir=build\n             cmake --build $builddir\n-            wget --quiet https://dl.bintray.com/pauldreik/simdjson-fuzz-corpus/corpus/corpus.tar\n-            tar xf corpus.tar && rm corpus.tar\n+            wget -O corpus.tar.gz https://readonly:readonly@www.pauldreik.se/fuzzdata/index.php?project=simdjson\n+            tar xf corpus.tar.gz\n             fuzzernames=$(cmake --build $builddir --target print_all_fuzzernames |tail -n1)\n             for fuzzer in $fuzzernames ; do\n                exe=$builddir/fuzz/$fuzzer\n--- vendor/simdjson/.github/workflows/ubuntu18-checkperf.yml\n@@ -24,6 +24,6 @@ jobs:\n         run: |\n           mkdir build &&\n           cd build &&\n-          cmake  -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_BUILD_STATIC=ON -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n+          cmake  -DSIMDJSON_DEVELOPER_MODE=ON -DSIMDJSON_ENABLE_DOM_CHECKPERF=ON -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n           cmake --build . --target checkperf  &&\n           ctest --output-on-failure -R checkperf  ubuntu18-checkperf.yml\n--- vendor/simdjson/.github/workflows/ubuntu18-oldclang.yml\n@@ -0,0 +1,31 @@\n+name: Ubuntu 18.04 CI (LLVM 7)\n+\n+on: [push, pull_request]\n+\n+jobs:\n+  ubuntu-build:\n+    if: >-\n+      ! contains(toJSON(github.event.commits.*.message), '[skip ci]') &&\n+      ! contains(toJSON(github.event.commits.*.message), '[skip github]')\n+    runs-on: ubuntu-18.04\n+\n+    env:\n+      CC: clang-7\n+      CXX: clang++-7\n+    steps:\n+      - uses: actions/checkout@v2\n+      - uses: actions/cache@v2\n+        with:\n+          path: dependencies/.cache\n+          key: ${{ hashFiles('dependencies/CMakeLists.txt') }}\n+      - name: install clang 7\n+        run: |\n+          sudo apt update\n+          sudo apt install clang-7\n+      - name: Use cmake\n+        run: |\n+          mkdir build &&\n+          cd build &&\n+          cmake  -DSIMDJSON_DEVELOPER_MODE=ON -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n+          cmake --build .   &&\n+          ctest -j --output-on-failure -LE explicitonly\n--- vendor/simdjson/.github/workflows/ubuntu18-threadsani.yml\n@@ -1,12 +1,7 @@\n name: Ubuntu 18.04 CI (GCC 7) with Thread Sanitizer\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n+\n \n jobs:\n   ubuntu-build:\n@@ -24,7 +19,7 @@ jobs:\n         run: |\n           mkdir build &&\n           cd build &&\n-          cmake  -DSIMDJSON_SANITIZE_THREADS=ON ..  &&\n-          cmake --build . --target document_stream_tests --target parse_many_test  &&\n+          cmake  -DSIMDJSON_DEVELOPER_MODE=ON -DSIMDJSON_SANITIZE_THREADS=ON ..  &&\n+          cmake --build . --target document_stream_tests --target ondemand_document_stream_tests --target parse_many_test  &&\n           ctest --output-on-failure  -R parse_many_test  &&\n           ctest --output-on-failure  -R document_stream_tests\n\\ No newline at end of file\n--- vendor/simdjson/.github/workflows/ubuntu18.yml\n@@ -1,12 +1,6 @@\n name: Ubuntu 18.04 CI (GCC 7)\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   ubuntu-build:\n@@ -24,7 +18,7 @@ jobs:\n         run: |\n           mkdir build &&\n           cd build &&\n-          cmake  -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_BUILD_STATIC=ON -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n+          cmake  -DSIMDJSON_DEVELOPER_MODE=ON -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n           cmake --build .   &&\n           ctest -j --output-on-failure -LE explicitonly   &&\n           make install  &&\n--- vendor/simdjson/.github/workflows/ubuntu20-checkperf.yml\n@@ -24,6 +24,6 @@ jobs:\n         run: |\n           mkdir build &&\n           cd build &&\n-          cmake  -DCMAKE_CXX_FLAGS=\"-Werror=old-style-cast -pedantic -Wpedantic\" -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_BUILD_STATIC=ON -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n+          cmake  -DSIMDJSON_DEVELOPER_MODE=ON -DSIMDJSON_ENABLE_DOM_CHECKPERF=ON -DCMAKE_CXX_FLAGS=\"-Werror=old-style-cast -pedantic -Wpedantic\" -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n           cmake --build . --target checkperf  &&\n           ctest --output-on-failure -R checkperf\n--- vendor/simdjson/.github/workflows/ubuntu20-noexcept.yml\n@@ -1,12 +1,6 @@\n name: Ubuntu 20.04 CI (GCC 9) without exceptions\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   ubuntu-build:\n@@ -22,9 +16,15 @@ jobs:\n           key: ${{ hashFiles('dependencies/CMakeLists.txt') }}\n       - name: Use cmake\n         run: |\n+          mkdir builddebug &&\n+          cd builddebug &&\n+          cmake -DCMAKE_BUILD_TYPE=Debug -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_DEVELOPER_MODE=ON -DSIMDJSON_EXCEPTIONS=OFF -DBUILD_SHARED_LIBS=OFF ..  &&\n+          cmake --build .   &&\n+          ctest -j --output-on-failure -LE explicitonly   &&\n+          cd .. &&\n           mkdir build &&\n           cd build &&\n-          cmake  -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_EXCEPTIONS=OFF -DSIMDJSON_BUILD_STATIC=ON -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n+          cmake  -DSIMDJSON_DEVELOPER_MODE=ON -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_EXCEPTIONS=OFF -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n           cmake --build .   &&\n           ctest -j --output-on-failure -LE explicitonly   &&\n           make install  &&\n--- vendor/simdjson/.github/workflows/ubuntu20-nothread.yml\n@@ -1,12 +1,6 @@\n-name: Ubuntu 20.04 CI (GCC 9) without threads\n+name: Ubuntu 20.04 CI (GCC 9) Without Threads\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   ubuntu-build:\n@@ -22,9 +16,15 @@ jobs:\n           key: ${{ hashFiles('dependencies/CMakeLists.txt') }}\n       - name: Use cmake\n         run: |\n+          mkdir builddebug &&\n+          cd builddebug &&\n+          cmake -DCMAKE_BUILD_TYPE=Debug -DSIMDJSON_GOOGLE_BENCHMARKS=OFF  -DSIMDJSON_ENABLE_THREADS=OFF -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF ..  &&\n+          cmake --build .   &&\n+          ctest -j --output-on-failure -LE explicitonly   &&\n+          cd .. &&\n           mkdir build &&\n           cd build &&\n-          cmake  -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_ENABLE_THREADS=OFF -DSIMDJSON_BUILD_STATIC=ON -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n+          cmake  -DSIMDJSON_DEVELOPER_MODE=ON -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_ENABLE_THREADS=OFF -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n           cmake --build .   &&\n           ctest -j --output-on-failure -LE explicitonly   &&\n           make install  &&\n--- vendor/simdjson/.github/workflows/ubuntu20-sani.yml\n@@ -0,0 +1,23 @@\n+name: Ubuntu 20.04 CI (GCC 9) With Memory Sanitizer\n+\n+on: [push, pull_request]\n+\n+jobs:\n+  ubuntu-build:\n+    if: >-\n+      ! contains(toJSON(github.event.commits.*.message), '[skip ci]') &&\n+      ! contains(toJSON(github.event.commits.*.message), '[skip github]')\n+    runs-on: ubuntu-20.04\n+    steps:\n+      - uses: actions/checkout@v2\n+      - uses: actions/cache@v2\n+        with:\n+          path: dependencies/.cache\n+          key: ${{ hashFiles('dependencies/CMakeLists.txt') }}\n+      - name: Use cmake\n+        run: |\n+          mkdir builddebug &&\n+          cd builddebug &&\n+          cmake -DSIMDJSON_SANITIZE=ON -DCMAKE_BUILD_TYPE=Debug -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF ..  &&\n+          cmake --build .   &&\n+          ctest -j --output-on-failure -LE explicitonly\n\\ No newline at end of file\n--- vendor/simdjson/.github/workflows/ubuntu20-threadsani.yml\n@@ -1,12 +1,6 @@\n name: Ubuntu 20.04 CI (GCC 9) with Thread Sanitizer\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   ubuntu-build:\n@@ -24,7 +18,7 @@ jobs:\n         run: |\n           mkdir build &&\n           cd build &&\n-          cmake  -DSIMDJSON_SANITIZE_THREADS=ON ..  &&\n-          cmake --build . --target document_stream_tests --target parse_many_test  &&\n+          cmake  -DSIMDJSON_DEVELOPER_MODE=ON -DSIMDJSON_SANITIZE_THREADS=ON ..  &&\n+          cmake --build . --target document_stream_tests  --target ondemand_document_stream_tests --target parse_many_test  &&\n           ctest --output-on-failure  -R parse_many_test  &&\n           ctest --output-on-failure  -R document_stream_tests\n\\ No newline at end of file\n--- vendor/simdjson/.github/workflows/ubuntu20.yml\n@@ -1,12 +1,6 @@\n name: Ubuntu 20.04 CI (GCC 9)\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   ubuntu-build:\n@@ -22,9 +16,15 @@ jobs:\n           key: ${{ hashFiles('dependencies/CMakeLists.txt') }}\n       - name: Use cmake\n         run: |\n+          mkdir builddebug &&\n+          cd builddebug &&\n+          cmake -DCMAKE_BUILD_TYPE=Debug -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF ..  &&\n+          cmake --build .   &&\n+          ctest -j --output-on-failure -LE explicitonly   &&\n+          cd .. &&\n           mkdir build &&\n           cd build &&\n-          cmake  -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_BUILD_STATIC=ON -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n+          cmake  -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n           cmake --build .   &&\n           ctest -j --output-on-failure -LE explicitonly   &&\n           cmake --install . &&\n--- vendor/simdjson/.github/workflows/vs15-ci.yml\n@@ -1,12 +1,6 @@\n name: VS15-CI\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   ci:\n@@ -28,15 +22,19 @@ jobs:\n       uses: actions/checkout@v2\n     - name: Configure\n       run: |\n-        cmake -G \"${{matrix.gen}}\" -A ${{matrix.arch}} -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_BUILD_STATIC=${{matrix.static}} -B build\n+        cmake -G \"${{matrix.gen}}\" -A ${{matrix.arch}} -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_DEVELOPER_MODE=ON -DSIMDJSON_BUILD_STATIC=${{matrix.static}} -B build\n     - name: Build Debug\n       run: cmake --build build --config Debug --verbose\n     - name: Build Release\n       run: cmake --build build --config Release --verbose\n-    - name: Run tests\n+    - name: Run Release tests\n       run: |\n         cd build\n         ctest -C Release  -LE explicitonly  --output-on-failure\n+    - name: Run Debug tests\n+      run: |\n+        cd build\n+        ctest -C Debug  -LE explicitonly  --output-on-failure\n     - name: Install\n       run: |\n         cmake --install build --config Release\n--- vendor/simdjson/.github/workflows/vs16-arm-ci.yml\n@@ -0,0 +1,21 @@\n+name: VS16-ARM-CI\n+\n+on: [push, pull_request]\n+\n+jobs:\n+   ci:\n+     name: windows-vs16\n+     runs-on: windows-latest\n+     strategy:\n+       fail-fast: false\n+       matrix:\n+         include:\n+           - {arch: ARM}\n+           - {arch: ARM64}\n+     steps:\n+       - name: checkout\n+         uses: actions/checkout@v2\n+       - name: Use cmake\n+         run: |\n+           cmake -A ${{ matrix.arch }} -DCMAKE_CROSSCOMPILING=1 -DSIMDJSON_DEVELOPER_MODE=ON -D SIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_EXCEPTIONS=OFF -B build  &&\n+           cmake --build build --verbose\n\\ No newline at end of file\n--- vendor/simdjson/.github/workflows/vs16-ci.yml\n@@ -1,12 +1,6 @@\n name: VS16-CI\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   ci:\n@@ -28,15 +22,19 @@ jobs:\n       uses: actions/checkout@v2\n     - name: Configure\n       run: |\n-        cmake -G \"${{matrix.gen}}\" -A ${{matrix.arch}} -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_BUILD_STATIC=${{matrix.static}} -B build\n+        cmake -G \"${{matrix.gen}}\" -A ${{matrix.arch}} -DSIMDJSON_DEVELOPER_MODE=ON -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_BUILD_STATIC=${{matrix.static}} -B build\n     - name: Build Debug\n       run: cmake --build build --config Debug --verbose\n     - name: Build Release\n       run: cmake --build build --config Release --verbose\n-    - name: Run tests\n+    - name: Run Release tests\n       run: |\n         cd build\n         ctest -C Release  -LE explicitonly  --output-on-failure\n+    - name: Run Debug tests\n+      run: |\n+        cd build\n+        ctest -C Debug  -LE explicitonly  --output-on-failure\n     - name: Install\n       run: |\n         cmake --install build --config Release\n--- vendor/simdjson/.github/workflows/vs16-clang-ci.yml\n@@ -1,12 +1,6 @@\n name: VS16-CLANG-CI\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   ci:\n@@ -29,9 +23,9 @@ jobs:\n         buildDirectory: \"${{ github.workspace }}/../../_temp/windows\"\n         cmakeBuildType: Release\n         buildWithCMake: true\n-        cmakeAppendedArgs:  -T ClangCL -DSIMDJSON_COMPETITION=OFF  -DSIMDJSON_BUILD_STATIC=ON\n+        cmakeAppendedArgs:  -T ClangCL -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF\n         buildWithCMakeArgs: --config Release\n-    \n+\n     - name: 'Run CTest'\n       run: ctest -C Release -LE explicitonly  --output-on-failure\n       working-directory: \"${{ github.workspace }}/../../_temp/windows\"\n\\ No newline at end of file\n--- vendor/simdjson/.github/workflows/vs16-ninja-ci.yml\n@@ -1,12 +1,6 @@\n name: VS16-Ninja-CI\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   ci:\n@@ -29,7 +23,7 @@ jobs:\n         buildDirectory: \"${{ github.workspace }}/../../_temp/windows\"\n         cmakeBuildType: Release\n         buildWithCMake: true\n-        cmakeAppendedArgs:  -G Ninja -DSIMDJSON_COMPETITION=OFF   -DSIMDJSON_BUILD_STATIC=ON\n+        cmakeAppendedArgs:  -G Ninja -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF\n         buildWithCMakeArgs: --config Release\n     - name: 'Run CTest'\n       run: ctest -C Release  -LE explicitonly  --output-on-failure\n--- vendor/simdjson/.github/workflows/vs16-noexcept-ci.yml\n@@ -1,12 +1,6 @@\n name: VS16-NoExcept-CI\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   ci:\n@@ -27,7 +21,7 @@ jobs:\n         cmakeBuildType: Release\n         buildWithCMake: true\n         cmakeGenerator: VS16Win64\n-        cmakeAppendedArgs: -DSIMDJSON_COMPETITION=OFF  -DSIMDJSON_EXCEPTIONS=OFF\n+        cmakeAppendedArgs: -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_DEVELOPER_MODE=ON  -DSIMDJSON_EXCEPTIONS=OFF\n         buildWithCMakeArgs: --config Release\n \n     - name: 'Run CTest'\n--- vendor/simdjson/.travis.yml\n@@ -48,17 +48,18 @@ matrix:\n         - COMPILER=\"CC=gcc-10 && CXX=g++-10\"\n       compiler: gcc-10\n \n-    - os: linux\n-      addons:\n-        apt:\n-          sources:\n-            - ubuntu-toolchain-r-test\n-          packages:\n-            - g++-10\n-      env:\n-        - COMPILER=\"CC=gcc-10 && CXX=g++-10\"\n-        - SANITIZE=\"on\"\n-      compiler: gcc-10-sanitize\n+# The sanitizer runs fail systematically\n+#    - os: linux\n+#      addons:\n+#        apt:\n+#          sources:\n+#            - ubuntu-toolchain-r-test\n+#          packages:\n+#            - g++-10\n+#      env:\n+#        - COMPILER=\"CC=gcc-10 && CXX=g++-10\"\n+#        - SANITIZE=\"on\"\n+#      compiler: gcc-10-sanitize\n \n     - os: linux\n       addons:\n@@ -143,19 +144,20 @@ matrix:\n         - STATIC=\"on\"\n       compiler: clang-10-static\n \n-    - os: linux\n-      addons:\n-        apt:\n-          packages:\n-            - clang-10\n-          sources:\n-            - ubuntu-toolchain-r-test\n-            - sourceline: 'deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-10 main'\n-              key_url: 'https://apt.llvm.org/llvm-snapshot.gpg.key'\n-      env:\n-        - COMPILER=\"CC=clang-10 && CXX=clang++-10\"\n-        - SANITIZE=\"on\"\n-      compiler: clang-10-sanitize\n+# The clang sanitizer runs fail frequently at setup time\n+#    - os: linux\n+#      addons:\n+#        apt:\n+#          packages:\n+#            - clang-10\n+#          sources:\n+#            - ubuntu-toolchain-r-test\n+#            - sourceline: 'deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-10 main'\n+#              key_url: 'https://apt.llvm.org/llvm-snapshot.gpg.key'\n+#      env:\n+#        - COMPILER=\"CC=clang-10 && CXX=clang++-10\"\n+#        - SANITIZE=\"on\"\n+#      compiler: clang-10-sanitize\n \n before_install:\n   - eval \"${COMPILER}\"\n@@ -174,7 +176,7 @@ install:\n       export ASAN_OPTIONS=\"detect_leaks=0\";\n     fi\n   - if [[ \"${STATIC}\" == \"on\" ]]; then\n-      export CMAKE_FLAGS=\"${CMAKE_FLAGS} -DSIMDJSON_BUILD_STATIC=ON\";\n+      export CMAKE_FLAGS=\"${CMAKE_FLAGS} -DBUILD_SHARED_LIBS=OFF\";\n     fi\n   - export CTEST_FLAGS=\"-j4 --output-on-failure -LE explicitonly\"\n \n--- vendor/simdjson/.vscode/extensions.json\n@@ -0,0 +1,17 @@\n+{\n+\t// See https://go.microsoft.com/fwlink/?LinkId=827846 to learn about workspace recommendations.\n+\t// Extension identifier format: ${publisher}.${name}. Example: vscode.csharp\n+\n+\t// List of extensions which should be recommended for users of this workspace.\n+\t\"recommendations\": [\n+\t\t// Syntax\n+\t\t\"ms-vscode.cpptools\",\n+\t\t\"ms-vscode.cmake-tools\",\n+\t\t\"ms-python.python\",\n+\t\t\"twxs.cmake\"\n+\t],\n+\t// List of extensions recommended by VS Code that should not be recommended for users of this workspace.\n+\t\"unwantedRecommendations\": [\n+\n+\t]\n+}\n\\ No newline at end of file\n--- vendor/simdjson/.vscode/settings.json\n@@ -0,0 +1,91 @@\n+{\n+    \"editor.rulers\": [\n+        {\"column\": 95 },\n+        {\"column\": 120 }\n+    ],\n+    \"files.trimTrailingWhitespace\": true,\n+    \"files.associations\": {\n+        \"array\": \"cpp\",\n+        \"iterator\": \"cpp\",\n+        \"chrono\": \"cpp\",\n+        \"optional\": \"cpp\",\n+        \"__locale\": \"cpp\",\n+        \"__tuple\": \"cpp\",\n+        \"__bit_reference\": \"cpp\",\n+        \"__config\": \"cpp\",\n+        \"__debug\": \"cpp\",\n+        \"__errc\": \"cpp\",\n+        \"__functional_base\": \"cpp\",\n+        \"__hash_table\": \"cpp\",\n+        \"__mutex_base\": \"cpp\",\n+        \"__node_handle\": \"cpp\",\n+        \"__nullptr\": \"cpp\",\n+        \"__split_buffer\": \"cpp\",\n+        \"__string\": \"cpp\",\n+        \"__threading_support\": \"cpp\",\n+        \"__tree\": \"cpp\",\n+        \"algorithm\": \"cpp\",\n+        \"atomic\": \"cpp\",\n+        \"bit\": \"cpp\",\n+        \"bitset\": \"cpp\",\n+        \"cctype\": \"cpp\",\n+        \"cinttypes\": \"cpp\",\n+        \"clocale\": \"cpp\",\n+        \"cmath\": \"cpp\",\n+        \"codecvt\": \"cpp\",\n+        \"complex\": \"cpp\",\n+        \"condition_variable\": \"cpp\",\n+        \"cstdarg\": \"cpp\",\n+        \"cstddef\": \"cpp\",\n+        \"cstdint\": \"cpp\",\n+        \"cstdio\": \"cpp\",\n+        \"cstdlib\": \"cpp\",\n+        \"cstring\": \"cpp\",\n+        \"ctime\": \"cpp\",\n+        \"cwchar\": \"cpp\",\n+        \"cwctype\": \"cpp\",\n+        \"deque\": \"cpp\",\n+        \"exception\": \"cpp\",\n+        \"forward_list\": \"cpp\",\n+        \"fstream\": \"cpp\",\n+        \"functional\": \"cpp\",\n+        \"initializer_list\": \"cpp\",\n+        \"iomanip\": \"cpp\",\n+        \"ios\": \"cpp\",\n+        \"iosfwd\": \"cpp\",\n+        \"iostream\": \"cpp\",\n+        \"istream\": \"cpp\",\n+        \"limits\": \"cpp\",\n+        \"list\": \"cpp\",\n+        \"locale\": \"cpp\",\n+        \"map\": \"cpp\",\n+        \"memory\": \"cpp\",\n+        \"mutex\": \"cpp\",\n+        \"new\": \"cpp\",\n+        \"numeric\": \"cpp\",\n+        \"ostream\": \"cpp\",\n+        \"random\": \"cpp\",\n+        \"ratio\": \"cpp\",\n+        \"regex\": \"cpp\",\n+        \"set\": \"cpp\",\n+        \"sstream\": \"cpp\",\n+        \"stack\": \"cpp\",\n+        \"stdexcept\": \"cpp\",\n+        \"streambuf\": \"cpp\",\n+        \"string\": \"cpp\",\n+        \"string_view\": \"cpp\",\n+        \"system_error\": \"cpp\",\n+        \"thread\": \"cpp\",\n+        \"tuple\": \"cpp\",\n+        \"type_traits\": \"cpp\",\n+        \"typeinfo\": \"cpp\",\n+        \"unordered_map\": \"cpp\",\n+        \"unordered_set\": \"cpp\",\n+        \"utility\": \"cpp\",\n+        \"valarray\": \"cpp\",\n+        \"vector\": \"cpp\",\n+        \"*.ipp\": \"cpp\",\n+        \"__functional_base_03\": \"cpp\",\n+        \"filesystem\": \"cpp\"\n+    }\n+}\n\\ No newline at end of file\n--- vendor/simdjson/CMakeLists.txt\n@@ -1,97 +1,267 @@\n cmake_minimum_required(VERSION 3.9)\n-# CMP0025: Compiler id for Apple Clang is now AppleClang.\n-# https://cmake.org/cmake/help/v3.17/policy/CMP0025.html\n-cmake_policy(SET CMP0025 NEW)\n-project(simdjson\n-  DESCRIPTION \"Parsing gigabytes of JSON per second\"\n-  LANGUAGES CXX C\n+\n+project(\n+    simdjson\n+    # The version number is modified by tools/release.py\n+    VERSION 1.0.0\n+    DESCRIPTION \"Parsing gigabytes of JSON per second\"\n+    LANGUAGES CXX C\n+)\n+\n+set(SIMDJSON_GITHUB_REPOSITORY \"https://github.com/simdjson/simdjson\")\n+\n+string(\n+    COMPARE EQUAL\n+    \"${CMAKE_SOURCE_DIR}\" \"${CMAKE_CURRENT_SOURCE_DIR}\"\n+    is_top_project\n )\n \n-set(PROJECT_VERSION_MAJOR 0)\n-set(PROJECT_VERSION_MINOR 9)\n-set(PROJECT_VERSION_PATCH 6)\n-set(SIMDJSON_SEMANTIC_VERSION \"0.9.6\" CACHE STRING \"simdjson semantic version\")\n-set(SIMDJSON_LIB_VERSION \"8.0.0\" CACHE STRING \"simdjson library version\")\n-set(SIMDJSON_LIB_SOVERSION \"8\" CACHE STRING \"simdjson library soversion\")\n-set(SIMDJSON_GITHUB_REPOSITORY https://github.com/simdjson/simdjson)\n+# ---- Options, variables ----\n+\n+# These version numbers are modified by tools/release.py\n+set(SIMDJSON_LIB_VERSION \"9.0.0\" CACHE STRING \"simdjson library version\")\n+set(SIMDJSON_LIB_SOVERSION \"9\" CACHE STRING \"simdjson library soversion\")\n \n+option(SIMDJSON_ENABLE_THREADS \"Link with thread support\" ON)\n+\n+include(cmake/simdjson-props.cmake)\n+include(cmake/implementation-flags.cmake)\n+include(cmake/exception-flags.cmake)\n+\n+option(SIMDJSON_DISABLE_DEPRECATED_API \"Disables deprecated APIs\" OFF)\n+if(SIMDJSON_DISABLE_DEPRECATED_API)\n+  simdjson_add_props(\n+      target_compile_definitions PUBLIC\n+      SIMDJSON_DISABLE_DEPRECATED_API=1\n+  )\n+endif()\n+\n+option(SIMDJSON_DEVELOPMENT_CHECKS \"Enable development-time aids, such as \\\n+checks for incorrect API usage. Enabled by default in DEBUG.\" OFF)\n+if(SIMDJSON_DEVELOPMENT_CHECKS)\n+  simdjson_add_props(\n+      target_compile_definitions PUBLIC\n+      SIMDJSON_DEVELOPMENT_CHECKS\n+  )\n+endif()\n+\n+if(is_top_project)\n+  option(SIMDJSON_DEVELOPER_MODE \"Enable targets for developing simdjson\" OFF)\n+  option(BUILD_SHARED_LIBS \"Build simdjson as a shared library\" OFF)\n+\n+  if(\"$ENV{CI}\")\n+    set(SIMDJSON_DEVELOPER_MODE ON CACHE INTERNAL \"\")\n+  endif()\n+endif()\n+\n+include(cmake/handle-deprecations.cmake)\n+\n+if(SIMDJSON_DEVELOPER_MODE)\n+  include(cmake/developer-options.cmake)\n+else()\n+  message(STATUS \"Building only the library. Advanced users may want to turn SIMDJSON_DEVELOPER_MODE to ON, e.g., via -D SIMDJSON_DEVELOPER_MODE=ON.\")\n+endif()\n+\n+# ---- simdjson library ----\n+\n+add_library(simdjson src/simdjson.cpp)\n+add_library(simdjson::simdjson ALIAS simdjson)\n+\n+set_target_properties(\n+    simdjson PROPERTIES\n+    VERSION \"${SIMDJSON_LIB_VERSION}\"\n+    SOVERSION \"${SIMDJSON_LIB_SOVERSION}\"\n+    # FIXME: symbols should be hidden by default\n+    WINDOWS_EXPORT_ALL_SYMBOLS YES\n+)\n+\n+# FIXME: Use proper CMake integration for exports\n+if(MSVC AND BUILD_SHARED_LIBS)\n+  target_compile_definitions(\n+      simdjson\n+      PRIVATE SIMDJSON_BUILDING_WINDOWS_DYNAMIC_LIBRARY=1\n+      INTERFACE SIMDJSON_USING_WINDOWS_DYNAMIC_LIBRARY=1\n+  )\n+endif()\n+\n+simdjson_add_props(\n+    target_include_directories\n+    PUBLIC \"$<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>\"\n+    PRIVATE \"$<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/src>\"\n+)\n+\n+simdjson_add_props(target_compile_features PUBLIC cxx_std_11)\n+\n+# workaround for GNU GCC poor AVX load/store code generation\n+if(\n+    CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\"\n+    AND CMAKE_SYSTEM_PROCESSOR MATCHES \"^(i.86|x86(_64)?)$\"\n+)\n+  simdjson_add_props(\n+      target_compile_options PRIVATE\n+      -mno-avx256-split-unaligned-load -mno-avx256-split-unaligned-store\n+  )\n+endif()\n+\n+if(SIMDJSON_ENABLE_THREADS)\n+  find_package(Threads REQUIRED)\n+  simdjson_add_props(target_link_libraries PUBLIC Threads::Threads)\n+  simdjson_add_props(target_compile_definitions PUBLIC SIMDJSON_THREADS_ENABLED=1)\n+endif()\n+\n+simdjson_apply_props(simdjson)\n+\n+# ---- Install rules ----\n+\n+include(CMakePackageConfigHelpers)\n include(GNUInstallDirs)\n-include(cmake/simdjson-flags.cmake)\n-include(cmake/simdjson-user-cmakecache.cmake)\n \n+install(\n+    FILES singleheader/simdjson.h\n+    DESTINATION \"${CMAKE_INSTALL_INCLUDEDIR}\"\n+    COMPONENT simdjson_Development\n+)\n+\n+configure_file(cmake/simdjson-config.cmake.in simdjson-config.cmake @ONLY)\n \n+set(\n+    SIMDJSON_INSTALL_CMAKEDIR \"${CMAKE_INSTALL_LIBDIR}/cmake/simdjson\"\n+    CACHE STRING \"CMake package config location relative to the install prefix\"\n+)\n+mark_as_advanced(SIMDJSON_INSTALL_CMAKEDIR)\n \n-if(SIMDJSON_JUST_LIBRARY)\n-  message( STATUS \"Building just the library, omitting all tests, tools and benchmarks.\" )\n-else(SIMDJSON_JUST_LIBRARY)\n-  # Setup tests\n-  enable_testing()\n-  add_subdirectory(jsonchecker)\n-  add_subdirectory(jsonexamples)\n-  add_library(test-data INTERFACE)\n-  target_link_libraries(test-data INTERFACE jsonchecker-data jsonchecker-minefield-data jsonexamples-data)\n-endif(SIMDJSON_JUST_LIBRARY)\n+install(\n+    FILES\n+    \"${PROJECT_BINARY_DIR}/simdjson-config.cmake\"\n+    \"${PROJECT_BINARY_DIR}/simdjson-config-version.cmake\"\n+    DESTINATION \"${SIMDJSON_INSTALL_CMAKEDIR}\"\n+    COMPONENT simdjson_Development\n+)\n \n-# Create the top level simdjson library (must be done at this level to use both src/ and include/\n-# directories) and tools\n #\n-add_subdirectory(include)\n-add_subdirectory(src)\n-add_subdirectory(windows)\n-if(NOT(SIMDJSON_JUST_LIBRARY))\n-  add_subdirectory(dependencies) ## This needs to be before tools because of cxxopts\n-  add_subdirectory(tools)  ## This needs to be before tests because of cxxopts\n-  add_subdirectory(singleheader)\n+# CPack\n+#\n+if(is_top_project)\n+  set(CPACK_PACKAGE_VENDOR \"Daniel Lemire\")\n+  set(CPACK_PACKAGE_CONTACT \"lemire@gmail.com\")\n+  set(CPACK_RESOURCE_FILE_LICENSE \"${PROJECT_SOURCE_DIR}/LICENSE\")\n+  set(CPACK_RESOURCE_FILE_README \"${PROJECT_SOURCE_DIR}/README.md\")\n+\n+  set(CPACK_RPM_PACKAGE_LICENSE \"${PROJECT_SOURCE_DIR}/LICENSE\")\n+\n+  set(CPACK_SOURCE_GENERATOR \"TGZ;ZIP\")\n+\n+  include(CPack)\n endif()\n-install(FILES singleheader/simdjson.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n \n-option(SIMDJSON_ENABLE_THREADS \"Link with thread support\" ON)\n-include(CMakePackageConfigHelpers)\n-configure_package_config_file(\"${PROJECT_SOURCE_DIR}/cmake/simdjson-config.cmake.in\"\n-      \"${PROJECT_BINARY_DIR}/simdjson-config.cmake\"\n-      INSTALL_DESTINATION \"${CMAKE_INSTALL_LIBDIR}/cmake/simdjson\"\n-      NO_SET_AND_CHECK_MACRO\n-      NO_CHECK_REQUIRED_COMPONENTS_MACRO)\n+# ---- Developer mode extras ----\n+\n+if(NOT SIMDJSON_DEVELOPER_MODE)\n+  return()\n+elseif(NOT is_top_project)\n+  message(AUTHOR_WARNING \"Developer mode is intended for developers of simdjson\")\n+endif()\n+\n+simdjson_apply_props(simdjson-internal-flags)\n+\n+set(\n+    SIMDJSON_USER_CMAKECACHE\n+    \"${CMAKE_BINARY_DIR}/.simdjson-user-CMakeCache.txt\"\n+)\n+add_custom_target(\n+    simdjson-user-cmakecache\n+    COMMAND \"${CMAKE_COMMAND}\"\n+    -D \"BINARY_DIR=${CMAKE_BINARY_DIR}\"\n+    -D \"USER_CMAKECACHE=${SIMDJSON_USER_CMAKECACHE}\"\n+    -P \"${PROJECT_SOURCE_DIR}/cmake/simdjson-user-cmakecache.cmake\"\n+    VERBATIM\n+)\n+\n+# Setup tests\n+enable_testing()\n+# So we can build just tests with \"make all_tests\"\n+add_custom_target(all_tests)\n+\n+add_subdirectory(windows)\n+add_subdirectory(dependencies) ## This needs to be before tools because of cxxopts\n+add_subdirectory(tools)  ## This needs to be before tests because of cxxopts\n+\n+# Data: jsonexamples is left with only the bare essential.\n+# most of the data has been moved to https://github.com/simdjson/simdjson-data\n+add_subdirectory(jsonexamples)\n+\n+\n+add_subdirectory(singleheader)\n+\n+\n \n #\n # Compile tools / tests / benchmarks\n #\n-if(NOT(SIMDJSON_JUST_LIBRARY))\n-  add_subdirectory(tests)\n-  add_subdirectory(examples)\n-  add_subdirectory(benchmark)\n-  add_subdirectory(fuzz)\n-endif()\n+add_subdirectory(tests)\n+add_subdirectory(examples)\n+add_subdirectory(benchmark)\n+add_subdirectory(fuzz)\n \n #\n # Source files should be just ASCII\n #\n find_program(FIND find)\n find_program(FILE file)\n find_program(GREP grep)\n-if((FIND) AND (FILE) AND (GREP))\n+if(FIND AND FILE AND GREP)\n+  add_test(\n+      NAME just_ascii\n+      COMMAND sh -c \"\\\n+${FIND} include src windows tools singleheader tests examples benchmark \\\n+-path benchmark/checkperf-reference -prune -name '*.h' -o -name '*.cpp' \\\n+-type f -exec ${FILE} '{}' \\; | ${GREP} -qv ASCII || exit 0  && exit 1\"\n+      WORKING_DIRECTORY \"${PROJECT_SOURCE_DIR}\"\n+  )\n+endif()\n+\n+##\n+## In systems like R, libraries must not use stderr or abort to be acceptable.\n+## Thus we make it a hard rule that one is not allowed to call abort or stderr.\n+## The sanitized builds are allowed to abort.\n+##\n+if(NOT SIMDJSON_SANITIZE)\n+  find_program(GREP grep)\n+  find_program(NM nm)\n+  if((NOT GREP) OR (NOT NM))\n+    message(\"grep and nm are unavailable on this system.\")\n+  else()\n+    add_test(\n+      NAME \"avoid_abort\"\n+      # Under FreeBSD, the __cxa_guard_abort symbol may appear but it is fine.\n+      # So we want to look for <space><possibly _>abort as a test.\n+      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} ' _*abort' || exit 0  && exit 1\"\n+      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n+    )\n+    add_test(\n+      NAME \"avoid_cout\"\n+      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} ' _*cout' || exit 0  && exit 1\"\n+      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n+    )\n+    add_test(\n+      NAME \"avoid_cerr\"\n+      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} ' _*cerr' || exit 0  && exit 1\"\n+      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n+    )\n+    add_test(\n+      NAME \"avoid_printf\"\n+      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} ' _*printf' || exit 0  && exit 1\"\n+      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n+    )\n     add_test(\n-      NAME \"just_ascii\"\n-      COMMAND sh -c \"${FIND}  include src windows tools singleheader tests examples benchmark -path benchmark/checkperf-reference -prune -name '*.h'  -o -name '*.cpp' -type f  -exec ${FILE} '{}' \\; |${GREP} -v ASCII || exit 0  && exit 1\"\n-      WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n+      NAME \"avoid_stdout\"\n+      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} stdout || exit 0 && exit 1\"\n+      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n     )\n+    add_test(\n+      NAME \"avoid_stderr\"\n+      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} stderr || exit 0 && exit 1\"\n+      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n+    )\n+  endif()\n endif()\n-\n-\n-#\n-# CPack\n-#\n-set(CPACK_PACKAGE_VENDOR \"Daniel Lemire\")\n-set(CPACK_PACKAGE_CONTACT \"lemire@gmail.com\")\n-set(CPACK_PACKAGE_DESCRIPTION_SUMMARY \"Parsing gigabytes of JSON per second\")\n-set(CPACK_PACKAGE_VERSION_MAJOR ${PROJECT_VERSION_MAJOR})\n-set(CPACK_PACKAGE_VERSION_MINOR ${PROJECT_VERSION_MINOR})\n-set(CPACK_PACKAGE_VERSION_PATCH ${PROJECT_VERSION_PATCH})\n-set(CPACK_RESOURCE_FILE_LICENSE \"${CMAKE_CURRENT_SOURCE_DIR}/LICENSE\")\n-set(CPACK_RESOURCE_FILE_README \"${CMAKE_CURRENT_SOURCE_DIR}/README.md\")\n-\n-set(CPACK_RPM_PACKAGE_LICENSE \"${CMAKE_CURRENT_SOURCE_DIR}/LICENSE\")\n-\n-set(CPACK_SOURCE_GENERATOR \"TGZ;ZIP\")\n-\n-include(CPack)\n--- vendor/simdjson/CONTRIBUTING.md\n@@ -69,7 +69,7 @@ Pull requests are always invited. However, we ask that you follow these guidelin\n    3. Other types of changes must be clearly motivated. We openly discourage changes with no identifiable benefits.\n - Changes should be focused and minimal. You should change as few lines of code as possible. Please do not reformat or touch files needlessly.\n - New features must be accompanied of new tests, in general.\n-- Your code should pass our continuous-integration tests. It is your responsability to ensure that your proposal pass the tests. We do not merge pull requests that would break our build.\n+- Your code should pass our continuous-integration tests. It is your responsibility to ensure that your proposal pass the tests. We do not merge pull requests that would break our build.\n    - An exception to this would be changes to non-code files, such as documentation and assets, or trivial changes to code, such as comments, where it is encouraged to explicitly ask for skipping a CI run using the `[skip ci]` prefix in your Pull Request title **and** in the first line of the most recent commit in a push. Example for such a commit: `[skip ci] Fixed typo in power_of_ten's docs`\n    This benefits the project in such a way that the CI pipeline is not burdened by running jobs on changes that don't change any behavior in the code, which reduces wait times for other Pull Requests that do change behavior and require testing.\n \n--- vendor/simdjson/CONTRIBUTORS\n@@ -36,5 +36,6 @@ Nong Li\n Furkan Ta\u015fkale\n Brendan Knapp\n Danila Kutenin\n+Pavel Pavlov\n # if you have contributed to the project and your name does not \n # appear in this list, please let us know!\n--- vendor/simdjson/Dockerfile\n@@ -1,88 +0,0 @@\n-###\n-#\n-# Though simdjson requires only commonly available compilers and tools, it can\n-# be convenient to build it and test it inside a docker container: it makes it\n-# possible to test and benchmark simdjson under even relatively out-of-date\n-# Linux servers. It should also work under macOS and Windows, though not\n-# at native speeds, maybe.\n-#\n-# Assuming that you have a working docker server, this file\n-# allows you to build, test and benchmark simdjson.\n-#\n-#  We build the library and associated files in the dockerbuild subdirectory.\n-# It may be necessary to delete it before creating the image:\n-#\n-# rm -r -f dockerbuild\n-#\n-# The need to delete the directory has nothing to do with docker per se: it is\n-# simply cleaner in CMake to start from a fresh directory. This is important: if you\n-# reuse the same directory with different configurations, you may get broken builds.\n-#\n-#\n-# Then you can build the image as follows:\n-#\n-# docker build -t simdjson --build-arg USER_ID=$(id -u)  --build-arg GROUP_ID=$(id -g) .\n-#\n-# Please note that the image does not contain a copy of the code. However, the image will contain the\n-# the compiler and the build system. This means that if you change the source code, after you have built\n-# the image, you won't need to rebuild the image. In fact, unless you want to try a different compiler, you\n-# do not need to ever rebuild the image, even if you do a lot of work on the source code.\n-#\n-# We specify the users to avoid having files owned by a privileged user (root) in our directory. Some\n-# people like to run their machine as the \"root\" user. We do not think it is cool.\n-#\n-# Then you need to build the project:\n-#\n-# docker run  -v $(pwd):/project:Z  simdjson\n-#\n-# Should you change a source file, you may need to call this command again. Because the output\n-# files are persistent between calls to this command (they reside in the dockerbuild directory),\n-# this command can be fast.\n-#\n-# Next you can test it as follows:\n-#\n-# docker run -it -v $(pwd):/project:Z   simdjson sh -c \"cd dockerbuild && ctest . --output-on-failure -LE explicitonly\"\n-#\n-# The run the complete tests requires you to have built all of simdjson.\n-#\n-# Building all of simdjson takes a long time. Instead, you can build just one target:\n-#\n-# docker run -it -v $(pwd):/project:Z  simdjson sh -c \"[ -d dockerbuild ] || mkdir dockerbuild && cd dockerbuild && cmake ..  && cmake --build . --target parse\"\n-#\n-# Note that it is safe to remove dockerbuild before call the previous command, as the repository gets rebuild. It is also possible, by changing the command, to use a different directory name.\n-#\n-# You can run performance tests:\n-#\n-# docker run -it --privileged -v $(pwd):/project:Z  simdjson sh -c \"cd dockerbuild && for i in ../jsonexamples/*.json; do echo \\$i; ./benchmark/parse \\$i;  done\"\n-#\n-# The \"--privileged\" is recommended so you can get performance counters under Linux.\n-#\n-# You can also grab a fresh copy of simdjson and rebuild it, to make comparisons:\n-#\n-# docker run -it -v $(pwd):/project:Z  simdjson sh -c \"git clone https://github.com/simdjson/simdjson.git && cd simdjson && mkdir build && cd build && cmake .. && cmake --build . --target parse \"\n-#\n-# Then you can run comparisons:\n-#\n-# docker run -it --privileged -v $(pwd):/project:Z  simdjson sh -c \"for i in jsonexamples/*.json; do echo \\$i; dockerbuild/benchmark/parse \\$i| grep GB| head -n 1; simdjson/build/benchmark/parse \\$i | grep GB |head -n 1;  done\"\n-#\n-####\n-FROM ubuntu:20.10\n-################\n-# We would prefer to use the conan io images but they do not support 64-bit ARM? The small gcc images appear to\n-# be broken on ARM.\n-# Furthermore, we would not expect users to frequently rebuild the container, so using ubuntu is probably fine.\n-###############\n-ARG USER_ID\n-ARG GROUP_ID\n-RUN apt-get update -qq\n-RUN DEBIAN_FRONTEND=\"noninteractive\" apt-get -y install tzdata\n-RUN apt-get install -y cmake g++ git\n-RUN mkdir project\n-\n-RUN addgroup --gid $GROUP_ID user; exit 0\n-RUN adduser --disabled-password --gecos '' --uid $USER_ID --gid $GROUP_ID user; exit 0\n-USER user\n-RUN gcc --version\n-WORKDIR /project\n-\n-CMD [\"sh\",\"-c\",\"[ -d dockerbuild ] || mkdir dockerbuild && cd dockerbuild && cmake .. && cmake --build . \"]\n--- vendor/simdjson/HACKING.md\n@@ -32,6 +32,18 @@ Stage 1 also does unicode validation.\n \n Stage 2 handles all of the rest: number parsings, recognizing atoms like true, false, null, and so forth.\n \n+Developer mode\n+--------------\n+\n+Build system targets that are only useful for developers of the simdjson\n+library are behind the `SIMDJSON_DEVELOPER_MODE` option. Enabling this option\n+makes tests, examples, benchmarks and other developer targets available. Not\n+enabling this option means that you are a consumer of simdjson and thus you\n+only get the library targets and options.\n+\n+Developer mode is forced to be on when the `CI` environment variable is set to\n+a value that CMake recognizes as \"on\", which is set to `true` in all of the CI\n+workflows used by simdjson.\n \n Directory Structure and Source\n ------------------------------\n@@ -74,19 +86,19 @@ Other important files and directories:\n   ```bash\n   mkdir build\n   cd build\n-  cmake ..\n+  cmake -D SIMDJSON_DEVELOPER_MODE=ON ..\n   cmake --build . --config Release\n-  benchmark/parse ../jsonexamples/twitter.json\n+  benchmark/dom/parse ../jsonexamples/twitter.json\n   ```\n   The last line becomes `./benchmark/Release/parse.exe ../jsonexample/twitter.json` under Windows. You may also use Google Benchmark:\n   ```bash\n   mkdir build\n   cd build\n-  cmake ..\n+  cmake -D SIMDJSON_DEVELOPER_MODE=ON ..\n   cmake --build . --target bench_parse_call --config Release\n   ./benchmark/bench_parse_call\n   ```\n-  The last line becomes `./benchmark/Release/bench_parse_call.exe` under Windows. Under Windows, you can also build with the clang compiler by adding `-T ClangCL` to the call to `cmake ..`: `cmake .. - TClangCL`.\n+  The last line becomes `./benchmark/Release/bench_parse_call.exe` under Windows. Under Windows, you can also build with the clang compiler by adding `-T ClangCL` to the call to `cmake ..`: `cmake -T ClangCL ..`.\n * **fuzz:** The source for fuzz testing. This lets us explore important edge and middle cases\n * **fuzz:** The source for fuzz testing. This lets us explore important edge and middle cases\n   automatically, and is run in CI.\n@@ -147,7 +159,7 @@ processor.\n \n At this point, we are require to use one of two main strategies.\n \n-1. On POSIX systems, the main compilers (LLVM clang, GNU gcc) allow us to use any intrinsic function after including the header, but they fail to inline the resulting instruction if the target processor does not support them. Because we compile for a generic processor, we would not be able to use most intrinsic functions. Thankfully, more recent versions of these compilers allow us to flag a region of code with a specific target, so that we can compile only some of the code with support for advanced instructions. Thus in our C++, one might notice macros like `TARGET_HASWELL`. It is then our responsability, at runtime, to only run the regions of code (that we call kernels) matching the properties of the runtime processor. The benefit of this approach is that the compiler not only let us use intrinsic functions, but it can also optimize the rest of the code in the kernel with advanced instructions we enabled.\n+1. On POSIX systems, the main compilers (LLVM clang, GNU gcc) allow us to use any intrinsic function after including the header, but they fail to inline the resulting instruction if the target processor does not support them. Because we compile for a generic processor, we would not be able to use most intrinsic functions. Thankfully, more recent versions of these compilers allow us to flag a region of code with a specific target, so that we can compile only some of the code with support for advanced instructions. Thus in our C++, one might notice macros like `TARGET_HASWELL`. It is then our responsibility, at runtime, to only run the regions of code (that we call kernels) matching the properties of the runtime processor. The benefit of this approach is that the compiler not only let us use intrinsic functions, but it can also optimize the rest of the code in the kernel with advanced instructions we enabled.\n \n 2. Under Visual Studio, the problem is somewhat simpler. Visual Studio will not only provide the intrinsic functions, but it will also allow us to use them. They will compile just fine. It is at runtime that they may cause a crash. So we do not need to mark regions of code for compilation toward advanced processors (e.g., with  `TARGET_HASWELL` macros). The downside of the Visual Studio approach is that the compiler is not allowed to use advanced instructions others than those we specify. In principle, this means that Visual Studio has weaker optimization opportunities.\n \n@@ -168,7 +180,7 @@ systematically regenerated on releases. To ensure you have the latest code, you\n ```bash\n mkdir build\n cd build\n-cmake ..\n+cmake -D SIMDJSON_DEVELOPER_MODE=ON ..\n cmake --build . # needed, because currently dependencies do not work fully for the amalgamate target\n cmake --build . --target amalgamate\n ```\n@@ -209,31 +221,31 @@ Building: While in the project repository, do the following:\n ```\n mkdir build\n cd build\n-cmake ..\n+cmake -D SIMDJSON_DEVELOPER_MODE=ON ..\n cmake --build .\n ctest\n ```\n \n-CMake will build a library. By default, it builds a shared library (e.g., libsimdjson.so on Linux).\n+CMake will build a library. By default, it builds a static library (e.g., libsimdjson.a on Linux).\n \n-You can build a static library:\n+You can build a shared library:\n \n ```\n-mkdir buildstatic\n-cd buildstatic\n-cmake -DSIMDJSON_BUILD_STATIC=ON ..\n+mkdir buildshared\n+cd buildshared\n+cmake -D BUILD_SHARED_LIBS=ON -D SIMDJSON_DEVELOPER_MODE=ON ..\n cmake --build .\n ctest\n ```\n \n-In some cases, you may want to specify your compiler, especially if the default compiler on your system is too old.  You need to tell cmake which compiler you wish to use by setting the CC and CXX variables. Under bash, you can do so with commands such as `export CC=gcc-7` and `export CXX=g++-7`. You can also do it as part of the `cmake` command: `cmake .. -DCMAKE_CXX_COMPILER=g++`.  You may proceed as follows:\n+In some cases, you may want to specify your compiler, especially if the default compiler on your system is too old.  You need to tell cmake which compiler you wish to use by setting the CC and CXX variables. Under bash, you can do so with commands such as `export CC=gcc-7` and `export CXX=g++-7`. You can also do it as part of the `cmake` command: `cmake -DCMAKE_CXX_COMPILER=g++ ..`.  You may proceed as follows:\n \n ```\n brew install gcc@8\n mkdir build\n cd build\n export CXX=g++-8 CC=gcc-8\n-cmake ..\n+cmake -D SIMDJSON_DEVELOPER_MODE=ON ..\n cmake --build .\n ctest\n ```\n@@ -269,7 +281,7 @@ Furthermore, if you have installed LLVM clang on Windows, for example as a compo\n \n - `mkdir build`\n - `cd build`\n-- `cmake ..  -T ClangCL`\n+- `cmake -T ClangCL ..`\n - `cmake --build . -config Release`\n \n \n--- vendor/simdjson/README.md\n@@ -1,9 +1,9 @@\n-[![Fuzzing Status](https://oss-fuzz-build-logs.storage.googleapis.com/badges/simdjson.svg)](https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&q=proj%3Asimdjson&can=2)\n+\n ![Ubuntu 18.04 CI](https://github.com/simdjson/simdjson/workflows/Ubuntu%2018.04%20CI%20(GCC%207)/badge.svg)\n [![Ubuntu 20.04 CI](https://github.com/simdjson/simdjson/workflows/Ubuntu%2020.04%20CI%20(GCC%209)/badge.svg)](https://simdjson.org/plots.html)\n ![VS16-CI](https://github.com/simdjson/simdjson/workflows/VS16-CI/badge.svg)\n ![MinGW64-CI](https://github.com/simdjson/simdjson/workflows/MinGW64-CI/badge.svg)\n-[![][license img]][license]  [![Doxygen Documentation](https://img.shields.io/badge/docs-doxygen-green.svg)](https://simdjson.org/api/0.9.0/index.html)\n+[![][license img]][license]  [![Doxygen Documentation](https://img.shields.io/badge/docs-doxygen-green.svg)](https://simdjson.org/api/1.0.0/index.html)\n \n simdjson : Parsing gigabytes of JSON per second\n ===============================================\n@@ -27,7 +27,6 @@ Table of Contents\n -----------------\n \n * [Quick Start](#quick-start)\n-  * [On Demand](#on-demand)\n * [Documentation](#documentation)\n * [Performance results](#performance-results)\n * [Real-world usage](#real-world-usage)\n@@ -54,6 +53,7 @@ The simdjson library is easily consumable with a single .h and .cpp file.\n 2. Create `quickstart.cpp`:\n \n ```c++\n+#include <iostream>\n #include \"simdjson.h\"\n using namespace simdjson;\n int main(void) {\n@@ -79,7 +79,7 @@ Usage documentation is available:\n * [Performance](doc/performance.md) shows some more advanced scenarios and how to tune for them.\n * [Implementation Selection](doc/implementation-selection.md) describes runtime CPU detection and\n   how you can work with it.\n-* [API](https://simdjson.org/api/0.9.0/annotated.html) contains the automatically generated API documentation.\n+* [API](https://simdjson.org/api/1.0.0/annotated.html) contains the automatically generated API documentation.\n \n Performance results\n -------------------\n@@ -137,6 +137,7 @@ We distinguish between \"bindings\" (which just wrap the C++ code) and a port to a\n - [simdjson-go](https://github.com/minio/simdjson-go): Go port using Golang assembly.\n - [rcppsimdjson](https://github.com/eddelbuettel/rcppsimdjson): R bindings.\n - [simdjson_erlang](https://github.com/ChomperT/simdjson_erlang): erlang bindings.\n+- [lua-simdjson](https://github.com/FourierTransformer/lua-simdjson): lua bindings.\n \n \n About simdjson\n@@ -152,13 +153,13 @@ and implementation of simdjson is in our research article:\n \n We have an in-depth paper focused on the UTF-8 validation:\n \n-- John Keiser, Daniel Lemire, [Validating UTF-8 In Less Than One Instruction Per Byte](https://arxiv.org/abs/2010.03090), Software: Practice & Experience (to appear)\n+- John Keiser, Daniel Lemire, [Validating UTF-8 In Less Than One Instruction Per Byte](https://arxiv.org/abs/2010.03090), Software: Practice & Experience 51 (5), 2021.\n \n We also have an informal [blog post providing some background and context](https://branchfree.org/2019/02/25/paper-parsing-gigabytes-of-json-per-second/).\n \n For the video inclined, <br />\n [![simdjson at QCon San Francisco 2019](http://img.youtube.com/vi/wlvKAT7SZIQ/0.jpg)](http://www.youtube.com/watch?v=wlvKAT7SZIQ)<br />\n-(it was the best voted talk, we're kinda proud of it).\n+(It was the best voted talk, we're kinda proud of it.)\n \n Funding\n -------\n@@ -182,4 +183,8 @@ This code is made available under the [Apache License 2.0](https://www.apache.or\n \n Under Windows, we build some tools using the windows/dirent_portable.h file (which is outside our library code): it under the liberal (business-friendly) MIT license.\n \n-For compilers that do not support [C++17](https://en.wikipedia.org/wiki/C%2B%2B17), we bundle the string-view library which is published under the Boost license (http://www.boost.org/LICENSE_1_0.txt). Like the Apache license, the Boost license is a permissive license allowing commercial redistribution.\n+For compilers that do not support [C++17](https://en.wikipedia.org/wiki/C%2B%2B17), we bundle the string-view library which is published under the [Boost license](http://www.boost.org/LICENSE_1_0.txt). Like the Apache license, the Boost license is a permissive license allowing commercial redistribution.\n+\n+For efficient number serialization, we bundle Florian Loitsch's implementation of the Grisu2 algorithm for binary to decimal floating-point numbers. The implementation was slightly modified by JSON for Modern C++ library. Both Florian Loitsch's implementation and JSON for Modern C++ are provided under the MIT license.\n+\n+For runtime dispatching, we use some code from the PyTorch project licensed under 3-clause BSD.\n--- vendor/simdjson/cmake/developer-options.cmake\n@@ -0,0 +1,180 @@\n+#\n+# Flags used by exes and by the simdjson library (project-wide flags)\n+#\n+add_library(simdjson-internal-flags INTERFACE)\n+\n+\n+option(SIMDJSON_CHECK_EOF \"Check for the end of the input buffer. The setting is unnecessary since we require padding of the inputs. You should expect tests to fail with this option turned on.\" OFF)\n+if(SIMDJSON_CHECK_EOF)\n+  add_compile_definitions(SIMDJSON_CHECK_EOF=1)\n+endif()\n+\n+option(SIMDJSON_SANITIZE_UNDEFINED \"Sanitize undefined behavior\" OFF)\n+if(SIMDJSON_SANITIZE_UNDEFINED)\n+  add_compile_options(-fsanitize=undefined -fno-sanitize-recover=all)\n+  add_link_options(-fsanitize=undefined -fno-sanitize-recover=all)\n+endif()\n+\n+option(SIMDJSON_SANITIZE \"Sanitize addresses\" OFF)\n+if(SIMDJSON_SANITIZE)\n+  if(CMAKE_CXX_COMPILER_ID STREQUAL \"AppleClang\")\n+    message(STATUS \"The address sanitizer under Apple's clang appears to be \\\n+incompatible with the undefined-behavior sanitizer.\")\n+    message(STATUS \"You may set SIMDJSON_SANITIZE_UNDEFINED to sanitize \\\n+undefined behavior.\")\n+    add_compile_options(\n+        -fsanitize=address -fno-omit-frame-pointer -fno-sanitize-recover=all\n+    )\n+    add_compile_definitions(ASAN_OPTIONS=detect_leaks=1)\n+    link_libraries(\n+        -fsanitize=address -fno-omit-frame-pointer -fno-sanitize-recover=all\n+    )\n+  else()\n+    message(\n+        STATUS\n+        \"Setting both the address sanitizer and the undefined sanitizer.\"\n+    )\n+    add_compile_options(\n+        -fsanitize=address -fno-omit-frame-pointer\n+        -fsanitize=undefined -fno-sanitize-recover=all\n+    )\n+    link_libraries(\n+        -fsanitize=address -fno-omit-frame-pointer\n+        -fsanitize=undefined -fno-sanitize-recover=all\n+    )\n+  endif()\n+\n+  # Ubuntu bug for GCC 5.0+ (safe for all versions)\n+  if(CMAKE_COMPILER_IS_GNUCC)\n+    link_libraries(-fuse-ld=gold)\n+  endif()\n+endif()\n+\n+if(SIMDJSON_SANITIZE_THREADS)\n+  message(STATUS \"Setting both the thread sanitizer \\\n+and the undefined-behavior sanitizer.\")\n+  add_compile_options(\n+      -fsanitize=thread -fsanitize=undefined -fno-sanitize-recover=all\n+  )\n+  link_libraries(\n+      -fsanitize=thread -fsanitize=undefined -fno-sanitize-recover=all\n+  )\n+\n+  # Ubuntu bug for GCC 5.0+ (safe for all versions)\n+  if(CMAKE_COMPILER_IS_GNUCC)\n+    link_libraries(-fuse-ld=gold)\n+  endif()\n+endif()\n+\n+get_cmake_property(is_multi_config GENERATOR_IS_MULTI_CONFIG)\n+if(NOT is_multi_config AND NOT CMAKE_BUILD_TYPE)\n+  # Deliberately not including SIMDJSON_SANITIZE_THREADS since thread behavior\n+  # depends on the build type.\n+  if(SIMDJSON_SANITIZE OR SIMDJSON_SANITIZE_UNDEFINED)\n+    message(STATUS \"No build type selected and you have enabled the sanitizer, \\\n+default to Debug. Consider setting CMAKE_BUILD_TYPE.\")\n+    set(CMAKE_BUILD_TYPE Debug CACHE STRING \"Choose the type of build.\" FORCE)\n+  else()\n+    message(STATUS \"No build type selected, default to Release\")\n+    set(CMAKE_BUILD_TYPE Release CACHE STRING \"Choose the type of build.\" FORCE)\n+  endif()\n+endif()\n+\n+if(NOT MSVC)\n+  option(SIMDJSON_USE_LIBCPP \"Use the libc++ library\" OFF)\n+endif()\n+\n+if(MSVC AND BUILD_SHARED_LIBS)\n+  # This will require special handling.\n+  set(SIMDJSON_WINDOWS_DLL TRUE)\n+endif()\n+\n+# We compile tools, tests, etc. with C++ 17. Override yourself if you need on a\n+# target.\n+set(CMAKE_CXX_STANDARD 17)\n+set(CMAKE_CXX_STANDARD_REQUIRED ON)\n+set(CMAKE_CXX_EXTENSIONS OFF)\n+set(CMAKE_MACOSX_RPATH OFF)\n+set(CMAKE_THREAD_PREFER_PTHREAD ON)\n+set(THREADS_PREFER_PTHREAD_FLAG ON)\n+\n+# LTO seems to create all sorts of fun problems. Let us\n+# disable temporarily.\n+#include(CheckIPOSupported)\n+#check_ipo_supported(RESULT ltoresult)\n+#if(ltoresult)\n+#  set(CMAKE_INTERPROCEDURAL_OPTIMIZATION TRUE)\n+#endif()\n+\n+option(SIMDJSON_VISUAL_STUDIO_BUILD_WITH_DEBUG_INFO_FOR_PROFILING \"\\\n+Under Visual Studio, add Zi to the compile flag and DEBUG to the link file to \\\n+add debugging information to the release build for easier profiling inside \\\n+tools like VTune\" OFF)\n+if(MSVC)\n+  if(MSVC_TOOLSET_VERSION STRLESS \"142\")\n+    set(SIMDJSON_LEGACY_VISUAL_STUDIO TRUE)\n+    message (STATUS \"A legacy Visual Studio version was detected. \\\n+We recommend Visual Studio 2019 or better on a 64-bit system.\")\n+  endif()\n+  if(MSVC_TOOLSET_VERSION STREQUAL \"140\")\n+    # Visual Studio 2015 issues warnings and we tolerate it\n+    # cmake -G \"Visual Studio 14\" ..\n+    target_compile_options(simdjson-internal-flags INTERFACE /W0 /sdl)\n+  else()\n+    # Recent version of Visual Studio expected (2017, 2019...). Prior versions\n+    # are unsupported.\n+    # https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warning-level-4-c4714?view=vs-2019\n+    target_compile_options(simdjson-internal-flags INTERFACE /WX /W3 /sdl /w34714)\n+    if(MSVC_VERSION GREATER 1910)\n+      target_compile_options(simdjson-internal-flags INTERFACE /permissive-)\n+    endif()\n+  endif()\n+  if(SIMDJSON_VISUAL_STUDIO_BUILD_WITH_DEBUG_INFO_FOR_PROFILING)\n+    add_link_options(/DEBUG)\n+    add_compile_options(/Zi)\n+  endif()\n+else()\n+  if(NOT WIN32)\n+    target_compile_options(simdjson-internal-flags INTERFACE -fPIC)\n+  endif()\n+  target_compile_options(\n+      simdjson-internal-flags INTERFACE\n+      -Werror -Wall -Wextra -Weffc++ -Wsign-compare -Wshadow -Wwrite-strings\n+      -Wpointer-arith -Winit-self -Wconversion -Wno-sign-conversion\n+  )\n+endif()\n+\n+#\n+# Other optional flags\n+#\n+option(SIMDJSON_BASH \"Allow usage of bash within CMake\" ON)\n+\n+option(\n+    SIMDJSON_VERBOSE_LOGGING\n+    \"Enable verbose logging for internal simdjson library development.\"\n+    OFF\n+)\n+if(SIMDJSON_VERBOSE_LOGGING)\n+  add_compile_definitions(SIMDJSON_VERBOSE_LOGGING=1\n+  )\n+endif()\n+\n+if(SIMDJSON_USE_LIBCPP)\n+  link_libraries(-stdlib=libc++ -lc++abi)\n+  # instead of the above line, we could have used\n+  # set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -stdlib=libc++\n+  # -lc++abi\")\n+  # The next line is needed empirically.\n+  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -stdlib=libc++\")\n+  # we update CMAKE_SHARED_LINKER_FLAGS, this gets updated later as well\n+  set(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -lc++abi\")\n+endif()\n+\n+# prevent shared libraries from depending on Intel provided libraries\n+if(CMAKE_C_COMPILER_ID MATCHES \"Intel\")\n+  set(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -static-intel\")\n+endif()\n+\n+include(CheckSymbolExists)\n+check_symbol_exists(fork unistd.h HAVE_POSIX_FORK)\n+check_symbol_exists(wait sys/wait.h HAVE_POSIX_WAIT)\n--- vendor/simdjson/cmake/exception-flags.cmake\n@@ -0,0 +1,28 @@\n+option(SIMDJSON_EXCEPTIONS \"Enable simdjson's exception-throwing interface\" ON)\n+if(NOT SIMDJSON_EXCEPTIONS)\n+  message(STATUS \"simdjson exception interface turned off. \\\n+Code that does not check error codes will not compile.\")\n+  simdjson_add_props(target_compile_definitions PUBLIC SIMDJSON_EXCEPTIONS=0)\n+  if(MSVC)\n+    if(NOT is_top_project)\n+      message(AUTHOR_WARNING \"Turning SIMDJSON_EXCEPTIONS off requires \\\n+editing CMAKE_CXX_FLAGS\")\n+    endif()\n+\n+    # CMake currently /EHsc as a default flag in CMAKE_CXX_FLAGS on MSVC.\n+    # Replacing this with a more general abstraction is a WIP\n+    # (see https://gitlab.kitware.com/cmake/cmake/-/issues/20610)\n+    # /EHs enables standard C++ stack unwinding when catching exceptions\n+    # (non-structured exception handling)\n+    # /EHc used in conjection with /EHs indicates that extern \"C\" functions\n+    # never throw (terminate-on-throw)\n+    # Here, we disable both with the - argument negation operator\n+    string(REPLACE \"/EHsc\" \"/EHs-c-\" CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS})\n+\n+    # Because we cannot change the flag above on an individual target (yet), the\n+    # definition below must similarly be added globally\n+    add_definitions(-D_HAS_EXCEPTIONS=0)\n+  elseif(CMAKE_COMPILER_IS_GNUCC)\n+    simdjson_add_props(target_link_libraries PRIVATE -fno-exceptions)\n+  endif()\n+endif()\n--- vendor/simdjson/cmake/handle-deprecations.cmake\n@@ -0,0 +1,23 @@\n+if(DEFINED SIMDJSON_BUILD_STATIC)\n+  message(DEPRECATION \"SIMDJSON_BUILD_STATIC is deprecated, setting \\\n+BUILD_SHARED_LIBS with its value and unsetting it\")\n+  set(shared ON)\n+  if(SIMDJSON_BUILD_STATIC)\n+    set(shared OFF)\n+  endif()\n+\n+  set(BUILD_SHARED_LIBS \"${shared}\" CACHE BOOL \"\" FORCE)\n+  unset(SIMDJSON_BUILD_STATIC CACHE)\n+endif()\n+\n+if(DEFINED SIMDJSON_JUST_LIBRARY)\n+  message(DEPRECATION \"SIMDJSON_JUST_LIBRARY is deprecated, setting \\\n+SIMDJSON_DEVELOPER_MODE with its value and unsetting it\")\n+  set(dev_mode ON)\n+  if(SIMDJSON_JUST_LIBRARY)\n+    set(dev_mode OFF)\n+  endif()\n+\n+  set(SIMDJSON_DEVELOPER_MODE \"${dev_mode}\" CACHE BOOL \"\" FORCE)\n+  unset(SIMDJSON_JUST_LIBRARY CACHE)\n+endif()\n--- vendor/simdjson/cmake/implementation-flags.cmake\n@@ -0,0 +1,106 @@\n+#\n+# Implementation selection\n+#\n+set(SIMDJSON_ALL_IMPLEMENTATIONS fallback westmere haswell arm64 ppc64)\n+\n+set(\n+    SIMDJSON_IMPLEMENTATION \"\"\n+    CACHE STRING \"\\\n+Semicolon-separated list of implementations to include \\\n+(${SIMDJSON_ALL_IMPLEMENTATIONS}). If this is not set, any implementations \\\n+that are supported at compile time and may be selected at runtime will be \\\n+included.\"\n+)\n+set(\n+    SIMDJSON_EXCLUDE_IMPLEMENTATION \"\"\n+    CACHE STRING \"\\\n+Semicolon-separated list of implementations to exclude \\\n+(haswell/westmere/arm64/ppc64/fallback). By default, excludes any \\\n+implementations that are unsupported at compile time or cannot be selected at \\\n+runtime.\"\n+)\n+\n+foreach(var IN ITEMS IMPLEMENTATION EXCLUDE_IMPLEMENTATION)\n+  set(var \"SIMDJSON_${var}\")\n+  foreach(impl IN LISTS \"${var}\")\n+    if(NOT impl IN_LIST SIMDJSON_ALL_IMPLEMENTATIONS)\n+      message(ERROR \"\\\n+Implementation ${impl} found in ${var} not supported by simdjson. \\\n+Possible implementations: ${SIMDJSON_ALL_IMPLEMENTATIONS}\")\n+    endif()\n+  endforeach()\n+endforeach()\n+\n+macro(flag_action action var val)\n+  message(STATUS \"${action} implementation ${impl} due to ${var}=${${var}}\")\n+  simdjson_add_props(\n+      target_compile_definitions PUBLIC\n+      \"SIMDJSON_IMPLEMENTATION_${impl_upper}=${val}\"\n+  )\n+endmacro()\n+\n+foreach(impl IN LISTS SIMDJSON_ALL_IMPLEMENTATIONS)\n+  string(TOUPPER \"${impl}\" impl_upper)\n+  if(impl IN_LIST SIMDJSON_EXCLUDE_IMPLEMENTATION)\n+    flag_action(Excluding SIMDJSON_EXCLUDE_IMPLEMENTATION 0)\n+  elseif(impl IN_LIST SIMDJSON_IMPLEMENTATION)\n+    flag_action(Including SIMDJSON_IMPLEMENTATION 1)\n+  elseif(SIMDJSON_IMPLEMENTATION)\n+    flag_action(Excluding SIMDJSON_IMPLEMENTATION 0)\n+  endif()\n+endforeach()\n+\n+# TODO make it so this generates the necessary compiler flags to select the\n+# given impl as the builtin automatically!\n+set(\n+    SIMDJSON_BUILTIN_IMPLEMENTATION \"\"\n+    CACHE STRING \"\\\n+Select the implementation that will be used for user code. Defaults to the \\\n+most universal implementation in SIMDJSON_IMPLEMENTATION (in the order \\\n+${SIMDJSON_ALL_IMPLEMENTATIONS}) if specified; otherwise, by default the \\\n+compiler will pick the best implementation that can always be selected given \\\n+the compiler flags.\"\n+)\n+if(NOT SIMDJSON_BUILTIN_IMPLEMENTATION STREQUAL \"\")\n+  simdjson_add_props(\n+      target_compile_definitions PUBLIC\n+      \"SIMDJSON_BUILTIN_IMPLEMENTATION=${SIMDJSON_BUILTIN_IMPLEMENTATION}\"\n+  )\n+else()\n+  # Pick the most universal implementation out of the selected implementations\n+  # (if any)\n+  foreach(impl IN LISTS SIMDJSON_ALL_IMPLEMENTATIONS)\n+    if(\n+        impl IN_LIST SIMDJSON_IMPLEMENTATION\n+        AND NOT impl IN_LIST SIMDJSON_EXCLUDE_IMPLEMENTATION\n+    )\n+      message(STATUS \"\\\n+Selected implementation ${impl} as builtin implementation based on \\\n+${SIMDJSON_IMPLEMENTATION}\")\n+      simdjson_add_props(\n+          target_compile_definitions PUBLIC\n+          \"SIMDJSON_BUILTIN_IMPLEMENTATION=${impl}\"\n+      )\n+      break()\n+    endif()\n+  endforeach()\n+endif()\n+\n+foreach(impl IN LISTS SIMDJSON_ALL_IMPLEMENTATIONS)\n+  string(TOUPPER \"${impl}\" impl_upper)\n+  option(\n+      \"SIMDJSON_IMPLEMENTATION_${impl_upper}\"\n+      \"Include the ${impl} implementation\"\n+      ON\n+  )\n+  mark_as_advanced(\"SIMDJSON_IMPLEMENTATION_${impl_upper}\")\n+  if(NOT \"${SIMDJSON_IMPLEMENTATION_${impl_upper}}\")\n+    message(DEPRECATION \"\\\n+SIMDJSON_IMPLEMENTATION_${impl_upper} is deprecated. \\\n+Use SIMDJSON_IMPLEMENTATION=-${impl} instead\")\n+     simdjson_add_props(\n+        target_compile_definitions PUBLIC\n+        \"SIMDJSON_IMPLEMENTATION_${impl_upper}=0\"\n+    )\n+  endif()\n+endforeach()\n--- vendor/simdjson/cmake/simdjson-config.cmake.in\n@@ -1,9 +1,6 @@\n-@PACKAGE_INIT@\n-\n include(CMakeFindDependencyMacro)\n-if(@SIMDJSON_ENABLE_THREADS@)\n-    set(CMAKE_THREAD_PREFER_PTHREAD TRUE)\n-    find_dependency(Threads)\n+if(\"@SIMDJSON_ENABLE_THREADS@\")\n+  find_dependency(Threads)\n endif()\n-# Import targets.\n-include(\"${CMAKE_CURRENT_LIST_DIR}/@PROJECT_NAME@-targets.cmake\")\n+\n+include(\"${CMAKE_CURRENT_LIST_DIR}/simdjsonTargets.cmake\")\n--- vendor/simdjson/cmake/simdjson-flags.cmake\n@@ -1,275 +0,0 @@\n-\n-if(CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR)\n-  message (STATUS \"The simdjson repository appears to be standalone.\")\n-  option(SIMDJSON_JUST_LIBRARY \"Build just the library, omit tests, tools and benchmarks\" OFF)\n-  message (STATUS \"By default, we attempt to build everything.\")\n-else()\n-  message (STATUS \"The simdjson repository appears to be used as a subdirectory.\")\n-  option(SIMDJSON_JUST_LIBRARY \"Build just the library, omit tests, tools and benchmarks\" ON)\n-  message (STATUS \"By default, we just build the library.\")\n-endif()\n-\n-#\n-# Flags used by exes and by the simdjson library (project-wide flags)\n-#\n-add_library(simdjson-flags INTERFACE)\n-add_library(simdjson-internal-flags INTERFACE)\n-target_link_libraries(simdjson-internal-flags INTERFACE simdjson-flags)\n-\n-option(SIMDJSON_SANITIZE_UNDEFINED \"Sanitize undefined behavior\" OFF)\n-if(SIMDJSON_SANITIZE_UNDEFINED)\n-  target_compile_options(simdjson-flags INTERFACE -fsanitize=undefined -fno-sanitize-recover=all)\n-  target_link_libraries(simdjson-flags INTERFACE -fsanitize=undefined -fno-sanitize-recover=all)\n-endif()\n-\n-option(SIMDJSON_SANITIZE \"Sanitize addresses\" OFF)\n-if(SIMDJSON_SANITIZE)\n-  if(CMAKE_CXX_COMPILER_ID STREQUAL \"AppleClang\")\n-    message(STATUS \"The address sanitizer under Apple's clang appears to be incompatible with the undefined-behavior sanitizer.\")\n-    message(STATUS \"You may set SIMDJSON_SANITIZE_UNDEFINED to sanitize undefined behavior.\")\n-    target_compile_options(simdjson-flags INTERFACE -fsanitize=address  -fno-omit-frame-pointer -fno-sanitize-recover=all)\n-    target_compile_definitions(simdjson-flags INTERFACE ASAN_OPTIONS=detect_leaks=1)\n-    target_link_libraries(simdjson-flags INTERFACE -fsanitize=address  -fno-omit-frame-pointer -fno-sanitize-recover=all)\n-  else()\n-    message(STATUS \"Setting both the address sanitizer and the undefined sanitizer.\")\n-    target_compile_options(simdjson-flags INTERFACE -fsanitize=address -fno-omit-frame-pointer -fsanitize=undefined -fno-sanitize-recover=all)\n-    target_link_libraries(simdjson-flags INTERFACE -fsanitize=address -fno-omit-frame-pointer -fsanitize=undefined -fno-sanitize-recover=all)\n-  endif()\n-  # Ubuntu bug for GCC 5.0+ (safe for all versions)\n-  if (CMAKE_COMPILER_IS_GNUCC)\n-    target_link_libraries(simdjson-flags INTERFACE -fuse-ld=gold)\n-  endif()\n-endif()\n-\n-\n-if(SIMDJSON_SANITIZE_THREADS)\n-  message(STATUS \"Setting both the thread sanitizer and the undefined-behavior sanitizer.\")\n-  target_compile_options(simdjson-flags INTERFACE -fsanitize=thread -fsanitize=undefined -fno-sanitize-recover=all)\n-  target_link_libraries(simdjson-flags INTERFACE -fsanitize=thread -fsanitize=undefined -fno-sanitize-recover=all)\n-\n-  # Ubuntu bug for GCC 5.0+ (safe for all versions)\n-  if (CMAKE_COMPILER_IS_GNUCC)\n-    target_link_libraries(simdjson-flags INTERFACE -fuse-ld=gold)\n-  endif()\n-endif()\n-\n-if (NOT CMAKE_BUILD_TYPE)\n-  # Deliberately not including SIMDJSON_SANITIZE_THREADS since thread behavior depends on the build type.\n-  if(SIMDJSON_SANITIZE OR SIMDJSON_SANITIZE_UNDEFINED)\n-    message(STATUS \"No build type selected and you have enabled the sanitizer, default to Debug. Consider setting CMAKE_BUILD_TYPE.\")\n-    set(CMAKE_BUILD_TYPE Debug CACHE STRING \"Choose the type of build.\" FORCE)\n-  else()\n-    message(STATUS \"No build type selected, default to Release\")\n-    set(CMAKE_BUILD_TYPE Release CACHE STRING \"Choose the type of build.\" FORCE)\n-  endif()\n-endif()\n-\n-if(MSVC)\n-  option(SIMDJSON_BUILD_STATIC \"Build a static library\" ON) # turning it on disables the production of a dynamic library\n-else()\n-  option(SIMDJSON_BUILD_STATIC \"Build a static library\" OFF) # turning it on disables the production of a dynamic library\n-  option(SIMDJSON_USE_LIBCPP \"Use the libc++ library\" OFF)\n-endif()\n-\n-if(MSVC AND NOT(SIMDJSON_BUILD_STATIC))\n-  # This will require special handling.\n-  set(SIMDJSON_WINDOWS_DLL TRUE)\n-endif()\n-\n-set(CMAKE_MODULE_PATH \"${CMAKE_CURRENT_SOURCE_DIR}/tools/cmake\")\n-\n-# We compile tools, tests, etc. with C++ 17. Override yourself if you need on a target.\n-set(CMAKE_CXX_STANDARD 17)\n-set(CMAKE_CXX_STANDARD_REQUIRED ON)\n-set(CMAKE_CXX_EXTENSIONS OFF)\n-set(CMAKE_MACOSX_RPATH OFF)\n-set(CMAKE_THREAD_PREFER_PTHREAD ON)\n-set(THREADS_PREFER_PTHREAD_FLAG ON)\n-\n-# LTO seems to create all sorts of fun problems. Let us\n-# disable temporarily.\n-#include(CheckIPOSupported)\n-#check_ipo_supported(RESULT ltoresult)\n-#if(ltoresult)\n-#  set(CMAKE_INTERPROCEDURAL_OPTIMIZATION TRUE)\n-#endif()\n-\n-option(SIMDJSON_VISUAL_STUDIO_BUILD_WITH_DEBUG_INFO_FOR_PROFILING \"Under Visual Studio, add Zi to the compile flag and DEBUG to the link file to add debugging information to the release build for easier profiling inside tools like VTune\" OFF)\n-if(MSVC)\n-  if(\"${MSVC_TOOLSET_VERSION}\" STRLESS \"142\")\n-    set(SIMDJSON_LEGACY_VISUAL_STUDIO TRUE)\n-    message (STATUS \"A legacy Visual Studio version was detected. We recommend Visual Studio 2019 or better on a 64-bit system.\")\n-  endif()\n-  if(\"${MSVC_TOOLSET_VERSION}\" STREQUAL \"140\")\n-    # Visual Studio 2015 issues warnings and we tolerate it,  cmake -G\"Visual Studio 14\" ..\n-    target_compile_options(simdjson-internal-flags INTERFACE /W0 /sdl)\n-  else()\n-    # Recent version of Visual Studio expected (2017, 2019...). Prior versions are unsupported.\n-    target_compile_options(simdjson-internal-flags INTERFACE /WX /W3 /sdl /w34714) # https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warning-level-4-c4714?view=vs-2019\n-  endif()\n-  if(SIMDJSON_VISUAL_STUDIO_BUILD_WITH_DEBUG_INFO_FOR_PROFILING)\n-    target_link_options(simdjson-flags  INTERFACE    /DEBUG )\n-    target_compile_options(simdjson-flags INTERFACE  /Zi)\n-  endif(SIMDJSON_VISUAL_STUDIO_BUILD_WITH_DEBUG_INFO_FOR_PROFILING)\n-else(MSVC)\n-  if(NOT WIN32)\n-    target_compile_options(simdjson-internal-flags INTERFACE -fPIC)\n-  endif()\n-  target_compile_options(simdjson-internal-flags INTERFACE -Werror -Wall -Wextra -Weffc++)\n-  target_compile_options(simdjson-internal-flags INTERFACE -Wsign-compare -Wshadow -Wwrite-strings -Wpointer-arith -Winit-self -Wconversion -Wno-sign-conversion)\n-endif(MSVC)\n-\n-\n-# workaround for GNU GCC poor AVX load/store code generation\n-if ((CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\") AND (CMAKE_SYSTEM_PROCESSOR MATCHES \"^(i.86|x86(_64)?)$\"))\n-  target_compile_options(simdjson-flags INTERFACE -mno-avx256-split-unaligned-load -mno-avx256-split-unaligned-store)\n-endif()\n-\n-#\n-# Optional flags\n-#\n-\n-#\n-# Implementation selection\n-#\n-set(SIMDJSON_ALL_IMPLEMENTATIONS \"fallback;westmere;haswell;arm64;ppc64\")\n-\n-set(SIMDJSON_IMPLEMENTATION \"\" CACHE STRING \"Semicolon-separated list of implementations to include (${SIMDJSON_ALL_IMPLEMENTATIONS}). If this is not set, any implementations that are supported at compile time and may be selected at runtime will be included.\")\n-foreach(implementation ${SIMDJSON_IMPLEMENTATION})\n-  if(NOT (implementation IN_LIST SIMDJSON_ALL_IMPLEMENTATIONS))\n-    message(ERROR \"Implementation ${implementation} not supported by simdjson. Possible implementations: ${SIMDJSON_ALL_IMPLEMENTATIONS}\")\n-  endif()\n-endforeach(implementation)\n-\n-set(SIMDJSON_EXCLUDE_IMPLEMENTATION \"\" CACHE STRING \"Semicolon-separated list of implementations to exclude (haswell/westmere/arm64/ppc64/fallback). By default, excludes any implementations that are unsupported at compile time or cannot be selected at runtime.\")\n-foreach(implementation ${SIMDJSON_EXCLUDE_IMPLEMENTATION})\n-  if(NOT (implementation IN_LIST SIMDJSON_ALL_IMPLEMENTATIONS))\n-    message(ERROR \"Implementation ${implementation} not supported by simdjson. Possible implementations: ${SIMDJSON_ALL_IMPLEMENTATIONS}\")\n-  endif()\n-endforeach(implementation)\n-\n-foreach(implementation ${SIMDJSON_ALL_IMPLEMENTATIONS})\n-  string(TOUPPER ${implementation} implementation_upper)\n-  if(implementation IN_LIST SIMDJSON_EXCLUDE_IMPLEMENTATION)\n-    message(STATUS \"Excluding implementation ${implementation} due to SIMDJSON_EXCLUDE_IMPLEMENTATION=${SIMDJSON_EXCLUDE_IMPLEMENTATION}\")\n-    target_compile_definitions(simdjson-flags INTERFACE \"SIMDJSON_IMPLEMENTATION_${implementation_upper}=0\")\n-  elseif(implementation IN_LIST SIMDJSON_IMPLEMENTATION)\n-    message(STATUS \"Including implementation ${implementation} due to SIMDJSON_IMPLEMENTATION=${SIMDJSON_IMPLEMENTATION}\")\n-    target_compile_definitions(simdjson-flags INTERFACE \"SIMDJSON_IMPLEMENTATION_${implementation_upper}=1\")\n-  elseif(SIMDJSON_IMPLEMENTATION)\n-    message(STATUS \"Excluding implementation ${implementation} due to SIMDJSON_IMPLEMENTATION=${SIMDJSON_IMPLEMENTATION}\")\n-    target_compile_definitions(simdjson-flags INTERFACE \"SIMDJSON_IMPLEMENTATION_${implementation_upper}=0\")\n-  endif()\n-endforeach(implementation)\n-\n-# TODO make it so this generates the necessary compiler flags to select the given implementation as the builtin automatically!\n-option(SIMDJSON_BUILTIN_IMPLEMENTATION \"Select the implementation that will be used for user code. Defaults to the most universal implementation in SIMDJSON_IMPLEMENTATION (in the order ${SIMDJSON_ALL_IMPLEMENTATIONS}) if specified; otherwise, by default the compiler will pick the best implementation that can always be selected given the compiler flags.\" \"\")\n-if(SIMDJSON_BUILTIN_IMPLEMENTATION)\n-  target_compile_definitions(simdjson-flags INTERFACE \"SIMDJSON_BUILTIN_IMPLEMENTATION=${SIMDJSON_BUILTIN_IMPLEMENTATION}\")\n-else()\n-  # Pick the most universal implementation out of the selected implementations (if any)\n-  foreach(implementation ${SIMDJSON_ALL_IMPLEMENTATIONS})\n-    if(implementation IN_LIST SIMDJSON_IMPLEMENTATION AND NOT (implementation IN_LIST SIMDJSON_EXCLUDE_IMPLEMENTATION))\n-      message(STATUS \"Selected implementation ${implementation} as builtin implementation based on ${SIMDJSON_IMPLEMENTATION}.\")\n-      target_compile_definitions(simdjson-flags INTERFACE \"SIMDJSON_BUILTIN_IMPLEMENTATION=${implementation}\")\n-      break()\n-    endif()\n-  endforeach(implementation)\n-endif(SIMDJSON_BUILTIN_IMPLEMENTATION)\n-\n-option(SIMDJSON_IMPLEMENTATION_HASWELL \"Include the haswell implementation\" ON)\n-if(NOT SIMDJSON_IMPLEMENTATION_HASWELL)\n-  message(DEPRECATION \"SIMDJSON_IMPLEMENTATION_HASWELL is deprecated. Use SIMDJSON_IMPLEMENTATION=-haswell instead.\")\n-  target_compile_definitions(simdjson-flags INTERFACE SIMDJSON_IMPLEMENTATION_HASWELL=0)\n-endif()\n-option(SIMDJSON_IMPLEMENTATION_WESTMERE \"Include the westmere implementation\" ON)\n-if(NOT SIMDJSON_IMPLEMENTATION_WESTMERE)\n-  message(DEPRECATION \"SIMDJSON_IMPLEMENTATION_WESTMERE is deprecated. SIMDJSON_IMPLEMENTATION=-westmere instead.\")\n-  target_compile_definitions(simdjson-flags INTERFACE SIMDJSON_IMPLEMENTATION_WESTMERE=0)\n-endif()\n-option(SIMDJSON_IMPLEMENTATION_ARM64 \"Include the arm64 implementation\" ON)\n-if(NOT SIMDJSON_IMPLEMENTATION_ARM64)\n-  message(DEPRECATION \"SIMDJSON_IMPLEMENTATION_ARM64 is deprecated. Use SIMDJSON_IMPLEMENTATION=-arm64 instead.\")\n-  target_compile_definitions(simdjson-flags INTERFACE SIMDJSON_IMPLEMENTATION_ARM64=0)\n-endif()\n-option(SIMDJSON_IMPLEMENTATION_PPC64 \"Include the arm64 implementation\" ON)\n-if(NOT SIMDJSON_IMPLEMENTATION_PPC64)\n-  message(DEPRECATION \"SIMDJSON_IMPLEMENTATION_PPC64 is deprecated. Use SIMDJSON_IMPLEMENTATION=-ppc64 instead.\")\n-  target_compile_definitions(simdjson-flags INTERFACE SIMDJSON_IMPLEMENTATION_PPC64=0)\n-endif()\n-option(SIMDJSON_IMPLEMENTATION_FALLBACK \"Include the fallback implementation\" ON)\n-if(NOT SIMDJSON_IMPLEMENTATION_FALLBACK)\n-  message(DEPRECATION \"SIMDJSON_IMPLEMENTATION_FALLBACK is deprecated. Use SIMDJSON_IMPLEMENTATION=-fallback instead.\")\n-  target_compile_definitions(simdjson-flags INTERFACE SIMDJSON_IMPLEMENTATION_FALLBACK=0)\n-endif()\n-\n-#\n-# Other optional flags\n-#\n-option(SIMDJSON_DEVELOPMENT_CHECKS \"Enable development-time aids, such as checks for incorrect API usage. Enabled by default in DEBUG.\" OFF)\n-if(SIMDJSON_DEVELOPMENT_CHECKS)\n-  target_compile_definitions(simdjson-flags INTERFACE SIMDJSON_DEVELOPMENT_CHECKS)\n-endif()\n-\n-option(SIMDJSON_BASH \"Allow usage of bash within CMake\" ON)\n-\n-option(SIMDJSON_EXCEPTIONS \"Enable simdjson's exception-throwing interface\" ON)\n-if(NOT SIMDJSON_EXCEPTIONS)\n-  message(STATUS \"simdjson exception interface turned off. Code that does not check error codes will not compile.\")\n-  target_compile_definitions(simdjson-flags INTERFACE SIMDJSON_EXCEPTIONS=0)\n-  if(MSVC)\n-    # CMake currently /EHsc as a default flag in CMAKE_CXX_FLAGS on MSVC. Replacing this with a more general abstraction is a WIP (see https://gitlab.kitware.com/cmake/cmake/-/issues/20610)\n-    # /EHs enables standard C++ stack unwinding when catching exceptions (non-structured exception handling)\n-    # /EHc used in conjection with /EHs indicates that extern \"C\" functions never throw (terminate-on-throw)\n-    # Here, we disable both with the - argument negation operator\n-    string(REPLACE \"/EHsc\" \"/EHs-c-\" CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS})\n-\n-    # Because we cannot change the flag above on an invidual target (yet), the definition below must similarly be added globally\n-    add_definitions(-D_HAS_EXCEPTIONS=0)\n-  elseif (CMAKE_COMPILER_IS_GNUCC)\n-    target_link_libraries(simdjson-flags INTERFACE -fno-exceptions)\n-  endif()\n-endif()\n-\n-option(SIMDJSON_ENABLE_THREADS \"Link with thread support\" ON)\n-if(SIMDJSON_ENABLE_THREADS)\n-  set(CMAKE_THREAD_PREFER_PTHREAD TRUE)\n-  set(THREADS_PREFER_PTHREAD_FLAG TRUE)\n-  find_package(Threads REQUIRED)\n-  target_link_libraries(simdjson-flags INTERFACE Threads::Threads)\n-  target_compile_definitions(simdjson-flags INTERFACE SIMDJSON_THREADS_ENABLED=1) # This will be set in the code automatically.\n-endif()\n-\n-option(SIMDJSON_VERBOSE_LOGGING, \"Enable verbose logging for internal simdjson library development.\" OFF)\n-if (SIMDJSON_VERBOSE_LOGGING)\n-  target_compile_definitions(simdjson-flags INTERFACE SIMDJSON_VERBOSE_LOGGING=1)\n-endif()\n-\n-option(SIMDJSON_DISABLE_DEPRECATED_API \"Disables deprecated APIs\" Off)\n-if (SIMDJSON_DISABLE_DEPRECATED_API)\n-    target_compile_definitions(simdjson-flags INTERFACE SIMDJSON_DISABLE_DEPRECATED_API=1)\n-endif()\n-\n-if(SIMDJSON_USE_LIBCPP)\n-  target_link_libraries(simdjson-flags INTERFACE -stdlib=libc++ -lc++abi)\n-  # instead of the above line, we could have used\n-  # set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -stdlib=libc++  -lc++abi\")\n-  # The next line is needed empirically.\n-  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -stdlib=libc++\")\n-  # we update CMAKE_SHARED_LINKER_FLAGS, this gets updated later as well\n-  set(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -lc++abi\")\n-endif(SIMDJSON_USE_LIBCPP)\n-\n-# prevent shared libraries from depending on Intel provided libraries\n-if(${CMAKE_C_COMPILER_ID} MATCHES \"Intel\") # icc / icpc\n-  set(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -static-intel\")\n-endif()\n-\n-include (CheckSymbolExists)\n-CHECK_SYMBOL_EXISTS(fork unistd.h HAVE_POSIX_FORK)\n-CHECK_SYMBOL_EXISTS(wait sys/wait.h HAVE_POSIX_WAIT)\n-\n-install(TARGETS simdjson-flags EXPORT simdjson-config)\n-\n-# I do not think we want to export our internal flags!\n-# install(TARGETS simdjson-internal-flags EXPORT simdjson-config)\n--- vendor/simdjson/cmake/simdjson-props.cmake\n@@ -0,0 +1,48 @@\n+#\n+# Accumulate flags\n+#\n+set(simdjson_props_script \"${PROJECT_BINARY_DIR}/simdjson-props.cmake\")\n+set(simdjson_props_content \"\")\n+set(simdjson_props_flushed NO)\n+\n+function(simdjson_add_props command)\n+  set(args \"\")\n+  math(EXPR limit \"${ARGC} - 1\")\n+  foreach(i RANGE 1 \"${limit}\")\n+    set(value \"${ARGV${i}}\")\n+    if(value MATCHES \"^(PRIVATE|PUBLIC)$\")\n+      string(TOLOWER \"${value}\" value)\n+      set(value \"\\${${value}}\")\n+    else()\n+      set(value \"[==[${value}]==]\")\n+    endif()\n+    string(APPEND args \" ${value}\")\n+  endforeach()\n+\n+  set(simdjson_props_flushed NO PARENT_SCOPE)\n+  set(\n+      simdjson_props_content\n+      \"${simdjson_props_content}${command}(\\\"\\${target}\\\"${args})\\n\"\n+      PARENT_SCOPE\n+  )\n+endfunction()\n+\n+macro(simdjson_flush_props)\n+  if(NOT simdjson_props_flushed)\n+    set(simdjson_props_flushed YES PARENT_SCOPE)\n+    file(WRITE \"${simdjson_props_script}\" \"${simdjson_props_content}\")\n+  endif()\n+endmacro()\n+\n+function(simdjson_apply_props target)\n+  set(private PRIVATE)\n+  set(public PUBLIC)\n+  get_target_property(TYPE \"${target}\" TYPE)\n+  if(TYPE STREQUAL \"INTERFACE_LIBRARY\")\n+    set(private INTERFACE)\n+    set(public INTERFACE)\n+  endif()\n+\n+  simdjson_flush_props()\n+  include(\"${simdjson_props_script}\")\n+endfunction()\n--- vendor/simdjson/cmake/simdjson-user-cmakecache.cmake\n@@ -1,24 +1,19 @@\n #\n-# ${SIMDJSON_USER_CMAKECACHE} contains the *user-specified* simdjson options so you can call cmake on\n-# another branch or repository with the same options.\n+# ${USER_CMAKECACHE} contains the *user-specified* simdjson options so you can\n+# call cmake on another branch or repository with the same options.\n #\n-# Not supported on Windows at present, because the only thing that uses it is checkperf, which we\n-# don't run on Windows.\n-#\n-set(SIMDJSON_USER_CMAKECACHE ${CMAKE_CURRENT_BINARY_DIR}/.simdjson-user-CMakeCache.txt)\n-if (MSVC)\n-  add_custom_command(\n-    OUTPUT ${SIMDJSON_USER_CMAKECACHE}\n-    COMMAND findstr SIMDJSON_ ${PROJECT_BINARY_DIR}/CMakeCache.txt > ${SIMDJSON_USER_CMAKECACHE}.tmp\n-    COMMAND findstr /v SIMDJSON_LIB_ ${SIMDJSON_USER_CMAKECACHE}.tmp > ${SIMDJSON_USER_CMAKECACHE}\n-    VERBATIM # Makes it not do weird escaping with the command\n-  )\n-else()\n-  add_custom_command(\n-    OUTPUT ${SIMDJSON_USER_CMAKECACHE}\n-    COMMAND grep SIMDJSON_ ${PROJECT_BINARY_DIR}/CMakeCache.txt > ${SIMDJSON_USER_CMAKECACHE}.tmp\n-    COMMAND grep -v SIMDJSON_LIB_ ${SIMDJSON_USER_CMAKECACHE}.tmp > ${SIMDJSON_USER_CMAKECACHE}\n-    VERBATIM # Makes it not do weird escaping with the command\n-  )\n-endif()\n-add_custom_target(simdjson-user-cmakecache DEPENDS ${SIMDJSON_USER_CMAKECACHE})\n+\n+file(READ \"${BINARY_DIR}/CMakeCache.txt\" cache)\n+# Escape semicolons, so the lines can be safely iterated in CMake\n+string(REPLACE \";\" \"\\\\;\" cache \"${cache}\")\n+# Turn the contents into a list\n+string(REPLACE \"\\n\" \";\" cache \"${cache}\")\n+\n+message(STATUS \"${USER_CMAKECACHE}\")\n+\n+file(REMOVE \"${USER_CMAKECACHE}\")\n+foreach(line IN LISTS cache)\n+  if(line MATCHES \"^SIMDJSON_\" AND NOT line MATCHES \"^SIMDJSON_LIB_\")\n+    file(APPEND \"${USER_CMAKECACHE}\" \"${line}\\n\")\n+  endif()\n+endforeach()\n--- vendor/simdjson/examples/quickstart/quickstart.cpp\n@@ -1,7 +1,8 @@\n+#include <iostream>\n #include \"simdjson.h\"\n \n int main(void) {\n   simdjson::dom::parser parser;\n   simdjson::dom::element tweets = parser.load(\"twitter.json\");\n   std::cout << tweets[\"search_metadata\"][\"count\"] << \" results.\" << std::endl;\n-}\n\\ No newline at end of file\n+}\n--- vendor/simdjson/examples/quickstart/quickstart2.cpp\n@@ -1,3 +1,4 @@\n+#include <iostream>\n #include \"simdjson.h\"\n \n int main(void) {\n--- vendor/simdjson/examples/quickstart/quickstart2_noexceptions.cpp\n@@ -1,3 +1,4 @@\n+#include <iostream>\n #include \"simdjson.h\"\n \n int main(void) {\n--- vendor/simdjson/examples/quickstart/quickstart_noexceptions.cpp\n@@ -1,3 +1,4 @@\n+#include <iostream>\n #include \"simdjson.h\"\n \n int main(void) {\n--- vendor/simdjson/examples/quickstart/quickstart_ondemand.cpp\n@@ -1,3 +1,4 @@\n+#include <iostream>\n #include \"simdjson.h\"\n using namespace simdjson;\n int main(void) {\n--- vendor/simdjson/examples/quickstart/quickstart_ondemand_noexceptions.cpp\n@@ -1,3 +1,4 @@\n+#include <iostream>\n #include \"simdjson.h\"\n using namespace simdjson;\n int main(void) {\n--- vendor/simdjson/include/CMakeLists.txt\n@@ -1,13 +0,0 @@\n-#\n-# Provides the simdjson headers.\n-#\n-# target_link_libraries(my-project simdjson-headers) grants the headers. It does not provide the\n-# source, libraries or any compiler flags.\n-#\n-add_library(simdjson-headers INTERFACE)\n-target_compile_features(simdjson-headers INTERFACE cxx_std_11) # headers require at least C++11\n-target_include_directories(simdjson-headers INTERFACE\n-  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\n-  $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCDIR}>)\n-\n-install(TARGETS simdjson-headers EXPORT simdjson-config INCLUDES DESTINATION include)\n--- vendor/simdjson/include/simdjson.h\n@@ -4,7 +4,7 @@\n /**\n  * @mainpage\n  *\n- * Check the [README.md](https://github.com/lemire/simdjson/blob/master/README.md#simdjson--parsing-gigabytes-of-json-per-second).\n+ * Check the [README.md](https://github.com/simdjson/simdjson/blob/master/README.md#simdjson--parsing-gigabytes-of-json-per-second).\n  *\n  * Sample code. See https://github.com/simdjson/simdjson/blob/master/doc/basics.md for more examples.\n \n--- vendor/simdjson/include/simdjson/arm64/bitmanipulation.h\n@@ -46,6 +46,40 @@ simdjson_really_inline int count_ones(uint64_t input_num) {\n    return vaddv_u8(vcnt_u8(vcreate_u8(input_num)));\n }\n \n+\n+#if defined(__GNUC__) // catches clang and gcc\n+/**\n+ * ARM has a fast 64-bit \"bit reversal function\" that is handy. However,\n+ * it is not generally available as an intrinsic function under Visual\n+ * Studio (though this might be changing). Even under clang/gcc, we\n+ * apparently need to invoke inline assembly.\n+ */\n+/*\n+ * We use SIMDJSON_PREFER_REVERSE_BITS as a hint that algorithms that\n+ * work well with bit reversal may use it.\n+ */\n+#define SIMDJSON_PREFER_REVERSE_BITS 1\n+\n+/* reverse the bits */\n+simdjson_really_inline uint64_t reverse_bits(uint64_t input_num) {\n+  uint64_t rev_bits;\n+  __asm(\"rbit %0, %1\" : \"=r\"(rev_bits) : \"r\"(input_num));\n+  return rev_bits;\n+}\n+\n+/**\n+ * Flips bit at index 63 - lz. Thus if you have 'leading_zeroes' leading zeroes,\n+ * then this will set to zero the leading bit. It is possible for leading_zeroes to be\n+ * greating or equal to 63 in which case we trigger undefined behavior, but the output\n+ * of such undefined behavior is never used.\n+ **/\n+NO_SANITIZE_UNDEFINED\n+simdjson_really_inline uint64_t zero_leading_bit(uint64_t rev_bits, int leading_zeroes) {\n+  return rev_bits ^ (uint64_t(0x8000000000000000) >> leading_zeroes);\n+}\n+\n+#endif\n+\n simdjson_really_inline bool add_overflow(uint64_t value1, uint64_t value2, uint64_t *result) {\n #ifdef SIMDJSON_REGULAR_VISUAL_STUDIO\n   *result = value1 + value2;\n--- vendor/simdjson/include/simdjson/arm64/numberparsing.h\n@@ -19,7 +19,7 @@ static simdjson_really_inline uint32_t parse_eight_digits_unrolled(const uint8_t\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n \n-#define SWAR_NUMBER_PARSING\n+#define SIMDJSON_SWAR_NUMBER_PARSING 1\n \n #include \"simdjson/generic/numberparsing.h\"\n \n--- vendor/simdjson/include/simdjson/arm64/simd.h\n@@ -57,6 +57,19 @@ simdjson_really_inline uint8x16_t make_uint8x16_t(uint8_t x1,  uint8_t x2,  uint\n   return x;\n }\n \n+simdjson_really_inline uint8x8_t make_uint8x8_t(uint8_t x1,  uint8_t x2,  uint8_t x3,  uint8_t x4,\n+                                         uint8_t x5,  uint8_t x6,  uint8_t x7,  uint8_t x8) {\n+  uint8x8_t x{};\n+  x = vset_lane_u8(x1, x, 0);\n+  x = vset_lane_u8(x2, x, 1);\n+  x = vset_lane_u8(x3, x, 2);\n+  x = vset_lane_u8(x4, x, 3);\n+  x = vset_lane_u8(x5, x, 4);\n+  x = vset_lane_u8(x6, x, 5);\n+  x = vset_lane_u8(x7, x, 6);\n+  x = vset_lane_u8(x8, x, 7);\n+  return x;\n+}\n \n // We have to do the same work for make_int8x16_t\n simdjson_really_inline int8x16_t make_int8x16_t(int8_t x1,  int8_t x2,  int8_t x3,  int8_t x4,\n@@ -289,6 +302,27 @@ simdjson_really_inline int8x16_t make_int8x16_t(int8_t x1,  int8_t x2,  int8_t x\n       vst1q_u8(reinterpret_cast<uint8_t*>(output), answer);\n     }\n \n+    // Copies all bytes corresponding to a 0 in the low half of the mask (interpreted as a\n+    // bitset) to output1, then those corresponding to a 0 in the high half to output2.\n+    template<typename L>\n+    simdjson_really_inline void compress_halves(uint16_t mask, L *output1, L *output2) const {\n+      using internal::thintable_epi8;\n+      uint8_t mask1 = uint8_t(mask); // least significant 8 bits\n+      uint8_t mask2 = uint8_t(mask >> 8); // most significant 8 bits\n+      uint8x8_t compactmask1 = vcreate_u8(thintable_epi8[mask1]);\n+      uint8x8_t compactmask2 = vcreate_u8(thintable_epi8[mask2]);\n+      // we increment by 0x08 the second half of the mask\n+#ifdef SIMDJSON_REGULAR_VISUAL_STUDIO\n+      uint8x8_t inc = make_uint8x8_t(0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08);\n+#else\n+      uint8x8_t inc = {0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08};\n+#endif\n+      compactmask2 = vadd_u8(compactmask2, inc);\n+      // store each result (with the second store possibly overlapping the first)\n+      vst1_u8((uint8_t*)output1, vqtbl1_u8(*this, compactmask1));\n+      vst1_u8((uint8_t*)output2, vqtbl1_u8(*this, compactmask2));\n+    }\n+\n     template<typename L>\n     simdjson_really_inline simd8<L> lookup_16(\n         L replace0,  L replace1,  L replace2,  L replace3,\n@@ -364,7 +398,7 @@ simdjson_really_inline int8x16_t make_int8x16_t(int8_t x1,  int8_t x2,  int8_t x\n     // Explicit conversion to/from unsigned\n     //\n     // Under Visual Studio/ARM64 uint8x16_t and int8x16_t are apparently the same type.\n-    // In theory, we could check this occurence with std::same_as and std::enabled_if but it is C++14\n+    // In theory, we could check this occurrence with std::same_as and std::enabled_if but it is C++14\n     // and relatively ugly and hard to read.\n #ifndef SIMDJSON_REGULAR_VISUAL_STUDIO\n     simdjson_really_inline explicit simd8(const uint8x16_t other): simd8(vreinterpretq_s8_u8(other)) {}\n@@ -439,11 +473,15 @@ simdjson_really_inline int8x16_t make_int8x16_t(int8_t x1,  int8_t x2,  int8_t x\n     }\n \n \n-    simdjson_really_inline void compress(uint64_t mask, T * output) const {\n-      this->chunks[0].compress(uint16_t(mask), output);\n-      this->chunks[1].compress(uint16_t(mask >> 16), output + 16 - count_ones(mask & 0xFFFF));\n-      this->chunks[2].compress(uint16_t(mask >> 32), output + 32 - count_ones(mask & 0xFFFFFFFF));\n-      this->chunks[3].compress(uint16_t(mask >> 48), output + 48 - count_ones(mask & 0xFFFFFFFFFFFF));\n+    simdjson_really_inline uint64_t compress(uint64_t mask, T * output) const {\n+      uint64_t popcounts = vget_lane_u64(vreinterpret_u64_u8(vcnt_u8(vcreate_u8(~mask))), 0);\n+      // compute the prefix sum of the popcounts of each byte\n+      uint64_t offsets = popcounts * 0x0101010101010101;\n+      this->chunks[0].compress_halves(uint16_t(mask), output, &output[popcounts & 0xFF]);\n+      this->chunks[1].compress_halves(uint16_t(mask >> 16), &output[(offsets >> 8) & 0xFF], &output[(offsets >> 16) & 0xFF]);\n+      this->chunks[2].compress_halves(uint16_t(mask >> 32), &output[(offsets >> 24) & 0xFF], &output[(offsets >> 32) & 0xFF]);\n+      this->chunks[3].compress_halves(uint16_t(mask >> 48), &output[(offsets >> 40) & 0xFF], &output[(offsets >> 48) & 0xFF]);\n+      return offsets >> 56;\n     }\n \n     simdjson_really_inline uint64_t to_bitmask() const {\n--- vendor/simdjson/include/simdjson/common_defs.h\n@@ -19,6 +19,8 @@ char *to_chars(char *first, const char *last, double value);\n  * Defined in src/from_chars\n  */\n double from_chars(const char *first) noexcept;\n+double from_chars(const char *first, const char* end) noexcept;\n+\n }\n \n #ifndef SIMDJSON_EXCEPTIONS\n@@ -38,7 +40,7 @@ constexpr size_t SIMDJSON_MAXSIZE_BYTES = 0xFFFFFFFF;\n  * the input buf should be readable up to buf + SIMDJSON_PADDING\n  * this is a stopgap; there should be a better description of the\n  * main loop and its behavior that abstracts over this\n- * See https://github.com/lemire/simdjson/issues/174\n+ * See https://github.com/simdjson/simdjson/issues/174\n  */\n constexpr size_t SIMDJSON_PADDING = 32;\n \n@@ -161,7 +163,7 @@ constexpr size_t DEFAULT_MAX_DEPTH = 1024;\n      * the regular visual studio or clang under visual\n      * studio, you still need to handle these issues.\n      *\n-     * Non-Windows sytems do not have this complexity.\n+     * Non-Windows systems do not have this complexity.\n      */\n     #if SIMDJSON_BUILDING_WINDOWS_DYNAMIC_LIBRARY\n     // We set SIMDJSON_BUILDING_WINDOWS_DYNAMIC_LIBRARY when we build a DLL under Windows.\n@@ -215,7 +217,7 @@ constexpr size_t DEFAULT_MAX_DEPTH = 1024;\n // now it is safe to trigger the include\n #include <string_view> // though the file is there, it does not follow that we got the implementation\n #if defined(_LIBCPP_STRING_VIEW)\n-// Ah! So we under libc++ which under its Library Fundamentals Technical Specification, which preceeded C++17,\n+// Ah! So we under libc++ which under its Library Fundamentals Technical Specification, which preceded C++17,\n // included string_view.\n // This means that we have string_view *even though* we may not have C++17.\n #define SIMDJSON_HAS_STRING_VIEW\n@@ -251,7 +253,8 @@ namespace std {\n #endif\n #endif\n \n-\n+// The SIMDJSON_CHECK_EOF macro is a feature flag for the \"don't require padding\"\n+// feature.\n \n #if SIMDJSON_CPLUSPLUS17\n // if we have C++, then fallthrough is a default attribute\n@@ -262,12 +265,11 @@ namespace std {\n #if __has_attribute(__fallthrough__)\n // we are good to go:\n # define simdjson_fallthrough                    __attribute__((__fallthrough__))\n-#endif\n-#endif\n+#endif // __has_attribute(__fallthrough__)\n+#endif // SIMDJSON_CPLUSPLUS17\n // on some systems, we simply do not have support for fallthrough, so use a default:\n #ifndef simdjson_fallthrough\n # define simdjson_fallthrough do {} while (0)  /* fallthrough */\n-#endif\n-\n+#endif // simdjson_fallthrough\n \n #endif // SIMDJSON_COMMON_DEFS_H\n--- vendor/simdjson/include/simdjson/dom/document-inl.h\n@@ -37,7 +37,7 @@ inline error_code document::allocate(size_t capacity) noexcept {\n   // need a capacity of at least capacity + 1, but it is also possible to do\n   // worse with \"[7,7,7,7,6,7,7,7,6,7,7,6,[7,7,7,7,6,7,7,7,6,7,7,6,7,7,7,7,7,7,6\"\n   //where capacity + 1 tape elements are\n-  // generated, see issue https://github.com/lemire/simdjson/issues/345\n+  // generated, see issue https://github.com/simdjson/simdjson/issues/345\n   size_t tape_capacity = SIMDJSON_ROUNDUP_N(capacity + 3, 64);\n   // a document with only zero-length strings... could have capacity/3 string\n   // and we would need capacity/3 * 5 bytes on the string buffer\n--- vendor/simdjson/include/simdjson/dom/document_stream-inl.h\n@@ -187,7 +187,7 @@ inline void document_stream::start() noexcept {\n   // Always run the first stage 1 parse immediately\n   batch_start = 0;\n   error = run_stage1(*parser, batch_start);\n-  if(error == EMPTY) {\n+  while(error == EMPTY) {\n     // In exceptional cases, we may start with an empty block\n     batch_start = next_batch_start();\n     if (batch_start >= len) { return; }\n@@ -204,7 +204,6 @@ inline void document_stream::start() noexcept {\n     if (error) { return; }\n   }\n #endif // SIMDJSON_THREADS_ENABLED\n-\n   next();\n }\n \n@@ -213,13 +212,20 @@ simdjson_really_inline size_t document_stream::iterator::current_index() const n\n }\n \n simdjson_really_inline std::string_view document_stream::iterator::source() const noexcept {\n-  size_t next_doc_index = stream->batch_start + stream->parser->implementation->structural_indexes[stream->parser->implementation->next_structural_index];\n-  return std::string_view(reinterpret_cast<const char*>(stream->buf) + current_index(), next_doc_index - current_index() - 1);\n+  const char* start = reinterpret_cast<const char*>(stream->buf) + current_index();\n+  bool object_or_array = ((*start == '[') || (*start == '{'));\n+  if(object_or_array) {\n+    size_t next_doc_index = stream->batch_start + stream->parser->implementation->structural_indexes[stream->parser->implementation->next_structural_index - 1];\n+    return std::string_view(start, next_doc_index - current_index() + 1);\n+  } else {\n+    size_t next_doc_index = stream->batch_start + stream->parser->implementation->structural_indexes[stream->parser->implementation->next_structural_index];\n+    return std::string_view(reinterpret_cast<const char*>(stream->buf) + current_index(), next_doc_index - current_index() - 1);\n+  }\n }\n \n \n inline void document_stream::next() noexcept {\n-  // We always enter at once once in an error condition.\n+  // We always exit at once, once in an error condition.\n   if (error) { return; }\n \n   // Load the next document from the batch\n@@ -245,18 +251,25 @@ inline void document_stream::next() noexcept {\n     error = parser->implementation->stage2_next(parser->doc);\n   }\n }\n+inline size_t document_stream::size_in_bytes() const noexcept {\n+  return len;\n+}\n+\n+inline size_t document_stream::truncated_bytes() const noexcept {\n+  if(error == CAPACITY) { return len - batch_start; }\n+  return parser->implementation->structural_indexes[parser->implementation->n_structural_indexes] - parser->implementation->structural_indexes[parser->implementation->n_structural_indexes + 1];\n+}\n \n inline size_t document_stream::next_batch_start() const noexcept {\n   return batch_start + parser->implementation->structural_indexes[parser->implementation->n_structural_indexes];\n }\n \n inline error_code document_stream::run_stage1(dom::parser &p, size_t _batch_start) noexcept {\n-  // If this is the final batch, pass partial = false\n   size_t remaining = len - _batch_start;\n   if (remaining <= batch_size) {\n-    return p.implementation->stage1(&buf[_batch_start], remaining, false);\n+    return p.implementation->stage1(&buf[_batch_start], remaining, stage1_mode::streaming_final);\n   } else {\n-    return p.implementation->stage1(&buf[_batch_start], batch_size, true);\n+    return p.implementation->stage1(&buf[_batch_start], batch_size, stage1_mode::streaming_partial);\n   }\n }\n \n--- vendor/simdjson/include/simdjson/dom/document_stream.h\n@@ -87,7 +87,29 @@ class document_stream {\n   simdjson_really_inline document_stream &operator=(document_stream &&other) noexcept = default;\n \n   simdjson_really_inline ~document_stream() noexcept;\n-\n+  /**\n+   * Returns the input size in bytes.\n+   */\n+  inline size_t size_in_bytes() const noexcept;\n+  /**\n+   * After iterating through the stream, this method\n+   * returns the number of bytes that were not parsed at the end\n+   * of the stream. If truncated_bytes() differs from zero,\n+   * then the input was truncated maybe because incomplete JSON\n+   * documents were found at the end of the stream. You\n+   * may need to process the bytes in the interval [size_in_bytes()-truncated_bytes(), size_in_bytes()).\n+   *\n+   * You should only call truncated_bytes() after streaming through all\n+   * documents, like so:\n+   *\n+   *   document_stream stream = parser.parse_many(json,window);\n+   *   for(auto doc : stream) {\n+   *      // do something with doc\n+   *   }\n+   *   size_t truncated = stream.truncated_bytes();\n+   *\n+   */\n+  inline size_t truncated_bytes() const noexcept;\n   /**\n    * An iterator through a forward-only stream of documents.\n    */\n@@ -101,7 +123,7 @@ class document_stream {\n     using iterator_category = std::input_iterator_tag;\n \n     /**\n-     * Default contructor.\n+     * Default constructor.\n      */\n     simdjson_really_inline iterator() noexcept;\n     /**\n@@ -245,7 +267,6 @@ class document_stream {\n   error_code error;\n   size_t batch_start{0};\n   size_t doc_index{};\n-\n #ifdef SIMDJSON_THREADS_ENABLED\n   /** Indicates whether we use threads. Note that this needs to be a constant during the execution of the parsing. */\n   bool use_thread;\n--- vendor/simdjson/include/simdjson/dom/element.h\n@@ -355,7 +355,7 @@ class element {\n    * The key will be matched against **unescaped** JSON:\n    *\n    *   dom::parser parser;\n-   *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"].get_uint64().first == 1\n+   *   int64_t(parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"]) == 1\n    *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\\\n\"].get_uint64().error() == NO_SUCH_FIELD\n    *\n    * @return The value associated with this field, or:\n@@ -370,7 +370,7 @@ class element {\n    * The key will be matched against **unescaped** JSON:\n    *\n    *   dom::parser parser;\n-   *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"].get_uint64().first == 1\n+   *   int64_t(parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"]) == 1\n    *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\\\n\"].get_uint64().error() == NO_SUCH_FIELD\n    *\n    * @return The value associated with this field, or:\n@@ -442,7 +442,7 @@ class element {\n    * The key will be matched against **unescaped** JSON:\n    *\n    *   dom::parser parser;\n-   *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"].get_uint64().first == 1\n+   *   int64_t(parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"]) == 1\n    *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\\\n\"].get_uint64().error() == NO_SUCH_FIELD\n    *\n    * @return The value associated with this field, or:\n--- vendor/simdjson/include/simdjson/dom/object.h\n@@ -123,7 +123,7 @@ class object {\n    * The key will be matched against **unescaped** JSON:\n    *\n    *   dom::parser parser;\n-   *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"].get_uint64().first == 1\n+   *   int64_t(parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"]) == 1\n    *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\\\n\"].get_uint64().error() == NO_SUCH_FIELD\n    *\n    * This function has linear-time complexity: the keys are checked one by one.\n@@ -140,7 +140,7 @@ class object {\n    * The key will be matched against **unescaped** JSON:\n    *\n    *   dom::parser parser;\n-   *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"].get_uint64().first == 1\n+   *   int64_t(parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"]) == 1\n    *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\\\n\"].get_uint64().error() == NO_SUCH_FIELD\n    *\n    * This function has linear-time complexity: the keys are checked one by one.\n@@ -182,7 +182,7 @@ class object {\n    * The key will be matched against **unescaped** JSON:\n    *\n    *   dom::parser parser;\n-   *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"].get_uint64().first == 1\n+   *   int64_t(parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"]) == 1\n    *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\\\n\"].get_uint64().error() == NO_SUCH_FIELD\n    *\n    * This function has linear-time complexity: the keys are checked one by one.\n--- vendor/simdjson/include/simdjson/dom/parsedjson_iterator.h\n@@ -208,7 +208,7 @@ class [[deprecated(\"Use the new DOM navigation API instead (see doc/basics.md)\")\n   // throughout return true if we can do the navigation, false\n   // otherwise\n \n-  // Withing a given scope (series of nodes at the same depth within either an\n+  // Within a given scope (series of nodes at the same depth within either an\n   // array or an object), we move forward.\n   // Thus, given [true, null, {\"a\":1}, [1,2]], we would visit true, null, {\n   // and [. At the object ({) or at the array ([), you can issue a \"down\" to\n--- vendor/simdjson/include/simdjson/dom/parser-inl.h\n@@ -100,13 +100,18 @@ inline simdjson_result<element> parser::parse_into_document(document& provided_d\n   // Important: It is possible that provided_doc is actually the internal 'doc' within the parser!!!\n   error_code _error = ensure_capacity(provided_doc, len);\n   if (_error) { return _error; }\n-  std::unique_ptr<uint8_t[]> tmp_buf;\n   if (realloc_if_needed) {\n-    tmp_buf.reset(reinterpret_cast<uint8_t *>( internal::allocate_padded_buffer(len) ));\n-    if (tmp_buf.get() == nullptr) { return MEMALLOC; }\n-    std::memcpy(static_cast<void *>(tmp_buf.get()), buf, len);\n+    // Make sure we have enough capacity to copy len bytes\n+    if (!loaded_bytes || _loaded_bytes_capacity < len) {\n+      loaded_bytes.reset( internal::allocate_padded_buffer(len) );\n+      if (!loaded_bytes) {\n+        return MEMALLOC;\n+      }\n+      _loaded_bytes_capacity = len;\n+    }\n+    std::memcpy(static_cast<void *>(loaded_bytes.get()), buf, len);\n   }\n-  _error = implementation->parse(realloc_if_needed ? tmp_buf.get() : buf, len, provided_doc);\n+  _error = implementation->parse(realloc_if_needed ? reinterpret_cast<const uint8_t*>(loaded_bytes.get()): buf, len, provided_doc);\n \n   if (_error) { return _error; }\n \n--- vendor/simdjson/include/simdjson/dom/parser.h\n@@ -335,7 +335,7 @@ class parser {\n    *         - other json errors if parsing fails. You should not rely on these errors to always the same for the\n    *           same document: they may vary under runtime dispatch (so they may vary depending on your system and hardware).\n    */\n-  inline simdjson_result<document_stream> load_many(const std::string &path, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept;\n+  inline simdjson_result<document_stream> load_many(const std::string &path, size_t batch_size = dom::DEFAULT_BATCH_SIZE) noexcept;\n \n   /**\n    * Parse a buffer containing many JSON documents.\n@@ -429,18 +429,18 @@ class parser {\n    *         - other json errors if parsing fails. You should not rely on these errors to always the same for the\n    *           same document: they may vary under runtime dispatch (so they may vary depending on your system and hardware).\n    */\n-  inline simdjson_result<document_stream> parse_many(const uint8_t *buf, size_t len, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept;\n+  inline simdjson_result<document_stream> parse_many(const uint8_t *buf, size_t len, size_t batch_size = dom::DEFAULT_BATCH_SIZE) noexcept;\n   /** @overload parse_many(const uint8_t *buf, size_t len, size_t batch_size) */\n-  inline simdjson_result<document_stream> parse_many(const char *buf, size_t len, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept;\n+  inline simdjson_result<document_stream> parse_many(const char *buf, size_t len, size_t batch_size = dom::DEFAULT_BATCH_SIZE) noexcept;\n   /** @overload parse_many(const uint8_t *buf, size_t len, size_t batch_size) */\n-  inline simdjson_result<document_stream> parse_many(const std::string &s, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept;\n+  inline simdjson_result<document_stream> parse_many(const std::string &s, size_t batch_size = dom::DEFAULT_BATCH_SIZE) noexcept;\n   inline simdjson_result<document_stream> parse_many(const std::string &&s, size_t batch_size) = delete;// unsafe\n   /** @overload parse_many(const uint8_t *buf, size_t len, size_t batch_size) */\n-  inline simdjson_result<document_stream> parse_many(const padded_string &s, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept;\n+  inline simdjson_result<document_stream> parse_many(const padded_string &s, size_t batch_size = dom::DEFAULT_BATCH_SIZE) noexcept;\n   inline simdjson_result<document_stream> parse_many(const padded_string &&s, size_t batch_size) = delete;// unsafe\n \n   /** @private We do not want to allow implicit conversion from C string to std::string. */\n-  simdjson_result<document_stream> parse_many(const char *buf, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept = delete;\n+  simdjson_result<document_stream> parse_many(const char *buf, size_t batch_size = dom::DEFAULT_BATCH_SIZE) noexcept = delete;\n \n   /**\n    * Ensure this parser has enough memory to process JSON documents up to `capacity` bytes in length\n@@ -536,7 +536,7 @@ class parser {\n \n   /**\n    * @private return an error code corresponding to the last parsing attempt, see\n-   * simdjson.h will return UNITIALIZED if no parsing was attempted\n+   * simdjson.h will return UNINITIALIZED if no parsing was attempted\n    */\n   [[deprecated(\"Use the result of parser.parse() instead\")]]\n   inline int get_error_code() const noexcept;\n--- vendor/simdjson/include/simdjson/dom/serialization.h\n@@ -37,7 +37,7 @@ class string_builder {\n   inline void append(simdjson::dom::element value);\n   /** Append an array to the builder (to be printed) **/\n   inline void append(simdjson::dom::array value);\n-  /** Append an objet to the builder (to be printed) **/\n+  /** Append an object to the builder (to be printed) **/\n   inline void append(simdjson::dom::object value);\n   /** Reset the builder (so that it would print the empty string) **/\n   simdjson_really_inline void clear();\n@@ -92,7 +92,7 @@ class mini_formatter {\n   /** Clears out the content. **/\n   simdjson_really_inline void clear();\n   /**\n-   * Get access to the buffer, it is own by the instance, but\n+   * Get access to the buffer, it is owned by the instance, but\n    * the user can make a copy.\n    **/\n   simdjson_really_inline std::string_view str() const;\n@@ -149,7 +149,7 @@ inline std::ostream& operator<<(std::ostream& out, simdjson::simdjson_result<sim\n  * Print JSON to an output stream.\n  *\n  * @param out The output stream.\n- * @param value The objet.\n+ * @param value The object.\n  * @throw if there is an error with the underlying output stream. simdjson itself will not throw.\n  */\n inline std::ostream& operator<<(std::ostream& out, simdjson::dom::object value)   {\n--- vendor/simdjson/include/simdjson/error.h\n@@ -10,33 +10,36 @@ namespace simdjson {\n  * All possible errors returned by simdjson.\n  */\n enum error_code {\n-  SUCCESS = 0,              ///< No error\n-  CAPACITY,                 ///< This parser can't support a document that big\n-  MEMALLOC,                 ///< Error allocating memory, most likely out of memory\n-  TAPE_ERROR,               ///< Something went wrong while writing to the tape (stage 2), this is a generic error\n-  DEPTH_ERROR,              ///< Your document exceeds the user-specified depth limitation\n-  STRING_ERROR,             ///< Problem while parsing a string\n-  T_ATOM_ERROR,             ///< Problem while parsing an atom starting with the letter 't'\n-  F_ATOM_ERROR,             ///< Problem while parsing an atom starting with the letter 'f'\n-  N_ATOM_ERROR,             ///< Problem while parsing an atom starting with the letter 'n'\n-  NUMBER_ERROR,             ///< Problem while parsing a number\n-  UTF8_ERROR,               ///< the input is not valid UTF-8\n-  UNINITIALIZED,            ///< unknown error, or uninitialized document\n-  EMPTY,                    ///< no structural element found\n-  UNESCAPED_CHARS,          ///< found unescaped characters in a string.\n-  UNCLOSED_STRING,          ///< missing quote at the end\n-  UNSUPPORTED_ARCHITECTURE, ///< unsupported architecture\n-  INCORRECT_TYPE,           ///< JSON element has a different type than user expected\n-  NUMBER_OUT_OF_RANGE,      ///< JSON number does not fit in 64 bits\n-  INDEX_OUT_OF_BOUNDS,      ///< JSON array index too large\n-  NO_SUCH_FIELD,            ///< JSON field not found in object\n-  IO_ERROR,                 ///< Error reading a file\n-  INVALID_JSON_POINTER,     ///< Invalid JSON pointer reference\n-  INVALID_URI_FRAGMENT,     ///< Invalid URI fragment\n-  UNEXPECTED_ERROR,         ///< indicative of a bug in simdjson\n-  PARSER_IN_USE,            ///< parser is already in use.\n-  OUT_OF_ORDER_ITERATION,   ///< tried to iterate an array or object out of order\n-  INSUFFICIENT_PADDING,     ///< The JSON doesn't have enough padding for simdjson to safely parse it.\n+  SUCCESS = 0,                ///< No error\n+  CAPACITY,                   ///< This parser can't support a document that big\n+  MEMALLOC,                   ///< Error allocating memory, most likely out of memory\n+  TAPE_ERROR,                 ///< Something went wrong while writing to the tape (stage 2), this is a generic error\n+  DEPTH_ERROR,                ///< Your document exceeds the user-specified depth limitation\n+  STRING_ERROR,               ///< Problem while parsing a string\n+  T_ATOM_ERROR,               ///< Problem while parsing an atom starting with the letter 't'\n+  F_ATOM_ERROR,               ///< Problem while parsing an atom starting with the letter 'f'\n+  N_ATOM_ERROR,               ///< Problem while parsing an atom starting with the letter 'n'\n+  NUMBER_ERROR,               ///< Problem while parsing a number\n+  UTF8_ERROR,                 ///< the input is not valid UTF-8\n+  UNINITIALIZED,              ///< unknown error, or uninitialized document\n+  EMPTY,                      ///< no structural element found\n+  UNESCAPED_CHARS,            ///< found unescaped characters in a string.\n+  UNCLOSED_STRING,            ///< missing quote at the end\n+  UNSUPPORTED_ARCHITECTURE,   ///< unsupported architecture\n+  INCORRECT_TYPE,             ///< JSON element has a different type than user expected\n+  NUMBER_OUT_OF_RANGE,        ///< JSON number does not fit in 64 bits\n+  INDEX_OUT_OF_BOUNDS,        ///< JSON array index too large\n+  NO_SUCH_FIELD,              ///< JSON field not found in object\n+  IO_ERROR,                   ///< Error reading a file\n+  INVALID_JSON_POINTER,       ///< Invalid JSON pointer reference\n+  INVALID_URI_FRAGMENT,       ///< Invalid URI fragment\n+  UNEXPECTED_ERROR,           ///< indicative of a bug in simdjson\n+  PARSER_IN_USE,              ///< parser is already in use.\n+  OUT_OF_ORDER_ITERATION,     ///< tried to iterate an array or object out of order\n+  INSUFFICIENT_PADDING,       ///< The JSON doesn't have enough padding for simdjson to safely parse it.\n+  INCOMPLETE_ARRAY_OR_OBJECT, ///< The document ends early.\n+  SCALAR_DOCUMENT_AS_VALUE,   ///< A scalar document is treated as a value.\n+  OUT_OF_BOUNDS,              ///< Attempted to access location outside of document.\n   NUM_ERROR_CODES\n };\n \n@@ -180,13 +183,13 @@ struct simdjson_result_base : protected std::pair<T, error_code> {\n \n   /**\n    * Get the result value. This function is safe if and only\n-   * the error() method returns a value that evoluates to false.\n+   * the error() method returns a value that evaluates to false.\n    */\n   simdjson_really_inline const T& value_unsafe() const& noexcept;\n \n   /**\n    * Take the result value (move it). This function is safe if and only\n-   * the error() method returns a value that evoluates to false.\n+   * the error() method returns a value that evaluates to false.\n    */\n   simdjson_really_inline T&& value_unsafe() && noexcept;\n \n@@ -271,13 +274,13 @@ struct simdjson_result : public internal::simdjson_result_base<T> {\n \n   /**\n    * Get the result value. This function is safe if and only\n-   * the error() method returns a value that evoluates to false.\n+   * the error() method returns a value that evaluates to false.\n    */\n   simdjson_really_inline const T& value_unsafe() const& noexcept;\n \n   /**\n    * Take the result value (move it). This function is safe if and only\n-   * the error() method returns a value that evoluates to false.\n+   * the error() method returns a value that evaluates to false.\n    */\n   simdjson_really_inline T&& value_unsafe() && noexcept;\n \n@@ -286,8 +289,7 @@ struct simdjson_result : public internal::simdjson_result_base<T> {\n #if SIMDJSON_EXCEPTIONS\n \n template<typename T>\n-inline std::ostream& operator<<(std::ostream& out, simdjson_result<T> value) noexcept { return out << value.value(); }\n-\n+inline std::ostream& operator<<(std::ostream& out, simdjson_result<T> value) { return out << value.value(); }\n #endif // SIMDJSON_EXCEPTIONS\n \n #ifndef SIMDJSON_DISABLE_DEPRECATED_API\n--- vendor/simdjson/include/simdjson/fallback/numberparsing.h\n@@ -27,7 +27,8 @@ static simdjson_really_inline uint32_t parse_eight_digits_unrolled(const uint8_t\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n \n-#define SWAR_NUMBER_PARSING\n+#define SIMDJSON_SWAR_NUMBER_PARSING 1\n+\n #include \"simdjson/generic/numberparsing.h\"\n \n #endif // SIMDJSON_FALLBACK_NUMBERPARSING_H\n--- vendor/simdjson/include/simdjson/generic/dom_parser_implementation.h\n@@ -32,7 +32,7 @@ class dom_parser_implementation final : public internal::dom_parser_implementati\n   dom_parser_implementation &operator=(const dom_parser_implementation &) = delete;\n \n   simdjson_warn_unused error_code parse(const uint8_t *buf, size_t len, dom::document &doc) noexcept final;\n-  simdjson_warn_unused error_code stage1(const uint8_t *buf, size_t len, bool partial) noexcept final;\n+  simdjson_warn_unused error_code stage1(const uint8_t *buf, size_t len, stage1_mode partial) noexcept final;\n   simdjson_warn_unused error_code stage2(dom::document &doc) noexcept final;\n   simdjson_warn_unused error_code stage2_next(dom::document &doc) noexcept final;\n   inline simdjson_warn_unused error_code set_capacity(size_t capacity) noexcept final;\n--- vendor/simdjson/include/simdjson/generic/implementation_simdjson_result_base-inl.h\n@@ -49,18 +49,23 @@ simdjson_really_inline implementation_simdjson_result_base<T>::operator T&&() &&\n   return std::forward<implementation_simdjson_result_base<T>>(*this).take_value();\n }\n \n+#endif // SIMDJSON_EXCEPTIONS\n+\n template<typename T>\n simdjson_really_inline const T& implementation_simdjson_result_base<T>::value_unsafe() const& noexcept {\n   return this->first;\n }\n \n+template<typename T>\n+simdjson_really_inline T& implementation_simdjson_result_base<T>::value_unsafe() & noexcept {\n+  return this->first;\n+}\n+\n template<typename T>\n simdjson_really_inline T&& implementation_simdjson_result_base<T>::value_unsafe() && noexcept {\n   return std::forward<T>(this->first);\n }\n \n-#endif // SIMDJSON_EXCEPTIONS\n-\n template<typename T>\n simdjson_really_inline implementation_simdjson_result_base<T>::implementation_simdjson_result_base(T &&value, error_code error) noexcept\n     : first{std::forward<T>(value)}, second{error} {}\n--- vendor/simdjson/include/simdjson/generic/implementation_simdjson_result_base.h\n@@ -97,22 +97,28 @@ struct implementation_simdjson_result_base {\n    */\n   simdjson_really_inline operator T&&() && noexcept(false);\n \n+\n+#endif // SIMDJSON_EXCEPTIONS\n+\n   /**\n    * Get the result value. This function is safe if and only\n-   * the error() method returns a value that evoluates to false.\n+   * the error() method returns a value that evaluates to false.\n    */\n   simdjson_really_inline const T& value_unsafe() const& noexcept;\n-\n+  /**\n+   * Get the result value. This function is safe if and only\n+   * the error() method returns a value that evaluates to false.\n+   */\n+  simdjson_really_inline T& value_unsafe() & noexcept;\n   /**\n    * Take the result value (move it). This function is safe if and only\n-   * the error() method returns a value that evoluates to false.\n+   * the error() method returns a value that evaluates to false.\n    */\n   simdjson_really_inline T&& value_unsafe() && noexcept;\n-\n-#endif // SIMDJSON_EXCEPTIONS\n-\n-  T first{};\n-  error_code second{UNINITIALIZED};\n+protected:\n+  /** users should never directly access first and second. **/\n+  T first{}; /** Users should never directly access 'first'. **/\n+  error_code second{UNINITIALIZED}; /** Users should never directly access 'second'. **/\n }; // struct implementation_simdjson_result_base\n \n } // namespace SIMDJSON_IMPLEMENTATION\n--- vendor/simdjson/include/simdjson/generic/numberparsing.h\n@@ -3,6 +3,18 @@\n \n namespace simdjson {\n namespace SIMDJSON_IMPLEMENTATION {\n+\n+namespace ondemand {\n+/**\n+ * The type of a JSON number\n+ */\n+enum class number_type {\n+    floating_point_number=1, /// a binary64 number\n+    signed_integer,          /// a signed integer that fits in a 64-bit word using two's complement\n+    unsigned_integer         /// a positive integer larger or equal to 1<<63\n+};\n+}\n+\n namespace {\n /// @private\n namespace numberparsing {\n@@ -161,8 +173,8 @@ simdjson_really_inline bool compute_float_64(int64_t power, uint64_t i, bool neg\n   // Both i and power_of_five_128[index] have their most significant bit set to 1 which\n   // implies that the either the most or the second most significant bit of the product\n   // is 1. We pack values in this manner for efficiency reasons: it maximizes the use\n-  // we make of the product. It also makes it easy to reason aboutthe product: there\n-  // 0 or 1 leading zero in the product.\n+  // we make of the product. It also makes it easy to reason about the product: there\n+  // is 0 or 1 leading zero in the product.\n \n   // Unless the least significant 9 bits of the high (64-bit) part of the full\n   // product are all 1s, then we know that the most significant 55 bits are\n@@ -277,7 +289,7 @@ simdjson_really_inline bool compute_float_64(int64_t power, uint64_t i, bool neg\n   mantissa &= ~(1ULL << 52);\n   // we have to check that real_exponent is in range, otherwise we bail out\n   if (simdjson_unlikely(real_exponent > 2046)) {\n-    // We have an infinte value!!! We could actually throw an error here if we could.\n+    // We have an infinite value!!! We could actually throw an error here if we could.\n     return false;\n   }\n   d = to_double(mantissa, real_exponent, negative);\n@@ -305,6 +317,20 @@ static bool parse_float_fallback(const uint8_t *ptr, double *outDouble) {\n   // to handle that max may be a macro on windows).\n   return !(*outDouble > (std::numeric_limits<double>::max)() || *outDouble < std::numeric_limits<double>::lowest());\n }\n+static bool parse_float_fallback(const uint8_t *ptr, const uint8_t *end_ptr, double *outDouble) {\n+  *outDouble = simdjson::internal::from_chars(reinterpret_cast<const char *>(ptr), reinterpret_cast<const char *>(end_ptr));\n+  // We do not accept infinite values.\n+\n+  // Detecting finite values in a portable manner is ridiculously hard, ideally\n+  // we would want to do:\n+  // return !std::isfinite(*outDouble);\n+  // but that mysteriously fails under legacy/old libc++ libraries, see\n+  // https://github.com/simdjson/simdjson/issues/1286\n+  //\n+  // Therefore, fall back to this solution (the extra parens are there\n+  // to handle that max may be a macro on windows).\n+  return !(*outDouble > (std::numeric_limits<double>::max)() || *outDouble < std::numeric_limits<double>::lowest());\n+}\n \n // check quickly whether the next 8 chars are made of digits\n // at a glance, it looks better than Mula's\n@@ -353,14 +379,16 @@ simdjson_really_inline error_code parse_decimal(simdjson_unused const uint8_t *c\n   // the integer into a float in a lossless manner.\n   const uint8_t *const first_after_period = p;\n \n-#ifdef SWAR_NUMBER_PARSING\n+#ifdef SIMDJSON_SWAR_NUMBER_PARSING\n+#if SIMDJSON_SWAR_NUMBER_PARSING\n   // this helps if we have lots of decimals!\n   // this turns out to be frequent enough.\n   if (is_made_of_eight_digits_fast(p)) {\n     i = i * 100000000 + parse_eight_digits_unrolled(p);\n     p += 8;\n   }\n-#endif\n+#endif // SIMDJSON_SWAR_NUMBER_PARSING\n+#endif // #ifdef SIMDJSON_SWAR_NUMBER_PARSING\n   // Unrolling the first digit makes a small difference on some implementations (e.g. westmere)\n   if (parse_digit(*p, i)) { ++p; }\n   while (parse_digit(*p, i)) { p++; }\n@@ -427,9 +455,7 @@ simdjson_really_inline size_t significant_digits(const uint8_t * start_digits, s\n   // It is possible that the integer had an overflow.\n   // We have to handle the case where we have 0.0000somenumber.\n   const uint8_t *start = start_digits;\n-  while ((*start == '0') || (*start == '.')) {\n-    start++;\n-  }\n+  while ((*start == '0') || (*start == '.')) { ++start; }\n   // we over-decrement by one when there is a '.'\n   return digit_count - size_t(start - start_digits);\n }\n@@ -440,7 +466,7 @@ simdjson_really_inline error_code write_float(const uint8_t *const src, bool neg\n   // we could extend our code by using a 128-bit integer instead\n   // of a 64-bit integer. However, this is uncommon in practice.\n   //\n-  // 9999999999999999999 < 2**64 so we can accomodate 19 digits.\n+  // 9999999999999999999 < 2**64 so we can accommodate 19 digits.\n   // If we have a decimal separator, then digit_count - 1 is the number of digits, but we\n   // may not have a decimal separator!\n   if (simdjson_unlikely(digit_count > 19 && significant_digits(start_digits, digit_count) > 19)) {\n@@ -499,7 +525,12 @@ simdjson_really_inline error_code parse_number(const uint8_t *const, W &writer)\n simdjson_unused simdjson_really_inline simdjson_result<uint64_t> parse_unsigned(const uint8_t * const src) noexcept { return 0; }\n simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer(const uint8_t * const src) noexcept { return 0; }\n simdjson_unused simdjson_really_inline simdjson_result<double> parse_double(const uint8_t * const src) noexcept { return 0; }\n-\n+simdjson_unused simdjson_really_inline simdjson_result<uint64_t> parse_unsigned_in_string(const uint8_t * const src) noexcept { return 0; }\n+simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer_in_string(const uint8_t * const src) noexcept { return 0; }\n+simdjson_unused simdjson_really_inline simdjson_result<double> parse_double_in_string(const uint8_t * const src) noexcept { return 0; }\n+simdjson_unused simdjson_really_inline bool is_negative(const uint8_t * src) noexcept  { return false; }\n+simdjson_unused simdjson_really_inline simdjson_result<bool> is_integer(const uint8_t * src) noexcept  { return false; }\n+simdjson_unused simdjson_really_inline simdjson_result<ondemand::number_type> get_number_type(const uint8_t * src) noexcept { return ondemand::number_type::signed_integer; }\n #else\n \n // parse the number at src\n@@ -709,14 +740,59 @@ simdjson_unused simdjson_really_inline simdjson_result<uint64_t> parse_unsigned(\n   return i;\n }\n \n-// Parse any number from  -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\n-simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer(const uint8_t *src) noexcept {\n+\n+// Parse any number from 0 to 18,446,744,073,709,551,615\n+// Never read at src_end or beyond\n+simdjson_unused simdjson_really_inline simdjson_result<uint64_t> parse_unsigned(const uint8_t * const src, const uint8_t * const src_end) noexcept {\n+  const uint8_t *p = src;\n   //\n-  // Check for minus sign\n+  // Parse the integer part.\n   //\n-  bool negative = (*src == '-');\n-  const uint8_t *p = src + negative;\n+  // PERF NOTE: we don't use is_made_of_eight_digits_fast because large integers like 123456789 are rare\n+  const uint8_t *const start_digits = p;\n+  uint64_t i = 0;\n+  while ((p != src_end) && parse_digit(*p, i)) { p++; }\n \n+  // If there were no digits, or if the integer starts with 0 and has more than one digit, it's an error.\n+  // Optimization note: size_t is expected to be unsigned.\n+  size_t digit_count = size_t(p - start_digits);\n+  // The longest positive 64-bit number is 20 digits.\n+  // We do it this way so we don't trigger this branch unless we must.\n+  // Optimization note: the compiler can probably merge\n+  // ((digit_count == 0) || (digit_count > 20))\n+  // into a single  branch since digit_count is unsigned.\n+  if ((digit_count == 0) || (digit_count > 20)) { return INCORRECT_TYPE; }\n+  // Here digit_count > 0.\n+  if (('0' == *start_digits) && (digit_count > 1)) { return NUMBER_ERROR; }\n+  // We can do the following...\n+  // if (!jsoncharutils::is_structural_or_whitespace(*p)) {\n+  //  return (*p == '.' || *p == 'e' || *p == 'E') ? INCORRECT_TYPE : NUMBER_ERROR;\n+  // }\n+  // as a single table lookup:\n+  if ((p != src_end) && integer_string_finisher[*p] != SUCCESS) { return error_code(integer_string_finisher[*p]); }\n+\n+  if (digit_count == 20) {\n+    // Positive overflow check:\n+    // - A 20 digit number starting with 2-9 is overflow, because 18,446,744,073,709,551,615 is the\n+    //   biggest uint64_t.\n+    // - A 20 digit number starting with 1 is overflow if it is less than INT64_MAX.\n+    //   If we got here, it's a 20 digit number starting with the digit \"1\".\n+    // - If a 20 digit number starting with 1 overflowed (i*10+digit), the result will be smaller\n+    //   than 1,553,255,926,290,448,384.\n+    // - That is smaller than the smallest possible 20-digit number the user could write:\n+    //   10,000,000,000,000,000,000.\n+    // - Therefore, if the number is positive and lower than that, it's overflow.\n+    // - The value we are looking at is less than or equal to 9,223,372,036,854,775,808 (INT64_MAX).\n+    //\n+    if (src[0] != uint8_t('1') || i <= uint64_t(INT64_MAX)) { return INCORRECT_TYPE; }\n+  }\n+\n+  return i;\n+}\n+\n+// Parse any number from 0 to 18,446,744,073,709,551,615\n+simdjson_unused simdjson_really_inline simdjson_result<uint64_t> parse_unsigned_in_string(const uint8_t * const src) noexcept {\n+  const uint8_t *p = src + 1;\n   //\n   // Parse the integer part.\n   //\n@@ -728,28 +804,22 @@ simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer(co\n   // If there were no digits, or if the integer starts with 0 and has more than one digit, it's an error.\n   // Optimization note: size_t is expected to be unsigned.\n   size_t digit_count = size_t(p - start_digits);\n-  // The longest negative 64-bit number is 19 digits.\n   // The longest positive 64-bit number is 20 digits.\n   // We do it this way so we don't trigger this branch unless we must.\n-  size_t longest_digit_count = negative ? 19 : 20;\n   // Optimization note: the compiler can probably merge\n-  // ((digit_count == 0) || (digit_count > longest_digit_count))\n+  // ((digit_count == 0) || (digit_count > 20))\n   // into a single  branch since digit_count is unsigned.\n-  if ((digit_count == 0) || (digit_count > longest_digit_count)) { return INCORRECT_TYPE; }\n+  if ((digit_count == 0) || (digit_count > 20)) { return INCORRECT_TYPE; }\n   // Here digit_count > 0.\n   if (('0' == *start_digits) && (digit_count > 1)) { return NUMBER_ERROR; }\n   // We can do the following...\n   // if (!jsoncharutils::is_structural_or_whitespace(*p)) {\n   //  return (*p == '.' || *p == 'e' || *p == 'E') ? INCORRECT_TYPE : NUMBER_ERROR;\n   // }\n   // as a single table lookup:\n-  if(integer_string_finisher[*p] != SUCCESS) { return error_code(integer_string_finisher[*p]); }\n-  if (digit_count == longest_digit_count) {\n-    if (negative) {\n-      // Anything negative above INT64_MAX+1 is invalid\n-      if (i > uint64_t(INT64_MAX)+1) { return INCORRECT_TYPE; }\n-      return ~i+1;\n+  if (*p != '\"') { return NUMBER_ERROR; }\n \n+  if (digit_count == 20) {\n     // Positive overflow check:\n     // - A 20 digit number starting with 2-9 is overflow, because 18,446,744,073,709,551,615 is the\n     //   biggest uint64_t.\n@@ -762,9 +832,137 @@ simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer(co\n     // - Therefore, if the number is positive and lower than that, it's overflow.\n     // - The value we are looking at is less than or equal to 9,223,372,036,854,775,808 (INT64_MAX).\n     //\n-    } else if (src[0] != uint8_t('1') || i <= uint64_t(INT64_MAX)) { return INCORRECT_TYPE; }\n+    if (src[0] != uint8_t('1') || i <= uint64_t(INT64_MAX)) { return INCORRECT_TYPE; }\n   }\n \n+  return i;\n+}\n+\n+// Parse any number from  -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\n+simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer(const uint8_t *src) noexcept {\n+  //\n+  // Check for minus sign\n+  //\n+  bool negative = (*src == '-');\n+  const uint8_t *p = src + negative;\n+\n+  //\n+  // Parse the integer part.\n+  //\n+  // PERF NOTE: we don't use is_made_of_eight_digits_fast because large integers like 123456789 are rare\n+  const uint8_t *const start_digits = p;\n+  uint64_t i = 0;\n+  while (parse_digit(*p, i)) { p++; }\n+\n+  // If there were no digits, or if the integer starts with 0 and has more than one digit, it's an error.\n+  // Optimization note: size_t is expected to be unsigned.\n+  size_t digit_count = size_t(p - start_digits);\n+  // We go from\n+  // -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\n+  // so we can never represent numbers that have more than 19 digits.\n+  size_t longest_digit_count = 19;\n+  // Optimization note: the compiler can probably merge\n+  // ((digit_count == 0) || (digit_count > longest_digit_count))\n+  // into a single  branch since digit_count is unsigned.\n+  if ((digit_count == 0) || (digit_count > longest_digit_count)) { return INCORRECT_TYPE; }\n+  // Here digit_count > 0.\n+  if (('0' == *start_digits) && (digit_count > 1)) { return NUMBER_ERROR; }\n+  // We can do the following...\n+  // if (!jsoncharutils::is_structural_or_whitespace(*p)) {\n+  //  return (*p == '.' || *p == 'e' || *p == 'E') ? INCORRECT_TYPE : NUMBER_ERROR;\n+  // }\n+  // as a single table lookup:\n+  if(integer_string_finisher[*p] != SUCCESS) { return error_code(integer_string_finisher[*p]); }\n+  // Negative numbers have can go down to - INT64_MAX - 1 whereas positive numbers are limited to INT64_MAX.\n+  // Performance note: This check is only needed when digit_count == longest_digit_count but it is\n+  // so cheap that we might as well always make it.\n+  if(i > uint64_t(INT64_MAX) + uint64_t(negative)) { return INCORRECT_TYPE; }\n+  return negative ? (~i+1) : i;\n+}\n+\n+// Parse any number from  -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\n+// Never read at src_end or beyond\n+simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer(const uint8_t * const src, const uint8_t * const src_end) noexcept {\n+  //\n+  // Check for minus sign\n+  //\n+  if(src == src_end) { return NUMBER_ERROR; }\n+  bool negative = (*src == '-');\n+  const uint8_t *p = src + negative;\n+\n+  //\n+  // Parse the integer part.\n+  //\n+  // PERF NOTE: we don't use is_made_of_eight_digits_fast because large integers like 123456789 are rare\n+  const uint8_t *const start_digits = p;\n+  uint64_t i = 0;\n+  while ((p != src_end) && parse_digit(*p, i)) { p++; }\n+\n+  // If there were no digits, or if the integer starts with 0 and has more than one digit, it's an error.\n+  // Optimization note: size_t is expected to be unsigned.\n+  size_t digit_count = size_t(p - start_digits);\n+  // We go from\n+  // -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\n+  // so we can never represent numbers that have more than 19 digits.\n+  size_t longest_digit_count = 19;\n+  // Optimization note: the compiler can probably merge\n+  // ((digit_count == 0) || (digit_count > longest_digit_count))\n+  // into a single  branch since digit_count is unsigned.\n+  if ((digit_count == 0) || (digit_count > longest_digit_count)) { return INCORRECT_TYPE; }\n+  // Here digit_count > 0.\n+  if (('0' == *start_digits) && (digit_count > 1)) { return NUMBER_ERROR; }\n+  // We can do the following...\n+  // if (!jsoncharutils::is_structural_or_whitespace(*p)) {\n+  //  return (*p == '.' || *p == 'e' || *p == 'E') ? INCORRECT_TYPE : NUMBER_ERROR;\n+  // }\n+  // as a single table lookup:\n+  if((p != src_end) && integer_string_finisher[*p] != SUCCESS) { return error_code(integer_string_finisher[*p]); }\n+  // Negative numbers have can go down to - INT64_MAX - 1 whereas positive numbers are limited to INT64_MAX.\n+  // Performance note: This check is only needed when digit_count == longest_digit_count but it is\n+  // so cheap that we might as well always make it.\n+  if(i > uint64_t(INT64_MAX) + uint64_t(negative)) { return INCORRECT_TYPE; }\n+  return negative ? (~i+1) : i;\n+}\n+\n+// Parse any number from  -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\n+simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer_in_string(const uint8_t *src) noexcept {\n+  //\n+  // Check for minus sign\n+  //\n+  bool negative = (*(src + 1) == '-');\n+  const uint8_t *p = src + negative + 1;\n+\n+  //\n+  // Parse the integer part.\n+  //\n+  // PERF NOTE: we don't use is_made_of_eight_digits_fast because large integers like 123456789 are rare\n+  const uint8_t *const start_digits = p;\n+  uint64_t i = 0;\n+  while (parse_digit(*p, i)) { p++; }\n+\n+  // If there were no digits, or if the integer starts with 0 and has more than one digit, it's an error.\n+  // Optimization note: size_t is expected to be unsigned.\n+  size_t digit_count = size_t(p - start_digits);\n+  // We go from\n+  // -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\n+  // so we can never represent numbers that have more than 19 digits.\n+  size_t longest_digit_count = 19;\n+  // Optimization note: the compiler can probably merge\n+  // ((digit_count == 0) || (digit_count > longest_digit_count))\n+  // into a single  branch since digit_count is unsigned.\n+  if ((digit_count == 0) || (digit_count > longest_digit_count)) { return INCORRECT_TYPE; }\n+  // Here digit_count > 0.\n+  if (('0' == *start_digits) && (digit_count > 1)) { return NUMBER_ERROR; }\n+  // We can do the following...\n+  // if (!jsoncharutils::is_structural_or_whitespace(*p)) {\n+  //  return (*p == '.' || *p == 'e' || *p == 'E') ? INCORRECT_TYPE : NUMBER_ERROR;\n+  // }\n+  // as a single table lookup:\n+  if(*p != '\"') { return NUMBER_ERROR; }\n+  // Negative numbers have can go down to - INT64_MAX - 1 whereas positive numbers are limited to INT64_MAX.\n+  // Performance note: This check is only needed when digit_count == longest_digit_count but it is\n+  // so cheap that we might as well always make it.\n+  if(i > uint64_t(INT64_MAX) + uint64_t(negative)) { return INCORRECT_TYPE; }\n   return negative ? (~i+1) : i;\n }\n \n@@ -845,6 +1043,199 @@ simdjson_unused simdjson_really_inline simdjson_result<double> parse_double(cons\n   }\n   return d;\n }\n+\n+simdjson_unused simdjson_really_inline bool is_negative(const uint8_t * src) noexcept {\n+  return (*src == '-');\n+}\n+\n+simdjson_unused simdjson_really_inline simdjson_result<bool> is_integer(const uint8_t * src) noexcept {\n+  bool negative = (*src == '-');\n+  src += negative;\n+  const uint8_t *p = src;\n+  while(static_cast<uint8_t>(*p - '0') <= 9) { p++; }\n+  if ( p == src ) { return NUMBER_ERROR; }\n+  if (jsoncharutils::is_structural_or_whitespace(*p)) { return true; }\n+  return false;\n+}\n+\n+simdjson_unused simdjson_really_inline simdjson_result<ondemand::number_type> get_number_type(const uint8_t * src) noexcept {\n+  bool negative = (*src == '-');\n+  src += negative;\n+  const uint8_t *p = src;\n+  while(static_cast<uint8_t>(*p - '0') <= 9) { p++; }\n+  if ( p == src ) { return NUMBER_ERROR; }\n+  if (jsoncharutils::is_structural_or_whitespace(*p)) {\n+    int digit_count = int(p - src);\n+    if(digit_count >= 19) {\n+      const uint8_t * smaller_big_integer = reinterpret_cast<const uint8_t *>(\"9223372036854775808\");\n+      if((digit_count >= 20) || (memcmp(src, smaller_big_integer, 19) >= 0)) {\n+        return ondemand::number_type::unsigned_integer;\n+      }\n+    }\n+    return ondemand::number_type::signed_integer;\n+  }\n+  return ondemand::number_type::floating_point_number;\n+}\n+\n+// Never read at src_end or beyond\n+simdjson_unused simdjson_really_inline simdjson_result<double> parse_double(const uint8_t * src, const uint8_t * const src_end) noexcept {\n+  if(src == src_end) { return NUMBER_ERROR; }\n+  //\n+  // Check for minus sign\n+  //\n+  bool negative = (*src == '-');\n+  src += negative;\n+\n+  //\n+  // Parse the integer part.\n+  //\n+  uint64_t i = 0;\n+  const uint8_t *p = src;\n+  if(p == src_end) { return NUMBER_ERROR; }\n+  p += parse_digit(*p, i);\n+  bool leading_zero = (i == 0);\n+  while ((p != src_end) && parse_digit(*p, i)) { p++; }\n+  // no integer digits, or 0123 (zero must be solo)\n+  if ( p == src ) { return INCORRECT_TYPE; }\n+  if ( (leading_zero && p != src+1)) { return NUMBER_ERROR; }\n+\n+  //\n+  // Parse the decimal part.\n+  //\n+  int64_t exponent = 0;\n+  bool overflow;\n+  if (simdjson_likely((p != src_end) && (*p == '.'))) {\n+    p++;\n+    const uint8_t *start_decimal_digits = p;\n+    if ((p == src_end) || !parse_digit(*p, i)) { return NUMBER_ERROR; } // no decimal digits\n+    p++;\n+    while ((p != src_end) && parse_digit(*p, i)) { p++; }\n+    exponent = -(p - start_decimal_digits);\n+\n+    // Overflow check. More than 19 digits (minus the decimal) may be overflow.\n+    overflow = p-src-1 > 19;\n+    if (simdjson_unlikely(overflow && leading_zero)) {\n+      // Skip leading 0.00000 and see if it still overflows\n+      const uint8_t *start_digits = src + 2;\n+      while (*start_digits == '0') { start_digits++; }\n+      overflow = start_digits-src > 19;\n+    }\n+  } else {\n+    overflow = p-src > 19;\n+  }\n+\n+  //\n+  // Parse the exponent\n+  //\n+  if ((p != src_end) && (*p == 'e' || *p == 'E')) {\n+    p++;\n+    if(p == src_end) { return NUMBER_ERROR; }\n+    bool exp_neg = *p == '-';\n+    p += exp_neg || *p == '+';\n+\n+    uint64_t exp = 0;\n+    const uint8_t *start_exp_digits = p;\n+    while ((p != src_end) && parse_digit(*p, exp)) { p++; }\n+    // no exp digits, or 20+ exp digits\n+    if (p-start_exp_digits == 0 || p-start_exp_digits > 19) { return NUMBER_ERROR; }\n+\n+    exponent += exp_neg ? 0-exp : exp;\n+  }\n+\n+  if ((p != src_end) && jsoncharutils::is_not_structural_or_whitespace(*p)) { return NUMBER_ERROR; }\n+\n+  overflow = overflow || exponent < simdjson::internal::smallest_power || exponent > simdjson::internal::largest_power;\n+\n+  //\n+  // Assemble (or slow-parse) the float\n+  //\n+  double d;\n+  if (simdjson_likely(!overflow)) {\n+    if (compute_float_64(exponent, i, negative, d)) { return d; }\n+  }\n+  if (!parse_float_fallback(src-negative, src_end, &d)) {\n+    return NUMBER_ERROR;\n+  }\n+  return d;\n+}\n+\n+simdjson_unused simdjson_really_inline simdjson_result<double> parse_double_in_string(const uint8_t * src) noexcept {\n+  //\n+  // Check for minus sign\n+  //\n+  bool negative = (*(src + 1) == '-');\n+  src += negative + 1;\n+\n+  //\n+  // Parse the integer part.\n+  //\n+  uint64_t i = 0;\n+  const uint8_t *p = src;\n+  p += parse_digit(*p, i);\n+  bool leading_zero = (i == 0);\n+  while (parse_digit(*p, i)) { p++; }\n+  // no integer digits, or 0123 (zero must be solo)\n+  if ( p == src ) { return INCORRECT_TYPE; }\n+  if ( (leading_zero && p != src+1)) { return NUMBER_ERROR; }\n+\n+  //\n+  // Parse the decimal part.\n+  //\n+  int64_t exponent = 0;\n+  bool overflow;\n+  if (simdjson_likely(*p == '.')) {\n+    p++;\n+    const uint8_t *start_decimal_digits = p;\n+    if (!parse_digit(*p, i)) { return NUMBER_ERROR; } // no decimal digits\n+    p++;\n+    while (parse_digit(*p, i)) { p++; }\n+    exponent = -(p - start_decimal_digits);\n+\n+    // Overflow check. More than 19 digits (minus the decimal) may be overflow.\n+    overflow = p-src-1 > 19;\n+    if (simdjson_unlikely(overflow && leading_zero)) {\n+      // Skip leading 0.00000 and see if it still overflows\n+      const uint8_t *start_digits = src + 2;\n+      while (*start_digits == '0') { start_digits++; }\n+      overflow = start_digits-src > 19;\n+    }\n+  } else {\n+    overflow = p-src > 19;\n+  }\n+\n+  //\n+  // Parse the exponent\n+  //\n+  if (*p == 'e' || *p == 'E') {\n+    p++;\n+    bool exp_neg = *p == '-';\n+    p += exp_neg || *p == '+';\n+\n+    uint64_t exp = 0;\n+    const uint8_t *start_exp_digits = p;\n+    while (parse_digit(*p, exp)) { p++; }\n+    // no exp digits, or 20+ exp digits\n+    if (p-start_exp_digits == 0 || p-start_exp_digits > 19) { return NUMBER_ERROR; }\n+\n+    exponent += exp_neg ? 0-exp : exp;\n+  }\n+\n+  if (*p != '\"') { return NUMBER_ERROR; }\n+\n+  overflow = overflow || exponent < simdjson::internal::smallest_power || exponent > simdjson::internal::largest_power;\n+\n+  //\n+  // Assemble (or slow-parse) the float\n+  //\n+  double d;\n+  if (simdjson_likely(!overflow)) {\n+    if (compute_float_64(exponent, i, negative, d)) { return d; }\n+  }\n+  if (!parse_float_fallback(src-negative, &d)) {\n+    return NUMBER_ERROR;\n+  }\n+  return d;\n+}\n } //namespace {}\n #endif // SIMDJSON_SKIPNUMBERPARSING\n \n--- vendor/simdjson/include/simdjson/generic/ondemand-inl.h\n@@ -12,3 +12,5 @@\n #include \"simdjson/generic/ondemand/field-inl.h\"\n #include \"simdjson/generic/ondemand/object-inl.h\"\n #include \"simdjson/generic/ondemand/parser-inl.h\"\n+#include \"simdjson/generic/ondemand/document_stream-inl.h\"\n+#include \"simdjson/generic/ondemand/serialization-inl.h\"\n--- vendor/simdjson/include/simdjson/generic/ondemand.h\n@@ -29,3 +29,5 @@ using depth_t = int32_t;\n #include \"simdjson/generic/ondemand/field.h\"\n #include \"simdjson/generic/ondemand/object.h\"\n #include \"simdjson/generic/ondemand/parser.h\"\n+#include \"simdjson/generic/ondemand/document_stream.h\"\n+#include \"simdjson/generic/ondemand/serialization.h\"\n--- vendor/simdjson/include/simdjson/generic/ondemand/array-inl.h\n@@ -57,8 +57,9 @@ simdjson_really_inline simdjson_result<array> array::start_root(value_iterator &\n   SIMDJSON_TRY( iter.start_root_array().get(has_value) );\n   return array(iter);\n }\n-simdjson_really_inline array array::started(value_iterator &iter) noexcept {\n-  simdjson_unused bool has_value = iter.started_array();\n+simdjson_really_inline simdjson_result<array> array::started(value_iterator &iter) noexcept {\n+  bool has_value;\n+  SIMDJSON_TRY(iter.started_array().get(has_value));\n   return array(iter);\n }\n \n@@ -71,6 +72,91 @@ simdjson_really_inline simdjson_result<array_iterator> array::begin() noexcept {\n simdjson_really_inline simdjson_result<array_iterator> array::end() noexcept {\n   return array_iterator(iter);\n }\n+simdjson_really_inline error_code array::consume() noexcept {\n+  auto error = iter.json_iter().skip_child(iter.depth()-1);\n+  if(error) { iter.abandon(); }\n+  return error;\n+}\n+\n+simdjson_really_inline simdjson_result<std::string_view> array::raw_json() noexcept {\n+  const uint8_t * starting_point{iter.peek_start()};\n+  auto error = consume();\n+  if(error) { return error; }\n+  // After 'consume()', we could be left pointing just beyond the document, but that\n+  // is ok because we are not going to dereference the final pointer position, we just\n+  // use it to compute the length in bytes.\n+  const uint8_t * final_point{iter._json_iter->unsafe_pointer()};\n+  return std::string_view(reinterpret_cast<const char*>(starting_point), size_t(final_point - starting_point));\n+}\n+\n+SIMDJSON_DISABLE_STRICT_OVERFLOW_WARNING\n+simdjson_really_inline simdjson_result<size_t> array::count_elements() & noexcept {\n+  size_t count{0};\n+  // Important: we do not consume any of the values.\n+  for(simdjson_unused auto v : *this) { count++; }\n+  // The above loop will always succeed, but we want to report errors.\n+  if(iter.error()) { return iter.error(); }\n+  // We need to move back at the start because we expect users to iterate through\n+  // the array after counting the number of elements.\n+  iter.reset_array();\n+  return count;\n+}\n+\n+simdjson_really_inline simdjson_result<bool> array::is_empty() & noexcept {\n+  bool is_not_empty;\n+  auto error = iter.reset_array().get(is_not_empty);\n+  if(error) { return error; }\n+  return !is_not_empty;\n+}\n+\n+inline simdjson_result<bool> array::reset() & noexcept {\n+  return iter.reset_array();\n+}\n+\n+inline simdjson_result<value> array::at_pointer(std::string_view json_pointer) noexcept {\n+  if (json_pointer[0] != '/') { return INVALID_JSON_POINTER; }\n+  json_pointer = json_pointer.substr(1);\n+  // - means \"the append position\" or \"the element after the end of the array\"\n+  // We don't support this, because we're returning a real element, not a position.\n+  if (json_pointer == \"-\") { return INDEX_OUT_OF_BOUNDS; }\n+\n+  // Read the array index\n+  size_t array_index = 0;\n+  size_t i;\n+  for (i = 0; i < json_pointer.length() && json_pointer[i] != '/'; i++) {\n+    uint8_t digit = uint8_t(json_pointer[i] - '0');\n+    // Check for non-digit in array index. If it's there, we're trying to get a field in an object\n+    if (digit > 9) { return INCORRECT_TYPE; }\n+    array_index = array_index*10 + digit;\n+  }\n+\n+  // 0 followed by other digits is invalid\n+  if (i > 1 && json_pointer[0] == '0') { return INVALID_JSON_POINTER; } // \"JSON pointer array index has other characters after 0\"\n+\n+  // Empty string is invalid; so is a \"/\" with no digits before it\n+  if (i == 0) { return INVALID_JSON_POINTER; } // \"Empty string in JSON pointer array index\"\n+  // Get the child\n+  auto child = at(array_index);\n+  // If there is an error, it ends here\n+  if(child.error()) {\n+    return child;\n+  }\n+\n+  // If there is a /, we're not done yet, call recursively.\n+  if (i < json_pointer.length()) {\n+    child = child.at_pointer(json_pointer.substr(i));\n+  }\n+  return child;\n+}\n+\n+simdjson_really_inline simdjson_result<value> array::at(size_t index) noexcept {\n+  size_t i = 0;\n+  for (auto value : *this) {\n+    if (i == index) { return value; }\n+    i++;\n+  }\n+  return INDEX_OUT_OF_BOUNDS;\n+}\n \n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n@@ -101,5 +187,20 @@ simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_\n   if (error()) { return error(); }\n   return first.end();\n }\n-\n+simdjson_really_inline  simdjson_result<size_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array>::count_elements() & noexcept {\n+  if (error()) { return error(); }\n+  return first.count_elements();\n+}\n+simdjson_really_inline  simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array>::is_empty() & noexcept {\n+  if (error()) { return error(); }\n+  return first.is_empty();\n+}\n+simdjson_really_inline  simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array>::at(size_t index) noexcept {\n+  if (error()) { return error(); }\n+  return first.at(index);\n+}\n+simdjson_really_inline  simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array>::at_pointer(std::string_view json_pointer) noexcept {\n+  if (error()) { return error(); }\n+  return first.at_pointer(json_pointer);\n+}\n } // namespace simdjson\n--- vendor/simdjson/include/simdjson/generic/ondemand/array.h\n@@ -31,8 +31,91 @@ class array {\n    * Part of the std::iterable interface.\n    */\n   simdjson_really_inline simdjson_result<array_iterator> end() noexcept;\n+  /**\n+   * This method scans the array and counts the number of elements.\n+   * The count_elements method should always be called before you have begun\n+   * iterating through the array: it is expected that you are pointing at\n+   * the beginning of the array.\n+   * The runtime complexity is linear in the size of the array. After\n+   * calling this function, if successful, the array is 'rewinded' at its\n+   * beginning as if it had never been accessed. If the JSON is malformed (e.g.,\n+   * there is a missing comma), then an error is returned and it is no longer\n+   * safe to continue.\n+   *\n+   * To check that an array is empty, it is more performant to use\n+   * the is_empty() method.\n+   */\n+  simdjson_really_inline simdjson_result<size_t> count_elements() & noexcept;\n+  /**\n+   * This method scans the beginning of the array and checks whether the\n+   * array is empty.\n+   * The runtime complexity is constant time. After\n+   * calling this function, if successful, the array is 'rewinded' at its\n+   * beginning as if it had never been accessed. If the JSON is malformed (e.g.,\n+   * there is a missing comma), then an error is returned and it is no longer\n+   * safe to continue.\n+   */\n+  simdjson_really_inline simdjson_result<bool> is_empty() & noexcept;\n+  /**\n+   * Reset the iterator so that we are pointing back at the\n+   * beginning of the array. You should still consume values only once even if you\n+   * can iterate through the array more than once. If you unescape a string\n+   * within the array more than once, you have unsafe code. Note that rewinding\n+   * an array means that you may need to reparse it anew: it is not a free\n+   * operation.\n+   *\n+   * @returns true if the array contains some elements (not empty)\n+   */\n+  inline simdjson_result<bool> reset() & noexcept;\n+  /**\n+   * Get the value associated with the given JSON pointer.  We use the RFC 6901\n+   * https://tools.ietf.org/html/rfc6901 standard, interpreting the current node\n+   * as the root of its own JSON document.\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"([ { \"foo\": { \"a\": [ 10, 20, 30 ] }} ])\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"/0/foo/a/1\") == 20\n+   *\n+   * Note that at_pointer() called on the document automatically calls the document's rewind\n+   * method between each call. It invalidates all previously accessed arrays, objects and values\n+   * that have not been consumed. Yet it is not the case when calling at_pointer on an array\n+   * instance: there is no rewind and no invalidation.\n+   *\n+   * You may only call at_pointer on an array after it has been created, but before it has\n+   * been first accessed. When calling at_pointer on an array, the pointer is advanced to\n+   * the location indicated by the JSON pointer (in case of success). It is no longer possible\n+   * to call at_pointer on the same array.\n+   *\n+   * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching.\n+   *\n+   * @return The value associated with the given JSON pointer, or:\n+   *         - NO_SUCH_FIELD if a field does not exist in an object\n+   *         - INDEX_OUT_OF_BOUNDS if an array index is larger than an array length\n+   *         - INCORRECT_TYPE if a non-integer is used to access an array\n+   *         - INVALID_JSON_POINTER if the JSON pointer is invalid and cannot be parsed\n+   */\n+  inline simdjson_result<value> at_pointer(std::string_view json_pointer) noexcept;\n+  /**\n+   * Consumes the array and returns a string_view instance corresponding to the\n+   * array as represented in JSON. It points inside the original document.\n+   */\n+  simdjson_really_inline simdjson_result<std::string_view> raw_json() noexcept;\n \n+  /**\n+   * Get the value at the given index. This function has linear-time complexity.\n+   * This function should only be called once as the array iterator is not reset between each call.\n+   *\n+   * @return The value at the given index, or:\n+   *         - INDEX_OUT_OF_BOUNDS if the array index is larger than an array length\n+   */\n+  simdjson_really_inline simdjson_result<value> at(size_t index) noexcept;\n protected:\n+  /**\n+   * Go to the end of the array, no matter where you are right now.\n+   */\n+  simdjson_really_inline error_code consume() noexcept;\n+\n   /**\n    * Begin array iteration.\n    *\n@@ -58,7 +141,7 @@ class array {\n    *\n    * @param iter The iterator. Must be after the initial [. Will be *moved* into the resulting array.\n    */\n-  static simdjson_really_inline array started(value_iterator &iter) noexcept;\n+  static simdjson_really_inline simdjson_result<array> started(value_iterator &iter) noexcept;\n \n   /**\n    * Create an array at the given Internal array creation. Call array::start() or array::started() instead of this.\n@@ -98,6 +181,11 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array> : public SIMDJS\n \n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> begin() noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> end() noexcept;\n+  inline simdjson_result<size_t> count_elements() & noexcept;\n+  inline simdjson_result<bool> is_empty() & noexcept;\n+  inline simdjson_result<bool> reset() & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at(size_t index) noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at_pointer(std::string_view json_pointer) noexcept;\n };\n \n } // namespace simdjson\n--- vendor/simdjson/include/simdjson/generic/ondemand/array_iterator-inl.h\n@@ -20,9 +20,9 @@ simdjson_really_inline array_iterator &array_iterator::operator++() noexcept {\n   error_code error;\n   // PERF NOTE this is a safety rail ... users should exit loops as soon as they receive an error, so we'll never get here.\n   // However, it does not seem to make a perf difference, so we add it out of an abundance of caution.\n-  if ((error = iter.error()) ) { return *this; }\n-  if ((error = iter.skip_child() )) { return *this; }\n-  if ((error = iter.has_next_element().error() )) { return *this; }\n+  if (( error = iter.error() )) { return *this; }\n+  if (( error = iter.skip_child() )) { return *this; }\n+  if (( error = iter.has_next_element().error() )) { return *this; }\n   return *this;\n }\n \n--- vendor/simdjson/include/simdjson/generic/ondemand/document-inl.h\n@@ -12,14 +12,48 @@ simdjson_really_inline document document::start(json_iterator &&iter) noexcept {\n   return document(std::forward<json_iterator>(iter));\n }\n \n+inline void document::rewind() noexcept {\n+  iter.rewind();\n+}\n+\n+inline std::string document::to_debug_string() noexcept {\n+  return iter.to_string();\n+}\n+\n+inline simdjson_result<const char *> document::current_location() noexcept {\n+  return iter.current_location();\n+}\n+\n+inline bool document::is_alive() noexcept {\n+  return iter.is_alive();\n+}\n simdjson_really_inline value_iterator document::resume_value_iterator() noexcept {\n-  return value_iterator(&iter, 1, iter.root_checkpoint());\n+  return value_iterator(&iter, 1, iter.root_position());\n }\n simdjson_really_inline value_iterator document::get_root_value_iterator() noexcept {\n   return resume_value_iterator();\n }\n-simdjson_really_inline value document::resume_value() noexcept {\n-  return resume_value_iterator();\n+simdjson_really_inline simdjson_result<object> document::start_or_resume_object() noexcept {\n+  if (iter.at_root()) {\n+    return get_object();\n+  } else {\n+    return object::resume(resume_value_iterator());\n+  }\n+}\n+simdjson_really_inline simdjson_result<value> document::get_value() noexcept {\n+  // Make sure we start any arrays or objects before returning, so that start_root_<object/array>()\n+  // gets called.\n+  iter.assert_at_document_depth();\n+  switch (*iter.peek()) {\n+    case '[':\n+    case '{':\n+      return value(get_root_value_iterator());\n+    default:\n+      // Unfortunately, scalar documents are a special case in simdjson and they cannot\n+      // be safely converted to value instances.\n+      return SCALAR_DOCUMENT_AS_VALUE;\n+      // return value(get_root_value_iterator());\n+  }\n }\n simdjson_really_inline simdjson_result<array> document::get_array() & noexcept {\n   auto value = get_root_value_iterator();\n@@ -32,12 +66,21 @@ simdjson_really_inline simdjson_result<object> document::get_object() & noexcept\n simdjson_really_inline simdjson_result<uint64_t> document::get_uint64() noexcept {\n   return get_root_value_iterator().get_root_uint64();\n }\n+simdjson_really_inline simdjson_result<uint64_t> document::get_uint64_in_string() noexcept {\n+  return get_root_value_iterator().get_root_uint64_in_string();\n+}\n simdjson_really_inline simdjson_result<int64_t> document::get_int64() noexcept {\n   return get_root_value_iterator().get_root_int64();\n }\n+simdjson_really_inline simdjson_result<int64_t> document::get_int64_in_string() noexcept {\n+  return get_root_value_iterator().get_root_int64_in_string();\n+}\n simdjson_really_inline simdjson_result<double> document::get_double() noexcept {\n   return get_root_value_iterator().get_root_double();\n }\n+simdjson_really_inline simdjson_result<double> document::get_double_in_string() noexcept {\n+  return get_root_value_iterator().get_root_double_in_string();\n+}\n simdjson_really_inline simdjson_result<std::string_view> document::get_string() noexcept {\n   return get_root_value_iterator().get_root_string();\n }\n@@ -59,13 +102,15 @@ template<> simdjson_really_inline simdjson_result<double> document::get() & noex\n template<> simdjson_really_inline simdjson_result<uint64_t> document::get() & noexcept { return get_uint64(); }\n template<> simdjson_really_inline simdjson_result<int64_t> document::get() & noexcept { return get_int64(); }\n template<> simdjson_really_inline simdjson_result<bool> document::get() & noexcept { return get_bool(); }\n+template<> simdjson_really_inline simdjson_result<value> document::get() & noexcept { return get_value(); }\n \n template<> simdjson_really_inline simdjson_result<raw_json_string> document::get() && noexcept { return get_raw_json_string(); }\n template<> simdjson_really_inline simdjson_result<std::string_view> document::get() && noexcept { return get_string(); }\n template<> simdjson_really_inline simdjson_result<double> document::get() && noexcept { return std::forward<document>(*this).get_double(); }\n template<> simdjson_really_inline simdjson_result<uint64_t> document::get() && noexcept { return std::forward<document>(*this).get_uint64(); }\n template<> simdjson_really_inline simdjson_result<int64_t> document::get() && noexcept { return std::forward<document>(*this).get_int64(); }\n template<> simdjson_really_inline simdjson_result<bool> document::get() && noexcept { return std::forward<document>(*this).get_bool(); }\n+template<> simdjson_really_inline simdjson_result<value> document::get() && noexcept { return get_value(); }\n \n template<typename T> simdjson_really_inline error_code document::get(T &out) & noexcept {\n   return get<T>().get(out);\n@@ -83,8 +128,33 @@ simdjson_really_inline document::operator double() noexcept(false) { return get_\n simdjson_really_inline document::operator std::string_view() noexcept(false) { return get_string(); }\n simdjson_really_inline document::operator raw_json_string() noexcept(false) { return get_raw_json_string(); }\n simdjson_really_inline document::operator bool() noexcept(false) { return get_bool(); }\n-#endif\n+simdjson_really_inline document::operator value() noexcept(false) { return get_value(); }\n \n+#endif\n+simdjson_really_inline simdjson_result<size_t> document::count_elements() & noexcept {\n+  auto a = get_array();\n+  simdjson_result<size_t> answer = a.count_elements();\n+  /* If there was an array, we are now left pointing at its first element. */\n+  if(answer.error() == SUCCESS) {\n+    iter._depth = 1 ; /* undoing the increment so we go back at the doc depth.*/\n+    iter.assert_at_document_depth();\n+  }\n+  return answer;\n+}\n+simdjson_really_inline simdjson_result<size_t> document::count_fields() & noexcept {\n+  auto a = get_object();\n+  simdjson_result<size_t> answer = a.count_fields();\n+  /* If there was an array, we are now left pointing at its first element. */\n+  if(answer.error() == SUCCESS) {\n+    iter._depth = 1 ; /* undoing the increment so we go back at the doc depth.*/\n+    iter.assert_at_document_depth();\n+  }\n+  return answer;\n+}\n+simdjson_really_inline simdjson_result<value> document::at(size_t index) & noexcept {\n+  auto a = get_array();\n+  return a.at(index);\n+}\n simdjson_really_inline simdjson_result<array_iterator> document::begin() & noexcept {\n   return get_array().begin();\n }\n@@ -93,33 +163,93 @@ simdjson_really_inline simdjson_result<array_iterator> document::end() & noexcep\n }\n \n simdjson_really_inline simdjson_result<value> document::find_field(std::string_view key) & noexcept {\n-  return resume_value().find_field(key);\n+  return start_or_resume_object().find_field(key);\n }\n simdjson_really_inline simdjson_result<value> document::find_field(const char *key) & noexcept {\n-  return resume_value().find_field(key);\n+  return start_or_resume_object().find_field(key);\n }\n simdjson_really_inline simdjson_result<value> document::find_field_unordered(std::string_view key) & noexcept {\n-  return resume_value().find_field_unordered(key);\n+  return start_or_resume_object().find_field_unordered(key);\n }\n simdjson_really_inline simdjson_result<value> document::find_field_unordered(const char *key) & noexcept {\n-  return resume_value().find_field_unordered(key);\n+  return start_or_resume_object().find_field_unordered(key);\n }\n simdjson_really_inline simdjson_result<value> document::operator[](std::string_view key) & noexcept {\n-  return resume_value()[key];\n+  return start_or_resume_object()[key];\n }\n simdjson_really_inline simdjson_result<value> document::operator[](const char *key) & noexcept {\n-  return resume_value()[key];\n+  return start_or_resume_object()[key];\n+}\n+\n+simdjson_really_inline error_code document::consume() noexcept {\n+  auto error = iter.skip_child(0);\n+  if(error) { iter.abandon(); }\n+  return error;\n+}\n+\n+simdjson_really_inline simdjson_result<std::string_view> document::raw_json() noexcept {\n+  auto _iter = get_root_value_iterator();\n+  const uint8_t * starting_point{_iter.peek_start()};\n+  auto error = consume();\n+  if(error) { return error; }\n+  // After 'consume()', we could be left pointing just beyond the document, but that\n+  // is ok because we are not going to dereference the final pointer position, we just\n+  // use it to compute the length in bytes.\n+  const uint8_t * final_point{iter.unsafe_pointer()};\n+  return std::string_view(reinterpret_cast<const char*>(starting_point), size_t(final_point - starting_point));\n }\n \n simdjson_really_inline simdjson_result<json_type> document::type() noexcept {\n   return get_root_value_iterator().type();\n }\n \n+simdjson_really_inline simdjson_result<bool> document::is_scalar() noexcept {\n+  json_type this_type;\n+  auto error = type().get(this_type);\n+  if(error) { return error; }\n+  return ! ((this_type == json_type::array) || (this_type == json_type::object));\n+}\n+\n+simdjson_really_inline bool document::is_negative() noexcept {\n+  return get_root_value_iterator().is_root_negative();\n+}\n+\n+simdjson_really_inline simdjson_result<bool> document::is_integer() noexcept {\n+  return get_root_value_iterator().is_root_integer();\n+}\n+\n+simdjson_really_inline simdjson_result<number_type> document::get_number_type() noexcept {\n+  return get_root_value_iterator().get_root_number_type();\n+}\n+\n+simdjson_really_inline simdjson_result<number> document::get_number() noexcept {\n+  return get_root_value_iterator().get_root_number();\n+}\n+\n+\n simdjson_really_inline simdjson_result<std::string_view> document::raw_json_token() noexcept {\n   auto _iter = get_root_value_iterator();\n   return std::string_view(reinterpret_cast<const char*>(_iter.peek_start()), _iter.peek_start_length());\n }\n \n+simdjson_really_inline simdjson_result<value> document::at_pointer(std::string_view json_pointer) noexcept {\n+  rewind(); // Rewind the document each time at_pointer is called\n+  if (json_pointer.empty()) {\n+    return this->get_value();\n+  }\n+  json_type t;\n+  SIMDJSON_TRY(type().get(t));\n+  switch (t)\n+  {\n+    case json_type::array:\n+      return (*this).get_array().at_pointer(json_pointer);\n+    case json_type::object:\n+      return (*this).get_object().at_pointer(json_pointer);\n+    default:\n+      return INVALID_JSON_POINTER;\n+  }\n+}\n+\n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n@@ -142,7 +272,23 @@ simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::docume\n     )\n {\n }\n-\n+simdjson_really_inline simdjson_result<size_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::count_elements() & noexcept {\n+  if (error()) { return error(); }\n+  return first.count_elements();\n+}\n+simdjson_really_inline simdjson_result<size_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::count_fields() & noexcept {\n+  if (error()) { return error(); }\n+  return first.count_fields();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::at(size_t index) & noexcept {\n+  if (error()) { return error(); }\n+  return first.at(index);\n+}\n+simdjson_really_inline error_code simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::rewind() noexcept {\n+  if (error()) { return error(); }\n+  first.rewind();\n+  return SUCCESS;\n+}\n simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::begin() & noexcept {\n   if (error()) { return error(); }\n   return first.begin();\n@@ -206,6 +352,10 @@ simdjson_really_inline simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTA\n   if (error()) { return error(); }\n   return first.get_bool();\n }\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::get_value() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_value();\n+}\n simdjson_really_inline bool simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::is_null() noexcept {\n   if (error()) { return error(); }\n   return first.is_null();\n@@ -249,6 +399,33 @@ simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::json_t\n   return first.type();\n }\n \n+simdjson_really_inline simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::is_scalar() noexcept {\n+  if (error()) { return error(); }\n+  return first.is_scalar();\n+}\n+\n+\n+simdjson_really_inline bool simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::is_negative() noexcept {\n+  if (error()) { return error(); }\n+  return first.is_negative();\n+}\n+\n+simdjson_really_inline simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::is_integer() noexcept {\n+  if (error()) { return error(); }\n+  return first.is_integer();\n+}\n+\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number_type> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::get_number_type() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_number_type();\n+}\n+\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::get_number() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_number();\n+}\n+\n+\n #if SIMDJSON_EXCEPTIONS\n simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::operator SIMDJSON_IMPLEMENTATION::ondemand::array() & noexcept(false) {\n   if (error()) { throw simdjson_error(error()); }\n@@ -282,11 +459,260 @@ simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::docume\n   if (error()) { throw simdjson_error(error()); }\n   return first;\n }\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::operator SIMDJSON_IMPLEMENTATION::ondemand::value() noexcept(false) {\n+  if (error()) { throw simdjson_error(error()); }\n+  return first;\n+}\n #endif\n \n+\n+simdjson_really_inline simdjson_result<const char *> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::current_location() noexcept {\n+  if (error()) { return error(); }\n+  return first.current_location();\n+}\n+\n simdjson_really_inline simdjson_result<std::string_view> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::raw_json_token() noexcept {\n   if (error()) { return error(); }\n   return first.raw_json_token();\n }\n \n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::at_pointer(std::string_view json_pointer) noexcept {\n+  if (error()) { return error(); }\n+  return first.at_pointer(json_pointer);\n+}\n+\n+\n } // namespace simdjson\n+\n+\n+namespace simdjson {\n+namespace SIMDJSON_IMPLEMENTATION {\n+namespace ondemand {\n+\n+simdjson_really_inline document_reference::document_reference() noexcept : doc{nullptr} {}\n+simdjson_really_inline document_reference::document_reference(document &d) noexcept : doc(&d) {}\n+simdjson_really_inline void document_reference::rewind() noexcept { doc->rewind(); }\n+simdjson_really_inline simdjson_result<array> document_reference::get_array() & noexcept { return doc->get_array(); }\n+simdjson_really_inline simdjson_result<object> document_reference::get_object() & noexcept { return doc->get_object(); }\n+simdjson_really_inline simdjson_result<uint64_t> document_reference::get_uint64() noexcept { return doc->get_uint64(); }\n+simdjson_really_inline simdjson_result<int64_t> document_reference::get_int64() noexcept { return doc->get_int64(); }\n+simdjson_really_inline simdjson_result<double> document_reference::get_double() noexcept { return doc->get_double(); }\n+simdjson_really_inline simdjson_result<std::string_view> document_reference::get_string() noexcept { return doc->get_string(); }\n+simdjson_really_inline simdjson_result<raw_json_string> document_reference::get_raw_json_string() noexcept { return doc->get_raw_json_string(); }\n+simdjson_really_inline simdjson_result<bool> document_reference::get_bool() noexcept { return doc->get_bool(); }\n+simdjson_really_inline simdjson_result<value> document_reference::get_value() noexcept { return doc->get_value(); }\n+simdjson_really_inline bool document_reference::is_null() noexcept { return doc->is_null(); }\n+\n+#if SIMDJSON_EXCEPTIONS\n+simdjson_really_inline document_reference::operator array() & noexcept(false) { return array(*doc); }\n+simdjson_really_inline document_reference::operator object() & noexcept(false) { return object(*doc); }\n+simdjson_really_inline document_reference::operator uint64_t() noexcept(false) { return uint64_t(*doc); }\n+simdjson_really_inline document_reference::operator int64_t() noexcept(false) { return int64_t(*doc); }\n+simdjson_really_inline document_reference::operator double() noexcept(false) { return double(*doc); }\n+simdjson_really_inline document_reference::operator std::string_view() noexcept(false) { return std::string_view(*doc); }\n+simdjson_really_inline document_reference::operator raw_json_string() noexcept(false) { return raw_json_string(*doc); }\n+simdjson_really_inline document_reference::operator bool() noexcept(false) { return bool(*doc); }\n+simdjson_really_inline document_reference::operator value() noexcept(false) { return value(*doc); }\n+#endif\n+simdjson_really_inline simdjson_result<size_t> document_reference::count_elements() & noexcept { return doc->count_elements(); }\n+simdjson_really_inline simdjson_result<size_t> document_reference::count_fields() & noexcept { return doc->count_fields(); }\n+simdjson_really_inline simdjson_result<value> document_reference::at(size_t index) & noexcept { return doc->at(index); }\n+simdjson_really_inline simdjson_result<array_iterator> document_reference::begin() & noexcept { return doc->begin(); }\n+simdjson_really_inline simdjson_result<array_iterator> document_reference::end() & noexcept { return doc->end(); }\n+simdjson_really_inline simdjson_result<value> document_reference::find_field(std::string_view key) & noexcept { return doc->find_field(key); }\n+simdjson_really_inline simdjson_result<value> document_reference::find_field(const char *key) & noexcept { return doc->find_field(key); }\n+simdjson_really_inline simdjson_result<value> document_reference::operator[](std::string_view key) & noexcept { return (*doc)[key]; }\n+simdjson_really_inline simdjson_result<value> document_reference::operator[](const char *key) & noexcept { return (*doc)[key]; }\n+simdjson_really_inline simdjson_result<value> document_reference::find_field_unordered(std::string_view key) & noexcept { return doc->find_field_unordered(key); }\n+simdjson_really_inline simdjson_result<value> document_reference::find_field_unordered(const char *key) & noexcept { return doc->find_field_unordered(key); }\n+simdjson_really_inline simdjson_result<json_type> document_reference::type() noexcept { return doc->type(); }\n+simdjson_really_inline simdjson_result<bool> document_reference::is_scalar() noexcept { return doc->is_scalar(); }\n+simdjson_really_inline simdjson_result<const char *> document_reference::current_location() noexcept { return doc->current_location(); };\n+simdjson_really_inline bool document_reference::is_negative() noexcept { return doc->is_negative(); }\n+simdjson_really_inline simdjson_result<bool> document_reference::is_integer() noexcept { return doc->is_integer(); }\n+simdjson_really_inline simdjson_result<number_type> document_reference::get_number_type() noexcept { return doc->get_number_type(); }\n+simdjson_really_inline simdjson_result<number> document_reference::get_number() noexcept { return doc->get_number(); }\n+simdjson_really_inline simdjson_result<std::string_view> document_reference::raw_json_token() noexcept { return doc->raw_json_token(); }\n+simdjson_really_inline simdjson_result<value> document_reference::at_pointer(std::string_view json_pointer) noexcept { return doc->at_pointer(json_pointer); }\n+simdjson_really_inline simdjson_result<std::string_view> document_reference::raw_json() noexcept { return doc->raw_json();}\n+simdjson_really_inline document_reference::operator document&() const noexcept { return *doc; }\n+\n+} // namespace ondemand\n+} // namespace SIMDJSON_IMPLEMENTATION\n+} // namespace simdjson\n+\n+\n+\n+namespace simdjson {\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::simdjson_result(SIMDJSON_IMPLEMENTATION::ondemand::document_reference value, error_code error)\n+  noexcept : implementation_simdjson_result_base<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>(std::forward<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>(value), error) {}\n+\n+\n+simdjson_really_inline simdjson_result<size_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::count_elements() & noexcept {\n+  if (error()) { return error(); }\n+  return first.count_elements();\n+}\n+simdjson_really_inline simdjson_result<size_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::count_fields() & noexcept {\n+  if (error()) { return error(); }\n+  return first.count_fields();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::at(size_t index) & noexcept {\n+  if (error()) { return error(); }\n+  return first.at(index);\n+}\n+simdjson_really_inline error_code simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::rewind() noexcept {\n+  if (error()) { return error(); }\n+  first.rewind();\n+  return SUCCESS;\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::begin() & noexcept {\n+  if (error()) { return error(); }\n+  return first.begin();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::end() & noexcept {\n+  return {};\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::find_field_unordered(std::string_view key) & noexcept {\n+  if (error()) { return error(); }\n+  return first.find_field_unordered(key);\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::find_field_unordered(const char *key) & noexcept {\n+  if (error()) { return error(); }\n+  return first.find_field_unordered(key);\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::operator[](std::string_view key) & noexcept {\n+  if (error()) { return error(); }\n+  return first[key];\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::operator[](const char *key) & noexcept {\n+  if (error()) { return error(); }\n+  return first[key];\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::find_field(std::string_view key) & noexcept {\n+  if (error()) { return error(); }\n+  return first.find_field(key);\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::find_field(const char *key) & noexcept {\n+  if (error()) { return error(); }\n+  return first.find_field(key);\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::get_array() & noexcept {\n+  if (error()) { return error(); }\n+  return first.get_array();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::get_object() & noexcept {\n+  if (error()) { return error(); }\n+  return first.get_object();\n+}\n+simdjson_really_inline simdjson_result<uint64_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::get_uint64() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_uint64();\n+}\n+simdjson_really_inline simdjson_result<int64_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::get_int64() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_int64();\n+}\n+simdjson_really_inline simdjson_result<double> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::get_double() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_double();\n+}\n+simdjson_really_inline simdjson_result<std::string_view> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::get_string() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_string();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::raw_json_string> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::get_raw_json_string() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_raw_json_string();\n+}\n+simdjson_really_inline simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::get_bool() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_bool();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::get_value() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_value();\n+}\n+simdjson_really_inline bool simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::is_null() noexcept {\n+  if (error()) { return error(); }\n+  return first.is_null();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::json_type> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::type() noexcept {\n+  if (error()) { return error(); }\n+  return first.type();\n+}\n+simdjson_really_inline simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::is_scalar() noexcept {\n+  if (error()) { return error(); }\n+  return first.is_scalar();\n+}\n+simdjson_really_inline bool simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::is_negative() noexcept {\n+  if (error()) { return error(); }\n+  return first.is_negative();\n+}\n+simdjson_really_inline simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::is_integer() noexcept {\n+  if (error()) { return error(); }\n+  return first.is_integer();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number_type> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::get_number_type() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_number_type();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::get_number() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_number();\n+}\n+#if SIMDJSON_EXCEPTIONS\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::operator SIMDJSON_IMPLEMENTATION::ondemand::array() & noexcept(false) {\n+  if (error()) { throw simdjson_error(error()); }\n+  return first;\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::operator SIMDJSON_IMPLEMENTATION::ondemand::object() & noexcept(false) {\n+  if (error()) { throw simdjson_error(error()); }\n+  return first;\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::operator uint64_t() noexcept(false) {\n+  if (error()) { throw simdjson_error(error()); }\n+  return first;\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::operator int64_t() noexcept(false) {\n+  if (error()) { throw simdjson_error(error()); }\n+  return first;\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::operator double() noexcept(false) {\n+  if (error()) { throw simdjson_error(error()); }\n+  return first;\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::operator std::string_view() noexcept(false) {\n+  if (error()) { throw simdjson_error(error()); }\n+  return first;\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::operator SIMDJSON_IMPLEMENTATION::ondemand::raw_json_string() noexcept(false) {\n+  if (error()) { throw simdjson_error(error()); }\n+  return first;\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::operator bool() noexcept(false) {\n+  if (error()) { throw simdjson_error(error()); }\n+  return first;\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::operator SIMDJSON_IMPLEMENTATION::ondemand::value() noexcept(false) {\n+  if (error()) { throw simdjson_error(error()); }\n+  return first;\n+}\n+#endif\n+\n+simdjson_really_inline simdjson_result<const char *> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::current_location() noexcept {\n+  if (error()) { return error(); }\n+  return first.current_location();\n+}\n+\n+simdjson_really_inline simdjson_result<std::string_view> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::raw_json_token() noexcept {\n+  if (error()) { return error(); }\n+  return first.raw_json_token();\n+}\n+\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::at_pointer(std::string_view json_pointer) noexcept {\n+  if (error()) { return error(); }\n+  return first.at_pointer(json_pointer);\n+}\n+\n+\n+} // namespace simdjson\n\\ No newline at end of file\n--- vendor/simdjson/include/simdjson/generic/ondemand/document.h\n@@ -10,9 +10,10 @@ class object;\n class value;\n class raw_json_string;\n class array_iterator;\n+class document_stream;\n \n /**\n- * A JSON document iteration.\n+ * A JSON document. It holds a json_iterator instance.\n  *\n  * Used by tokens to get text, and string buffer location.\n  *\n@@ -26,7 +27,7 @@ class document {\n    * Exists so you can declare a variable and later assign to it before use.\n    */\n   simdjson_really_inline document() noexcept = default;\n-  simdjson_really_inline document(const document &other) noexcept = delete;\n+  simdjson_really_inline document(const document &other) noexcept = delete; // pass your documents by reference, not by copy\n   simdjson_really_inline document(document &&other) noexcept = default;\n   simdjson_really_inline document &operator=(const document &other) noexcept = delete;\n   simdjson_really_inline document &operator=(document &&other) noexcept = default;\n@@ -52,20 +53,42 @@ class document {\n    * @returns INCORRECT_TYPE If the JSON value is not a 64-bit unsigned integer.\n    */\n   simdjson_really_inline simdjson_result<uint64_t> get_uint64() noexcept;\n+  /**\n+   * Cast this JSON value (inside string) to an unsigned integer.\n+   *\n+   * @returns A signed 64-bit integer.\n+   * @returns INCORRECT_TYPE If the JSON value is not a 64-bit unsigned integer.\n+   */\n+  simdjson_really_inline simdjson_result<uint64_t> get_uint64_in_string() noexcept;\n   /**\n    * Cast this JSON value to a signed integer.\n    *\n    * @returns A signed 64-bit integer.\n    * @returns INCORRECT_TYPE If the JSON value is not a 64-bit integer.\n    */\n   simdjson_really_inline simdjson_result<int64_t> get_int64() noexcept;\n+  /**\n+   * Cast this JSON value (inside string) to a signed integer.\n+   *\n+   * @returns A signed 64-bit integer.\n+   * @returns INCORRECT_TYPE If the JSON value is not a 64-bit integer.\n+   */\n+  simdjson_really_inline simdjson_result<int64_t> get_int64_in_string() noexcept;\n   /**\n    * Cast this JSON value to a double.\n    *\n    * @returns A double.\n    * @returns INCORRECT_TYPE If the JSON value is not a valid floating-point number.\n    */\n   simdjson_really_inline simdjson_result<double> get_double() noexcept;\n+\n+  /**\n+   * Cast this JSON value (inside string) to a double.\n+   *\n+   * @returns A double.\n+   * @returns INCORRECT_TYPE If the JSON value is not a valid floating-point number.\n+   */\n+  simdjson_really_inline simdjson_result<double> get_double_in_string() noexcept;\n   /**\n    * Cast this JSON value to a string.\n    *\n@@ -92,6 +115,14 @@ class document {\n    * @returns INCORRECT_TYPE if the JSON value is not true or false.\n    */\n   simdjson_really_inline simdjson_result<bool> get_bool() noexcept;\n+  /**\n+   * Cast this JSON value to a value when the document is an object or an array.\n+   *\n+   * @returns A value if a JSON array or object cannot be found.\n+   * @returns SCALAR_DOCUMENT_AS_VALUE error is the document is a scalar (see is_scalar() function).\n+   */\n+  simdjson_really_inline simdjson_result<value> get_value() noexcept;\n+\n   /**\n    * Checks if this JSON value is null.\n    *\n@@ -125,7 +156,9 @@ class document {\n   /**\n    * Get this value as the given type.\n    *\n-   * Supported types: object, array, raw_json_string, string_view, uint64_t, int64_t, double, bool\n+   * Supported types: object, array, raw_json_string, string_view, uint64_t, int64_t, double, bool, value\n+   *\n+   * Be mindful that the document instance must remain in scope while you are accessing object, array and value instances.\n    *\n    * @param out This is set to a value of the given type, parsed from the JSON. If there is an error, this may not be initialized.\n    * @returns INCORRECT_TYPE If the JSON value is not an object.\n@@ -197,8 +230,49 @@ class document {\n    * @exception simdjson_error(INCORRECT_TYPE) if the JSON value is not true or false.\n    */\n   simdjson_really_inline operator bool() noexcept(false);\n+  /**\n+   * Cast this JSON value to a value.\n+   *\n+   * @returns A value value.\n+   * @exception if a JSON value cannot be found\n+   */\n+  simdjson_really_inline operator value() noexcept(false);\n #endif\n-\n+  /**\n+   * This method scans the array and counts the number of elements.\n+   * The count_elements method should always be called before you have begun\n+   * iterating through the array: it is expected that you are pointing at\n+   * the beginning of the array.\n+   * The runtime complexity is linear in the size of the array. After\n+   * calling this function, if successful, the array is 'rewinded' at its\n+   * beginning as if it had never been accessed. If the JSON is malformed (e.g.,\n+   * there is a missing comma), then an error is returned and it is no longer\n+   * safe to continue.\n+   */\n+  simdjson_really_inline simdjson_result<size_t> count_elements() & noexcept;\n+   /**\n+   * This method scans the object and counts the number of key-value pairs.\n+   * The count_fields method should always be called before you have begun\n+   * iterating through the object: it is expected that you are pointing at\n+   * the beginning of the object.\n+   * The runtime complexity is linear in the size of the object. After\n+   * calling this function, if successful, the object is 'rewinded' at its\n+   * beginning as if it had never been accessed. If the JSON is malformed (e.g.,\n+   * there is a missing comma), then an error is returned and it is no longer\n+   * safe to continue.\n+   *\n+   * To check that an object is empty, it is more performant to use\n+   * the is_empty() method.\n+   */\n+  simdjson_really_inline simdjson_result<size_t> count_fields() & noexcept;\n+  /**\n+   * Get the value at the given index in the array. This function has linear-time complexity.\n+   * This function should only be called once as the array iterator is not reset between each call.\n+   *\n+   * @return The value at the given index, or:\n+   *         - INDEX_OUT_OF_BOUNDS if the array index is larger than an array length\n+   */\n+  simdjson_really_inline simdjson_result<value> at(size_t index) & noexcept;\n   /**\n    * Begin array iteration.\n    *\n@@ -274,6 +348,77 @@ class document {\n    */\n   simdjson_really_inline simdjson_result<json_type> type() noexcept;\n \n+  /**\n+   * Checks whether the document is a scalar (string, number, null, Boolean).\n+   * Returns false when there it is an array or object.\n+   *\n+   * @returns true if the type is string, number, null, Boolean\n+   * @error TAPE_ERROR when the JSON value is a bad token like \"}\" \",\" or \"alse\".\n+   */\n+  simdjson_really_inline simdjson_result<bool> is_scalar() noexcept;\n+\n+  /**\n+   * Checks whether the document is a negative number.\n+   *\n+   * @returns true if the number if negative.\n+   */\n+  simdjson_really_inline bool is_negative() noexcept;\n+  /**\n+   * Checks whether the document is an integer number. Note that\n+   * this requires to partially parse the number string. If\n+   * the value is determined to be an integer, it may still\n+   * not parse properly as an integer in subsequent steps\n+   * (e.g., it might overflow).\n+   *\n+   * @returns true if the number if negative.\n+   */\n+  simdjson_really_inline simdjson_result<bool> is_integer() noexcept;\n+  /**\n+   * Determine the number type (integer or floating-point number).\n+   *\n+   * get_number_type() is number_type::unsigned_integer if we have\n+   * an integer greater or equal to 9223372036854775808\n+   * get_number_type() is number_type::signed_integer if we have an\n+   * integer that is less than 9223372036854775808\n+   * Otherwise, get_number_type() has value number_type::floating_point_number\n+   *\n+   * This function req\n+   * uires processing the number string, but it is expected\n+   * to be faster than get_number().get_number_type() because it is does not\n+   * parse the number value.\n+   *\n+   * @returns the type of the number\n+   */\n+  simdjson_really_inline simdjson_result<number_type> get_number_type() noexcept;\n+\n+  /**\n+   * Attempt to parse an ondemand::number. An ondemand::number may\n+   * contain an integer value or a floating-point value, the simdjson\n+   * library will autodetect the type. Thus it is a dynamically typed\n+   * number. Before accessing the value, you must determine the detected\n+   * type.\n+   *\n+   * number.get_number_type() is number_type::signed_integer if we have\n+   * a integer in [-9223372036854775808,9223372036854775808)\n+   * You can recover the value by calling number.get_int64() and you\n+   * have that number.is_int64() is true.\n+   *\n+   * number.get_number_type() is number_type::unsigned_integer if we have\n+   * an integer in [9223372036854775808,18446744073709551616)\n+   * You can recover the value by calling number.get_uint64() and you\n+   * have that number.is_uint64() is true.\n+   *\n+   * Otherwise, number.get_number_type() has value number_type::floating_point_number\n+   * and we have a binary64 number.\n+   * You can recover the value by calling number.get_double() and you\n+   * have that number.is_double() is true.\n+   *\n+   * You must check the type before accessing the value: it is an error\n+   * to call \"get_int64()\" when number.get_number_type() is not\n+   * number_type::signed_integer and when number.is_int64() is false.\n+   */\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<number> get_number() noexcept;\n+\n   /**\n    * Get the raw JSON for this token.\n    *\n@@ -298,13 +443,77 @@ class document {\n    */\n   simdjson_really_inline simdjson_result<std::string_view> raw_json_token() noexcept;\n \n+  /**\n+   * Reset the iterator inside the document instance so we are pointing back at the\n+   * beginning of the document, as if it had just been created. It invalidates all\n+   * values, objects and arrays that you have created so far (including unescaped strings).\n+   */\n+  inline void rewind() noexcept;\n+  /**\n+   * Returns debugging information.\n+   */\n+  inline std::string to_debug_string() noexcept;\n+  /**\n+   * Some unrecoverable error conditions may render the document instance unusable.\n+   * The is_alive() method returns true when the document is still suitable.\n+   */\n+  inline bool is_alive() noexcept;\n+\n+  /**\n+   * Returns the current location in the document if in bounds.\n+   */\n+  inline simdjson_result<const char *> current_location() noexcept;\n+\n+  /**\n+   * Get the value associated with the given JSON pointer.  We use the RFC 6901\n+   * https://tools.ietf.org/html/rfc6901 standard.\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"foo\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"/foo/a/1\") == 20\n+   *\n+   * It is allowed for a key to be the empty string:\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"//a/1\") == 20\n+   *\n+   * Note that at_pointer() automatically calls rewind between each call. Thus\n+   * all values, objects and arrays that you have created so far (including unescaped strings)\n+   * are invalidated. After calling at_pointer, you need to consume the result: string values\n+   * should be stored in your own variables, arrays should be decoded and stored in your own array-like\n+   * structures and so forth.\n+   *\n+   * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching\n+   *\n+   * @return The value associated with the given JSON pointer, or:\n+   *         - NO_SUCH_FIELD if a field does not exist in an object\n+   *         - INDEX_OUT_OF_BOUNDS if an array index is larger than an array length\n+   *         - INCORRECT_TYPE if a non-integer is used to access an array\n+   *         - INVALID_JSON_POINTER if the JSON pointer is invalid and cannot be parsed\n+   *         - SCALAR_DOCUMENT_AS_VALUE if the json_pointer is empty and the document is not a scalar (see is_scalar() function).\n+   */\n+  simdjson_really_inline simdjson_result<value> at_pointer(std::string_view json_pointer) noexcept;\n+  /**\n+   * Consumes the document and returns a string_view instance corresponding to the\n+   * document as represented in JSON. It points inside the original byte array containg\n+   * the JSON document.\n+   */\n+  simdjson_really_inline simdjson_result<std::string_view> raw_json() noexcept;\n protected:\n+  /**\n+   * Consumes the document.\n+   */\n+  simdjson_really_inline error_code consume() noexcept;\n+\n   simdjson_really_inline document(ondemand::json_iterator &&iter) noexcept;\n   simdjson_really_inline const uint8_t *text(uint32_t idx) const noexcept;\n \n   simdjson_really_inline value_iterator resume_value_iterator() noexcept;\n   simdjson_really_inline value_iterator get_root_value_iterator() noexcept;\n-  simdjson_really_inline value resume_value() noexcept;\n+  simdjson_really_inline simdjson_result<object> start_or_resume_object() noexcept;\n   static simdjson_really_inline document start(ondemand::json_iterator &&iter) noexcept;\n \n   //\n@@ -313,16 +522,76 @@ class document {\n   json_iterator iter{}; ///< Current position in the document\n   static constexpr depth_t DOCUMENT_DEPTH = 0; ///< document depth is always 0\n \n-  friend struct simdjson_result<document>;\n   friend class array_iterator;\n   friend class value;\n   friend class ondemand::parser;\n   friend class object;\n   friend class array;\n   friend class field;\n   friend class token;\n+  friend class document_stream;\n };\n \n+\n+/**\n+ * A document_reference is a thin wrapper around a document reference instance.\n+ */\n+class document_reference {\n+public:\n+  simdjson_really_inline document_reference() noexcept;\n+  simdjson_really_inline document_reference(document &d) noexcept;\n+  simdjson_really_inline document_reference(const document_reference &other) noexcept = default;\n+  simdjson_really_inline void rewind() noexcept;\n+  simdjson_really_inline simdjson_result<array> get_array() & noexcept;\n+  simdjson_really_inline simdjson_result<object> get_object() & noexcept;\n+  simdjson_really_inline simdjson_result<uint64_t> get_uint64() noexcept;\n+  simdjson_really_inline simdjson_result<int64_t> get_int64() noexcept;\n+  simdjson_really_inline simdjson_result<double> get_double() noexcept;\n+  simdjson_really_inline simdjson_result<std::string_view> get_string() noexcept;\n+  simdjson_really_inline simdjson_result<raw_json_string> get_raw_json_string() noexcept;\n+  simdjson_really_inline simdjson_result<bool> get_bool() noexcept;\n+  simdjson_really_inline simdjson_result<value> get_value() noexcept;\n+\n+  simdjson_really_inline bool is_null() noexcept;\n+  simdjson_really_inline simdjson_result<std::string_view> raw_json() noexcept;\n+  simdjson_really_inline operator document&() const noexcept;\n+\n+#if SIMDJSON_EXCEPTIONS\n+  simdjson_really_inline operator array() & noexcept(false);\n+  simdjson_really_inline operator object() & noexcept(false);\n+  simdjson_really_inline operator uint64_t() noexcept(false);\n+  simdjson_really_inline operator int64_t() noexcept(false);\n+  simdjson_really_inline operator double() noexcept(false);\n+  simdjson_really_inline operator std::string_view() noexcept(false);\n+  simdjson_really_inline operator raw_json_string() noexcept(false);\n+  simdjson_really_inline operator bool() noexcept(false);\n+  simdjson_really_inline operator value() noexcept(false);\n+#endif\n+  simdjson_really_inline simdjson_result<size_t> count_elements() & noexcept;\n+  simdjson_really_inline simdjson_result<size_t> count_fields() & noexcept;\n+  simdjson_really_inline simdjson_result<value> at(size_t index) & noexcept;\n+  simdjson_really_inline simdjson_result<array_iterator> begin() & noexcept;\n+  simdjson_really_inline simdjson_result<array_iterator> end() & noexcept;\n+  simdjson_really_inline simdjson_result<value> find_field(std::string_view key) & noexcept;\n+  simdjson_really_inline simdjson_result<value> find_field(const char *key) & noexcept;\n+  simdjson_really_inline simdjson_result<value> operator[](std::string_view key) & noexcept;\n+  simdjson_really_inline simdjson_result<value> operator[](const char *key) & noexcept;\n+  simdjson_really_inline simdjson_result<value> find_field_unordered(std::string_view key) & noexcept;\n+  simdjson_really_inline simdjson_result<value> find_field_unordered(const char *key) & noexcept;\n+\n+  simdjson_really_inline simdjson_result<json_type> type() noexcept;\n+  simdjson_really_inline simdjson_result<bool> is_scalar() noexcept;\n+\n+  simdjson_really_inline simdjson_result<const char *> current_location() noexcept;\n+  simdjson_really_inline bool is_negative() noexcept;\n+  simdjson_really_inline simdjson_result<bool> is_integer() noexcept;\n+  simdjson_really_inline simdjson_result<number_type> get_number_type() noexcept;\n+  simdjson_really_inline simdjson_result<number> get_number() noexcept;\n+  simdjson_really_inline simdjson_result<std::string_view> raw_json_token() noexcept;\n+  simdjson_really_inline simdjson_result<value> at_pointer(std::string_view json_pointer) noexcept;\n+private:\n+  document *doc{nullptr};\n+};\n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n@@ -335,15 +604,18 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document> : public SIM\n   simdjson_really_inline simdjson_result(SIMDJSON_IMPLEMENTATION::ondemand::document &&value) noexcept; ///< @private\n   simdjson_really_inline simdjson_result(error_code error) noexcept; ///< @private\n   simdjson_really_inline simdjson_result() noexcept = default;\n+  simdjson_really_inline error_code rewind() noexcept;\n \n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array> get_array() & noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> get_object() & noexcept;\n   simdjson_really_inline simdjson_result<uint64_t> get_uint64() noexcept;\n   simdjson_really_inline simdjson_result<int64_t> get_int64() noexcept;\n   simdjson_really_inline simdjson_result<double> get_double() noexcept;\n+  simdjson_really_inline simdjson_result<double> get_double_from_string() noexcept;\n   simdjson_really_inline simdjson_result<std::string_view> get_string() noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::raw_json_string> get_raw_json_string() noexcept;\n   simdjson_really_inline simdjson_result<bool> get_bool() noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> get_value() noexcept;\n   simdjson_really_inline bool is_null() noexcept;\n \n   template<typename T> simdjson_really_inline simdjson_result<T> get() & noexcept;\n@@ -361,8 +633,11 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document> : public SIM\n   simdjson_really_inline operator std::string_view() noexcept(false);\n   simdjson_really_inline operator SIMDJSON_IMPLEMENTATION::ondemand::raw_json_string() noexcept(false);\n   simdjson_really_inline operator bool() noexcept(false);\n+  simdjson_really_inline operator SIMDJSON_IMPLEMENTATION::ondemand::value() noexcept(false);\n #endif\n-\n+  simdjson_really_inline simdjson_result<size_t> count_elements() & noexcept;\n+  simdjson_really_inline simdjson_result<size_t> count_fields() & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at(size_t index) & noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> begin() & noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> end() & noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field(std::string_view key) & noexcept;\n@@ -371,11 +646,78 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document> : public SIM\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> operator[](const char *key) & noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(std::string_view key) & noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(const char *key) & noexcept;\n-\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::json_type> type() noexcept;\n-\n+  simdjson_really_inline simdjson_result<bool> is_scalar() noexcept;\n+  simdjson_really_inline simdjson_result<const char *> current_location() noexcept;\n+  simdjson_really_inline bool is_negative() noexcept;\n+  simdjson_really_inline simdjson_result<bool> is_integer() noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number_type> get_number_type() noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number> get_number() noexcept;\n   /** @copydoc simdjson_really_inline std::string_view document::raw_json_token() const noexcept */\n   simdjson_really_inline simdjson_result<std::string_view> raw_json_token() noexcept;\n+\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at_pointer(std::string_view json_pointer) noexcept;\n };\n \n+\n } // namespace simdjson\n+\n+\n+\n+namespace simdjson {\n+\n+template<>\n+struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference> : public SIMDJSON_IMPLEMENTATION::implementation_simdjson_result_base<SIMDJSON_IMPLEMENTATION::ondemand::document_reference> {\n+public:\n+  simdjson_really_inline simdjson_result(SIMDJSON_IMPLEMENTATION::ondemand::document_reference value, error_code error) noexcept;\n+  simdjson_really_inline simdjson_result() noexcept = default;\n+  simdjson_really_inline error_code rewind() noexcept;\n+\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array> get_array() & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> get_object() & noexcept;\n+  simdjson_really_inline simdjson_result<uint64_t> get_uint64() noexcept;\n+  simdjson_really_inline simdjson_result<int64_t> get_int64() noexcept;\n+  simdjson_really_inline simdjson_result<double> get_double() noexcept;\n+  simdjson_really_inline simdjson_result<std::string_view> get_string() noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::raw_json_string> get_raw_json_string() noexcept;\n+  simdjson_really_inline simdjson_result<bool> get_bool() noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> get_value() noexcept;\n+  simdjson_really_inline bool is_null() noexcept;\n+\n+#if SIMDJSON_EXCEPTIONS\n+  simdjson_really_inline operator SIMDJSON_IMPLEMENTATION::ondemand::array() & noexcept(false);\n+  simdjson_really_inline operator SIMDJSON_IMPLEMENTATION::ondemand::object() & noexcept(false);\n+  simdjson_really_inline operator uint64_t() noexcept(false);\n+  simdjson_really_inline operator int64_t() noexcept(false);\n+  simdjson_really_inline operator double() noexcept(false);\n+  simdjson_really_inline operator std::string_view() noexcept(false);\n+  simdjson_really_inline operator SIMDJSON_IMPLEMENTATION::ondemand::raw_json_string() noexcept(false);\n+  simdjson_really_inline operator bool() noexcept(false);\n+  simdjson_really_inline operator SIMDJSON_IMPLEMENTATION::ondemand::value() noexcept(false);\n+#endif\n+  simdjson_really_inline simdjson_result<size_t> count_elements() & noexcept;\n+  simdjson_really_inline simdjson_result<size_t> count_fields() & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at(size_t index) & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> begin() & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> end() & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field(std::string_view key) & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field(const char *key) & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> operator[](std::string_view key) & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> operator[](const char *key) & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(std::string_view key) & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(const char *key) & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::json_type> type() noexcept;\n+  simdjson_really_inline simdjson_result<bool> is_scalar() noexcept;\n+  simdjson_really_inline simdjson_result<const char *> current_location() noexcept;\n+  simdjson_really_inline bool is_negative() noexcept;\n+  simdjson_really_inline simdjson_result<bool> is_integer() noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number_type> get_number_type() noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number> get_number() noexcept;\n+  /** @copydoc simdjson_really_inline std::string_view document_reference::raw_json_token() const noexcept */\n+  simdjson_really_inline simdjson_result<std::string_view> raw_json_token() noexcept;\n+\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at_pointer(std::string_view json_pointer) noexcept;\n+};\n+\n+\n+} // namespace simdjson\n\\ No newline at end of file\n--- vendor/simdjson/include/simdjson/generic/ondemand/document_stream-inl.h\n@@ -0,0 +1,407 @@\n+#include <algorithm>\n+#include <limits>\n+#include <stdexcept>\n+namespace simdjson {\n+namespace SIMDJSON_IMPLEMENTATION {\n+namespace ondemand {\n+\n+#ifdef SIMDJSON_THREADS_ENABLED\n+\n+inline void stage1_worker::finish() {\n+  // After calling \"run\" someone would call finish() to wait\n+  // for the end of the processing.\n+  // This function will wait until either the thread has done\n+  // the processing or, else, the destructor has been called.\n+  std::unique_lock<std::mutex> lock(locking_mutex);\n+  cond_var.wait(lock, [this]{return has_work == false;});\n+}\n+\n+inline stage1_worker::~stage1_worker() {\n+  // The thread may never outlive the stage1_worker instance\n+  // and will always be stopped/joined before the stage1_worker\n+  // instance is gone.\n+  stop_thread();\n+}\n+\n+inline void stage1_worker::start_thread() {\n+  std::unique_lock<std::mutex> lock(locking_mutex);\n+  if(thread.joinable()) {\n+    return; // This should never happen but we never want to create more than one thread.\n+  }\n+  thread = std::thread([this]{\n+      while(true) {\n+        std::unique_lock<std::mutex> thread_lock(locking_mutex);\n+        // We wait for either \"run\" or \"stop_thread\" to be called.\n+        cond_var.wait(thread_lock, [this]{return has_work || !can_work;});\n+        // If, for some reason, the stop_thread() method was called (i.e., the\n+        // destructor of stage1_worker is called, then we want to immediately destroy\n+        // the thread (and not do any more processing).\n+        if(!can_work) {\n+          break;\n+        }\n+        this->owner->stage1_thread_error = this->owner->run_stage1(*this->stage1_thread_parser,\n+              this->_next_batch_start);\n+        this->has_work = false;\n+        // The condition variable call should be moved after thread_lock.unlock() for performance\n+        // reasons but thread sanitizers may report it as a data race if we do.\n+        // See https://stackoverflow.com/questions/35775501/c-should-condition-variable-be-notified-under-lock\n+        cond_var.notify_one(); // will notify \"finish\"\n+        thread_lock.unlock();\n+      }\n+    }\n+  );\n+}\n+\n+\n+inline void stage1_worker::stop_thread() {\n+  std::unique_lock<std::mutex> lock(locking_mutex);\n+  // We have to make sure that all locks can be released.\n+  can_work = false;\n+  has_work = false;\n+  cond_var.notify_all();\n+  lock.unlock();\n+  if(thread.joinable()) {\n+    thread.join();\n+  }\n+}\n+\n+inline void stage1_worker::run(document_stream * ds, parser * stage1, size_t next_batch_start) {\n+  std::unique_lock<std::mutex> lock(locking_mutex);\n+  owner = ds;\n+  _next_batch_start = next_batch_start;\n+  stage1_thread_parser = stage1;\n+  has_work = true;\n+  // The condition variable call should be moved after thread_lock.unlock() for performance\n+  // reasons but thread sanitizers may report it as a data race if we do.\n+  // See https://stackoverflow.com/questions/35775501/c-should-condition-variable-be-notified-under-lock\n+  cond_var.notify_one(); // will notify the thread lock that we have work\n+  lock.unlock();\n+}\n+\n+#endif  // SIMDJSON_THREADS_ENABLED\n+\n+simdjson_really_inline document_stream::document_stream(\n+  ondemand::parser &_parser,\n+  const uint8_t *_buf,\n+  size_t _len,\n+  size_t _batch_size\n+) noexcept\n+  : parser{&_parser},\n+    buf{_buf},\n+    len{_len},\n+    batch_size{_batch_size <= MINIMAL_BATCH_SIZE ? MINIMAL_BATCH_SIZE : _batch_size},\n+    error{SUCCESS}\n+    #ifdef SIMDJSON_THREADS_ENABLED\n+    , use_thread(_parser.threaded) // we need to make a copy because _parser.threaded can change\n+    #endif\n+{\n+#ifdef SIMDJSON_THREADS_ENABLED\n+  if(worker.get() == nullptr) {\n+    error = MEMALLOC;\n+  }\n+#endif\n+}\n+\n+simdjson_really_inline document_stream::document_stream() noexcept\n+  : parser{nullptr},\n+    buf{nullptr},\n+    len{0},\n+    batch_size{0},\n+    error{UNINITIALIZED}\n+    #ifdef SIMDJSON_THREADS_ENABLED\n+    , use_thread(false)\n+    #endif\n+{\n+}\n+\n+simdjson_really_inline document_stream::~document_stream() noexcept\n+{\n+  #ifdef SIMDJSON_THREADS_ENABLED\n+  worker.reset();\n+  #endif\n+}\n+\n+inline size_t document_stream::size_in_bytes() const noexcept {\n+  return len;\n+}\n+\n+inline size_t document_stream::truncated_bytes() const noexcept {\n+  if(error == CAPACITY) { return len - batch_start; }\n+  return parser->implementation->structural_indexes[parser->implementation->n_structural_indexes] - parser->implementation->structural_indexes[parser->implementation->n_structural_indexes + 1];\n+}\n+\n+simdjson_really_inline document_stream::iterator::iterator() noexcept\n+  : stream{nullptr}, finished{true} {\n+}\n+\n+simdjson_really_inline document_stream::iterator::iterator(document_stream* _stream, bool is_end) noexcept\n+  : stream{_stream}, finished{is_end} {\n+}\n+\n+simdjson_really_inline simdjson_result<ondemand::document_reference> document_stream::iterator::operator*() noexcept {\n+  //if(stream->error) { return stream->error; }\n+  return simdjson_result<ondemand::document_reference>(stream->doc, stream->error);\n+}\n+\n+simdjson_really_inline document_stream::iterator& document_stream::iterator::operator++() noexcept {\n+  // If there is an error, then we want the iterator\n+  // to be finished, no matter what. (E.g., we do not\n+  // keep generating documents with errors, or go beyond\n+  // a document with errors.)\n+  //\n+  // Users do not have to call \"operator*()\" when they use operator++,\n+  // so we need to end the stream in the operator++ function.\n+  //\n+  // Note that setting finished = true is essential otherwise\n+  // we would enter an infinite loop.\n+  if (stream->error) { finished = true; }\n+  // Note that stream->error() is guarded against error conditions\n+  // (it will immediately return if stream->error casts to false).\n+  // In effect, this next function does nothing when (stream->error)\n+  // is true (hence the risk of an infinite loop).\n+  stream->next();\n+  // If that was the last document, we're finished.\n+  // It is the only type of error we do not want to appear\n+  // in operator*.\n+  if (stream->error == EMPTY) { finished = true; }\n+  // If we had any other kind of error (not EMPTY) then we want\n+  // to pass it along to the operator* and we cannot mark the result\n+  // as \"finished\" just yet.\n+  return *this;\n+}\n+\n+simdjson_really_inline bool document_stream::iterator::operator!=(const document_stream::iterator &other) const noexcept {\n+  return finished != other.finished;\n+}\n+\n+simdjson_really_inline document_stream::iterator document_stream::begin() noexcept {\n+  start();\n+  // If there are no documents, we're finished.\n+  return iterator(this, error == EMPTY);\n+}\n+\n+simdjson_really_inline document_stream::iterator document_stream::end() noexcept {\n+  return iterator(this, true);\n+}\n+\n+inline void document_stream::start() noexcept {\n+  if (error) { return; }\n+  error = parser->allocate(batch_size);\n+  if (error) { return; }\n+  // Always run the first stage 1 parse immediately\n+  batch_start = 0;\n+  error = run_stage1(*parser, batch_start);\n+  while(error == EMPTY) {\n+    // In exceptional cases, we may start with an empty block\n+    batch_start = next_batch_start();\n+    if (batch_start >= len) { return; }\n+    error = run_stage1(*parser, batch_start);\n+  }\n+  if (error) { return; }\n+  doc_index = batch_start;\n+  doc = document(json_iterator(&buf[batch_start], parser));\n+  doc.iter._streaming = true;\n+\n+  #ifdef SIMDJSON_THREADS_ENABLED\n+  if (use_thread && next_batch_start() < len) {\n+    // Kick off the first thread on next batch if needed\n+    error = stage1_thread_parser.allocate(batch_size);\n+    if (error) { return; }\n+    worker->start_thread();\n+    start_stage1_thread();\n+    if (error) { return; }\n+  }\n+  #endif // SIMDJSON_THREADS_ENABLED\n+}\n+\n+inline void document_stream::next() noexcept {\n+  // We always enter at once once in an error condition.\n+  if (error) { return; }\n+  next_document();\n+  if (error) { return; }\n+  auto cur_struct_index = doc.iter._root - parser->implementation->structural_indexes.get();\n+  doc_index = batch_start + parser->implementation->structural_indexes[cur_struct_index];\n+\n+  // Check if at end of structural indexes (i.e. at end of batch)\n+  if(cur_struct_index >= static_cast<int64_t>(parser->implementation->n_structural_indexes)) {\n+    error = EMPTY;\n+    // Load another batch (if available)\n+    while (error == EMPTY) {\n+      batch_start = next_batch_start();\n+      if (batch_start >= len) { break; }\n+      #ifdef SIMDJSON_THREADS_ENABLED\n+      if(use_thread) {\n+        load_from_stage1_thread();\n+      } else {\n+        error = run_stage1(*parser, batch_start);\n+      }\n+      #else\n+      error = run_stage1(*parser, batch_start);\n+      #endif\n+      /**\n+       * Whenever we move to another window, we need to update all pointers to make\n+       * it appear as if the input buffer started at the beginning of the window.\n+       *\n+       * Take this input:\n+       *\n+       * {\"z\":5}  {\"1\":1,\"2\":2,\"4\":4} [7,  10,   9]  [15,  11,   12, 13]  [154,  110,   112, 1311]\n+       *\n+       * Say you process the following window...\n+       *\n+       * '{\"z\":5}  {\"1\":1,\"2\":2,\"4\":4} [7,  10,   9]'\n+       *\n+       * When you do so, the json_iterator has a pointer at the beginning of the memory region\n+       * (pointing at the beginning of '{\"z\"...'.\n+       *\n+       * When you move to the window that starts at...\n+       *\n+       * '[7,  10,   9]  [15,  11,   12, 13] ...\n+       *\n+       * then it is not sufficient to just run stage 1. You also need to re-anchor the\n+       * json_iterator so that it believes we are starting at '[7,  10,   9]...'.\n+       *\n+       * Under the DOM front-end, this gets done automatically because the parser owns\n+       * the pointer the data, and when you call stage1 and then stage2 on the same\n+       * parser, then stage2 will run on the pointer acquired by stage1.\n+       *\n+       * That is, stage1 calls \"this->buf = _buf\" so the parser remembers the buffer that\n+       * we used. But json_iterator has no callback when stage1 is called on the parser.\n+       * In fact, I think that the parser is unaware of json_iterator.\n+       *\n+       *\n+       * So we need to re-anchor the json_iterator after each call to stage 1 so that\n+       * all of the pointers are in sync.\n+       */\n+      doc.iter = json_iterator(&buf[batch_start], parser);\n+      doc.iter._streaming = true;\n+      /**\n+       * End of resync.\n+       */\n+\n+      if (error) { continue; } // If the error was EMPTY, we may want to load another batch.\n+      doc_index = batch_start;\n+    }\n+  }\n+}\n+\n+inline void document_stream::next_document() noexcept {\n+  // Go to next place where depth=0 (document depth)\n+  error = doc.iter.skip_child(0);\n+  if (error) { return; }\n+  // Always set depth=1 at the start of document\n+  doc.iter._depth = 1;\n+  // Resets the string buffer at the beginning, thus invalidating the strings.\n+  doc.iter._string_buf_loc = parser->string_buf.get();\n+  doc.iter._root = doc.iter.position();\n+}\n+\n+inline size_t document_stream::next_batch_start() const noexcept {\n+  return batch_start + parser->implementation->structural_indexes[parser->implementation->n_structural_indexes];\n+}\n+\n+inline error_code document_stream::run_stage1(ondemand::parser &p, size_t _batch_start) noexcept {\n+  // This code only updates the structural index in the parser, it does not update any json_iterator\n+  // instance.\n+  size_t remaining = len - _batch_start;\n+  if (remaining <= batch_size) {\n+    return p.implementation->stage1(&buf[_batch_start], remaining, stage1_mode::streaming_final);\n+  } else {\n+    return p.implementation->stage1(&buf[_batch_start], batch_size, stage1_mode::streaming_partial);\n+  }\n+}\n+\n+simdjson_really_inline size_t document_stream::iterator::current_index() const noexcept {\n+  return stream->doc_index;\n+}\n+\n+simdjson_really_inline std::string_view document_stream::iterator::source() const noexcept {\n+  auto depth = stream->doc.iter.depth();\n+  auto cur_struct_index = stream->doc.iter._root - stream->parser->implementation->structural_indexes.get();\n+\n+  // If at root, process the first token to determine if scalar value\n+  if (stream->doc.iter.at_root()) {\n+    switch (stream->buf[stream->batch_start + stream->parser->implementation->structural_indexes[cur_struct_index]]) {\n+      case '{': case '[':   // Depth=1 already at start of document\n+        break;\n+      case '}': case ']':\n+        depth--;\n+        break;\n+      default:    // Scalar value document\n+        // TODO: Remove any trailing whitespaces\n+        // This returns a string spanning from start of value to the beginning of the next document (excluded)\n+        return std::string_view(reinterpret_cast<const char*>(stream->buf) + current_index(), stream->parser->implementation->structural_indexes[++cur_struct_index] - current_index() - 1);\n+    }\n+    cur_struct_index++;\n+  }\n+\n+  while (cur_struct_index <= static_cast<int64_t>(stream->parser->implementation->n_structural_indexes)) {\n+    switch (stream->buf[stream->batch_start + stream->parser->implementation->structural_indexes[cur_struct_index]]) {\n+      case '{': case '[':\n+        depth++;\n+        break;\n+      case '}': case ']':\n+        depth--;\n+        break;\n+    }\n+    if (depth == 0) { break; }\n+    cur_struct_index++;\n+  }\n+\n+  return std::string_view(reinterpret_cast<const char*>(stream->buf) + current_index(), stream->parser->implementation->structural_indexes[cur_struct_index] - current_index() + stream->batch_start + 1);;\n+}\n+\n+inline error_code document_stream::iterator::error() const noexcept {\n+  return stream->error;\n+}\n+\n+#ifdef SIMDJSON_THREADS_ENABLED\n+\n+inline void document_stream::load_from_stage1_thread() noexcept {\n+  worker->finish();\n+  // Swap to the parser that was loaded up in the thread. Make sure the parser has\n+  // enough memory to swap to, as well.\n+  std::swap(stage1_thread_parser,*parser);\n+  error = stage1_thread_error;\n+  if (error) { return; }\n+\n+  // If there's anything left, start the stage 1 thread!\n+  if (next_batch_start() < len) {\n+    start_stage1_thread();\n+  }\n+}\n+\n+inline void document_stream::start_stage1_thread() noexcept {\n+  // we call the thread on a lambda that will update\n+  // this->stage1_thread_error\n+  // there is only one thread that may write to this value\n+  // TODO this is NOT exception-safe.\n+  this->stage1_thread_error = UNINITIALIZED; // In case something goes wrong, make sure it's an error\n+  size_t _next_batch_start = this->next_batch_start();\n+\n+  worker->run(this, & this->stage1_thread_parser, _next_batch_start);\n+}\n+\n+#endif // SIMDJSON_THREADS_ENABLED\n+\n+} // namespace ondemand\n+} // namespace SIMDJSON_IMPLEMENTATION\n+} // namespace simdjson\n+\n+namespace simdjson {\n+\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_stream>::simdjson_result(\n+  error_code error\n+) noexcept :\n+    implementation_simdjson_result_base<SIMDJSON_IMPLEMENTATION::ondemand::document_stream>(error)\n+{\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_stream>::simdjson_result(\n+  SIMDJSON_IMPLEMENTATION::ondemand::document_stream &&value\n+) noexcept :\n+    implementation_simdjson_result_base<SIMDJSON_IMPLEMENTATION::ondemand::document_stream>(\n+      std::forward<SIMDJSON_IMPLEMENTATION::ondemand::document_stream>(value)\n+    )\n+{\n+}\n+\n+}\n\\ No newline at end of file\n--- vendor/simdjson/include/simdjson/generic/ondemand/document_stream.h\n@@ -0,0 +1,330 @@\n+#include \"simdjson/error.h\"\n+#ifdef SIMDJSON_THREADS_ENABLED\n+#include <thread>\n+#include <mutex>\n+#include <condition_variable>\n+#endif\n+\n+namespace simdjson {\n+namespace SIMDJSON_IMPLEMENTATION {\n+namespace ondemand {\n+\n+class parser;\n+class json_iterator;\n+class document;\n+\n+#ifdef SIMDJSON_THREADS_ENABLED\n+/** @private Custom worker class **/\n+struct stage1_worker {\n+  stage1_worker() noexcept = default;\n+  stage1_worker(const stage1_worker&) = delete;\n+  stage1_worker(stage1_worker&&) = delete;\n+  stage1_worker operator=(const stage1_worker&) = delete;\n+  ~stage1_worker();\n+  /**\n+   * We only start the thread when it is needed, not at object construction, this may throw.\n+   * You should only call this once.\n+   **/\n+  void start_thread();\n+  /**\n+   * Start a stage 1 job. You should first call 'run', then 'finish'.\n+   * You must call start_thread once before.\n+   */\n+  void run(document_stream * ds, parser * stage1, size_t next_batch_start);\n+  /** Wait for the run to finish (blocking). You should first call 'run', then 'finish'. **/\n+  void finish();\n+\n+private:\n+\n+  /**\n+   * Normally, we would never stop the thread. But we do in the destructor.\n+   * This function is only safe assuming that you are not waiting for results. You\n+   * should have called run, then finish, and be done.\n+   **/\n+  void stop_thread();\n+\n+  std::thread thread{};\n+  /** These three variables define the work done by the thread. **/\n+  ondemand::parser * stage1_thread_parser{};\n+  size_t _next_batch_start{};\n+  document_stream * owner{};\n+  /**\n+   * We have two state variables. This could be streamlined to one variable in the future but\n+   * we use two for clarity.\n+   */\n+  bool has_work{false};\n+  bool can_work{true};\n+\n+  /**\n+   * We lock using a mutex.\n+   */\n+  std::mutex locking_mutex{};\n+  std::condition_variable cond_var{};\n+\n+  friend class document_stream;\n+};\n+#endif  // SIMDJSON_THREADS_ENABLED\n+\n+/**\n+ * A forward-only stream of documents.\n+ *\n+ * Produced by parser::iterate_many.\n+ *\n+ */\n+class document_stream {\n+public:\n+  /**\n+   * Construct an uninitialized document_stream.\n+   *\n+   *  ```c++\n+   *  document_stream docs;\n+   *  auto error = parser.iterate_many(json).get(docs);\n+   *  ```\n+   */\n+  simdjson_really_inline document_stream() noexcept;\n+  /** Move one document_stream to another. */\n+  simdjson_really_inline document_stream(document_stream &&other) noexcept = default;\n+  /** Move one document_stream to another. */\n+  simdjson_really_inline document_stream &operator=(document_stream &&other) noexcept = default;\n+\n+  simdjson_really_inline ~document_stream() noexcept;\n+\n+  /**\n+   * Returns the input size in bytes.\n+   */\n+  inline size_t size_in_bytes() const noexcept;\n+\n+  /**\n+   * After iterating through the stream, this method\n+   * returns the number of bytes that were not parsed at the end\n+   * of the stream. If truncated_bytes() differs from zero,\n+   * then the input was truncated maybe because incomplete JSON\n+   * documents were found at the end of the stream. You\n+   * may need to process the bytes in the interval [size_in_bytes()-truncated_bytes(), size_in_bytes()).\n+   *\n+   * You should only call truncated_bytes() after streaming through all\n+   * documents, like so:\n+   *\n+   *   document_stream stream = parser.iterate_many(json,window);\n+   *   for(auto & doc : stream) {\n+   *      // do something with doc\n+   *   }\n+   *   size_t truncated = stream.truncated_bytes();\n+   *\n+   */\n+  inline size_t truncated_bytes() const noexcept;\n+\n+  class iterator {\n+  public:\n+    using value_type = simdjson_result<document>;\n+    using reference  = value_type;\n+\n+    using difference_type   = std::ptrdiff_t;\n+\n+    using iterator_category = std::input_iterator_tag;\n+\n+    /**\n+     * Default constructor.\n+     */\n+    simdjson_really_inline iterator() noexcept;\n+    /**\n+     * Get the current document (or error).\n+     */\n+    simdjson_really_inline simdjson_result<ondemand::document_reference> operator*() noexcept;\n+    /**\n+     * Advance to the next document (prefix).\n+     */\n+    inline iterator& operator++() noexcept;\n+    /**\n+     * Check if we're at the end yet.\n+     * @param other the end iterator to compare to.\n+     */\n+    simdjson_really_inline bool operator!=(const iterator &other) const noexcept;\n+    /**\n+     * @private\n+     *\n+     * Gives the current index in the input document in bytes.\n+     *\n+     *   document_stream stream = parser.parse_many(json,window);\n+     *   for(auto i = stream.begin(); i != stream.end(); ++i) {\n+     *      auto doc = *i;\n+     *      size_t index = i.current_index();\n+     *   }\n+     *\n+     * This function (current_index()) is experimental and the usage\n+     * may change in future versions of simdjson: we find the API somewhat\n+     * awkward and we would like to offer something friendlier.\n+     */\n+     simdjson_really_inline size_t current_index() const noexcept;\n+\n+     /**\n+     * @private\n+     *\n+     * Gives a view of the current document at the current position.\n+     *\n+     *   document_stream stream = parser.iterate_many(json,window);\n+     *   for(auto i = stream.begin(); i != stream.end(); ++i) {\n+     *      std::string_view v = i.source();\n+     *   }\n+     *\n+     * The returned string_view instance is simply a map to the (unparsed)\n+     * source string: it may thus include white-space characters and all manner\n+     * of padding.\n+     *\n+     * This function (source()) is experimental and the usage\n+     * may change in future versions of simdjson: we find the API somewhat\n+     * awkward and we would like to offer something friendlier.\n+     *\n+     */\n+     simdjson_really_inline std::string_view source() const noexcept;\n+\n+    /**\n+     * Returns error of the stream (if any).\n+     */\n+     inline error_code error() const noexcept;\n+\n+  private:\n+    simdjson_really_inline iterator(document_stream *s, bool finished) noexcept;\n+    /** The document_stream we're iterating through. */\n+    document_stream* stream;\n+    /** Whether we're finished or not. */\n+    bool finished;\n+\n+    friend class document;\n+    friend class document_stream;\n+    friend class json_iterator;\n+  };\n+\n+  /**\n+   * Start iterating the documents in the stream.\n+   */\n+  simdjson_really_inline iterator begin() noexcept;\n+  /**\n+   * The end of the stream, for iterator comparison purposes.\n+   */\n+  simdjson_really_inline iterator end() noexcept;\n+\n+private:\n+\n+  document_stream &operator=(const document_stream &) = delete; // Disallow copying\n+  document_stream(const document_stream &other) = delete; // Disallow copying\n+\n+  /**\n+   * Construct a document_stream. Does not allocate or parse anything until the iterator is\n+   * used.\n+   *\n+   * @param parser is a reference to the parser instance used to generate this document_stream\n+   * @param buf is the raw byte buffer we need to process\n+   * @param len is the length of the raw byte buffer in bytes\n+   * @param batch_size is the size of the windows (must be strictly greater or equal to the largest JSON document)\n+   */\n+  simdjson_really_inline document_stream(\n+    ondemand::parser &parser,\n+    const uint8_t *buf,\n+    size_t len,\n+    size_t batch_size\n+  ) noexcept;\n+\n+  /**\n+   * Parse the first document in the buffer. Used by begin(), to handle allocation and\n+   * initialization.\n+   */\n+  inline void start() noexcept;\n+\n+  /**\n+   * Parse the next document found in the buffer previously given to document_stream.\n+   *\n+   * The content should be a valid JSON document encoded as UTF-8. If there is a\n+   * UTF-8 BOM, the caller is responsible for omitting it, UTF-8 BOM are\n+   * discouraged.\n+   *\n+   * You do NOT need to pre-allocate a parser.  This function takes care of\n+   * pre-allocating a capacity defined by the batch_size defined when creating the\n+   * document_stream object.\n+   *\n+   * The function returns simdjson::EMPTY if there is no more data to be parsed.\n+   *\n+   * The function returns simdjson::SUCCESS (as integer = 0) in case of success\n+   * and indicates that the buffer has successfully been parsed to the end.\n+   * Every document it contained has been parsed without error.\n+   *\n+   * The function returns an error code from simdjson/simdjson.h in case of failure\n+   * such as simdjson::CAPACITY, simdjson::MEMALLOC, simdjson::DEPTH_ERROR and so forth;\n+   * the simdjson::error_message function converts these error codes into a string).\n+   *\n+   * You can also check validity by calling parser.is_valid(). The same parser can\n+   * and should be reused for the other documents in the buffer.\n+   */\n+  inline void next() noexcept;\n+\n+  /** Move the json_iterator of the document to the location of the next document in the stream. */\n+  inline void next_document() noexcept;\n+\n+  /** Get the next document index. */\n+  inline size_t next_batch_start() const noexcept;\n+\n+  /** Pass the next batch through stage 1 with the given parser. */\n+  inline error_code run_stage1(ondemand::parser &p, size_t batch_start) noexcept;\n+\n+  // Fields\n+  ondemand::parser *parser;\n+  const uint8_t *buf;\n+  size_t len;\n+  size_t batch_size;\n+  /**\n+   * We are going to use just one document instance. The document owns\n+   * the json_iterator. It implies that we only ever pass a reference\n+   * to the document to the users.\n+   */\n+  document doc{};\n+  /** The error (or lack thereof) from the current document. */\n+  error_code error;\n+  size_t batch_start{0};\n+  size_t doc_index{};\n+\n+  #ifdef SIMDJSON_THREADS_ENABLED\n+  /** Indicates whether we use threads. Note that this needs to be a constant during the execution of the parsing. */\n+  bool use_thread;\n+\n+  inline void load_from_stage1_thread() noexcept;\n+\n+  /** Start a thread to run stage 1 on the next batch. */\n+  inline void start_stage1_thread() noexcept;\n+\n+  /** Wait for the stage 1 thread to finish and capture the results. */\n+  inline void finish_stage1_thread() noexcept;\n+\n+  /** The error returned from the stage 1 thread. */\n+  error_code stage1_thread_error{UNINITIALIZED};\n+  /** The thread used to run stage 1 against the next batch in the background. */\n+  std::unique_ptr<stage1_worker> worker{new(std::nothrow) stage1_worker()};\n+  /**\n+   * The parser used to run stage 1 in the background. Will be swapped\n+   * with the regular parser when finished.\n+   */\n+  ondemand::parser stage1_thread_parser{};\n+\n+  friend struct stage1_worker;\n+  #endif // SIMDJSON_THREADS_ENABLED\n+\n+  friend class parser;\n+  friend class document;\n+  friend class json_iterator;\n+  friend struct simdjson_result<ondemand::document_stream>;\n+  friend struct internal::simdjson_result_base<ondemand::document_stream>;\n+};  // document_stream\n+\n+} // namespace ondemand\n+} // namespace SIMDJSON_IMPLEMENTATION\n+} // namespace simdjson\n+\n+namespace simdjson {\n+template<>\n+struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_stream> : public SIMDJSON_IMPLEMENTATION::implementation_simdjson_result_base<SIMDJSON_IMPLEMENTATION::ondemand::document_stream> {\n+public:\n+  simdjson_really_inline simdjson_result(SIMDJSON_IMPLEMENTATION::ondemand::document_stream &&value) noexcept; ///< @private\n+  simdjson_really_inline simdjson_result(error_code error) noexcept; ///< @private\n+  simdjson_really_inline simdjson_result() noexcept = default;\n+};\n+\n+} // namespace simdjson\n\\ No newline at end of file\n--- vendor/simdjson/include/simdjson/generic/ondemand/field-inl.h\n@@ -22,7 +22,7 @@ simdjson_really_inline simdjson_result<field> field::start(const value_iterator\n }\n \n simdjson_really_inline simdjson_warn_unused simdjson_result<std::string_view> field::unescaped_key() noexcept {\n-  SIMDJSON_ASSUME(first.buf != nullptr); // We would like to call .alive() by Visual Studio won't let us.\n+  SIMDJSON_ASSUME(first.buf != nullptr); // We would like to call .alive() but Visual Studio won't let us.\n   simdjson_result<std::string_view> answer = first.unescape(second.iter.string_buf_loc());\n   first.consume();\n   return answer;\n--- vendor/simdjson/include/simdjson/generic/ondemand/json_iterator-inl.h\n@@ -7,7 +7,9 @@ simdjson_really_inline json_iterator::json_iterator(json_iterator &&other) noexc\n     parser{other.parser},\n     _string_buf_loc{other._string_buf_loc},\n     error{other.error},\n-    _depth{other._depth}\n+    _depth{other._depth},\n+    _root{other._root},\n+    _streaming{other._streaming}\n {\n   other.parser = nullptr;\n }\n@@ -17,17 +19,32 @@ simdjson_really_inline json_iterator &json_iterator::operator=(json_iterator &&o\n   _string_buf_loc = other._string_buf_loc;\n   error = other.error;\n   _depth = other._depth;\n+  _root = other._root;\n+  _streaming = other._streaming;\n   other.parser = nullptr;\n   return *this;\n }\n \n simdjson_really_inline json_iterator::json_iterator(const uint8_t *buf, ondemand::parser *_parser) noexcept\n-  : token(buf, _parser->implementation->structural_indexes.get()),\n+  : token(buf, &_parser->implementation->structural_indexes[0]),\n     parser{_parser},\n     _string_buf_loc{parser->string_buf.get()},\n-    _depth{1}\n+    _depth{1},\n+    _root{parser->implementation->structural_indexes.get()},\n+    _streaming{false}\n+\n {\n   logger::log_headers();\n+#if SIMDJSON_CHECK_EOF\n+  assert_more_tokens();\n+#endif\n+}\n+\n+inline void json_iterator::rewind() noexcept {\n+  token.set_position( root_position() );\n+  logger::log_headers(); // We start again\n+  _string_buf_loc = parser->string_buf.get();\n+  _depth = 1;\n }\n \n // GCC 7 warns when the first line of this function is inlined away into oblivion due to the caller\n@@ -36,9 +53,19 @@ simdjson_really_inline json_iterator::json_iterator(const uint8_t *buf, ondemand\n SIMDJSON_PUSH_DISABLE_WARNINGS\n SIMDJSON_DISABLE_STRICT_OVERFLOW_WARNING\n simdjson_warn_unused simdjson_really_inline error_code json_iterator::skip_child(depth_t parent_depth) noexcept {\n+  /***\n+   * WARNING:\n+   * Inside an object, a string value is a depth of +1 compared to the object. Yet a key\n+   * is at the same depth as the object.\n+   * But json_iterator cannot easily tell whether we are pointing at a key or a string value.\n+   * Instead, it assumes that if you are pointing at a string, then it is a value, not a key.\n+   * To be clear...\n+   * the following code assumes that we are *not* pointing at a key. If we are then a bug\n+   * will follow. Unfortunately, it is not possible for the json_iterator its to make this\n+   * check.\n+   */\n   if (depth() <= parent_depth) { return SUCCESS; }\n-\n-  switch (*advance()) {\n+  switch (*return_current_and_advance()) {\n     // TODO consider whether matching braces is a requirement: if non-matching braces indicates\n     // *missing* braces, then future lookups are not in the object/arrays they think they are,\n     // violating the rule \"validate enough structure that the user can be confident they are\n@@ -59,7 +86,24 @@ simdjson_warn_unused simdjson_really_inline error_code json_iterator::skip_child\n       logger::log_end_value(*this, \"skip\");\n       _depth--;\n       if (depth() <= parent_depth) { return SUCCESS; }\n+#if SIMDJSON_CHECK_EOF\n+      // If there are no more tokens, the parent is incomplete.\n+      if (at_end()) { return report_error(INCOMPLETE_ARRAY_OR_OBJECT, \"Missing [ or { at start\"); }\n+#endif // SIMDJSON_CHECK_EOF\n       break;\n+    /*case '\"':\n+      if(*peek() == ':') {\n+        // we are at a key!!! This is\n+        // only possible if someone searched\n+        // for a key in an object and the key\n+        // was not found but our code then\n+        // decided the consume the separating\n+        // comma before returning.\n+        logger::log_value(*this, \"key\");\n+        advance(); // eat up the ':'\n+        break; // important!!!\n+      }\n+      simdjson_fallthrough;*/\n     // Anything else must be a scalar value\n     default:\n       // For the first scalar, we will have incremented depth already, so we decrement it here.\n@@ -70,9 +114,8 @@ simdjson_warn_unused simdjson_really_inline error_code json_iterator::skip_child\n   }\n \n   // Now that we've considered the first value, we only increment/decrement for arrays/objects\n-  auto end = &parser->implementation->structural_indexes[parser->implementation->n_structural_indexes];\n-  while (token.index <= end) {\n-    switch (*advance()) {\n+  while (position() < end_position()) {\n+    switch (*return_current_and_advance()) {\n       case '[': case '{':\n         logger::log_start_value(*this, \"skip\");\n         _depth++;\n@@ -99,23 +142,71 @@ simdjson_warn_unused simdjson_really_inline error_code json_iterator::skip_child\n SIMDJSON_POP_DISABLE_WARNINGS\n \n simdjson_really_inline bool json_iterator::at_root() const noexcept {\n-  return token.position() == root_checkpoint();\n+  return position() == root_position();\n+}\n+\n+simdjson_really_inline bool json_iterator::streaming() const noexcept {\n+  return _streaming;\n+}\n+\n+simdjson_really_inline token_position json_iterator::root_position() const noexcept {\n+  return _root;\n }\n \n-simdjson_really_inline token_position json_iterator::root_checkpoint() const noexcept {\n-  return parser->implementation->structural_indexes.get();\n+simdjson_really_inline void json_iterator::assert_at_document_depth() const noexcept {\n+  SIMDJSON_ASSUME( _depth == 1 );\n }\n \n simdjson_really_inline void json_iterator::assert_at_root() const noexcept {\n   SIMDJSON_ASSUME( _depth == 1 );\n-  // Visual Studio Clang treats unique_ptr.get() as \"side effecting.\"\n #ifndef SIMDJSON_CLANG_VISUAL_STUDIO\n-  SIMDJSON_ASSUME( token.index == parser->implementation->structural_indexes.get() );\n+  // Under Visual Studio, the next SIMDJSON_ASSUME fails with: the argument\n+  // has side effects that will be discarded.\n+  SIMDJSON_ASSUME( token.position() == _root );\n #endif\n }\n \n-simdjson_really_inline bool json_iterator::at_eof() const noexcept {\n-  return token.index == &parser->implementation->structural_indexes[parser->implementation->n_structural_indexes];\n+simdjson_really_inline void json_iterator::assert_more_tokens(uint32_t required_tokens) const noexcept {\n+  assert_valid_position(token._position + required_tokens - 1);\n+}\n+\n+simdjson_really_inline void json_iterator::assert_valid_position(token_position position) const noexcept {\n+#ifndef SIMDJSON_CLANG_VISUAL_STUDIO\n+  SIMDJSON_ASSUME( position >= &parser->implementation->structural_indexes[0] );\n+  SIMDJSON_ASSUME( position < &parser->implementation->structural_indexes[parser->implementation->n_structural_indexes] );\n+#endif\n+}\n+\n+simdjson_really_inline bool json_iterator::at_end() const noexcept {\n+  return position() == end_position();\n+}\n+simdjson_really_inline token_position json_iterator::end_position() const noexcept {\n+  uint32_t n_structural_indexes{parser->implementation->n_structural_indexes};\n+  return &parser->implementation->structural_indexes[n_structural_indexes];\n+}\n+\n+inline std::string json_iterator::to_string() const noexcept {\n+  if( !is_alive() ) { return \"dead json_iterator instance\"; }\n+  const char * current_structural = reinterpret_cast<const char *>(token.peek());\n+  return std::string(\"json_iterator [ depth : \") + std::to_string(_depth)\n+          + std::string(\", structural : '\") + std::string(current_structural,1)\n+          + std::string(\"', offset : \") + std::to_string(token.current_offset())\n+          + std::string(\"', error : \") + error_message(error)\n+          + std::string(\" ]\");\n+}\n+\n+inline simdjson_result<const char *> json_iterator::current_location() noexcept {\n+  if (!is_alive()) {    // Unrecoverable error\n+    if (!at_root()) {\n+      return reinterpret_cast<const char *>(token.peek(-1));\n+    } else {\n+      return reinterpret_cast<const char *>(token.peek());\n+    }\n+  }\n+  if (at_end()) {\n+    return OUT_OF_BOUNDS;\n+  }\n+  return reinterpret_cast<const char *>(token.peek());\n }\n \n simdjson_really_inline bool json_iterator::is_alive() const noexcept {\n@@ -127,27 +218,49 @@ simdjson_really_inline void json_iterator::abandon() noexcept {\n   _depth = 0;\n }\n \n-simdjson_really_inline const uint8_t *json_iterator::advance() noexcept {\n-  return token.advance();\n+simdjson_really_inline const uint8_t *json_iterator::return_current_and_advance() noexcept {\n+#if SIMDJSON_CHECK_EOF\n+  assert_more_tokens();\n+#endif // SIMDJSON_CHECK_EOF\n+  return token.return_current_and_advance();\n+}\n+\n+simdjson_really_inline const uint8_t *json_iterator::unsafe_pointer() const noexcept {\n+  // deliberately done without safety guard:\n+  return token.peek(0);\n }\n \n simdjson_really_inline const uint8_t *json_iterator::peek(int32_t delta) const noexcept {\n+#if SIMDJSON_CHECK_EOF\n+  assert_more_tokens(delta+1);\n+#endif // SIMDJSON_CHECK_EOF\n   return token.peek(delta);\n }\n \n simdjson_really_inline uint32_t json_iterator::peek_length(int32_t delta) const noexcept {\n+#if SIMDJSON_CHECK_EOF\n+  assert_more_tokens(delta+1);\n+#endif // #if SIMDJSON_CHECK_EOF\n   return token.peek_length(delta);\n }\n \n simdjson_really_inline const uint8_t *json_iterator::peek(token_position position) const noexcept {\n+  // todo: currently we require end-of-string buffering, but the following\n+  // assert_valid_position should be turned on if/when we lift that condition.\n+  // assert_valid_position(position);\n+  // This is almost surely related to SIMDJSON_CHECK_EOF but given that SIMDJSON_CHECK_EOF\n+  // is ON by default, we have no choice but to disable it for real with a comment.\n   return token.peek(position);\n }\n \n simdjson_really_inline uint32_t json_iterator::peek_length(token_position position) const noexcept {\n+#if SIMDJSON_CHECK_EOF\n+  assert_valid_position(position);\n+#endif // SIMDJSON_CHECK_EOF\n   return token.peek_length(position);\n }\n \n-simdjson_really_inline token_position json_iterator::last_document_position() const noexcept {\n+simdjson_really_inline token_position json_iterator::last_position() const noexcept {\n   // The following line fails under some compilers...\n   // SIMDJSON_ASSUME(parser->implementation->n_structural_indexes > 0);\n   // since it has side-effects.\n@@ -156,7 +269,7 @@ simdjson_really_inline token_position json_iterator::last_document_position() co\n   return &parser->implementation->structural_indexes[n_structural_indexes - 1];\n }\n simdjson_really_inline const uint8_t *json_iterator::peek_last() const noexcept {\n-  return token.peek(last_document_position());\n+  return token.peek(last_position());\n }\n \n simdjson_really_inline void json_iterator::ascend_to(depth_t parent_depth) noexcept {\n@@ -189,6 +302,7 @@ simdjson_really_inline error_code json_iterator::report_error(error_code _error,\n simdjson_really_inline token_position json_iterator::position() const noexcept {\n   return token.position();\n }\n+\n simdjson_really_inline void json_iterator::reenter_child(token_position position, depth_t child_depth) noexcept {\n   SIMDJSON_ASSUME(child_depth >= 1 && child_depth < INT32_MAX);\n   SIMDJSON_ASSUME(_depth == child_depth - 1);\n@@ -202,9 +316,11 @@ simdjson_really_inline void json_iterator::reenter_child(token_position position\n }\n \n #ifdef SIMDJSON_DEVELOPMENT_CHECKS\n+\n simdjson_really_inline token_position json_iterator::start_position(depth_t depth) const noexcept {\n   return parser->start_positions[depth];\n }\n+\n simdjson_really_inline void json_iterator::set_start_position(depth_t depth, token_position position) noexcept {\n   parser->start_positions[depth] = position;\n }\n@@ -220,9 +336,11 @@ simdjson_really_inline error_code json_iterator::optional_error(error_code _erro\n \n template<int N>\n simdjson_warn_unused simdjson_really_inline bool json_iterator::copy_to_buffer(const uint8_t *json, uint32_t max_len, uint8_t (&tmpbuf)[N]) noexcept {\n+  // Let us guard against silly cases:\n+  if((N < max_len) || (N == 0)) { return false; }\n   // Truncate whitespace to fit the buffer.\n   if (max_len > N-1) {\n-    if (jsoncharutils::is_not_structural_or_whitespace(json[N-1])) { return false; }\n+    // if (jsoncharutils::is_not_structural_or_whitespace(json[N-1])) { return false; }\n     max_len = N-1;\n   }\n \n@@ -232,20 +350,6 @@ simdjson_warn_unused simdjson_really_inline bool json_iterator::copy_to_buffer(c\n   return true;\n }\n \n-template<int N>\n-simdjson_warn_unused simdjson_really_inline bool json_iterator::peek_to_buffer(uint8_t (&tmpbuf)[N]) noexcept {\n-  auto max_len = token.peek_length();\n-  auto json = token.peek();\n-  return copy_to_buffer(json, max_len, tmpbuf);\n-}\n-\n-template<int N>\n-simdjson_warn_unused simdjson_really_inline bool json_iterator::advance_to_buffer(uint8_t (&tmpbuf)[N]) noexcept {\n-  auto max_len = peek_length();\n-  auto json = advance();\n-  return copy_to_buffer(json, max_len, tmpbuf);\n-}\n-\n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n--- vendor/simdjson/include/simdjson/generic/ondemand/json_iterator.h\n@@ -3,6 +3,7 @@ namespace SIMDJSON_IMPLEMENTATION {\n namespace ondemand {\n \n class document;\n+class document_stream;\n class object;\n class array;\n class value;\n@@ -44,14 +45,27 @@ class json_iterator {\n    * - 3 = key or value inside root array/object.\n    */\n   depth_t _depth{};\n+  /**\n+   * Beginning of the document indexes.\n+   * Normally we have root == parser->implementation->structural_indexes.get()\n+   * but this may differ, especially in streaming mode (where we have several\n+   * documents);\n+   */\n+  token_position _root{};\n+  /**\n+   * Normally, a json_iterator operates over a single document, but in\n+   * some cases, we may have a stream of documents. This attribute is meant\n+   * as meta-data: the json_iterator works the same irrespective of the\n+   * value of this attribute.\n+   */\n+  bool _streaming{false};\n \n public:\n   simdjson_really_inline json_iterator() noexcept = default;\n   simdjson_really_inline json_iterator(json_iterator &&other) noexcept;\n   simdjson_really_inline json_iterator &operator=(json_iterator &&other) noexcept;\n-  simdjson_really_inline json_iterator(const json_iterator &other) noexcept = delete;\n-  simdjson_really_inline json_iterator &operator=(const json_iterator &other) noexcept = delete;\n-\n+  simdjson_really_inline explicit json_iterator(const json_iterator &other) noexcept = default;\n+  simdjson_really_inline json_iterator &operator=(const json_iterator &other) noexcept = default;\n   /**\n    * Skips a JSON value, whether it is a scalar, array or object.\n    */\n@@ -63,19 +77,30 @@ class json_iterator {\n   simdjson_really_inline bool at_root() const noexcept;\n \n   /**\n-   * Get the root value iterator\n+   * Tell whether we should be expected to run in streaming\n+   * mode (iterating over many documents). It is pure metadata\n+   * that does not affect how the iterator works. It is used by\n+   * start_root_array() and start_root_object().\n    */\n-  simdjson_really_inline token_position root_checkpoint() const noexcept;\n+  simdjson_really_inline bool streaming() const noexcept;\n \n   /**\n-   * Assert if the iterator is not at the start\n+   * Get the root value iterator\n+   */\n+  simdjson_really_inline token_position root_position() const noexcept;\n+  /**\n+   * Assert that we are at the document depth (== 1)\n+   */\n+  simdjson_really_inline void assert_at_document_depth() const noexcept;\n+  /**\n+   * Assert that we are at the root of the document\n    */\n   simdjson_really_inline void assert_at_root() const noexcept;\n \n   /**\n    * Tell whether the iterator is at the EOF mark\n    */\n-  simdjson_really_inline bool at_eof() const noexcept;\n+  simdjson_really_inline bool at_end() const noexcept;\n \n   /**\n    * Tell whether the iterator is live (has not been moved).\n@@ -88,10 +113,22 @@ class json_iterator {\n   simdjson_really_inline void abandon() noexcept;\n \n   /**\n-   * Advance the current token.\n+   * Advance the current token without modifying depth.\n    */\n-  simdjson_really_inline const uint8_t *advance() noexcept;\n+  simdjson_really_inline const uint8_t *return_current_and_advance() noexcept;\n \n+  /**\n+   * Assert that there are at least the given number of tokens left.\n+   *\n+   * Has no effect in release builds.\n+   */\n+  simdjson_really_inline void assert_more_tokens(uint32_t required_tokens=1) const noexcept;\n+  /**\n+   * Assert that the given position addresses an actual token (is within bounds).\n+   *\n+   * Has no effect in release builds.\n+   */\n+  simdjson_really_inline void assert_valid_position(token_position position) const noexcept;\n   /**\n    * Get the JSON text for a given token (relative).\n    *\n@@ -111,12 +148,21 @@ class json_iterator {\n    * @param delta The relative position of the token to retrieve. e.g. 0 = next token, -1 = prev token.\n    */\n   simdjson_really_inline uint32_t peek_length(int32_t delta=0) const noexcept;\n+  /**\n+   * Get a pointer to the current location in the input buffer.\n+   *\n+   * This is not null-terminated; it is a view into the JSON.\n+   *\n+   * You may be pointing outside of the input buffer: it is not generally\n+   * safe to derefence this pointer.\n+   */\n+  simdjson_really_inline const uint8_t *unsafe_pointer() const noexcept;\n   /**\n    * Get the JSON text for a given token.\n    *\n    * This is not null-terminated; it is a view into the JSON.\n    *\n-   * @param index The position of the token to retrieve.\n+   * @param position The position of the token to retrieve.\n    *\n    * TODO consider a string_view, assuming the length will get stripped out by the optimizer when\n    * it isn't used ...\n@@ -127,7 +173,7 @@ class json_iterator {\n    *\n    * The length will include any whitespace at the end of the token.\n    *\n-   * @param index The position of the token to retrieve.\n+   * @param position The position of the token to retrieve.\n    */\n   simdjson_really_inline uint32_t peek_length(token_position position) const noexcept;\n   /**\n@@ -156,8 +202,8 @@ class json_iterator {\n    *\n    * @param child_depth the expected child depth.\n    */\n-  simdjson_really_inline void descend_to(depth_t parent_depth) noexcept;\n-  simdjson_really_inline void descend_to(depth_t parent_depth, int32_t delta) noexcept;\n+  simdjson_really_inline void descend_to(depth_t child_depth) noexcept;\n+  simdjson_really_inline void descend_to(depth_t child_depth, int32_t delta) noexcept;\n \n   /**\n    * Get current depth.\n@@ -170,7 +216,7 @@ class json_iterator {\n   simdjson_really_inline uint8_t *&string_buf_loc() noexcept;\n \n   /**\n-   * Report an error, preventing further iteration.\n+   * Report an unrecoverable error, preventing further iteration.\n    *\n    * @param error The error to report. Must not be SUCCESS, UNINITIALIZED, INCORRECT_TYPE, or NO_SUCH_FIELD.\n    * @param message An error message to report with the error.\n@@ -185,21 +231,37 @@ class json_iterator {\n   simdjson_really_inline error_code optional_error(error_code error, const char *message) noexcept;\n \n   template<int N> simdjson_warn_unused simdjson_really_inline bool copy_to_buffer(const uint8_t *json, uint32_t max_len, uint8_t (&tmpbuf)[N]) noexcept;\n-  template<int N> simdjson_warn_unused simdjson_really_inline bool peek_to_buffer(uint8_t (&tmpbuf)[N]) noexcept;\n-  template<int N> simdjson_warn_unused simdjson_really_inline bool advance_to_buffer(uint8_t (&tmpbuf)[N]) noexcept;\n \n   simdjson_really_inline token_position position() const noexcept;\n   simdjson_really_inline void reenter_child(token_position position, depth_t child_depth) noexcept;\n #ifdef SIMDJSON_DEVELOPMENT_CHECKS\n   simdjson_really_inline token_position start_position(depth_t depth) const noexcept;\n   simdjson_really_inline void set_start_position(depth_t depth, token_position position) noexcept;\n #endif\n+  /* Useful for debugging and logging purposes. */\n+  inline std::string to_string() const noexcept;\n+\n+  /**\n+   * Returns the current location in the document if in bounds.\n+   */\n+  inline simdjson_result<const char *> current_location() noexcept;\n \n+  /**\n+   * Updates this json iterator so that it is back at the beginning of the document,\n+   * as if it had just been created.\n+   */\n+  inline void rewind() noexcept;\n protected:\n   simdjson_really_inline json_iterator(const uint8_t *buf, ondemand::parser *parser) noexcept;\n-  simdjson_really_inline token_position last_document_position() const noexcept;\n+  /// The last token before the end\n+  simdjson_really_inline token_position last_position() const noexcept;\n+  /// The token *at* the end. This points at gibberish and should only be used for comparison.\n+  simdjson_really_inline token_position end_position() const noexcept;\n+  /// The end of the buffer.\n+  simdjson_really_inline token_position end() const noexcept;\n \n   friend class document;\n+  friend class document_stream;\n   friend class object;\n   friend class array;\n   friend class value;\n--- vendor/simdjson/include/simdjson/generic/ondemand/json_type-inl.h\n@@ -15,12 +15,93 @@ inline std::ostream& operator<<(std::ostream& out, json_type type) noexcept {\n     return out;\n }\n \n+inline std::ostream& operator<<(std::ostream& out, number_type type) noexcept {\n+    switch (type) {\n+        case number_type::signed_integer: out << \"integer in [-9223372036854775808,9223372036854775808)\"; break;\n+        case number_type::unsigned_integer: out << \"unsigned integer in [9223372036854775808,18446744073709551616)\"; break;\n+        case number_type::floating_point_number: out << \"floating-point number (binary64)\"; break;\n+        default: SIMDJSON_UNREACHABLE();\n+    }\n+    return out;\n+}\n #if SIMDJSON_EXCEPTIONS\n inline std::ostream& operator<<(std::ostream& out, simdjson_result<json_type> &type) noexcept(false) {\n     return out << type.value();\n }\n #endif\n \n+\n+\n+simdjson_really_inline number_type number::get_number_type() const noexcept {\n+  return type;\n+}\n+\n+simdjson_really_inline bool number::is_uint64() const noexcept {\n+  return get_number_type() == number_type::unsigned_integer;\n+}\n+\n+simdjson_really_inline uint64_t number::get_uint64() const noexcept {\n+  return payload.unsigned_integer;\n+}\n+\n+simdjson_really_inline number::operator uint64_t() const noexcept {\n+  return get_uint64();\n+}\n+\n+\n+simdjson_really_inline bool number::is_int64() const noexcept {\n+  return get_number_type() == number_type::signed_integer;\n+}\n+\n+simdjson_really_inline int64_t number::get_int64() const noexcept {\n+  return payload.signed_integer;\n+}\n+\n+simdjson_really_inline number::operator int64_t() const noexcept {\n+  return get_int64();\n+}\n+\n+simdjson_really_inline bool number::is_double() const noexcept {\n+    return get_number_type() == number_type::floating_point_number;\n+}\n+\n+simdjson_really_inline double number::get_double() const noexcept {\n+  return payload.floating_point_number;\n+}\n+\n+simdjson_really_inline number::operator double() const noexcept {\n+  return get_double();\n+}\n+\n+simdjson_really_inline double number::as_double() const noexcept {\n+  if(is_double()) {\n+    return payload.floating_point_number;\n+  }\n+  if(is_int64()) {\n+    return double(payload.signed_integer);\n+  }\n+  return double(payload.unsigned_integer);\n+}\n+\n+simdjson_really_inline void number::append_s64(int64_t value) noexcept {\n+  payload.signed_integer = value;\n+  type = number_type::signed_integer;\n+}\n+\n+simdjson_really_inline void number::append_u64(uint64_t value) noexcept {\n+  payload.unsigned_integer = value;\n+  type = number_type::unsigned_integer;\n+}\n+\n+simdjson_really_inline void number::append_double(double value) noexcept {\n+  payload.floating_point_number = value;\n+  type = number_type::floating_point_number;\n+}\n+\n+simdjson_really_inline void number::skip_double() noexcept {\n+  type = number_type::floating_point_number;\n+}\n+\n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n--- vendor/simdjson/include/simdjson/generic/ondemand/json_type.h\n@@ -1,7 +1,6 @@\n namespace simdjson {\n namespace SIMDJSON_IMPLEMENTATION {\n namespace ondemand {\n-\n /**\n  * The type of a JSON value.\n  */\n@@ -15,13 +14,114 @@ enum class json_type {\n     null     ///< A JSON null    (null)\n };\n \n+class value_iterator;\n+\n+/**\n+ * A type representing a JSON number.\n+ * The design of the struct is deliberately straight-forward. All\n+ * functions return standard values with no error check.\n+ */\n+struct number {\n+\n+  /**\n+   * return the automatically determined type of\n+   * the number: number_type::floating_point_number,\n+   * number_type::signed_integer or number_type::unsigned_integer.\n+   *\n+   *    enum class number_type {\n+   *        floating_point_number=1, /// a binary64 number\n+   *        signed_integer,          /// a signed integer that fits in a 64-bit word using two's complement\n+   *        unsigned_integer         /// a positive integer larger or equal to 1<<63\n+   *    };\n+   */\n+  simdjson_really_inline number_type get_number_type() const noexcept;\n+  /**\n+   * return true if the automatically determined type of\n+   * the number is number_type::unsigned_integer.\n+   */\n+  simdjson_really_inline bool is_uint64() const noexcept;\n+  /**\n+   * return the value as a uint64_t, only valid if is_uint64() is true.\n+   */\n+  simdjson_really_inline uint64_t get_uint64() const noexcept;\n+  simdjson_really_inline operator uint64_t() const noexcept;\n+\n+  /**\n+   * return true if the automatically determined type of\n+   * the number is number_type::signed_integer.\n+   */\n+  simdjson_really_inline bool is_int64() const noexcept;\n+  /**\n+   * return the value as a int64_t, only valid if is_int64() is true.\n+   */\n+  simdjson_really_inline int64_t get_int64() const noexcept;\n+  simdjson_really_inline operator int64_t() const noexcept;\n+\n+\n+  /**\n+   * return true if the automatically determined type of\n+   * the number is number_type::floating_point_number.\n+   */\n+  simdjson_really_inline bool is_double() const noexcept;\n+  /**\n+   * return the value as a double, only valid if is_double() is true.\n+   */\n+  simdjson_really_inline double get_double() const noexcept;\n+  simdjson_really_inline operator double() const noexcept;\n+\n+  /**\n+   * Convert the number to a double. Though it always succeed, the conversion\n+   * may be lossy if the number cannot be represented exactly.\n+   */\n+  simdjson_really_inline double as_double() const noexcept;\n+\n+\n+protected:\n+  /**\n+   * The next block of declaration is designed so that we can call the number parsing\n+   * functions on a number type. They are protected and should never be used outside\n+   * of the core simdjson library.\n+   */\n+  friend class value_iterator;\n+  template<typename W>\n+  friend error_code numberparsing::write_float(const uint8_t *const src, bool negative, uint64_t i, const uint8_t * start_digits, size_t digit_count, int64_t exponent, W &writer);\n+  template<typename W>\n+  friend error_code numberparsing::parse_number(const uint8_t *const src, W &writer);\n+  template<typename W>\n+  friend error_code numberparsing::slow_float_parsing(simdjson_unused const uint8_t * src, W writer);\n+  /** Store a signed 64-bit value to the number. */\n+  simdjson_really_inline void append_s64(int64_t value) noexcept;\n+  /** Store an unsigned 64-bit value to the number. */\n+  simdjson_really_inline void append_u64(uint64_t value) noexcept;\n+  /** Store a double value to the number. */\n+  simdjson_really_inline void append_double(double value) noexcept;\n+  /** Specifies that the value is a double, but leave it undefined. */\n+  simdjson_really_inline void skip_double() noexcept;\n+  /**\n+   * End of friend declarations.\n+   */\n+\n+  /**\n+   * Our attributes are a union type (size = 64 bits)\n+   * followed by a type indicator.\n+   */\n+  union {\n+    double floating_point_number;\n+    int64_t signed_integer;\n+    uint64_t unsigned_integer;\n+  } payload{0};\n+  number_type type{number_type::signed_integer};\n+  friend class value_iterator;\n+};\n+\n /**\n  * Write the JSON type to the output stream\n  *\n  * @param out The output stream.\n  * @param type The json_type.\n  */\n inline std::ostream& operator<<(std::ostream& out, json_type type) noexcept;\n+inline std::ostream& operator<<(std::ostream& out, number_type type) noexcept;\n \n #if SIMDJSON_EXCEPTIONS\n /**\n--- vendor/simdjson/include/simdjson/generic/ondemand/logger-inl.h\n@@ -10,70 +10,98 @@ static constexpr const int LOG_SMALL_BUFFER_LEN = 10;\n static int log_depth = 0; // Not threadsafe. Log only.\n \n // Helper to turn unprintable or newline characters into spaces\n-static simdjson_really_inline char printable_char(char c) {\n+static inline char printable_char(char c) {\n   if (c >= 0x20) {\n     return c;\n   } else {\n     return ' ';\n   }\n }\n \n-simdjson_really_inline void log_event(const json_iterator &iter, const char *type, std::string_view detail, int delta, int depth_delta) noexcept {\n+inline void log_event(const json_iterator &iter, const char *type, std::string_view detail, int delta, int depth_delta) noexcept {\n   log_line(iter, \"\", type, detail, delta, depth_delta);\n }\n \n-simdjson_really_inline void log_value(const json_iterator &iter, token_position index, depth_t depth, const char *type, std::string_view detail) noexcept {\n+inline void log_value(const json_iterator &iter, token_position index, depth_t depth, const char *type, std::string_view detail) noexcept {\n   log_line(iter, index, depth, \"\", type, detail);\n }\n-simdjson_really_inline void log_value(const json_iterator &iter, const char *type, std::string_view detail, int delta, int depth_delta) noexcept {\n+inline void log_value(const json_iterator &iter, const char *type, std::string_view detail, int delta, int depth_delta) noexcept {\n   log_line(iter, \"\", type, detail, delta, depth_delta);\n }\n \n-simdjson_really_inline void log_start_value(const json_iterator &iter, token_position index, depth_t depth, const char *type, std::string_view detail) noexcept {\n+inline void log_start_value(const json_iterator &iter, token_position index, depth_t depth, const char *type, std::string_view detail) noexcept {\n   log_line(iter, index, depth, \"+\", type, detail);\n   if (LOG_ENABLED) { log_depth++; }\n }\n-simdjson_really_inline void log_start_value(const json_iterator &iter, const char *type, int delta, int depth_delta) noexcept {\n+inline void log_start_value(const json_iterator &iter, const char *type, int delta, int depth_delta) noexcept {\n   log_line(iter, \"+\", type, \"\", delta, depth_delta);\n   if (LOG_ENABLED) { log_depth++; }\n }\n \n-simdjson_really_inline void log_end_value(const json_iterator &iter, const char *type, int delta, int depth_delta) noexcept {\n+inline void log_end_value(const json_iterator &iter, const char *type, int delta, int depth_delta) noexcept {\n   if (LOG_ENABLED) { log_depth--; }\n   log_line(iter, \"-\", type, \"\", delta, depth_delta);\n }\n \n-simdjson_really_inline void log_error(const json_iterator &iter, const char *error, const char *detail, int delta, int depth_delta) noexcept {\n+inline void log_error(const json_iterator &iter, const char *error, const char *detail, int delta, int depth_delta) noexcept {\n   log_line(iter, \"ERROR: \", error, detail, delta, depth_delta);\n }\n-simdjson_really_inline void log_error(const json_iterator &iter, token_position index, depth_t depth, const char *error, const char *detail) noexcept {\n+inline void log_error(const json_iterator &iter, token_position index, depth_t depth, const char *error, const char *detail) noexcept {\n   log_line(iter, index, depth, \"ERROR: \", error, detail);\n }\n \n-simdjson_really_inline void log_event(const value_iterator &iter, const char *type, std::string_view detail, int delta, int depth_delta) noexcept {\n+inline void log_event(const value_iterator &iter, const char *type, std::string_view detail, int delta, int depth_delta) noexcept {\n   log_event(iter.json_iter(), type, detail, delta, depth_delta);\n }\n \n-simdjson_really_inline void log_value(const value_iterator &iter, const char *type, std::string_view detail, int delta, int depth_delta) noexcept {\n+inline void log_value(const value_iterator &iter, const char *type, std::string_view detail, int delta, int depth_delta) noexcept {\n   log_value(iter.json_iter(), type, detail, delta, depth_delta);\n }\n \n-simdjson_really_inline void log_start_value(const value_iterator &iter, const char *type, int delta, int depth_delta) noexcept {\n+inline void log_start_value(const value_iterator &iter, const char *type, int delta, int depth_delta) noexcept {\n   log_start_value(iter.json_iter(), type, delta, depth_delta);\n }\n \n-simdjson_really_inline void log_end_value(const value_iterator &iter, const char *type, int delta, int depth_delta) noexcept {\n+inline void log_end_value(const value_iterator &iter, const char *type, int delta, int depth_delta) noexcept {\n   log_end_value(iter.json_iter(), type, delta, depth_delta);\n }\n \n-simdjson_really_inline void log_error(const value_iterator &iter, const char *error, const char *detail, int delta, int depth_delta) noexcept {\n+inline void log_error(const value_iterator &iter, const char *error, const char *detail, int delta, int depth_delta) noexcept {\n   log_error(iter.json_iter(), error, detail, delta, depth_delta);\n }\n \n-simdjson_really_inline void log_headers() noexcept {\n+inline void log_headers() noexcept {\n   if (LOG_ENABLED) {\n+    // Technically a static variable is not thread-safe, but if you are using threads\n+    // and logging... well...\n+    static bool displayed_hint{false};\n     log_depth = 0;\n     printf(\"\\n\");\n+    if(!displayed_hint) {\n+      // We only print this helpful header once.\n+      printf(\"# Logging provides the depth and position of the iterator user-visible steps:\\n\");\n+      printf(\"# +array says 'this is where we were when we discovered the start array'\\n\");\n+      printf(\"# -array says 'this is where we were when we ended the array'\\n\");\n+      printf(\"# skip says 'this is a structural or value I am skipping'\\n\");\n+      printf(\"# +/-skip says 'this is a start/end array or object I am skipping'\\n\");\n+      printf(\"#\\n\");\n+      printf(\"# The identation of the terms (array, string,...) indicates the depth,\\n\");\n+      printf(\"# in addition to the depth being displayed.\\n\");\n+      printf(\"#\\n\");\n+      printf(\"# Every token in the document has a single depth determined by the tokens before it,\\n\");\n+      printf(\"# and is not affected by what the token actually is.\\n\");\n+      printf(\"#\\n\");\n+      printf(\"# Not all structural elements are presented as tokens in the logs.\\n\");\n+      printf(\"#\\n\");\n+      printf(\"# We never give control to the user within an empty array or an empty object.\\n\");\n+      printf(\"#\\n\");\n+      printf(\"# Inside an array, having a depth greater than the array's depth means that\\n\");\n+      printf(\"# we are pointing inside a value.\\n\");\n+      printf(\"# Having a depth equal to the array means that we are pointing right before a value.\\n\");\n+      printf(\"# Having a depth smaller than the array means that we have moved beyond the array.\\n\");\n+      displayed_hint = true;\n+    }\n+    printf(\"\\n\");\n     printf(\"| %-*s \", LOG_EVENT_LEN,        \"Event\");\n     printf(\"| %-*s \", LOG_BUFFER_LEN,       \"Buffer\");\n     printf(\"| %-*s \", LOG_SMALL_BUFFER_LEN, \"Next\");\n@@ -93,10 +121,10 @@ simdjson_really_inline void log_headers() noexcept {\n   }\n }\n \n-simdjson_really_inline void log_line(const json_iterator &iter, const char *title_prefix, const char *title, std::string_view detail, int delta, int depth_delta) noexcept {\n-  log_line(iter, iter.token.index+delta, depth_t(iter.depth()+depth_delta), title_prefix, title, detail);\n+inline void log_line(const json_iterator &iter, const char *title_prefix, const char *title, std::string_view detail, int delta, int depth_delta) noexcept {\n+  log_line(iter, iter.position()+delta, depth_t(iter.depth()+depth_delta), title_prefix, title, detail);\n }\n-simdjson_really_inline void log_line(const json_iterator &iter, token_position index, depth_t depth, const char *title_prefix, const char *title, std::string_view detail) noexcept {\n+inline void log_line(const json_iterator &iter, token_position index, depth_t depth, const char *title_prefix, const char *title, std::string_view detail) noexcept {\n   if (LOG_ENABLED) {\n     const int indent = depth*2;\n     const auto buf = iter.token.buf;\n--- vendor/simdjson/include/simdjson/generic/ondemand/logger.h\n@@ -13,23 +13,26 @@ namespace logger {\n   static constexpr const bool LOG_ENABLED = false;\n #endif\n \n-static simdjson_really_inline void log_headers() noexcept;\n-static simdjson_really_inline void log_line(const json_iterator &iter, token_position index, depth_t depth, const char *title_prefix, const char *title, std::string_view detail) noexcept;\n-static simdjson_really_inline void log_line(const json_iterator &iter, const char *title_prefix, const char *title, std::string_view detail, int delta, int depth_delta) noexcept;\n-static simdjson_really_inline void log_event(const json_iterator &iter, const char *type, std::string_view detail=\"\", int delta=0, int depth_delta=0) noexcept;\n-static simdjson_really_inline void log_value(const json_iterator &iter, token_position index, depth_t depth, const char *type, std::string_view detail=\"\") noexcept;\n-static simdjson_really_inline void log_value(const json_iterator &iter, const char *type, std::string_view detail=\"\", int delta=-1, int depth_delta=0) noexcept;\n-static simdjson_really_inline void log_start_value(const json_iterator &iter, token_position index, depth_t depth, const char *type, std::string_view detail=\"\") noexcept;\n-static simdjson_really_inline void log_start_value(const json_iterator &iter, const char *type, int delta=-1, int depth_delta=0) noexcept;\n-static simdjson_really_inline void log_end_value(const json_iterator &iter, const char *type, int delta=-1, int depth_delta=0) noexcept;\n-static simdjson_really_inline void log_error(const json_iterator &iter, token_position index, depth_t depth, const char *error, const char *detail=\"\") noexcept;\n-static simdjson_really_inline void log_error(const json_iterator &iter, const char *error, const char *detail=\"\", int delta=-1, int depth_delta=0) noexcept;\n+// We do not want these functions to be 'really inlined' since real inlining is\n+// for performance purposes and if you are using the loggers, you do not care about\n+// performance (or should not).\n+static inline void log_headers() noexcept;\n+static inline void log_line(const json_iterator &iter, token_position index, depth_t depth, const char *title_prefix, const char *title, std::string_view detail) noexcept;\n+static inline void log_line(const json_iterator &iter, const char *title_prefix, const char *title, std::string_view detail, int delta, int depth_delta) noexcept;\n+static inline void log_event(const json_iterator &iter, const char *type, std::string_view detail=\"\", int delta=0, int depth_delta=0) noexcept;\n+static inline void log_value(const json_iterator &iter, token_position index, depth_t depth, const char *type, std::string_view detail=\"\") noexcept;\n+static inline void log_value(const json_iterator &iter, const char *type, std::string_view detail=\"\", int delta=-1, int depth_delta=0) noexcept;\n+static inline void log_start_value(const json_iterator &iter, token_position index, depth_t depth, const char *type, std::string_view detail=\"\") noexcept;\n+static inline void log_start_value(const json_iterator &iter, const char *type, int delta=-1, int depth_delta=0) noexcept;\n+static inline void log_end_value(const json_iterator &iter, const char *type, int delta=-1, int depth_delta=0) noexcept;\n+static inline void log_error(const json_iterator &iter, token_position index, depth_t depth, const char *error, const char *detail=\"\") noexcept;\n+static inline void log_error(const json_iterator &iter, const char *error, const char *detail=\"\", int delta=-1, int depth_delta=0) noexcept;\n \n-static simdjson_really_inline void log_event(const value_iterator &iter, const char *type, std::string_view detail=\"\", int delta=0, int depth_delta=0) noexcept;\n-static simdjson_really_inline void log_value(const value_iterator &iter, const char *type, std::string_view detail=\"\", int delta=-1, int depth_delta=0) noexcept;\n-static simdjson_really_inline void log_start_value(const value_iterator &iter, const char *type, int delta=-1, int depth_delta=0) noexcept;\n-static simdjson_really_inline void log_end_value(const value_iterator &iter, const char *type, int delta=-1, int depth_delta=0) noexcept;\n-static simdjson_really_inline void log_error(const value_iterator &iter, const char *error, const char *detail=\"\", int delta=-1, int depth_delta=0) noexcept;\n+static inline void log_event(const value_iterator &iter, const char *type, std::string_view detail=\"\", int delta=0, int depth_delta=0) noexcept;\n+static inline void log_value(const value_iterator &iter, const char *type, std::string_view detail=\"\", int delta=-1, int depth_delta=0) noexcept;\n+static inline void log_start_value(const value_iterator &iter, const char *type, int delta=-1, int depth_delta=0) noexcept;\n+static inline void log_end_value(const value_iterator &iter, const char *type, int delta=-1, int depth_delta=0) noexcept;\n+static inline void log_error(const value_iterator &iter, const char *error, const char *detail=\"\", int delta=-1, int depth_delta=0) noexcept;\n \n } // namespace logger\n } // namespace ondemand\n--- vendor/simdjson/include/simdjson/generic/ondemand/object-inl.h\n@@ -34,21 +34,52 @@ simdjson_really_inline simdjson_result<value> object::find_field(const std::stri\n }\n \n simdjson_really_inline simdjson_result<object> object::start(value_iterator &iter) noexcept {\n-  // We don't need to know if the object is empty to start iteration, but we do want to know if there\n-  // is an error--thus `simdjson_unused`.\n-  simdjson_unused bool has_value;\n-  SIMDJSON_TRY( iter.start_object().get(has_value) );\n+  SIMDJSON_TRY( iter.start_object().error() );\n   return object(iter);\n }\n simdjson_really_inline simdjson_result<object> object::start_root(value_iterator &iter) noexcept {\n-  simdjson_unused bool has_value;\n-  SIMDJSON_TRY( iter.start_root_object().get(has_value) );\n+  SIMDJSON_TRY( iter.start_root_object().error() );\n   return object(iter);\n }\n-simdjson_really_inline object object::started(value_iterator &iter) noexcept {\n-  simdjson_unused bool has_value = iter.started_object();\n-  return iter;\n+simdjson_really_inline error_code object::consume() noexcept {\n+  if(iter.is_at_key()) {\n+    /**\n+     * whenever you are pointing at a key, calling skip_child() is\n+     * unsafe because you will hit a string and you will assume that\n+     * it is string value, and this mistake will lead you to make bad\n+     * depth computation.\n+     */\n+    /**\n+     * We want to 'consume' the key. We could really\n+     * just do _json_iter->return_current_and_advance(); at this\n+     * point, but, for clarity, we will use the high-level API to\n+     * eat the key. We assume that the compiler optimizes away\n+     * most of the work.\n+     */\n+    simdjson_unused raw_json_string actual_key;\n+    auto error = iter.field_key().get(actual_key);\n+    if (error) { iter.abandon(); return error; };\n+    // Let us move to the value while we are at it.\n+    if ((error = iter.field_value())) { iter.abandon(); return error; }\n+  }\n+  auto error_skip = iter.json_iter().skip_child(iter.depth()-1);\n+  if(error_skip) { iter.abandon(); }\n+  return error_skip;\n+}\n+\n+simdjson_really_inline simdjson_result<std::string_view> object::raw_json() noexcept {\n+  const uint8_t * starting_point{iter.peek_start()};\n+  auto error = consume();\n+  if(error) { return error; }\n+  const uint8_t * final_point{iter._json_iter->peek(0)};\n+  return std::string_view(reinterpret_cast<const char*>(starting_point), size_t(final_point - starting_point));\n }\n+\n+simdjson_really_inline simdjson_result<object> object::started(value_iterator &iter) noexcept {\n+  SIMDJSON_TRY( iter.started_object().error() );\n+  return object(iter);\n+}\n+\n simdjson_really_inline object object::resume(const value_iterator &iter) noexcept {\n   return iter;\n }\n@@ -68,6 +99,69 @@ simdjson_really_inline simdjson_result<object_iterator> object::end() noexcept {\n   return object_iterator(iter);\n }\n \n+inline simdjson_result<value> object::at_pointer(std::string_view json_pointer) noexcept {\n+  if (json_pointer[0] != '/') { return INVALID_JSON_POINTER; }\n+  json_pointer = json_pointer.substr(1);\n+  size_t slash = json_pointer.find('/');\n+  std::string_view key = json_pointer.substr(0, slash);\n+  // Grab the child with the given key\n+  simdjson_result<value> child;\n+\n+  // If there is an escape character in the key, unescape it and then get the child.\n+  size_t escape = key.find('~');\n+  if (escape != std::string_view::npos) {\n+    // Unescape the key\n+    std::string unescaped(key);\n+    do {\n+      switch (unescaped[escape+1]) {\n+        case '0':\n+          unescaped.replace(escape, 2, \"~\");\n+          break;\n+        case '1':\n+          unescaped.replace(escape, 2, \"/\");\n+          break;\n+        default:\n+          return INVALID_JSON_POINTER; // \"Unexpected ~ escape character in JSON pointer\");\n+      }\n+      escape = unescaped.find('~', escape+1);\n+    } while (escape != std::string::npos);\n+    child = find_field(unescaped);  // Take note find_field does not unescape keys when matching\n+  } else {\n+    child = find_field(key);\n+  }\n+  if(child.error()) {\n+    return child; // we do not continue if there was an error\n+  }\n+  // If there is a /, we have to recurse and look up more of the path\n+  if (slash != std::string_view::npos) {\n+    child = child.at_pointer(json_pointer.substr(slash));\n+  }\n+  return child;\n+}\n+\n+simdjson_really_inline simdjson_result<size_t> object::count_fields() & noexcept {\n+  size_t count{0};\n+  // Important: we do not consume any of the values.\n+  for(simdjson_unused auto v : *this) { count++; }\n+  // The above loop will always succeed, but we want to report errors.\n+  if(iter.error()) { return iter.error(); }\n+  // We need to move back at the start because we expect users to iterate through\n+  // the object after counting the number of elements.\n+  iter.reset_object();\n+  return count;\n+}\n+\n+simdjson_really_inline simdjson_result<bool> object::is_empty() & noexcept {\n+  bool is_not_empty;\n+  auto error = iter.reset_object().get(is_not_empty);\n+  if(error) { return error; }\n+  return !is_not_empty;\n+}\n+\n+simdjson_really_inline simdjson_result<bool> object::reset() & noexcept {\n+  return iter.reset_object();\n+}\n+\n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n@@ -112,4 +206,24 @@ simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>\n   return std::forward<SIMDJSON_IMPLEMENTATION::ondemand::object>(first).find_field(key);\n }\n \n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object>::at_pointer(std::string_view json_pointer) noexcept {\n+  if (error()) { return error(); }\n+  return first.at_pointer(json_pointer);\n+}\n+\n+inline simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object>::reset() noexcept {\n+  if (error()) { return error(); }\n+  return first.reset();\n+}\n+\n+inline simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object>::is_empty() noexcept {\n+  if (error()) { return error(); }\n+  return first.is_empty();\n+}\n+\n+simdjson_really_inline  simdjson_result<size_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object>::count_fields() & noexcept {\n+  if (error()) { return error(); }\n+  return first.count_fields();\n+}\n+\n } // namespace simdjson\n--- vendor/simdjson/include/simdjson/generic/ondemand/object.h\n@@ -18,7 +18,6 @@ class object {\n \n   simdjson_really_inline simdjson_result<object_iterator> begin() noexcept;\n   simdjson_really_inline simdjson_result<object_iterator> end() noexcept;\n-\n   /**\n    * Look up a field by name on an object (order-sensitive).\n    *\n@@ -75,10 +74,92 @@ class object {\n   /** @overload simdjson_really_inline simdjson_result<value> find_field_unordered(std::string_view key) & noexcept; */\n   simdjson_really_inline simdjson_result<value> operator[](std::string_view key) && noexcept;\n \n+  /**\n+   * Get the value associated with the given JSON pointer. We use the RFC 6901\n+   * https://tools.ietf.org/html/rfc6901 standard, interpreting the current node\n+   * as the root of its own JSON document.\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"foo\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"/foo/a/1\") == 20\n+   *\n+   * It is allowed for a key to be the empty string:\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"//a/1\") == 20\n+   *\n+   * Note that at_pointer() called on the document automatically calls the document's rewind\n+   * method between each call. It invalidates all previously accessed arrays, objects and values\n+   * that have not been consumed. Yet it is not the case when calling at_pointer on an object\n+   * instance: there is no rewind and no invalidation.\n+   *\n+   * You may call at_pointer more than once on an object, but each time the pointer is advanced\n+   * to be within the value matched by the key indicated by the JSON pointer query. Thus any preceeding\n+   * key (as well as the current key) can no longer be used with following JSON pointer calls.\n+   *\n+   * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching.\n+   *\n+   * @return The value associated with the given JSON pointer, or:\n+   *         - NO_SUCH_FIELD if a field does not exist in an object\n+   *         - INDEX_OUT_OF_BOUNDS if an array index is larger than an array length\n+   *         - INCORRECT_TYPE if a non-integer is used to access an array\n+   *         - INVALID_JSON_POINTER if the JSON pointer is invalid and cannot be parsed\n+   */\n+  inline simdjson_result<value> at_pointer(std::string_view json_pointer) noexcept;\n+\n+  /**\n+   * Reset the iterator so that we are pointing back at the\n+   * beginning of the object. You should still consume values only once even if you\n+   * can iterate through the object more than once. If you unescape a string within\n+   * the object more than once, you have unsafe code. Note that rewinding an object\n+   * means that you may need to reparse it anew: it is not a free operation.\n+   *\n+   * @returns true if the object contains some elements (not empty)\n+   */\n+  inline simdjson_result<bool> reset() & noexcept;\n+  /**\n+   * This method scans the beginning of the object and checks whether the\n+   * object is empty.\n+   * The runtime complexity is constant time. After\n+   * calling this function, if successful, the object is 'rewinded' at its\n+   * beginning as if it had never been accessed. If the JSON is malformed (e.g.,\n+   * there is a missing comma), then an error is returned and it is no longer\n+   * safe to continue.\n+   */\n+  inline simdjson_result<bool> is_empty() & noexcept;\n+  /**\n+   * This method scans the object and counts the number of key-value pairs.\n+   * The count_fields method should always be called before you have begun\n+   * iterating through the object: it is expected that you are pointing at\n+   * the beginning of the object.\n+   * The runtime complexity is linear in the size of the object. After\n+   * calling this function, if successful, the object is 'rewinded' at its\n+   * beginning as if it had never been accessed. If the JSON is malformed (e.g.,\n+   * there is a missing comma), then an error is returned and it is no longer\n+   * safe to continue.\n+   *\n+   * To check that an object is empty, it is more performant to use\n+   * the is_empty() method.\n+   */\n+  simdjson_really_inline simdjson_result<size_t> count_fields() & noexcept;\n+  /**\n+   * Consumes the object and returns a string_view instance corresponding to the\n+   * object as represented in JSON. It points inside the original byte array containg\n+   * the JSON document.\n+   */\n+  simdjson_really_inline simdjson_result<std::string_view> raw_json() noexcept;\n+\n protected:\n+  /**\n+   * Go to the end of the object, no matter where you are right now.\n+   */\n+  simdjson_really_inline error_code consume() noexcept;\n   static simdjson_really_inline simdjson_result<object> start(value_iterator &iter) noexcept;\n   static simdjson_really_inline simdjson_result<object> start_root(value_iterator &iter) noexcept;\n-  static simdjson_really_inline object started(value_iterator &iter) noexcept;\n+  static simdjson_really_inline simdjson_result<object> started(value_iterator &iter) noexcept;\n   static simdjson_really_inline object resume(const value_iterator &iter) noexcept;\n   simdjson_really_inline object(const value_iterator &iter) noexcept;\n \n@@ -112,6 +193,11 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> : public SIMDJ\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(std::string_view key) && noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> operator[](std::string_view key) & noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> operator[](std::string_view key) && noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at_pointer(std::string_view json_pointer) noexcept;\n+  inline simdjson_result<bool> reset() noexcept;\n+  inline simdjson_result<bool> is_empty() noexcept;\n+  inline simdjson_result<size_t> count_fields() & noexcept;\n+\n };\n \n } // namespace simdjson\n--- vendor/simdjson/include/simdjson/generic/ondemand/parser-inl.h\n@@ -2,7 +2,12 @@ namespace simdjson {\n namespace SIMDJSON_IMPLEMENTATION {\n namespace ondemand {\n \n+simdjson_really_inline parser::parser(size_t max_capacity) noexcept\n+  : _max_capacity{max_capacity} {\n+}\n+\n simdjson_warn_unused simdjson_really_inline error_code parser::allocate(size_t new_capacity, size_t new_max_depth) noexcept {\n+  if (new_capacity > max_capacity()) { return CAPACITY; }\n   if (string_buf && new_capacity == capacity() && new_max_depth == max_depth()) { return SUCCESS; }\n \n   // string_capacity copied from document::allocate\n@@ -32,7 +37,7 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<document> parser::it\n   }\n \n   // Run stage 1.\n-  SIMDJSON_TRY( implementation->stage1(reinterpret_cast<const uint8_t *>(json.data()), json.length(), false) );\n+  SIMDJSON_TRY( implementation->stage1(reinterpret_cast<const uint8_t *>(json.data()), json.length(), stage1_mode::regular) );\n   return document::start({ reinterpret_cast<const uint8_t *>(json.data()), this });\n }\n \n@@ -75,17 +80,42 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<json_iterator> parse\n   }\n \n   // Run stage 1.\n-  SIMDJSON_TRY( implementation->stage1(reinterpret_cast<const uint8_t *>(json.data()), json.length(), false) );\n+  SIMDJSON_TRY( implementation->stage1(reinterpret_cast<const uint8_t *>(json.data()), json.length(), stage1_mode::regular) );\n   return json_iterator(reinterpret_cast<const uint8_t *>(json.data()), this);\n }\n \n+inline simdjson_result<document_stream> parser::iterate_many(const uint8_t *buf, size_t len, size_t batch_size) noexcept {\n+  if(batch_size < MINIMAL_BATCH_SIZE) { batch_size = MINIMAL_BATCH_SIZE; }\n+  return document_stream(*this, buf, len, batch_size);\n+}\n+inline simdjson_result<document_stream> parser::iterate_many(const char *buf, size_t len, size_t batch_size) noexcept {\n+  return iterate_many(reinterpret_cast<const uint8_t *>(buf), len, batch_size);\n+}\n+inline simdjson_result<document_stream> parser::iterate_many(const std::string &s, size_t batch_size) noexcept {\n+  return iterate_many(s.data(), s.length(), batch_size);\n+}\n+inline simdjson_result<document_stream> parser::iterate_many(const padded_string &s, size_t batch_size) noexcept {\n+  return iterate_many(s.data(), s.length(), batch_size);\n+}\n+\n simdjson_really_inline size_t parser::capacity() const noexcept {\n   return _capacity;\n }\n+simdjson_really_inline size_t parser::max_capacity() const noexcept {\n+  return _max_capacity;\n+}\n simdjson_really_inline size_t parser::max_depth() const noexcept {\n   return _max_depth;\n }\n \n+simdjson_really_inline void parser::set_max_capacity(size_t max_capacity) noexcept {\n+  size_t MINIMAL_DOCUMENT_CAPACITY = 32;\n+  if(max_capacity < MINIMAL_DOCUMENT_CAPACITY) {\n+    _max_capacity = max_capacity;\n+  } else {\n+    _max_capacity = MINIMAL_DOCUMENT_CAPACITY;\n+  }\n+}\n \n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n--- vendor/simdjson/include/simdjson/generic/ondemand/parser.h\n@@ -8,6 +8,23 @@ class array;\n class object;\n class value;\n class raw_json_string;\n+class document_stream;\n+\n+/**\n+ * The default batch size for document_stream instances for this On Demand kernel.\n+ * Note that different On Demand kernel may use a different DEFAULT_BATCH_SIZE value\n+ * in the future.\n+ */\n+static constexpr size_t DEFAULT_BATCH_SIZE = 1000000;\n+/**\n+ * Some adversary might try to set the batch size to 0 or 1, which might cause problems.\n+ * We set a minimum of 32B since anything else is highly likely to be an error. In practice,\n+ * most users will want a much larger batch size.\n+ *\n+ * All non-negative MINIMAL_BATCH_SIZE values should be 'safe' except that, obviously, no JSON\n+ * document can ever span 0 or 1 byte and that very large values would create memory allocation issues.\n+ */\n+static constexpr size_t MINIMAL_BATCH_SIZE = 32;\n \n /**\n  * A JSON fragment iterator.\n@@ -21,11 +38,12 @@ class parser {\n    *\n    * The new parser will have zero capacity.\n    */\n-  inline parser() noexcept = default;\n+  inline explicit parser(size_t max_capacity = SIMDJSON_MAXSIZE_BYTES) noexcept;\n \n   inline parser(parser &&other) noexcept = default;\n   simdjson_really_inline parser(const parser &other) = delete;\n   simdjson_really_inline parser &operator=(const parser &other) = delete;\n+  simdjson_really_inline parser &operator=(parser &&other) noexcept = default;\n \n   /** Deallocate the JSON parser. */\n   inline ~parser() noexcept = default;\n@@ -36,6 +54,11 @@ class parser {\n    *   ondemand::parser parser;\n    *   document doc = parser.iterate(json);\n    *\n+   * ### IMPORTANT: Validate what you use\n+   *\n+   * Calling iterate on an invalid JSON document may not immediately trigger an error. The call to\n+   * iterate does not parse and validate the whole document.\n+   *\n    * ### IMPORTANT: Buffer Lifetime\n    *\n    * Because parsing is done while you iterate, you *must* keep the JSON buffer around at least as\n@@ -100,14 +123,15 @@ class parser {\n    * iteration to ensure intermediate buffers can be accessed. Any document must be destroyed before\n    * you call parse() again or destroy the parser.\n    *\n+   * The ondemand::document instance holds the iterator. The document must remain in scope\n+   * while you are accessing instances of ondemand::value, ondemand::object, ondemand::array.\n+   *\n    * ### REQUIRED: Buffer Padding\n    *\n    * The buffer must have at least SIMDJSON_PADDING extra allocated bytes. It does not matter what\n    * those bytes are initialized to, as long as they are allocated.\n    *\n    * @param json The JSON to parse.\n-   * @param len The length of the JSON.\n-   * @param allocated The number of bytes allocated in the JSON (must be at least len+SIMDJSON_PADDING).\n    *\n    * @return The iterator, or an error:\n    *         - INSUFFICIENT_PADDING if the input has less than SIMDJSON_PADDING extra bytes.\n@@ -120,21 +144,88 @@ class parser {\n    */\n   simdjson_warn_unused simdjson_result<json_iterator> iterate_raw(padded_string_view json) & noexcept;\n \n+\n+  /**\n+   * Parse a buffer containing many JSON documents.\n+   *\n+   *   auto json = R\"({ \"foo\": 1 } { \"foo\": 2 } { \"foo\": 3 } )\"_padded;\n+   *   ondemand::parser parser;\n+   *   ondemand::document_stream docs = parser.iterate_many(json);\n+   *   for (auto & doc : docs) {\n+   *     std::cout << doc[\"foo\"] << std::endl;\n+   *   }\n+   *   // Prints 1 2 3\n+   *\n+   * No copy of the input buffer is made.\n+   *\n+   * The function is lazy: it may be that no more than one JSON document at a time is parsed.\n+   *\n+   * The caller is responsabile to ensure that the input string data remains unchanged and is\n+   * not deleted during the loop.\n+   *\n+   * ### Format\n+   *\n+   * The buffer must contain a series of one or more JSON documents, concatenated into a single\n+   * buffer, separated by whitespace. It effectively parses until it has a fully valid document,\n+   * then starts parsing the next document at that point. (It does this with more parallelism and\n+   * lookahead than you might think, though.)\n+   *\n+   * documents that consist of an object or array may omit the whitespace between them, concatenating\n+   * with no separator. documents that consist of a single primitive (i.e. documents that are not\n+   * arrays or objects) MUST be separated with whitespace.\n+   *\n+   * The documents must not exceed batch_size bytes (by default 1MB) or they will fail to parse.\n+   * Setting batch_size to excessively large or excesively small values may impact negatively the\n+   * performance.\n+   *\n+   * ### REQUIRED: Buffer Padding\n+   *\n+   * The buffer must have at least SIMDJSON_PADDING extra allocated bytes. It does not matter what\n+   * those bytes are initialized to, as long as they are allocated.\n+   *\n+   * ### Threads\n+   *\n+   * When compiled with SIMDJSON_THREADS_ENABLED, this method will use a single thread under the\n+   * hood to do some lookahead.\n+   *\n+   * ### Parser Capacity\n+   *\n+   * If the parser's current capacity is less than batch_size, it will allocate enough capacity\n+   * to handle it (up to max_capacity).\n+   *\n+   * @param buf The concatenated JSON to parse.\n+   * @param len The length of the concatenated JSON.\n+   * @param batch_size The batch size to use. MUST be larger than the largest document. The sweet\n+   *                   spot is cache-related: small enough to fit in cache, yet big enough to\n+   *                   parse as many documents as possible in one tight loop.\n+   *                   Defaults to 10MB, which has been a reasonable sweet spot in our tests.\n+   * @return The stream, or an error. An empty input will yield 0 documents rather than an EMPTY error. Errors:\n+   *         - MEMALLOC if the parser does not have enough capacity and memory allocation fails\n+   *         - CAPACITY if the parser does not have enough capacity and batch_size > max_capacity.\n+   *         - other json errors if parsing fails. You should not rely on these errors to always the same for the\n+   *           same document: they may vary under runtime dispatch (so they may vary depending on your system and hardware).\n+   */\n+  inline simdjson_result<document_stream> iterate_many(const uint8_t *buf, size_t len, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept;\n+  /** @overload parse_many(const uint8_t *buf, size_t len, size_t batch_size) */\n+  inline simdjson_result<document_stream> iterate_many(const char *buf, size_t len, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept;\n+  /** @overload parse_many(const uint8_t *buf, size_t len, size_t batch_size) */\n+  inline simdjson_result<document_stream> iterate_many(const std::string &s, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept;\n+  inline simdjson_result<document_stream> iterate_many(const std::string &&s, size_t batch_size) = delete;// unsafe\n+  /** @overload parse_many(const uint8_t *buf, size_t len, size_t batch_size) */\n+  inline simdjson_result<document_stream> iterate_many(const padded_string &s, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept;\n+  inline simdjson_result<document_stream> iterate_many(const padded_string &&s, size_t batch_size) = delete;// unsafe\n+\n+  /** @private We do not want to allow implicit conversion from C string to std::string. */\n+  simdjson_result<document_stream> iterate_many(const char *buf, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept = delete;\n+\n   /** The capacity of this parser (the largest document it can process). */\n   simdjson_really_inline size_t capacity() const noexcept;\n+  /** The maximum capacity of this parser (the largest document it is allowed to process). */\n+  simdjson_really_inline size_t max_capacity() const noexcept;\n+  simdjson_really_inline void set_max_capacity(size_t max_capacity) noexcept;\n   /** The maximum depth of this parser (the most deeply nested objects and arrays it can process). */\n   simdjson_really_inline size_t max_depth() const noexcept;\n \n-private:\n-  /** @private [for benchmarking access] The implementation to use */\n-  std::unique_ptr<internal::dom_parser_implementation> implementation{};\n-  size_t _capacity{0};\n-  size_t _max_depth{DEFAULT_MAX_DEPTH};\n-  std::unique_ptr<uint8_t[]> string_buf{};\n-#ifdef SIMDJSON_DEVELOPMENT_CHECKS\n-  std::unique_ptr<token_position[]> start_positions{};\n-#endif\n-\n   /**\n    * Ensure this parser has enough memory to process JSON documents up to `capacity` bytes in length\n    * and `max_depth` depth.\n@@ -145,7 +236,28 @@ class parser {\n    */\n   simdjson_warn_unused error_code allocate(size_t capacity, size_t max_depth=DEFAULT_MAX_DEPTH) noexcept;\n \n+  #ifdef SIMDJSON_THREADS_ENABLED\n+  /**\n+   * The parser instance can use threads when they are available to speed up some\n+   * operations. It is enabled by default. Changing this attribute will change the\n+   * behavior of the parser for future operations.\n+   */\n+  bool threaded{true};\n+  #endif\n+\n+private:\n+  /** @private [for benchmarking access] The implementation to use */\n+  std::unique_ptr<internal::dom_parser_implementation> implementation{};\n+  size_t _capacity{0};\n+  size_t _max_capacity;\n+  size_t _max_depth{DEFAULT_MAX_DEPTH};\n+  std::unique_ptr<uint8_t[]> string_buf{};\n+#ifdef SIMDJSON_DEVELOPMENT_CHECKS\n+  std::unique_ptr<token_position[]> start_positions{};\n+#endif\n+\n   friend class json_iterator;\n+  friend class document_stream;\n };\n \n } // namespace ondemand\n--- vendor/simdjson/include/simdjson/generic/ondemand/raw_json_string.h\n@@ -75,7 +75,7 @@ class raw_json_string {\n    * long strings.\n    *\n    * If target is a compile-time constant, and your compiler likes you,\n-   * you should be able to do the following without performance penatly...\n+   * you should be able to do the following without performance penalty...\n    *\n    *   static_assert(raw_json_string::is_free_from_unescaped_quote(target), \"\");\n    *   s.unsafe_is_equal(target);\n@@ -89,7 +89,7 @@ class raw_json_string {\n    * the caller is responsible for this check. See is_free_from_unescaped_quote.\n    *\n    * If target is a compile-time constant, and your compiler likes you,\n-   * you should be able to do the following without performance penatly...\n+   * you should be able to do the following without performance penalty...\n    *\n    *   static_assert(raw_json_string::is_free_from_unescaped_quote(target), \"\");\n    *   s.unsafe_is_equal(target);\n--- vendor/simdjson/include/simdjson/generic/ondemand/serialization-inl.h\n@@ -0,0 +1,218 @@\n+\n+\n+namespace simdjson {\n+\n+inline std::string_view trim(const std::string_view str) noexcept {\n+  // We can almost surely do better by rolling our own find_first_not_of function.\n+  size_t first = str.find_first_not_of(\" \\t\\n\\r\");\n+  // If we have the empty string (just white space), then no trimming is possible, and\n+  // we return the empty string_view.\n+  if (std::string_view::npos == first) { return std::string_view(); }\n+  size_t last = str.find_last_not_of(\" \\t\\n\\r\");\n+  return str.substr(first, (last - first + 1));\n+}\n+\n+\n+inline simdjson_result<std::string_view> to_json_string(SIMDJSON_IMPLEMENTATION::ondemand::document& x) noexcept {\n+  std::string_view v;\n+  auto error = x.raw_json().get(v);\n+  if(error) {return error; }\n+  return trim(v);\n+}\n+\n+inline simdjson_result<std::string_view> to_json_string(SIMDJSON_IMPLEMENTATION::ondemand::document_reference& x) noexcept {\n+  std::string_view v;\n+  auto error = x.raw_json().get(v);\n+  if(error) {return error; }\n+  return trim(v);\n+}\n+\n+inline simdjson_result<std::string_view> to_json_string(SIMDJSON_IMPLEMENTATION::ondemand::value& x) noexcept {\n+  /**\n+   * If we somehow receive a value that has already been consumed,\n+   * then the following code could be in trouble. E.g., we create\n+   * an array as needed, but if an array was already created, then\n+   * it could be bad.\n+   */\n+  using namespace SIMDJSON_IMPLEMENTATION::ondemand;\n+  SIMDJSON_IMPLEMENTATION::ondemand::json_type t;\n+  auto error = x.type().get(t);\n+  if(error != SUCCESS) { return error; }\n+  switch (t)\n+  {\n+    case json_type::array:\n+    {\n+      SIMDJSON_IMPLEMENTATION::ondemand::array array;\n+      error = x.get_array().get(array);\n+      if(error) { return error; }\n+      return to_json_string(array);\n+    }\n+    case json_type::object:\n+    {\n+      SIMDJSON_IMPLEMENTATION::ondemand::object object;\n+      error = x.get_object().get(object);\n+      if(error) { return error; }\n+      return to_json_string(object);\n+    }\n+    default:\n+      return trim(x.raw_json_token());\n+  }\n+}\n+\n+inline simdjson_result<std::string_view> to_json_string(SIMDJSON_IMPLEMENTATION::ondemand::object& x) noexcept {\n+  std::string_view v;\n+  auto error = x.raw_json().get(v);\n+  if(error) {return error; }\n+  return trim(v);\n+}\n+\n+inline simdjson_result<std::string_view> to_json_string(SIMDJSON_IMPLEMENTATION::ondemand::array& x) noexcept {\n+  std::string_view v;\n+  auto error = x.raw_json().get(v);\n+  if(error) {return error; }\n+  return trim(v);\n+}\n+\n+inline simdjson_result<std::string_view> to_json_string(simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document> x) {\n+  if (x.error()) { return x.error(); }\n+  return to_json_string(x.value_unsafe());\n+}\n+\n+inline simdjson_result<std::string_view> to_json_string(simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference> x) {\n+  if (x.error()) { return x.error(); }\n+  return to_json_string(x.value_unsafe());\n+}\n+\n+inline simdjson_result<std::string_view> to_json_string(simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> x) {\n+  if (x.error()) { return x.error(); }\n+  return to_json_string(x.value_unsafe());\n+}\n+\n+inline simdjson_result<std::string_view> to_json_string(simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> x) {\n+  if (x.error()) { return x.error(); }\n+  return to_json_string(x.value_unsafe());\n+}\n+\n+inline simdjson_result<std::string_view> to_json_string(simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array> x) {\n+  if (x.error()) { return x.error(); }\n+  return to_json_string(x.value_unsafe());\n+}\n+} // namespace simdjson\n+\n+\n+#if SIMDJSON_EXCEPTIONS\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::value x) {\n+  std::string_view v;\n+  auto error = simdjson::to_json_string(x).get(v);\n+  if(error == simdjson::SUCCESS) {\n+    return (out << v);\n+  } else {\n+    throw simdjson::simdjson_error(error);\n+  }\n+}\n+inline std::ostream& operator<<(std::ostream& out, simdjson::simdjson_result<simdjson::SIMDJSON_IMPLEMENTATION::ondemand::value> x) {\n+  if (x.error()) { throw simdjson::simdjson_error(x.error()); }\n+  return (out << x.value());\n+}\n+#else\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::value x) {\n+  std::string_view v;\n+  auto error = simdjson::to_json_string(x).get(v);\n+  if(error == simdjson::SUCCESS) {\n+    return (out << v);\n+  } else {\n+    return (out << error);\n+  }\n+}\n+#endif\n+\n+#if SIMDJSON_EXCEPTIONS\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::array value) {\n+  std::string_view v;\n+  auto error = simdjson::to_json_string(value).get(v);\n+  if(error == simdjson::SUCCESS) {\n+    return (out << v);\n+  } else {\n+    throw simdjson::simdjson_error(error);\n+  }\n+}\n+inline std::ostream& operator<<(std::ostream& out, simdjson::simdjson_result<simdjson::SIMDJSON_IMPLEMENTATION::ondemand::array> x) {\n+  if (x.error()) { throw simdjson::simdjson_error(x.error()); }\n+  return (out << x.value());\n+}\n+#else\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::array value) {\n+  std::string_view v;\n+  auto error = simdjson::to_json_string(value).get(v);\n+  if(error == simdjson::SUCCESS) {\n+    return (out << v);\n+  } else {\n+    return (out << error);\n+  }\n+}\n+#endif\n+\n+#if SIMDJSON_EXCEPTIONS\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::document& value)  {\n+  std::string_view v;\n+  auto error = simdjson::to_json_string(value).get(v);\n+  if(error == simdjson::SUCCESS) {\n+    return (out << v);\n+  } else {\n+    throw simdjson::simdjson_error(error);\n+  }\n+}\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::document_reference& value)  {\n+  std::string_view v;\n+  auto error = simdjson::to_json_string(value).get(v);\n+  if(error == simdjson::SUCCESS) {\n+    return (out << v);\n+  } else {\n+    throw simdjson::simdjson_error(error);\n+  }\n+}\n+inline std::ostream& operator<<(std::ostream& out, simdjson::simdjson_result<simdjson::SIMDJSON_IMPLEMENTATION::ondemand::document>&& x) {\n+  if (x.error()) { throw simdjson::simdjson_error(x.error()); }\n+  return (out << x.value());\n+}\n+inline std::ostream& operator<<(std::ostream& out, simdjson::simdjson_result<simdjson::SIMDJSON_IMPLEMENTATION::ondemand::document_reference>&& x) {\n+  if (x.error()) { throw simdjson::simdjson_error(x.error()); }\n+  return (out << x.value());\n+}\n+#else\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::document& value)  {\n+  std::string_view v;\n+  auto error = simdjson::to_json_string(value).get(v);\n+  if(error == simdjson::SUCCESS) {\n+    return (out << v);\n+  } else {\n+    return (out << error);\n+  }\n+}\n+#endif\n+\n+#if SIMDJSON_EXCEPTIONS\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::object value) {\n+  std::string_view v;\n+  auto error = simdjson::to_json_string(value).get(v);\n+  if(error == simdjson::SUCCESS) {\n+    return (out << v);\n+  } else {\n+    throw simdjson::simdjson_error(error);\n+  }\n+}\n+inline std::ostream& operator<<(std::ostream& out,  simdjson::simdjson_result<simdjson::SIMDJSON_IMPLEMENTATION::ondemand::object> x) {\n+  if (x.error()) { throw  simdjson::simdjson_error(x.error()); }\n+  return (out << x.value());\n+}\n+#else\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::object value) {\n+  std::string_view v;\n+  auto error = simdjson::to_json_string(value).get(v);\n+  if(error == simdjson::SUCCESS) {\n+    return (out << v);\n+  } else {\n+    return (out << error);\n+  }\n+}\n+#endif\n--- vendor/simdjson/include/simdjson/generic/ondemand/serialization.h\n@@ -0,0 +1,80 @@\n+#include \"simdjson/dom/serialization.h\"\n+#include \"simdjson/error.h\"\n+\n+namespace simdjson {\n+/**\n+ * Create a string-view instance out of a document instance. The string-view instance\n+ * contains JSON text that is suitable to be parsed as JSON again.\n+ */\n+inline simdjson_result<std::string_view> to_json_string(SIMDJSON_IMPLEMENTATION::ondemand::document& x) noexcept;\n+/**\n+ * Create a string-view instance out of a value instance. The string-view instance\n+ * contains JSON text that is suitable to be parsed as JSON again. The value must\n+ * not have been accessed previously.\n+ */\n+inline simdjson_result<std::string_view> to_json_string(SIMDJSON_IMPLEMENTATION::ondemand::value& x) noexcept;\n+/**\n+ * Create a string-view instance out of an object instance. The string-view instance\n+ * contains JSON text that is suitable to be parsed as JSON again.\n+ */\n+inline simdjson_result<std::string_view> to_json_string(SIMDJSON_IMPLEMENTATION::ondemand::object& x) noexcept;\n+/**\n+ * Create a string-view instance out of an array instance. The string-view instance\n+ * contains JSON text that is suitable to be parsed as JSON again.\n+ */\n+inline simdjson_result<std::string_view> to_json_string(SIMDJSON_IMPLEMENTATION::ondemand::array& x) noexcept;\n+inline simdjson_result<std::string_view> to_json_string(simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document> x);\n+inline simdjson_result<std::string_view> to_json_string(simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> x);\n+inline simdjson_result<std::string_view> to_json_string(simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> x);\n+inline simdjson_result<std::string_view> to_json_string(simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array> x);\n+} // namespace simdjson\n+\n+\n+/**\n+ * Print JSON to an output stream.\n+ *\n+ * @param out The output stream.\n+ * @param value The element.\n+ * @throw if there is an error with the underlying output stream. simdjson itself will not throw.\n+ */\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::value x);\n+#if SIMDJSON_EXCEPTIONS\n+inline std::ostream& operator<<(std::ostream& out, simdjson::simdjson_result<simdjson::SIMDJSON_IMPLEMENTATION::ondemand::value> x);\n+#endif\n+/**\n+ * Print JSON to an output stream.\n+ *\n+ * @param out The output stream.\n+ * @param value The array.\n+ * @throw if there is an error with the underlying output stream. simdjson itself will not throw.\n+ */\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::array value);\n+#if SIMDJSON_EXCEPTIONS\n+inline std::ostream& operator<<(std::ostream& out, simdjson::simdjson_result<simdjson::SIMDJSON_IMPLEMENTATION::ondemand::array> x);\n+#endif\n+/**\n+ * Print JSON to an output stream.\n+ *\n+ * @param out The output stream.\n+ * @param value The array.\n+ * @throw if there is an error with the underlying output stream. simdjson itself will not throw.\n+ */\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::document& value);\n+#if SIMDJSON_EXCEPTIONS\n+inline std::ostream& operator<<(std::ostream& out, simdjson::simdjson_result<simdjson::SIMDJSON_IMPLEMENTATION::ondemand::document>&& x);\n+#endif\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::document_reference& value);\n+#if SIMDJSON_EXCEPTIONS\n+inline std::ostream& operator<<(std::ostream& out, simdjson::simdjson_result<simdjson::SIMDJSON_IMPLEMENTATION::ondemand::document_reference>&& x);\n+#endif\n+/**\n+ * Print JSON to an output stream.\n+ *\n+ * @param out The output stream.\n+ * @param value The object.\n+ * @throw if there is an error with the underlying output stream. simdjson itself will not throw.\n+ */\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::object value);\n+#if SIMDJSON_EXCEPTIONS\n+inline std::ostream& operator<<(std::ostream& out, simdjson::simdjson_result<simdjson::SIMDJSON_IMPLEMENTATION::ondemand::object> x);\n+#endif\n--- vendor/simdjson/include/simdjson/generic/ondemand/token_iterator-inl.h\n@@ -2,13 +2,20 @@ namespace simdjson {\n namespace SIMDJSON_IMPLEMENTATION {\n namespace ondemand {\n \n-simdjson_really_inline token_iterator::token_iterator(const uint8_t *_buf, token_position _index) noexcept\n-  : buf{_buf}, index{_index}\n+simdjson_really_inline token_iterator::token_iterator(\n+  const uint8_t *_buf,\n+  token_position position\n+) noexcept : buf{_buf}, _position{position}\n {\n }\n \n-simdjson_really_inline const uint8_t *token_iterator::advance() noexcept {\n-  return &buf[*(index++)];\n+simdjson_really_inline uint32_t token_iterator::current_offset() const noexcept {\n+  return *(_position);\n+}\n+\n+\n+simdjson_really_inline const uint8_t *token_iterator::return_current_and_advance() noexcept {\n+  return &buf[*(_position++)];\n }\n \n simdjson_really_inline const uint8_t *token_iterator::peek(token_position position) const noexcept {\n@@ -22,39 +29,39 @@ simdjson_really_inline uint32_t token_iterator::peek_length(token_position posit\n }\n \n simdjson_really_inline const uint8_t *token_iterator::peek(int32_t delta) const noexcept {\n-  return &buf[*(index+delta)];\n+  return &buf[*(_position+delta)];\n }\n simdjson_really_inline uint32_t token_iterator::peek_index(int32_t delta) const noexcept {\n-  return *(index+delta);\n+  return *(_position+delta);\n }\n simdjson_really_inline uint32_t token_iterator::peek_length(int32_t delta) const noexcept {\n-  return *(index+delta+1) - *(index+delta);\n+  return *(_position+delta+1) - *(_position+delta);\n }\n \n simdjson_really_inline token_position token_iterator::position() const noexcept {\n-  return index;\n+  return _position;\n }\n-simdjson_really_inline void token_iterator::set_position(token_position target_checkpoint) noexcept {\n-  index = target_checkpoint;\n+simdjson_really_inline void token_iterator::set_position(token_position target_position) noexcept {\n+  _position = target_position;\n }\n \n simdjson_really_inline bool token_iterator::operator==(const token_iterator &other) const noexcept {\n-  return index == other.index;\n+  return _position == other._position;\n }\n simdjson_really_inline bool token_iterator::operator!=(const token_iterator &other) const noexcept {\n-  return index != other.index;\n+  return _position != other._position;\n }\n simdjson_really_inline bool token_iterator::operator>(const token_iterator &other) const noexcept {\n-  return index > other.index;\n+  return _position > other._position;\n }\n simdjson_really_inline bool token_iterator::operator>=(const token_iterator &other) const noexcept {\n-  return index >= other.index;\n+  return _position >= other._position;\n }\n simdjson_really_inline bool token_iterator::operator<(const token_iterator &other) const noexcept {\n-  return index < other.index;\n+  return _position < other._position;\n }\n simdjson_really_inline bool token_iterator::operator<=(const token_iterator &other) const noexcept {\n-  return index <= other.index;\n+  return _position <= other._position;\n }\n \n } // namespace ondemand\n--- vendor/simdjson/include/simdjson/generic/ondemand/token_iterator.h\n@@ -23,11 +23,12 @@ class token_iterator {\n \n   /**\n    * Advance to the next token (returning the current one).\n-   *\n-   * Does not check or update depth/expect_value. Caller is responsible for that.\n    */\n-  simdjson_really_inline const uint8_t *advance() noexcept;\n-\n+  simdjson_really_inline const uint8_t *return_current_and_advance() noexcept;\n+  /**\n+   * Reports the current offset in bytes from the start of the underlying buffer.\n+   */\n+  simdjson_really_inline uint32_t current_offset() const noexcept;\n   /**\n    * Get the JSON text for a given token (relative).\n    *\n@@ -57,8 +58,6 @@ class token_iterator {\n    *\n    * @param position The position of the token.\n    *\n-   * TODO consider a string_view, assuming the length will get stripped out by the optimizer when\n-   * it isn't used ...\n    */\n   simdjson_really_inline const uint8_t *peek(token_position position) const noexcept;\n   /**\n@@ -71,13 +70,13 @@ class token_iterator {\n   simdjson_really_inline uint32_t peek_length(token_position position) const noexcept;\n \n   /**\n-   * Save the current index to be restored later.\n+   * Return the current index.\n    */\n   simdjson_really_inline token_position position() const noexcept;\n   /**\n    * Reset to a previously saved index.\n    */\n-  simdjson_really_inline void set_position(token_position target_checkpoint) noexcept;\n+  simdjson_really_inline void set_position(token_position target_position) noexcept;\n \n   // NOTE: we don't support a full C++ iterator interface, because we expect people to make\n   // different calls to advance the iterator based on *their own* state.\n@@ -90,7 +89,7 @@ class token_iterator {\n   simdjson_really_inline bool operator<=(const token_iterator &other) const noexcept;\n \n protected:\n-  simdjson_really_inline token_iterator(const uint8_t *buf, token_position index) noexcept;\n+  simdjson_really_inline token_iterator(const uint8_t *buf, token_position position) noexcept;\n \n   /**\n    * Get the index of the JSON text for a given token (relative).\n@@ -112,7 +111,7 @@ class token_iterator {\n   simdjson_really_inline uint32_t peek_index(token_position position) const noexcept;\n \n   const uint8_t *buf{};\n-  token_position index{};\n+  token_position _position{};\n \n   friend class json_iterator;\n   friend class value_iterator;\n--- vendor/simdjson/include/simdjson/generic/ondemand/value-inl.h\n@@ -36,12 +36,21 @@ simdjson_really_inline simdjson_result<std::string_view> value::get_string() noe\n simdjson_really_inline simdjson_result<double> value::get_double() noexcept {\n   return iter.get_double();\n }\n+simdjson_really_inline simdjson_result<double> value::get_double_in_string() noexcept {\n+  return iter.get_double_in_string();\n+}\n simdjson_really_inline simdjson_result<uint64_t> value::get_uint64() noexcept {\n   return iter.get_uint64();\n }\n+simdjson_really_inline simdjson_result<uint64_t> value::get_uint64_in_string() noexcept {\n+  return iter.get_uint64_in_string();\n+}\n simdjson_really_inline simdjson_result<int64_t> value::get_int64() noexcept {\n   return iter.get_int64();\n }\n+simdjson_really_inline simdjson_result<int64_t> value::get_int64_in_string() noexcept {\n+  return iter.get_int64_in_string();\n+}\n simdjson_really_inline simdjson_result<bool> value::get_bool() noexcept {\n   return iter.get_bool();\n }\n@@ -95,6 +104,20 @@ simdjson_really_inline simdjson_result<array_iterator> value::begin() & noexcept\n simdjson_really_inline simdjson_result<array_iterator> value::end() & noexcept {\n   return {};\n }\n+simdjson_really_inline simdjson_result<size_t> value::count_elements() & noexcept {\n+  simdjson_result<size_t> answer;\n+  auto a = get_array();\n+  answer = a.count_elements();\n+  // count_elements leaves you pointing inside the array, at the first element.\n+  // We need to move back so that the user can create a new array (which requires that\n+  // we point at '[').\n+  iter.move_at_start();\n+  return answer;\n+}\n+simdjson_really_inline simdjson_result<value> value::at(size_t index) noexcept {\n+  auto a = get_array();\n+  return a.at(index);\n+}\n \n simdjson_really_inline simdjson_result<value> value::find_field(std::string_view key) noexcept {\n   return start_or_resume_object().find_field(key);\n@@ -121,10 +144,45 @@ simdjson_really_inline simdjson_result<json_type> value::type() noexcept {\n   return iter.type();\n }\n \n+simdjson_really_inline simdjson_result<bool> value::is_scalar() noexcept {\n+  json_type this_type;\n+  auto error = type().get(this_type);\n+  if(error) { return error; }\n+  return ! ((this_type == json_type::array) || (this_type == json_type::object));\n+}\n+\n+simdjson_really_inline bool value::is_negative() noexcept {\n+  return iter.is_negative();\n+}\n+\n+simdjson_really_inline simdjson_result<bool> value::is_integer() noexcept {\n+  return iter.is_integer();\n+}\n+simdjson_warn_unused simdjson_really_inline simdjson_result<number_type> value::get_number_type() noexcept {\n+  return iter.get_number_type();\n+}\n+simdjson_warn_unused simdjson_really_inline simdjson_result<number> value::get_number() noexcept {\n+  return iter.get_number();\n+}\n+\n simdjson_really_inline std::string_view value::raw_json_token() noexcept {\n   return std::string_view(reinterpret_cast<const char*>(iter.peek_start()), iter.peek_start_length());\n }\n \n+simdjson_really_inline simdjson_result<value> value::at_pointer(std::string_view json_pointer) noexcept {\n+  json_type t;\n+  SIMDJSON_TRY(type().get(t));\n+  switch (t)\n+  {\n+    case json_type::array:\n+      return (*this).get_array().at_pointer(json_pointer);\n+    case json_type::object:\n+      return (*this).get_object().at_pointer(json_pointer);\n+    default:\n+      return INVALID_JSON_POINTER;\n+  }\n+}\n+\n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n@@ -145,7 +203,14 @@ simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>\n     implementation_simdjson_result_base<SIMDJSON_IMPLEMENTATION::ondemand::value>(error)\n {\n }\n-\n+simdjson_really_inline simdjson_result<size_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::count_elements() & noexcept {\n+  if (error()) { return error(); }\n+  return first.count_elements();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::at(size_t index) noexcept {\n+  if (error()) { return error(); }\n+  return first.at(index);\n+}\n simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::begin() & noexcept {\n   if (error()) { return error(); }\n   return first.begin();\n@@ -194,14 +259,26 @@ simdjson_really_inline simdjson_result<uint64_t> simdjson_result<SIMDJSON_IMPLEM\n   if (error()) { return error(); }\n   return first.get_uint64();\n }\n+simdjson_really_inline simdjson_result<uint64_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_uint64_in_string() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_uint64_in_string();\n+}\n simdjson_really_inline simdjson_result<int64_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_int64() noexcept {\n   if (error()) { return error(); }\n   return first.get_int64();\n }\n+simdjson_really_inline simdjson_result<int64_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_int64_in_string() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_int64_in_string();\n+}\n simdjson_really_inline simdjson_result<double> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_double() noexcept {\n   if (error()) { return error(); }\n   return first.get_double();\n }\n+simdjson_really_inline simdjson_result<double> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_double_in_string() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_double_in_string();\n+}\n simdjson_really_inline simdjson_result<std::string_view> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_string() noexcept {\n   if (error()) { return error(); }\n   return first.get_string();\n@@ -242,7 +319,26 @@ simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::json_t\n   if (error()) { return error(); }\n   return first.type();\n }\n-\n+simdjson_really_inline simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::is_scalar() noexcept {\n+  if (error()) { return error(); }\n+  return first.is_scalar();\n+}\n+simdjson_really_inline simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::is_negative() noexcept {\n+  if (error()) { return error(); }\n+  return first.is_negative();\n+}\n+simdjson_really_inline simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::is_integer() noexcept {\n+  if (error()) { return error(); }\n+  return first.is_integer();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number_type> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_number_type() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_number_type();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_number() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_number();\n+}\n #if SIMDJSON_EXCEPTIONS\n simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::operator SIMDJSON_IMPLEMENTATION::ondemand::array() noexcept(false) {\n   if (error()) { throw simdjson_error(error()); }\n@@ -283,4 +379,9 @@ simdjson_really_inline simdjson_result<std::string_view> simdjson_result<SIMDJSO\n   return first.raw_json_token();\n }\n \n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::at_pointer(std::string_view json_pointer) noexcept {\n+  if (error()) { return error(); }\n+  return first.at_pointer(json_pointer);\n+}\n+\n } // namespace simdjson\n--- vendor/simdjson/include/simdjson/generic/ondemand/value.h\n@@ -69,11 +69,19 @@ class value {\n   /**\n    * Cast this JSON value to an unsigned integer.\n    *\n-   * @returns A signed 64-bit integer.\n+   * @returns A unsigned 64-bit integer.\n    * @returns INCORRECT_TYPE If the JSON value is not a 64-bit unsigned integer.\n    */\n   simdjson_really_inline simdjson_result<uint64_t> get_uint64() noexcept;\n \n+  /**\n+   * Cast this JSON value (inside string) to a unsigned integer.\n+   *\n+   * @returns A unsigned 64-bit integer.\n+   * @returns INCORRECT_TYPE If the JSON value is not a 64-bit unsigned integer.\n+   */\n+  simdjson_really_inline simdjson_result<uint64_t> get_uint64_in_string() noexcept;\n+\n   /**\n    * Cast this JSON value to a signed integer.\n    *\n@@ -82,6 +90,14 @@ class value {\n    */\n   simdjson_really_inline simdjson_result<int64_t> get_int64() noexcept;\n \n+  /**\n+   * Cast this JSON value (inside string) to a signed integer.\n+   *\n+   * @returns A signed 64-bit integer.\n+   * @returns INCORRECT_TYPE If the JSON value is not a 64-bit integer.\n+   */\n+  simdjson_really_inline simdjson_result<int64_t> get_int64_in_string() noexcept;\n+\n   /**\n    * Cast this JSON value to a double.\n    *\n@@ -90,6 +106,14 @@ class value {\n    */\n   simdjson_really_inline simdjson_result<double> get_double() noexcept;\n \n+  /**\n+   * Cast this JSON value (inside string) to a double\n+   *\n+   * @returns A double.\n+   * @returns INCORRECT_TYPE If the JSON value is not a valid floating-point number.\n+   */\n+  simdjson_really_inline simdjson_result<double> get_double_in_string() noexcept;\n+\n   /**\n    * Cast this JSON value to a string.\n    *\n@@ -208,7 +232,26 @@ class value {\n    * Part of the std::iterable interface.\n    */\n   simdjson_really_inline simdjson_result<array_iterator> end() & noexcept;\n-\n+  /**\n+   * This method scans the array and counts the number of elements.\n+   * The count_elements method should always be called before you have begun\n+   * iterating through the array: it is expected that you are pointing at\n+   * the beginning of the array.\n+   * The runtime complexity is linear in the size of the array. After\n+   * calling this function, if successful, the array is 'rewinded' at its\n+   * beginning as if it had never been accessed. If the JSON is malformed (e.g.,\n+   * there is a missing comma), then an error is returned and it is no longer\n+   * safe to continue.\n+   */\n+  simdjson_really_inline simdjson_result<size_t> count_elements() & noexcept;\n+  /**\n+   * Get the value at the given index in the array. This function has linear-time complexity.\n+   * This function should only be called once as the array iterator is not reset between each call.\n+   *\n+   * @return The value at the given index, or:\n+   *         - INDEX_OUT_OF_BOUNDS if the array index is larger than an array length\n+   */\n+  simdjson_really_inline simdjson_result<value> at(size_t index) noexcept;\n   /**\n    * Look up a field by name on an object (order-sensitive).\n    *\n@@ -278,6 +321,85 @@ class value {\n    */\n   simdjson_really_inline simdjson_result<json_type> type() noexcept;\n \n+  /**\n+   * Checks whether the value is a scalar (string, number, null, Boolean).\n+   * Returns false when there it is an array or object.\n+   *\n+   * @returns true if the type is string, number, null, Boolean\n+   * @error TAPE_ERROR when the JSON value is a bad token like \"}\" \",\" or \"alse\".\n+   */\n+  simdjson_really_inline simdjson_result<bool> is_scalar() noexcept;\n+\n+  /**\n+   * Checks whether the value is a negative number.\n+   *\n+   * @returns true if the number if negative.\n+   */\n+  simdjson_really_inline bool is_negative() noexcept;\n+  /**\n+   * Checks whether the value is an integer number. Note that\n+   * this requires to partially parse the number string. If\n+   * the value is determined to be an integer, it may still\n+   * not parse properly as an integer in subsequent steps\n+   * (e.g., it might overflow).\n+   *\n+   * Performance note: if you call this function systematically\n+   * before parsing a number, you may have fallen for a performance\n+   * anti-pattern.\n+   *\n+   * @returns true if the number if negative.\n+   */\n+  simdjson_really_inline simdjson_result<bool> is_integer() noexcept;\n+  /**\n+   * Determine the number type (integer or floating-point number).\n+   *\n+   * get_number_type() is number_type::unsigned_integer if we have\n+   * an integer greater or equal to 9223372036854775808\n+   * get_number_type() is number_type::signed_integer if we have an\n+   * integer that is less than 9223372036854775808\n+   * Otherwise, get_number_type() has value number_type::floating_point_number\n+   *\n+   * This function requires processing the number string, but it is expected\n+   * to be faster than get_number().get_number_type() because it is does not\n+   * parse the number value.\n+   *\n+   * @returns the type of the number\n+   */\n+  simdjson_really_inline simdjson_result<number_type> get_number_type() noexcept;\n+\n+  /**\n+   * Attempt to parse an ondemand::number. An ondemand::number may\n+   * contain an integer value or a floating-point value, the simdjson\n+   * library will autodetect the type. Thus it is a dynamically typed\n+   * number. Before accessing the value, you must determine the detected\n+   * type.\n+   *\n+   * number.get_number_type() is number_type::signed_integer if we have\n+   * a integer in [-9223372036854775808,9223372036854775808)\n+   * You can recover the value by calling number.get_int64() and you\n+   * have that number.is_int64() is true.\n+   *\n+   * number.get_number_type() is number_type::unsigned_integer if we have\n+   * an integer in [9223372036854775808,18446744073709551616)\n+   * You can recover the value by calling number.get_uint64() and you\n+   * have that number.is_uint64() is true.\n+   *\n+   * Otherwise, number.get_number_type() has value number_type::floating_point_number\n+   * and we have a binary64 number.\n+   * You can recover the value by calling number.get_double() and you\n+   * have that number.is_double() is true.\n+   *\n+   * You must check the type before accessing the value: it is an error\n+   * to call \"get_int64()\" when number.get_number_type() is not\n+   * number_type::signed_integer and when number.is_int64() is false.\n+   *\n+   * Performance note: this is designed with performance in mind. When\n+   * calling 'get_number()', you scan the number string only once, determining\n+   * efficiently the type and storing it in an efficient manner.\n+   */\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<number> get_number() noexcept;\n+\n+\n   /**\n    * Get the raw JSON for this token.\n    *\n@@ -303,6 +425,50 @@ class value {\n    */\n   simdjson_really_inline std::string_view raw_json_token() noexcept;\n \n+  /**\n+   * Get the value associated with the given JSON pointer.  We use the RFC 6901\n+   * https://tools.ietf.org/html/rfc6901 standard.\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"foo\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"/foo/a/1\") == 20\n+   *\n+   * It is allowed for a key to be the empty string:\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"//a/1\") == 20\n+   *\n+   * Note that at_pointer() called on the document automatically calls the document's rewind\n+   * method between each call. It invalidates all previously accessed arrays, objects and values\n+   * that have not been consumed.\n+   *\n+   * Calling at_pointer() on non-document instances (e.g., arrays and objects) is not\n+   * standardized (by RFC 6901). We provide some experimental support for JSON pointers\n+   * on non-document instances.  Yet it is not the case when calling at_pointer on an array\n+   * or an object instance: there is no rewind and no invalidation.\n+   *\n+   * You may only call at_pointer on an array after it has been created, but before it has\n+   * been first accessed. When calling at_pointer on an array, the pointer is advanced to\n+   * the location indicated by the JSON pointer (in case of success). It is no longer possible\n+   * to call at_pointer on the same array.\n+   *\n+   * You may call at_pointer more than once on an object, but each time the pointer is advanced\n+   * to be within the value matched by the key indicated by the JSON pointer query. Thus any preceeding\n+   * key (as well as the current key) can no longer be used with following JSON pointer calls.\n+   *\n+   * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching\n+   *\n+   * @return The value associated with the given JSON pointer, or:\n+   *         - NO_SUCH_FIELD if a field does not exist in an object\n+   *         - INDEX_OUT_OF_BOUNDS if an array index is larger than an array length\n+   *         - INCORRECT_TYPE if a non-integer is used to access an array\n+   *         - INVALID_JSON_POINTER if the JSON pointer is invalid and cannot be parsed\n+   */\n+  simdjson_really_inline simdjson_result<value> at_pointer(std::string_view json_pointer) noexcept;\n+\n protected:\n   /**\n    * Create a value.\n@@ -341,7 +507,6 @@ class value {\n   friend class field;\n   friend class object;\n   friend struct simdjson_result<value>;\n-  friend struct simdjson_result<document>;\n   friend struct simdjson_result<field>;\n };\n \n@@ -362,8 +527,11 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> : public SIMDJS\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> get_object() noexcept;\n \n   simdjson_really_inline simdjson_result<uint64_t> get_uint64() noexcept;\n+  simdjson_really_inline simdjson_result<uint64_t> get_uint64_in_string() noexcept;\n   simdjson_really_inline simdjson_result<int64_t> get_int64() noexcept;\n+  simdjson_really_inline simdjson_result<int64_t> get_int64_in_string() noexcept;\n   simdjson_really_inline simdjson_result<double> get_double() noexcept;\n+  simdjson_really_inline simdjson_result<double> get_double_in_string() noexcept;\n   simdjson_really_inline simdjson_result<std::string_view> get_string() noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::raw_json_string> get_raw_json_string() noexcept;\n   simdjson_really_inline simdjson_result<bool> get_bool() noexcept;\n@@ -383,7 +551,8 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> : public SIMDJS\n   simdjson_really_inline operator SIMDJSON_IMPLEMENTATION::ondemand::raw_json_string() noexcept(false);\n   simdjson_really_inline operator bool() noexcept(false);\n #endif\n-\n+  simdjson_really_inline simdjson_result<size_t> count_elements() & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at(size_t index) noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> begin() & noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> end() & noexcept;\n \n@@ -446,9 +615,16 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> : public SIMDJS\n    * let it throw an exception).\n    */\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::json_type> type() noexcept;\n+  simdjson_really_inline simdjson_result<bool> is_scalar() noexcept;\n+  simdjson_really_inline simdjson_result<bool> is_negative() noexcept;\n+  simdjson_really_inline simdjson_result<bool> is_integer() noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number_type> get_number_type() noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number> get_number() noexcept;\n \n   /** @copydoc simdjson_really_inline std::string_view value::raw_json_token() const noexcept */\n   simdjson_really_inline simdjson_result<std::string_view> raw_json_token() noexcept;\n+\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at_pointer(std::string_view json_pointer) noexcept;\n };\n \n } // namespace simdjson\n--- vendor/simdjson/include/simdjson/generic/ondemand/value_iterator-inl.h\n@@ -2,54 +2,73 @@ namespace simdjson {\n namespace SIMDJSON_IMPLEMENTATION {\n namespace ondemand {\n \n-simdjson_really_inline value_iterator::value_iterator(json_iterator *json_iter, depth_t depth, token_position start_index) noexcept\n-  : _json_iter{json_iter},\n-    _depth{depth},\n-    _start_position{start_index}\n+simdjson_really_inline value_iterator::value_iterator(\n+  json_iterator *json_iter,\n+  depth_t depth,\n+  token_position start_position\n+) noexcept : _json_iter{json_iter}, _depth{depth}, _start_position{start_position}\n {\n }\n \n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::start_object() noexcept {\n-  const uint8_t *json;\n-  SIMDJSON_TRY( advance_container_start(\"object\", json) );\n-  if (*json != '{') { return incorrect_type_error(\"Not an object\"); }\n+  SIMDJSON_TRY( start_container('{', \"Not an object\", \"object\") );\n   return started_object();\n }\n \n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::start_root_object() noexcept {\n-  bool result;\n-  SIMDJSON_TRY( start_object().get(result) );\n-  if (*_json_iter->peek_last() != '}') { return _json_iter->report_error(TAPE_ERROR, \"object invalid: { at beginning of document unmatched by } at end of document\"); }\n-  return result;\n+  SIMDJSON_TRY( start_container('{', \"Not an object\", \"object\") );\n+  return started_root_object();\n }\n \n-simdjson_warn_unused simdjson_really_inline bool value_iterator::started_object() noexcept {\n+simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::started_object() noexcept {\n   assert_at_container_start();\n #ifdef SIMDJSON_DEVELOPMENT_CHECKS\n-  _json_iter->set_start_position(_depth, _start_position);\n+  _json_iter->set_start_position(_depth, start_position());\n #endif\n   if (*_json_iter->peek() == '}') {\n     logger::log_value(*_json_iter, \"empty object\");\n-    _json_iter->advance();\n-    _json_iter->ascend_to(depth()-1);\n+    _json_iter->return_current_and_advance();\n+    end_container();\n     return false;\n   }\n-  logger::log_start_value(*_json_iter, \"object\");\n   return true;\n }\n \n+simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::started_root_object() noexcept {\n+  // When in streaming mode, we cannot expect peek_last() to be the last structural element of the\n+  // current document. It only works in the normal mode where we have indexed a single document.\n+  // Note that adding a check for 'streaming' is not expensive since we only have at most\n+  // one root element.\n+  if (! _json_iter->streaming() && (*_json_iter->peek_last() != '}')) {\n+    _json_iter->abandon();\n+    return report_error(INCOMPLETE_ARRAY_OR_OBJECT, \"missing } at end\");\n+  }\n+  return started_object();\n+}\n+\n+simdjson_warn_unused simdjson_really_inline error_code value_iterator::end_container() noexcept {\n+#if SIMDJSON_CHECK_EOF\n+    if (depth() > 1 && at_end()) { return report_error(INCOMPLETE_ARRAY_OR_OBJECT, \"missing parent ] or }\"); }\n+    // if (depth() <= 1 && !at_end()) { return report_error(INCOMPLETE_ARRAY_OR_OBJECT, \"missing [ or { at start\"); }\n+#endif // SIMDJSON_CHECK_EOF\n+    _json_iter->ascend_to(depth()-1);\n+    return SUCCESS;\n+}\n+\n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::has_next_field() noexcept {\n   assert_at_next();\n \n-  switch (*_json_iter->advance()) {\n+  // It's illegal to call this unless there are more tokens: anything that ends in } or ] is\n+  // obligated to verify there are more tokens if they are not the top level.\n+  switch (*_json_iter->return_current_and_advance()) {\n     case '}':\n       logger::log_end_value(*_json_iter, \"object\");\n-      _json_iter->ascend_to(depth()-1);\n+      SIMDJSON_TRY( end_container() );\n       return false;\n     case ',':\n       return true;\n     default:\n-      return _json_iter->report_error(TAPE_ERROR, \"Missing comma between object fields\");\n+      return report_error(TAPE_ERROR, \"Missing comma between object fields\");\n   }\n }\n \n@@ -65,7 +84,6 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator\n   //    { \"a\": [ 1, 2 ], \"b\": [ 3, 4 ] }\n   //      ^ (depth 2, index 1)\n   //    ```\n-  //\n   if (at_first_field()) {\n     has_value = true;\n \n@@ -86,7 +104,7 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator\n     // this object iterator will blithely scan that object for fields.\n     if (_json_iter->depth() < depth() - 1) { return OUT_OF_ORDER_ITERATION; }\n #endif\n-    has_value = false;\n+    return false;\n \n   // 3. When a previous search found a field or an iterator yielded a value:\n   //\n@@ -106,15 +124,19 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator\n     if ((error = skip_child() )) { abandon(); return error; }\n     if ((error = has_next_field().get(has_value) )) { abandon(); return error; }\n #ifdef SIMDJSON_DEVELOPMENT_CHECKS\n-    if (_json_iter->start_position(_depth) != _start_position) { return OUT_OF_ORDER_ITERATION; }\n+    if (_json_iter->start_position(_depth) != start_position()) { return OUT_OF_ORDER_ITERATION; }\n #endif\n   }\n   while (has_value) {\n     // Get the key and colon, stopping at the value.\n     raw_json_string actual_key;\n     // size_t max_key_length = _json_iter->peek_length() - 2; // -2 for the two quotes\n+    // Note: _json_iter->peek_length() - 2 might overflow if _json_iter->peek_length() < 2.\n+    // field_key() advances the pointer and checks that '\"' is found (corresponding to a key).\n+    // The depth is left unchanged by field_key().\n     if ((error = field_key().get(actual_key) )) { abandon(); return error; };\n-\n+    // field_value() will advance and check that we find a ':' separating the\n+    // key and the value. It will also increment the depth by one.\n     if ((error = field_value() )) { abandon(); return error; }\n     // If it matches, stop and return\n     // We could do it this way if we wanted to allow arbitrary\n@@ -126,20 +148,25 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator\n     // input).\n     if (actual_key.unsafe_is_equal(key)) {\n       logger::log_event(*this, \"match\", key, -2);\n+      // If we return here, then we return while pointing at the ':' that we just checked.\n       return true;\n     }\n \n     // No match: skip the value and see if , or } is next\n     logger::log_event(*this, \"no match\", key, -2);\n+    // The call to skip_child is meant to skip over the value corresponding to the key.\n+    // After skip_child(), we are right before the next comma (',') or the final brace ('}').\n     SIMDJSON_TRY( skip_child() ); // Skip the value entirely\n+    // The has_next_field() advances the pointer and check that either ',' or '}' is found.\n+    // It returns true if ',' is found, false otherwise. If anything other than ',' or '}' is found,\n+    // then we are in error and we abort.\n     if ((error = has_next_field().get(has_value) )) { abandon(); return error; }\n   }\n \n   // If the loop ended, we're out of fields to look at.\n   return false;\n }\n \n-\n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::find_field_unordered_raw(const std::string_view key) noexcept {\n   /**\n    * When find_field_unordered_raw is called, we can either be pointing at the\n@@ -187,9 +214,8 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator\n     // this object iterator will blithely scan that object for fields.\n     if (_json_iter->depth() < depth() - 1) { return OUT_OF_ORDER_ITERATION; }\n #endif\n-    _json_iter->reenter_child(_start_position + 1, _depth);\n+    SIMDJSON_TRY(reset_object().get(has_value));\n     at_first = true;\n-    has_value = started_object();\n   // 3. When a previous search found a field or an iterator yielded a value:\n   //\n   //    ```\n@@ -205,17 +231,14 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator\n   //    ```\n   //\n   } else {\n-    // If someone queried a key but they did access the value, then we are left pointing\n+    // If someone queried a key but they not did access the value, then we are left pointing\n     // at the ':' and we need to move forward through the value... If the value was\n     // processed then skip_child() does not move the iterator (but may adjust the depth).\n     if ((error = skip_child() )) { abandon(); return error; }\n     search_start = _json_iter->position();\n-    // The has_next_field() advances the pointer and check that either ',' or '}' is found.\n-    // It returns true if ',' is found, false otherwise. If anything other than ',' or '}' is found,\n-    // then we are in error and we abort.\n     if ((error = has_next_field().get(has_value) )) { abandon(); return error; }\n #ifdef SIMDJSON_DEVELOPMENT_CHECKS\n-    if (_json_iter->start_position(_depth) != _start_position) { return OUT_OF_ORDER_ITERATION; }\n+    if (_json_iter->start_position(_depth) != start_position()) { return OUT_OF_ORDER_ITERATION; }\n #endif\n   }\n \n@@ -232,14 +255,14 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator\n   //                                  ^ (depth 0)\n   // ```\n   //\n-\n   // Next, we find a match starting from the current position.\n   while (has_value) {\n     SIMDJSON_ASSUME( _json_iter->_depth == _depth ); // We must be at the start of a field\n \n     // Get the key and colon, stopping at the value.\n     raw_json_string actual_key;\n     // size_t max_key_length = _json_iter->peek_length() - 2; // -2 for the two quotes\n+    // Note: _json_iter->peek_length() - 2 might overflow if _json_iter->peek_length() < 2.\n     // field_key() advances the pointer and checks that '\"' is found (corresponding to a key).\n     // The depth is left unchanged by field_key().\n     if ((error = field_key().get(actual_key) )) { abandon(); return error; };\n@@ -281,15 +304,15 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator\n   // beginning of the object.\n   // (We have already run through the object before, so we've already validated its structure. We\n   // don't check errors in this bit.)\n-  _json_iter->reenter_child(_start_position + 1, _depth);\n-  has_value = started_object();\n+  SIMDJSON_TRY(reset_object().get(has_value));\n   while (true) {\n     SIMDJSON_ASSUME(has_value); // we should reach search_start before ever reaching the end of the object\n     SIMDJSON_ASSUME( _json_iter->_depth == _depth ); // We must be at the start of a field\n \n     // Get the key and colon, stopping at the value.\n     raw_json_string actual_key;\n     // size_t max_key_length = _json_iter->peek_length() - 2; // -2 for the two quotes\n+    // Note: _json_iter->peek_length() - 2 might overflow if _json_iter->peek_length() < 2.\n     // field_key() advances the pointer and checks that '\"' is found (corresponding to a key).\n     // The depth is left unchanged by field_key().\n     error = field_key().get(actual_key); SIMDJSON_ASSUME(!error);\n@@ -335,62 +358,77 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator\n simdjson_warn_unused simdjson_really_inline simdjson_result<raw_json_string> value_iterator::field_key() noexcept {\n   assert_at_next();\n \n-  const uint8_t *key = _json_iter->advance();\n-  if (*(key++) != '\"') { return _json_iter->report_error(TAPE_ERROR, \"Object key is not a string\"); }\n+  const uint8_t *key = _json_iter->return_current_and_advance();\n+  if (*(key++) != '\"') { return report_error(TAPE_ERROR, \"Object key is not a string\"); }\n   return raw_json_string(key);\n }\n \n simdjson_warn_unused simdjson_really_inline error_code value_iterator::field_value() noexcept {\n   assert_at_next();\n \n-  if (*_json_iter->advance() != ':') { return _json_iter->report_error(TAPE_ERROR, \"Missing colon in object field\"); }\n+  if (*_json_iter->return_current_and_advance() != ':') { return report_error(TAPE_ERROR, \"Missing colon in object field\"); }\n   _json_iter->descend_to(depth()+1);\n   return SUCCESS;\n }\n \n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::start_array() noexcept {\n-  const uint8_t *json;\n-  SIMDJSON_TRY( advance_container_start(\"array\", json) );\n-  if (*json != '[') { return incorrect_type_error(\"Not an array\"); }\n+  SIMDJSON_TRY( start_container('[', \"Not an array\", \"array\") );\n   return started_array();\n }\n \n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::start_root_array() noexcept {\n-  bool result;\n-  SIMDJSON_TRY( start_array().get(result) );\n-  if (*_json_iter->peek_last() != ']') { return _json_iter->report_error(TAPE_ERROR, \"array invalid: [ at beginning of document unmatched by ] at end of document\"); }\n-  return result;\n+  SIMDJSON_TRY( start_container('[', \"Not an array\", \"array\") );\n+  return started_root_array();\n }\n \n-simdjson_warn_unused simdjson_really_inline bool value_iterator::started_array() noexcept {\n+inline std::string value_iterator::to_string() const noexcept {\n+  auto answer = std::string(\"value_iterator [ depth : \") + std::to_string(_depth) + std::string(\", \");\n+  if(_json_iter != nullptr) { answer +=  _json_iter->to_string(); }\n+  answer += std::string(\" ]\");\n+  return answer;\n+}\n+\n+simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::started_array() noexcept {\n   assert_at_container_start();\n   if (*_json_iter->peek() == ']') {\n     logger::log_value(*_json_iter, \"empty array\");\n-    _json_iter->advance();\n-    _json_iter->ascend_to(depth()-1);\n+    _json_iter->return_current_and_advance();\n+    SIMDJSON_TRY( end_container() );\n     return false;\n   }\n-  logger::log_start_value(*_json_iter, \"array\");\n   _json_iter->descend_to(depth()+1);\n #ifdef SIMDJSON_DEVELOPMENT_CHECKS\n-  _json_iter->set_start_position(_depth, _start_position);\n+  _json_iter->set_start_position(_depth, start_position());\n #endif\n   return true;\n }\n \n+simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::started_root_array() noexcept {\n+  // When in streaming mode, we cannot expect peek_last() to be the last structural element of the\n+  // current document. It only works in the normal mode where we have indexed a single document.\n+  // Note that adding a check for 'streaming' is not expensive since we only have at most\n+  // one root element.\n+  if ( ! _json_iter->streaming() && (*_json_iter->peek_last() != ']')) {\n+    _json_iter->abandon();\n+    return report_error(INCOMPLETE_ARRAY_OR_OBJECT, \"missing ] at end\");\n+  }\n+  return started_array();\n+}\n+\n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::has_next_element() noexcept {\n   assert_at_next();\n \n-  switch (*_json_iter->advance()) {\n+  logger::log_event(*this, \"has_next_element\");\n+  switch (*_json_iter->return_current_and_advance()) {\n     case ']':\n       logger::log_end_value(*_json_iter, \"array\");\n-      _json_iter->ascend_to(depth()-1);\n+      SIMDJSON_TRY( end_container() );\n       return false;\n     case ',':\n       _json_iter->descend_to(depth()+1);\n       return true;\n     default:\n-      return _json_iter->report_error(TAPE_ERROR, \"Missing comma between array elements\");\n+      return report_error(TAPE_ERROR, \"Missing comma between array elements\");\n   }\n }\n \n@@ -409,27 +447,110 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<std::string_view> va\n   return get_raw_json_string().unescape(_json_iter->string_buf_loc());\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<raw_json_string> value_iterator::get_raw_json_string() noexcept {\n-  auto json = advance_start(\"string\");\n+  auto json = peek_scalar(\"string\");\n   if (*json != '\"') { return incorrect_type_error(\"Not a string\"); }\n+  advance_scalar(\"string\");\n   return raw_json_string(json+1);\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> value_iterator::get_uint64() noexcept {\n-  return numberparsing::parse_unsigned(advance_non_root_scalar(\"uint64\"));\n+  auto result = numberparsing::parse_unsigned(peek_non_root_scalar(\"uint64\"));\n+  if(result.error() == SUCCESS) { advance_non_root_scalar(\"uint64\"); }\n+  return result;\n+}\n+simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> value_iterator::get_uint64_in_string() noexcept {\n+  auto result = numberparsing::parse_unsigned_in_string(peek_non_root_scalar(\"uint64\"));\n+  if(result.error() == SUCCESS) { advance_non_root_scalar(\"uint64\"); }\n+  return result;\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> value_iterator::get_int64() noexcept {\n-  return numberparsing::parse_integer(advance_non_root_scalar(\"int64\"));\n+  auto result = numberparsing::parse_integer(peek_non_root_scalar(\"int64\"));\n+  if(result.error() == SUCCESS) { advance_non_root_scalar(\"int64\"); }\n+  return result;\n+}\n+simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> value_iterator::get_int64_in_string() noexcept {\n+  auto result = numberparsing::parse_integer_in_string(peek_non_root_scalar(\"int64\"));\n+  if(result.error() == SUCCESS) { advance_non_root_scalar(\"int64\"); }\n+  return result;\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<double> value_iterator::get_double() noexcept {\n-  return numberparsing::parse_double(advance_non_root_scalar(\"double\"));\n+  auto result = numberparsing::parse_double(peek_non_root_scalar(\"double\"));\n+  if(result.error() == SUCCESS) { advance_non_root_scalar(\"double\"); }\n+  return result;\n+}\n+simdjson_warn_unused simdjson_really_inline simdjson_result<double> value_iterator::get_double_in_string() noexcept {\n+  auto result = numberparsing::parse_double_in_string(peek_non_root_scalar(\"double\"));\n+  if(result.error() == SUCCESS) { advance_non_root_scalar(\"double\"); }\n+  return result;\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::get_bool() noexcept {\n-  return parse_bool(advance_non_root_scalar(\"bool\"));\n+  auto result = parse_bool(peek_non_root_scalar(\"bool\"));\n+  if(result.error() == SUCCESS) { advance_non_root_scalar(\"bool\"); }\n+  return result;\n }\n simdjson_really_inline bool value_iterator::is_null() noexcept {\n-  return parse_null(advance_non_root_scalar(\"null\"));\n+  auto result = parse_null(peek_non_root_scalar(\"null\"));\n+  if(result) { advance_non_root_scalar(\"null\"); }\n+  return result;\n+}\n+simdjson_really_inline bool value_iterator::is_negative() noexcept {\n+  return numberparsing::is_negative(peek_non_root_scalar(\"numbersign\"));\n+}\n+simdjson_really_inline bool value_iterator::is_root_negative() noexcept {\n+  return numberparsing::is_negative(peek_root_scalar(\"numbersign\"));\n+}\n+simdjson_really_inline simdjson_result<bool> value_iterator::is_integer() noexcept {\n+  return numberparsing::is_integer(peek_non_root_scalar(\"integer\"));\n+}\n+simdjson_really_inline simdjson_result<number_type> value_iterator::get_number_type() noexcept {\n+  return numberparsing::get_number_type(peek_non_root_scalar(\"integer\"));\n+}\n+simdjson_really_inline simdjson_result<number> value_iterator::get_number() noexcept {\n+  number num;\n+  error_code error =  numberparsing::parse_number(peek_non_root_scalar(\"number\"), num);\n+  if(error) { return error; }\n+  return num;\n }\n \n-constexpr const uint32_t MAX_INT_LENGTH = 1024;\n+simdjson_really_inline simdjson_result<bool> value_iterator::is_root_integer() noexcept {\n+  auto max_len = peek_start_length();\n+  auto json = peek_root_scalar(\"is_root_integer\");\n+  uint8_t tmpbuf[20+1]; // <20 digits> is the longest possible unsigned integer\n+  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) {\n+    return false; // if there are more than 20 characters, it cannot be represented as an integer.\n+  }\n+  return numberparsing::is_integer(tmpbuf);\n+}\n+\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number_type> value_iterator::get_root_number_type() noexcept {\n+  auto max_len = peek_start_length();\n+  auto json = peek_root_scalar(\"number\");\n+  // Per https://www.exploringbinary.com/maximum-number-of-decimal-digits-in-binary-floating-point-numbers/,\n+  // 1074 is the maximum number of significant fractional digits. Add 8 more digits for the biggest\n+  // number: -0.<fraction>e-308.\n+  uint8_t tmpbuf[1074+8+1];\n+  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) {\n+    logger::log_error(*_json_iter, start_position(), depth(), \"Root number more than 1082 characters\");\n+    return NUMBER_ERROR;\n+  }\n+  return numberparsing::get_number_type(tmpbuf);\n+}\n+simdjson_really_inline simdjson_result<number> value_iterator::get_root_number() noexcept {\n+  auto max_len = peek_start_length();\n+  auto json = peek_root_scalar(\"number\");\n+  // Per https://www.exploringbinary.com/maximum-number-of-decimal-digits-in-binary-floating-point-numbers/,\n+  // 1074 is the maximum number of significant fractional digits. Add 8 more digits for the biggest\n+  // number: -0.<fraction>e-308.\n+  uint8_t tmpbuf[1074+8+1];\n+  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) {\n+    logger::log_error(*_json_iter, start_position(), depth(), \"Root number more than 1082 characters\");\n+    return NUMBER_ERROR;\n+  }\n+  number num;\n+  error_code error =  numberparsing::parse_number(tmpbuf, num);\n+  if(error) { return error; }\n+  advance_root_scalar(\"number\");\n+  return num;\n+}\n \n simdjson_warn_unused simdjson_really_inline simdjson_result<std::string_view> value_iterator::get_root_string() noexcept {\n   return get_string();\n@@ -439,42 +560,105 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<raw_json_string> val\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> value_iterator::get_root_uint64() noexcept {\n   auto max_len = peek_start_length();\n-  auto json = advance_root_scalar(\"uint64\");\n+  auto json = peek_root_scalar(\"uint64\");\n+  uint8_t tmpbuf[20+1]; // <20 digits> is the longest possible unsigned integer\n+  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) {\n+    logger::log_error(*_json_iter, start_position(), depth(), \"Root number more than 20 characters\");\n+    return NUMBER_ERROR;\n+  }\n+  auto result = numberparsing::parse_unsigned(tmpbuf);\n+  if(result.error() == SUCCESS) { advance_root_scalar(\"uint64\"); }\n+  return result;\n+}\n+simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> value_iterator::get_root_uint64_in_string() noexcept {\n+  auto max_len = peek_start_length();\n+  auto json = peek_root_scalar(\"uint64\");\n   uint8_t tmpbuf[20+1]; // <20 digits> is the longest possible unsigned integer\n-  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) { logger::log_error(*_json_iter, _start_position, depth(), \"Root number more than 20 characters\"); return NUMBER_ERROR; }\n-  return numberparsing::parse_unsigned(tmpbuf);\n+  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) {\n+    logger::log_error(*_json_iter, start_position(), depth(), \"Root number more than 20 characters\");\n+    return NUMBER_ERROR;\n+  }\n+  auto result = numberparsing::parse_unsigned_in_string(tmpbuf);\n+  if(result.error() == SUCCESS) { advance_root_scalar(\"uint64\"); }\n+  return result;\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> value_iterator::get_root_int64() noexcept {\n   auto max_len = peek_start_length();\n-  auto json = advance_root_scalar(\"int64\");\n+  auto json = peek_root_scalar(\"int64\");\n+  uint8_t tmpbuf[20+1]; // -<19 digits> is the longest possible integer\n+  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) {\n+    logger::log_error(*_json_iter, start_position(), depth(), \"Root number more than 20 characters\");\n+    return NUMBER_ERROR;\n+  }\n+\n+  auto result = numberparsing::parse_integer(tmpbuf);\n+  if(result.error() == SUCCESS) { advance_root_scalar(\"int64\"); }\n+  return result;\n+}\n+simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> value_iterator::get_root_int64_in_string() noexcept {\n+  auto max_len = peek_start_length();\n+  auto json = peek_root_scalar(\"int64\");\n   uint8_t tmpbuf[20+1]; // -<19 digits> is the longest possible integer\n-  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) { logger::log_error(*_json_iter, _start_position, depth(), \"Root number more than 20 characters\"); return NUMBER_ERROR; }\n-  return numberparsing::parse_integer(tmpbuf);\n+  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) {\n+    logger::log_error(*_json_iter, start_position(), depth(), \"Root number more than 20 characters\");\n+    return NUMBER_ERROR;\n+  }\n+\n+  auto result = numberparsing::parse_integer_in_string(tmpbuf);\n+  if(result.error() == SUCCESS) { advance_root_scalar(\"int64\"); }\n+  return result;\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<double> value_iterator::get_root_double() noexcept {\n   auto max_len = peek_start_length();\n-  auto json = advance_root_scalar(\"double\");\n-  // Per https://www.exploringbinary.com/maximum-number-of-decimal-digits-in-binary-floating-point-numbers/, 1074 is the maximum number of significant fractional digits. Add 8 more digits for the biggest number: -0.<fraction>e-308.\n+  auto json = peek_root_scalar(\"double\");\n+  // Per https://www.exploringbinary.com/maximum-number-of-decimal-digits-in-binary-floating-point-numbers/,\n+  // 1074 is the maximum number of significant fractional digits. Add 8 more digits for the biggest\n+  // number: -0.<fraction>e-308.\n+  uint8_t tmpbuf[1074+8+1];\n+  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) {\n+    logger::log_error(*_json_iter, start_position(), depth(), \"Root number more than 1082 characters\");\n+    return NUMBER_ERROR;\n+  }\n+  auto result = numberparsing::parse_double(tmpbuf);\n+  if(result.error() == SUCCESS) { advance_root_scalar(\"double\"); }\n+  return result;\n+}\n+\n+simdjson_warn_unused simdjson_really_inline simdjson_result<double> value_iterator::get_root_double_in_string() noexcept {\n+  auto max_len = peek_start_length();\n+  auto json = peek_root_scalar(\"double\");\n+  // Per https://www.exploringbinary.com/maximum-number-of-decimal-digits-in-binary-floating-point-numbers/,\n+  // 1074 is the maximum number of significant fractional digits. Add 8 more digits for the biggest\n+  // number: -0.<fraction>e-308.\n   uint8_t tmpbuf[1074+8+1];\n-  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) { logger::log_error(*_json_iter, _start_position, depth(), \"Root number more than 1082 characters\"); return NUMBER_ERROR; }\n-  return numberparsing::parse_double(tmpbuf);\n+  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) {\n+    logger::log_error(*_json_iter, start_position(), depth(), \"Root number more than 1082 characters\");\n+    return NUMBER_ERROR;\n+  }\n+  auto result = numberparsing::parse_double_in_string(tmpbuf);\n+  if(result.error() == SUCCESS) { advance_root_scalar(\"double\"); }\n+  return result;\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::get_root_bool() noexcept {\n   auto max_len = peek_start_length();\n-  auto json = advance_root_scalar(\"bool\");\n+  auto json = peek_root_scalar(\"bool\");\n   uint8_t tmpbuf[5+1];\n   if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) { return incorrect_type_error(\"Not a boolean\"); }\n-  return parse_bool(tmpbuf);\n+  auto result = parse_bool(tmpbuf);\n+  if(result.error() == SUCCESS) { advance_root_scalar(\"bool\"); }\n+  return result;\n }\n simdjson_really_inline bool value_iterator::is_root_null() noexcept {\n   auto max_len = peek_start_length();\n-  auto json = advance_root_scalar(\"null\");\n-  return max_len >= 4 && !atomparsing::str4ncmp(json, \"null\") &&\n-         (max_len == 4 || jsoncharutils::is_structural_or_whitespace(json[5]));\n+  auto json = peek_root_scalar(\"null\");\n+  bool result = (max_len >= 4 && !atomparsing::str4ncmp(json, \"null\") &&\n+         (max_len == 4 || jsoncharutils::is_structural_or_whitespace(json[5])));\n+  if(result) { advance_root_scalar(\"null\"); }\n+  return result;\n }\n \n simdjson_warn_unused simdjson_really_inline error_code value_iterator::skip_child() noexcept {\n-  SIMDJSON_ASSUME( _json_iter->token.index > _start_position );\n+  SIMDJSON_ASSUME( _json_iter->token._position > _start_position );\n   SIMDJSON_ASSUME( _json_iter->_depth >= _depth );\n \n   return _json_iter->skip_child(depth());\n@@ -495,17 +679,17 @@ simdjson_really_inline bool value_iterator::is_open() const noexcept {\n }\n SIMDJSON_POP_DISABLE_WARNINGS\n \n-simdjson_really_inline bool value_iterator::at_eof() const noexcept {\n-  return _json_iter->at_eof();\n+simdjson_really_inline bool value_iterator::at_end() const noexcept {\n+  return _json_iter->at_end();\n }\n \n simdjson_really_inline bool value_iterator::at_start() const noexcept {\n-  return _json_iter->token.index == _start_position;\n+  return _json_iter->token.position() == start_position();\n }\n \n simdjson_really_inline bool value_iterator::at_first_field() const noexcept {\n-  SIMDJSON_ASSUME( _json_iter->token.index > _start_position );\n-  return _json_iter->token.index == _start_position + 1;\n+  SIMDJSON_ASSUME( _json_iter->token._position > _start_position );\n+  return _json_iter->token.position() == start_position() + 1;\n }\n \n simdjson_really_inline void value_iterator::abandon() noexcept {\n@@ -529,120 +713,177 @@ simdjson_warn_unused simdjson_really_inline json_iterator &value_iterator::json_\n }\n \n simdjson_really_inline const uint8_t *value_iterator::peek_start() const noexcept {\n-  return _json_iter->peek(_start_position);\n+  return _json_iter->peek(start_position());\n }\n simdjson_really_inline uint32_t value_iterator::peek_start_length() const noexcept {\n-  return _json_iter->peek_length(_start_position);\n+  return _json_iter->peek_length(start_position());\n }\n \n-simdjson_really_inline const uint8_t *value_iterator::advance_start(const char *type) const noexcept {\n-  logger::log_value(*_json_iter, _start_position, depth(), type);\n+simdjson_really_inline const uint8_t *value_iterator::peek_scalar(const char *type) noexcept {\n+  logger::log_value(*_json_iter, start_position(), depth(), type);\n   // If we're not at the position anymore, we don't want to advance the cursor.\n   if (!is_at_start()) { return peek_start(); }\n \n   // Get the JSON and advance the cursor, decreasing depth to signify that we have retrieved the value.\n   assert_at_start();\n-  auto result = _json_iter->advance();\n+  return _json_iter->peek();\n+}\n+\n+simdjson_really_inline void value_iterator::advance_scalar(const char *type) noexcept {\n+  logger::log_value(*_json_iter, start_position(), depth(), type);\n+  // If we're not at the position anymore, we don't want to advance the cursor.\n+  if (!is_at_start()) { return; }\n+\n+  // Get the JSON and advance the cursor, decreasing depth to signify that we have retrieved the value.\n+  assert_at_start();\n+  _json_iter->return_current_and_advance();\n   _json_iter->ascend_to(depth()-1);\n-  return result;\n }\n-simdjson_really_inline error_code value_iterator::advance_container_start(const char *type, const uint8_t *&json) const noexcept {\n-  logger::log_start_value(*_json_iter, _start_position, depth(), type);\n \n+simdjson_really_inline error_code value_iterator::start_container(uint8_t start_char, const char *incorrect_type_message, const char *type) noexcept {\n+  logger::log_start_value(*_json_iter, start_position(), depth(), type);\n   // If we're not at the position anymore, we don't want to advance the cursor.\n+  const uint8_t *json;\n   if (!is_at_start()) {\n #ifdef SIMDJSON_DEVELOPMENT_CHECKS\n     if (!is_at_iterator_start()) { return OUT_OF_ORDER_ITERATION; }\n #endif\n     json = peek_start();\n-    return SUCCESS;\n+    if (*json != start_char) { return incorrect_type_error(incorrect_type_message); }\n+  } else {\n+    assert_at_start();\n+    /**\n+     * We should be prudent. Let us peek. If it is not the right type, we\n+     * return an error. Only once we have determined that we have the right\n+     * type are we allowed to advance!\n+     */\n+    json = _json_iter->peek();\n+    if (*json != start_char) { return incorrect_type_error(incorrect_type_message); }\n+    _json_iter->return_current_and_advance();\n   }\n \n-  // Get the JSON and advance the cursor, decreasing depth to signify that we have retrieved the value.\n-  assert_at_start();\n-  json = _json_iter->advance();\n+\n   return SUCCESS;\n }\n-simdjson_really_inline const uint8_t *value_iterator::advance_root_scalar(const char *type) const noexcept {\n-  logger::log_value(*_json_iter, _start_position, depth(), type);\n+\n+\n+simdjson_really_inline const uint8_t *value_iterator::peek_root_scalar(const char *type) noexcept {\n+  logger::log_value(*_json_iter, start_position(), depth(), type);\n   if (!is_at_start()) { return peek_start(); }\n \n   assert_at_root();\n-  auto result = _json_iter->advance();\n-  _json_iter->ascend_to(depth()-1);\n-  return result;\n+  return _json_iter->peek();\n }\n-simdjson_really_inline const uint8_t *value_iterator::advance_non_root_scalar(const char *type) const noexcept {\n-  logger::log_value(*_json_iter, _start_position, depth(), type);\n+simdjson_really_inline const uint8_t *value_iterator::peek_non_root_scalar(const char *type) noexcept {\n+  logger::log_value(*_json_iter, start_position(), depth(), type);\n   if (!is_at_start()) { return peek_start(); }\n \n   assert_at_non_root_start();\n-  auto result = _json_iter->advance();\n+  return _json_iter->peek();\n+}\n+\n+simdjson_really_inline void value_iterator::advance_root_scalar(const char *type) noexcept {\n+  logger::log_value(*_json_iter, start_position(), depth(), type);\n+  if (!is_at_start()) { return; }\n+\n+  assert_at_root();\n+  _json_iter->return_current_and_advance();\n+  _json_iter->ascend_to(depth()-1);\n+}\n+simdjson_really_inline void value_iterator::advance_non_root_scalar(const char *type) noexcept {\n+  logger::log_value(*_json_iter, start_position(), depth(), type);\n+  if (!is_at_start()) { return; }\n+\n+  assert_at_non_root_start();\n+  _json_iter->return_current_and_advance();\n   _json_iter->ascend_to(depth()-1);\n-  return result;\n }\n \n simdjson_really_inline error_code value_iterator::incorrect_type_error(const char *message) const noexcept {\n-  logger::log_error(*_json_iter, _start_position, depth(), message);\n+  logger::log_error(*_json_iter, start_position(), depth(), message);\n   return INCORRECT_TYPE;\n }\n \n simdjson_really_inline bool value_iterator::is_at_start() const noexcept {\n-  return _json_iter->token.index == _start_position;\n+  return position() == start_position();\n }\n-simdjson_really_inline bool value_iterator::is_at_container_start() const noexcept {\n-  return _json_iter->token.index == _start_position + 1;\n+\n+simdjson_really_inline bool value_iterator::is_at_key() const noexcept {\n+  // Keys are at the same depth as the object.\n+  // Note here that we could be safer and check that we are within an object,\n+  // but we do not.\n+  return _depth == _json_iter->_depth && *_json_iter->peek() == '\"';\n }\n+\n simdjson_really_inline bool value_iterator::is_at_iterator_start() const noexcept {\n   // We can legitimately be either at the first value ([1]), or after the array if it's empty ([]).\n-  auto delta = _json_iter->token.index - _start_position;\n+  auto delta = position() - start_position();\n   return delta == 1 || delta == 2;\n }\n \n-simdjson_really_inline void value_iterator::assert_at_start() const noexcept {\n-  SIMDJSON_ASSUME( _json_iter->token.index == _start_position );\n+inline void value_iterator::assert_at_start() const noexcept {\n+  SIMDJSON_ASSUME( _json_iter->token._position == _start_position );\n   SIMDJSON_ASSUME( _json_iter->_depth == _depth );\n   SIMDJSON_ASSUME( _depth > 0 );\n }\n \n-simdjson_really_inline void value_iterator::assert_at_container_start() const noexcept {\n-  SIMDJSON_ASSUME( _json_iter->token.index == _start_position + 1 );\n+inline void value_iterator::assert_at_container_start() const noexcept {\n+  SIMDJSON_ASSUME( _json_iter->token._position == _start_position + 1 );\n   SIMDJSON_ASSUME( _json_iter->_depth == _depth );\n   SIMDJSON_ASSUME( _depth > 0 );\n }\n \n-simdjson_really_inline void value_iterator::assert_at_next() const noexcept {\n-  SIMDJSON_ASSUME( _json_iter->token.index > _start_position );\n+inline void value_iterator::assert_at_next() const noexcept {\n+  SIMDJSON_ASSUME( _json_iter->token._position > _start_position );\n   SIMDJSON_ASSUME( _json_iter->_depth == _depth );\n   SIMDJSON_ASSUME( _depth > 0 );\n }\n \n-simdjson_really_inline void value_iterator::assert_at_child() const noexcept {\n-  SIMDJSON_ASSUME( _json_iter->token.index > _start_position );\n+simdjson_really_inline void value_iterator::move_at_start() noexcept {\n+  _json_iter->_depth = _depth;\n+  _json_iter->token.set_position(_start_position);\n+}\n+\n+simdjson_really_inline void value_iterator::move_at_container_start() noexcept {\n+  _json_iter->_depth = _depth;\n+  _json_iter->token.set_position(_start_position + 1);\n+}\n+\n+simdjson_really_inline simdjson_result<bool> value_iterator::reset_array() noexcept {\n+  move_at_container_start();\n+  return started_array();\n+}\n+\n+simdjson_really_inline simdjson_result<bool> value_iterator::reset_object() noexcept {\n+  move_at_container_start();\n+  return started_object();\n+}\n+\n+inline void value_iterator::assert_at_child() const noexcept {\n+  SIMDJSON_ASSUME( _json_iter->token._position > _start_position );\n   SIMDJSON_ASSUME( _json_iter->_depth == _depth + 1 );\n   SIMDJSON_ASSUME( _depth > 0 );\n }\n \n-simdjson_really_inline void value_iterator::assert_at_root() const noexcept {\n+inline void value_iterator::assert_at_root() const noexcept {\n   assert_at_start();\n   SIMDJSON_ASSUME( _depth == 1 );\n }\n \n-simdjson_really_inline void value_iterator::assert_at_non_root_start() const noexcept {\n+inline void value_iterator::assert_at_non_root_start() const noexcept {\n   assert_at_start();\n   SIMDJSON_ASSUME( _depth > 1 );\n }\n \n-simdjson_really_inline void value_iterator::assert_is_valid() const noexcept {\n+inline void value_iterator::assert_is_valid() const noexcept {\n   SIMDJSON_ASSUME( _json_iter != nullptr );\n }\n \n simdjson_really_inline bool value_iterator::is_valid() const noexcept {\n   return _json_iter != nullptr;\n }\n \n-\n-simdjson_really_inline simdjson_result<json_type> value_iterator::type() noexcept {\n+simdjson_really_inline simdjson_result<json_type> value_iterator::type() const noexcept {\n   switch (*peek_start()) {\n     case '{':\n       return json_type::object;\n@@ -663,6 +904,26 @@ simdjson_really_inline simdjson_result<json_type> value_iterator::type() noexcep\n   }\n }\n \n+simdjson_really_inline token_position value_iterator::start_position() const noexcept {\n+  return _start_position;\n+}\n+\n+simdjson_really_inline token_position value_iterator::position() const noexcept {\n+  return _json_iter->position();\n+}\n+\n+simdjson_really_inline token_position value_iterator::end_position() const noexcept {\n+  return _json_iter->end_position();\n+}\n+\n+simdjson_really_inline token_position value_iterator::last_position() const noexcept {\n+  return _json_iter->last_position();\n+}\n+\n+simdjson_really_inline error_code value_iterator::report_error(error_code error, const char *message) noexcept {\n+  return _json_iter->report_error(error, message);\n+}\n+\n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n--- vendor/simdjson/include/simdjson/generic/ondemand/value_iterator.h\n@@ -25,8 +25,6 @@ class value_iterator {\n   depth_t _depth{};\n   /**\n    * The starting token index for this value\n-   *\n-   * PERF NOTE: this is a safety check; we expect this to be elided in release builds.\n    */\n   token_position _start_position{};\n \n@@ -48,7 +46,7 @@ class value_iterator {\n   /**\n    * Tell whether the iterator is at the EOF mark\n    */\n-  simdjson_really_inline bool at_eof() const noexcept;\n+  simdjson_really_inline bool at_end() const noexcept;\n \n   /**\n    * Tell whether the iterator is at the start of the value\n@@ -85,7 +83,7 @@ class value_iterator {\n    *\n    * @error TAPE_ERROR when the JSON value is a bad token like \"}\" \",\" or \"alse\".\n    */\n-  simdjson_really_inline simdjson_result<json_type> type() noexcept;\n+  simdjson_really_inline simdjson_result<json_type> type() const noexcept;\n \n   /**\n    * @addtogroup object Object iteration\n@@ -115,11 +113,23 @@ class value_iterator {\n   /**\n    * Start an object iteration after the user has already checked and moved past the {.\n    *\n-   * Does not move the iterator.\n+   * Does not move the iterator unless the object is empty ({}).\n+   *\n+   * @returns Whether the object had any fields (returns false for empty).\n+   * @error INCOMPLETE_ARRAY_OR_OBJECT If there are no more tokens (implying the *parent*\n+   *        array or object is incomplete).\n+   */\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<bool> started_object() noexcept;\n+  /**\n+   * Start an object iteration from the root, after the user has already checked and moved past the {.\n+   *\n+   * Does not move the iterator unless the object is empty ({}).\n    *\n    * @returns Whether the object had any fields (returns false for empty).\n+   * @error INCOMPLETE_ARRAY_OR_OBJECT If there are no more tokens (implying the *parent*\n+   *        array or object is incomplete).\n    */\n-  simdjson_warn_unused simdjson_really_inline bool started_object() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<bool> started_root_object() noexcept;\n \n   /**\n    * Moves to the next field in an object.\n@@ -129,6 +139,7 @@ class value_iterator {\n    *\n    * @return whether there is another field in the object.\n    * @error TAPE_ERROR If there is a comma missing between fields.\n+   * @error TAPE_ERROR If there is a comma, but not enough tokens remaining to have a key, :, and value.\n    */\n   simdjson_warn_unused simdjson_really_inline simdjson_result<bool> has_next_field() noexcept;\n \n@@ -225,13 +236,25 @@ class value_iterator {\n   simdjson_warn_unused simdjson_really_inline simdjson_result<bool> start_root_array() noexcept;\n \n   /**\n-   * Start an array iteration after the user has already checked and moved past the [.\n+   * Start an array iteration, after the user has already checked and moved past the [.\n    *\n-   * Does not move the iterator.\n+   * Does not move the iterator unless the array is empty ([]).\n    *\n    * @returns Whether the array had any elements (returns false for empty).\n+   * @error INCOMPLETE_ARRAY_OR_OBJECT If there are no more tokens (implying the *parent*\n+   *        array or object is incomplete).\n    */\n-  simdjson_warn_unused simdjson_really_inline bool started_array() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<bool> started_array() noexcept;\n+  /**\n+   * Start an array iteration from the root, after the user has already checked and moved past the [.\n+   *\n+   * Does not move the iterator unless the array is empty ([]).\n+   *\n+   * @returns Whether the array had any elements (returns false for empty).\n+   * @error INCOMPLETE_ARRAY_OR_OBJECT If there are no more tokens (implying the *parent*\n+   *        array or object is incomplete).\n+   */\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<bool> started_root_array() noexcept;\n \n   /**\n    * Moves to the next element in an array.\n@@ -260,17 +283,31 @@ class value_iterator {\n   simdjson_warn_unused simdjson_really_inline simdjson_result<std::string_view> get_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<raw_json_string> get_raw_json_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> get_uint64() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> get_uint64_in_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> get_int64() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> get_int64_in_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<double> get_double() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<double> get_double_in_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<bool> get_bool() noexcept;\n   simdjson_really_inline bool is_null() noexcept;\n+  simdjson_warn_unused simdjson_really_inline bool is_negative() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<bool> is_integer() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<number_type> get_number_type() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<number> get_number() noexcept;\n \n   simdjson_warn_unused simdjson_really_inline simdjson_result<std::string_view> get_root_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<raw_json_string> get_root_raw_json_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> get_root_uint64() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> get_root_uint64_in_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> get_root_int64() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> get_root_int64_in_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<double> get_root_double() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<double> get_root_double_in_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<bool> get_root_bool() noexcept;\n+  simdjson_warn_unused simdjson_really_inline bool is_root_negative() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<bool> is_root_integer() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<number_type> get_root_number_type() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<number> get_root_number() noexcept;\n   simdjson_really_inline bool is_root_null() noexcept;\n \n   simdjson_really_inline error_code error() const noexcept;\n@@ -282,31 +319,130 @@ class value_iterator {\n   simdjson_really_inline bool is_valid() const noexcept;\n \n   /** @} */\n-\n protected:\n+  /**\n+   * Restarts an array iteration.\n+   * @returns Whether the array has any elements (returns false for empty).\n+   */\n+  simdjson_really_inline simdjson_result<bool> reset_array() noexcept;\n+  /**\n+   * Restarts an object iteration.\n+   * @returns Whether the object has any fields (returns false for empty).\n+   */\n+  simdjson_really_inline simdjson_result<bool> reset_object() noexcept;\n+  /**\n+   * move_at_start(): moves us so that we are pointing at the beginning of\n+   * the container. It updates the index so that at_start() is true and it\n+   * syncs the depth. The user can then create a new container instance.\n+   *\n+   * Usage: used with value::count_elements().\n+   **/\n+  simdjson_really_inline void move_at_start() noexcept;\n+\n+  /**\n+   * move_at_container_start(): moves us so that we are pointing at the beginning of\n+   * the container so that assert_at_container_start() passes.\n+   *\n+   * Usage: used with reset_array() and reset_object().\n+   **/\n+   simdjson_really_inline void move_at_container_start() noexcept;\n+  /* Useful for debugging and logging purposes. */\n+  inline std::string to_string() const noexcept;\n   simdjson_really_inline value_iterator(json_iterator *json_iter, depth_t depth, token_position start_index) noexcept;\n \n   simdjson_really_inline bool parse_null(const uint8_t *json) const noexcept;\n   simdjson_really_inline simdjson_result<bool> parse_bool(const uint8_t *json) const noexcept;\n-\n   simdjson_really_inline const uint8_t *peek_start() const noexcept;\n   simdjson_really_inline uint32_t peek_start_length() const noexcept;\n-  simdjson_really_inline const uint8_t *advance_start(const char *type) const noexcept;\n-  simdjson_really_inline error_code advance_container_start(const char *type, const uint8_t *&json) const noexcept;\n-  simdjson_really_inline const uint8_t *advance_root_scalar(const char *type) const noexcept;\n-  simdjson_really_inline const uint8_t *advance_non_root_scalar(const char *type) const noexcept;\n+\n+  /**\n+   * The general idea of the advance_... methods and the peek_* methods\n+   * is that you first peek and check that you have desired type. If you do,\n+   * and only if you do, then you advance.\n+   *\n+   * We used to unconditionally advance. But this made reasoning about our\n+   * current state difficult.\n+   * Suppose you always advance. Look at the 'value' matching the key\n+   * \"shadowable\" in the following example...\n+   *\n+   * ({\"globals\":{\"a\":{\"shadowable\":[}}}})\n+   *\n+   * If the user thinks it is a Boolean and asks for it, then we check the '[',\n+   * decide it is not a Boolean, but still move into the next character ('}'). Now\n+   * we are left pointing at '}' right after a '['. And we have not yet reported\n+   * an error, only that we do not have a Boolean.\n+   *\n+   * If, instead, you just stand your ground until it is content that you know, then\n+   * you will only even move beyond the '[' if the user tells you that you have an\n+   * array. So you will be at the '}' character inside the array and, hopefully, you\n+   * will then catch the error because an array cannot start with '}', but the code\n+   * processing Boolean values does not know this.\n+   *\n+   * So the contract is: first call 'peek_...' and then call 'advance_...' only\n+   * if you have determined that it is a type you can handle.\n+   *\n+   * Unfortunately, it makes the code more verbose, longer and maybe more error prone.\n+   */\n+\n+  simdjson_really_inline void advance_scalar(const char *type) noexcept;\n+  simdjson_really_inline void advance_root_scalar(const char *type) noexcept;\n+  simdjson_really_inline void advance_non_root_scalar(const char *type) noexcept;\n+\n+  simdjson_really_inline const uint8_t *peek_scalar(const char *type) noexcept;\n+  simdjson_really_inline const uint8_t *peek_root_scalar(const char *type) noexcept;\n+  simdjson_really_inline const uint8_t *peek_non_root_scalar(const char *type) noexcept;\n+\n+\n+  simdjson_really_inline error_code start_container(uint8_t start_char, const char *incorrect_type_message, const char *type) noexcept;\n+  simdjson_really_inline error_code end_container() noexcept;\n+\n+  /**\n+   * Advance to a place expecting a value (increasing depth).\n+   *\n+   * @return The current token (the one left behind).\n+   * @error TAPE_ERROR If the document ended early.\n+   */\n+  simdjson_really_inline simdjson_result<const uint8_t *> advance_to_value() noexcept;\n \n   simdjson_really_inline error_code incorrect_type_error(const char *message) const noexcept;\n+  simdjson_really_inline error_code error_unless_more_tokens(uint32_t tokens=1) const noexcept;\n \n   simdjson_really_inline bool is_at_start() const noexcept;\n-  simdjson_really_inline bool is_at_container_start() const noexcept;\n+  /**\n+   * is_at_iterator_start() returns true on an array or object after it has just been\n+   * created, whether the instance is empty or not.\n+   *\n+   * Usage: used by array::begin() in debug mode (SIMDJSON_DEVELOPMENT_CHECKS)\n+   */\n   simdjson_really_inline bool is_at_iterator_start() const noexcept;\n-  simdjson_really_inline void assert_at_start() const noexcept;\n-  simdjson_really_inline void assert_at_container_start() const noexcept;\n-  simdjson_really_inline void assert_at_root() const noexcept;\n-  simdjson_really_inline void assert_at_child() const noexcept;\n-  simdjson_really_inline void assert_at_next() const noexcept;\n-  simdjson_really_inline void assert_at_non_root_start() const noexcept;\n+\n+  /**\n+   * Assuming that we are within an object, this returns true if we\n+   * are pointing at a key.\n+   *\n+   * Usage: the skip_child() method should never be used while we are pointing\n+   * at a key inside an object.\n+   */\n+  simdjson_really_inline bool is_at_key() const noexcept;\n+\n+  inline void assert_at_start() const noexcept;\n+  inline void assert_at_container_start() const noexcept;\n+  inline void assert_at_root() const noexcept;\n+  inline void assert_at_child() const noexcept;\n+  inline void assert_at_next() const noexcept;\n+  inline void assert_at_non_root_start() const noexcept;\n+\n+  /** Get the starting position of this value */\n+  simdjson_really_inline token_position start_position() const noexcept;\n+\n+  /** @copydoc error_code json_iterator::position() const noexcept; */\n+  simdjson_really_inline token_position position() const noexcept;\n+  /** @copydoc error_code json_iterator::end_position() const noexcept; */\n+  simdjson_really_inline token_position last_position() const noexcept;\n+  /** @copydoc error_code json_iterator::end_position() const noexcept; */\n+  simdjson_really_inline token_position end_position() const noexcept;\n+  /** @copydoc error_code json_iterator::report_error(error_code error, const char *message) noexcept; */\n+  simdjson_really_inline error_code report_error(error_code error, const char *message) noexcept;\n \n   friend class document;\n   friend class object;\n--- vendor/simdjson/include/simdjson/haswell/numberparsing.h\n@@ -27,7 +27,7 @@ static simdjson_really_inline uint32_t parse_eight_digits_unrolled(const uint8_t\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n \n-#define SWAR_NUMBER_PARSING\n+#define SIMDJSON_SWAR_NUMBER_PARSING 1\n \n #include \"simdjson/generic/numberparsing.h\"\n \n--- vendor/simdjson/include/simdjson/haswell/simd.h\n@@ -303,11 +303,12 @@ namespace simd {\n     simdjson_really_inline simd8x64(const simd8<T> chunk0, const simd8<T> chunk1) : chunks{chunk0, chunk1} {}\n     simdjson_really_inline simd8x64(const T ptr[64]) : chunks{simd8<T>::load(ptr), simd8<T>::load(ptr+32)} {}\n \n-    simdjson_really_inline void compress(uint64_t mask, T * output) const {\n+    simdjson_really_inline uint64_t compress(uint64_t mask, T * output) const {\n       uint32_t mask1 = uint32_t(mask);\n       uint32_t mask2 = uint32_t(mask >> 32);\n       this->chunks[0].compress(mask1, output);\n       this->chunks[1].compress(mask2, output + 32 - count_ones(mask1));\n+      return 64 - count_ones(mask);\n     }\n \n     simdjson_really_inline void store(T ptr[64]) const {\n--- vendor/simdjson/include/simdjson/internal/dom_parser_implementation.h\n@@ -11,8 +11,30 @@ namespace dom {\n class document;\n } // namespace dom\n \n+/**\n+* This enum is used with the dom_parser_implementation::stage1 function.\n+* 1) The regular mode expects a fully formed JSON document.\n+* 2) The streaming_partial mode expects a possibly truncated\n+* input within a stream on JSON documents.\n+* 3) The stream_final mode allows us to truncate final\n+* unterminated strings. It is useful in conjunction with streaming_partial.\n+*/\n+enum class stage1_mode { regular, streaming_partial, streaming_final};\n+\n+/**\n+ * Returns true if mode == streaming_partial or mode == streaming_final\n+ */\n+inline bool is_streaming(stage1_mode mode) {\n+  // performance note: it is probably faster to check that mode is different\n+  // from regular than checking that it is either streaming_partial or streaming_final.\n+  return (mode != stage1_mode::regular);\n+  // return (mode == stage1_mode::streaming_partial || mode == stage1_mode::streaming_final);\n+}\n+\n+\n namespace internal {\n \n+\n /**\n  * An implementation of simdjson's DOM parser for a particular CPU architecture.\n  *\n@@ -51,7 +73,7 @@ class dom_parser_implementation {\n    * @param streaming Whether this is being called by parser::parse_many.\n    * @return The error code, or SUCCESS if there was no error.\n    */\n-  simdjson_warn_unused virtual error_code stage1(const uint8_t *buf, size_t len, bool streaming) noexcept = 0;\n+  simdjson_warn_unused virtual error_code stage1(const uint8_t *buf, size_t len, stage1_mode streaming) noexcept = 0;\n \n   /**\n    * @private For internal implementation use\n--- vendor/simdjson/include/simdjson/nonstd/string_view.hpp\n@@ -1,4 +1,4 @@\n-// Copyright 2017-2019 by Martin Moene\n+// Copyright 2017-2020 by Martin Moene\n //\n // string-view lite, a C++17-like string_view for C++98 and later.\n // For more information see https://github.com/martinmoene/string-view-lite\n@@ -12,7 +12,7 @@\n #define NONSTD_SV_LITE_H_INCLUDED\n \n #define string_view_lite_MAJOR  1\n-#define string_view_lite_MINOR  4\n+#define string_view_lite_MINOR  6\n #define string_view_lite_PATCH  0\n \n #define string_view_lite_VERSION  nssv_STRINGIFY(string_view_lite_MAJOR) \".\" nssv_STRINGIFY(string_view_lite_MINOR) \".\" nssv_STRINGIFY(string_view_lite_PATCH)\n@@ -26,12 +26,22 @@\n #define nssv_STRING_VIEW_NONSTD   1\n #define nssv_STRING_VIEW_STD      2\n \n-#if !defined( nssv_CONFIG_SELECT_STRING_VIEW )\n-# define nssv_CONFIG_SELECT_STRING_VIEW  ( nssv_HAVE_STD_STRING_VIEW ? nssv_STRING_VIEW_STD : nssv_STRING_VIEW_NONSTD )\n+// tweak header support:\n+\n+#ifdef __has_include\n+# if __has_include(<nonstd/string_view.tweak.hpp>)\n+#  include <nonstd/string_view.tweak.hpp>\n+# endif\n+#define nssv_HAVE_TWEAK_HEADER  1\n+#else\n+#define nssv_HAVE_TWEAK_HEADER  0\n+//# pragma message(\"string_view.hpp: Note: Tweak header not supported.\")\n #endif\n \n-#if defined( nssv_CONFIG_SELECT_STD_STRING_VIEW ) || defined( nssv_CONFIG_SELECT_NONSTD_STRING_VIEW )\n-# error nssv_CONFIG_SELECT_STD_STRING_VIEW and nssv_CONFIG_SELECT_NONSTD_STRING_VIEW are deprecated and removed, please use nssv_CONFIG_SELECT_STRING_VIEW=nssv_STRING_VIEW_...\n+// string_view selection and configuration:\n+\n+#if !defined( nssv_CONFIG_SELECT_STRING_VIEW )\n+# define nssv_CONFIG_SELECT_STRING_VIEW  ( nssv_HAVE_STD_STRING_VIEW ? nssv_STRING_VIEW_STD : nssv_STRING_VIEW_NONSTD )\n #endif\n \n #ifndef  nssv_CONFIG_STD_SV_OPERATOR\n@@ -55,10 +65,17 @@\n # define nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS  1\n #endif\n \n+#ifndef  nssv_CONFIG_NO_STREAM_INSERTION\n+# define nssv_CONFIG_NO_STREAM_INSERTION  0\n+#endif\n+\n // Control presence of exception handling (try and auto discover):\n \n #ifndef nssv_CONFIG_NO_EXCEPTIONS\n-# if defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)\n+# if _MSC_VER\n+#  include <cstddef>    // for _HAS_EXCEPTIONS\n+# endif\n+# if defined(__cpp_exceptions) || defined(__EXCEPTIONS) || (_HAS_EXCEPTIONS)\n #  define nssv_CONFIG_NO_EXCEPTIONS  0\n # else\n #  define nssv_CONFIG_NO_EXCEPTIONS  1\n@@ -221,16 +238,21 @@ using std::operator<<;\n \n #define nssv_COMPILER_VERSION( major, minor, patch )  ( 10 * ( 10 * (major) + (minor) ) + (patch) )\n \n-#if defined(__clang__)\n-# define nssv_COMPILER_CLANG_VERSION  nssv_COMPILER_VERSION(__clang_major__, __clang_minor__, __clang_patchlevel__)\n+#if defined( __apple_build_version__ )\n+# define nssv_COMPILER_APPLECLANG_VERSION  nssv_COMPILER_VERSION(__clang_major__, __clang_minor__, __clang_patchlevel__)\n+# define nssv_COMPILER_CLANG_VERSION       0\n+#elif defined( __clang__ )\n+# define nssv_COMPILER_APPLECLANG_VERSION  0\n+# define nssv_COMPILER_CLANG_VERSION       nssv_COMPILER_VERSION(__clang_major__, __clang_minor__, __clang_patchlevel__)\n #else\n-# define nssv_COMPILER_CLANG_VERSION    0\n+# define nssv_COMPILER_APPLECLANG_VERSION  0\n+# define nssv_COMPILER_CLANG_VERSION       0\n #endif\n \n #if defined(__GNUC__) && !defined(__clang__)\n # define nssv_COMPILER_GNUC_VERSION  nssv_COMPILER_VERSION(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)\n #else\n-# define nssv_COMPILER_GNUC_VERSION    0\n+# define nssv_COMPILER_GNUC_VERSION  0\n #endif\n \n // half-open range [lo..hi):\n@@ -292,6 +314,45 @@ using std::operator<<;\n \n #define nssv_HAVE_STD_HASH              nssv_CPP11_120\n \n+// Presence of compiler intrinsics:\n+\n+// Providing char-type specializations for compare() and length() that\n+// use compiler intrinsics can improve compile- and run-time performance.\n+//\n+// The challenge is in using the right combinations of builtin availability\n+// and its constexpr-ness.\n+//\n+// | compiler | __builtin_memcmp (constexpr) | memcmp  (constexpr) |\n+// |----------|------------------------------|---------------------|\n+// | clang    | 4.0              (>= 4.0   ) | any     (?        ) |\n+// | clang-a  | 9.0              (>= 9.0   ) | any     (?        ) |\n+// | gcc      | any              (constexpr) | any     (?        ) |\n+// | msvc     | >= 14.2 C++17    (>= 14.2  ) | any     (?        ) |\n+\n+#define nssv_HAVE_BUILTIN_VER     ( (nssv_CPP17_000 && nssv_COMPILER_MSVC_VERSION >= 142) || nssv_COMPILER_GNUC_VERSION > 0 || nssv_COMPILER_CLANG_VERSION >= 400 || nssv_COMPILER_APPLECLANG_VERSION >= 900 )\n+#define nssv_HAVE_BUILTIN_CE      (  nssv_HAVE_BUILTIN_VER )\n+\n+#define nssv_HAVE_BUILTIN_MEMCMP  ( (nssv_HAVE_CONSTEXPR_14 && nssv_HAVE_BUILTIN_CE) || !nssv_HAVE_CONSTEXPR_14 )\n+#define nssv_HAVE_BUILTIN_STRLEN  ( (nssv_HAVE_CONSTEXPR_11 && nssv_HAVE_BUILTIN_CE) || !nssv_HAVE_CONSTEXPR_11 )\n+\n+#ifdef __has_builtin\n+# define nssv_HAVE_BUILTIN( x )  __has_builtin( x )\n+#else\n+# define nssv_HAVE_BUILTIN( x )  0\n+#endif\n+\n+#if nssv_HAVE_BUILTIN(__builtin_memcmp) || nssv_HAVE_BUILTIN_VER\n+# define nssv_BUILTIN_MEMCMP  __builtin_memcmp\n+#else\n+# define nssv_BUILTIN_MEMCMP  memcmp\n+#endif\n+\n+#if nssv_HAVE_BUILTIN(__builtin_strlen) || nssv_HAVE_BUILTIN_VER\n+# define nssv_BUILTIN_STRLEN  __builtin_strlen\n+#else\n+# define nssv_BUILTIN_STRLEN  strlen\n+#endif\n+\n // C++ feature usage:\n \n #if nssv_HAVE_CONSTEXPR_11\n@@ -350,9 +411,12 @@ using std::operator<<;\n #include <cassert>\n #include <iterator>\n #include <limits>\n-#include <ostream>\n #include <string>   // std::char_traits<>\n \n+#if ! nssv_CONFIG_NO_STREAM_INSERTION\n+# include <ostream>\n+#endif\n+\n #if ! nssv_CONFIG_NO_EXCEPTIONS\n # include <stdexcept>\n #endif\n@@ -405,39 +469,74 @@ nssv_DISABLE_MSVC_WARNINGS( 4455 26481 26472 )\n \n namespace nonstd { namespace sv_lite {\n \n-#if nssv_CPP11_OR_GREATER\n-\n namespace detail {\n \n-#if nssv_CPP14_OR_GREATER\n+// support constexpr comparison in C++14;\n+// for C++17 and later, use provided traits:\n \n template< typename CharT >\n-inline constexpr std::size_t length( CharT * s, std::size_t result = 0 )\n+inline nssv_constexpr14 int compare( CharT const * s1, CharT const * s2, std::size_t count )\n {\n-    CharT * v = s;\n-    std::size_t r = result;\n-    while ( *v != '\\0' ) {\n-       ++v;\n-       ++r;\n+    while ( count-- != 0 )\n+    {\n+        if ( *s1 < *s2 ) return -1;\n+        if ( *s1 > *s2 ) return +1;\n+        ++s1; ++s2;\n     }\n-    return r;\n+    return 0;\n+}\n+\n+#if nssv_HAVE_BUILTIN_MEMCMP\n+\n+// specialization of compare() for char, see also generic compare() above:\n+\n+inline nssv_constexpr14 int compare( char const * s1, char const * s2, std::size_t count )\n+{\n+    return nssv_BUILTIN_MEMCMP( s1, s2, count );\n+}\n+\n+#endif\n+\n+#if nssv_HAVE_BUILTIN_STRLEN\n+\n+// specialization of length() for char, see also generic length() further below:\n+\n+inline nssv_constexpr std::size_t length( char const * s )\n+{\n+    return nssv_BUILTIN_STRLEN( s );\n }\n \n-#else // nssv_CPP14_OR_GREATER\n+#endif\n+\n+#if defined(__OPTIMIZE__)\n \n+// gcc, clang provide __OPTIMIZE__\n // Expect tail call optimization to make length() non-recursive:\n \n template< typename CharT >\n-inline constexpr std::size_t length( CharT * s, std::size_t result = 0 )\n+inline nssv_constexpr std::size_t length( CharT * s, std::size_t result = 0 )\n {\n     return *s == '\\0' ? result : length( s + 1, result + 1 );\n }\n \n-#endif // nssv_CPP14_OR_GREATER\n+#else // OPTIMIZE\n \n-} // namespace detail\n+// non-recursive:\n \n-#endif // nssv_CPP11_OR_GREATER\n+template< typename CharT >\n+inline nssv_constexpr14 std::size_t length( CharT * s )\n+{\n+    std::size_t result = 0;\n+    while ( *s++ != '\\0' )\n+    {\n+       ++result;\n+    }\n+    return result;\n+}\n+\n+#endif // OPTIMIZE\n+\n+} // namespace detail\n \n template\n <\n@@ -589,9 +688,9 @@ class basic_string_view\n \n     nssv_constexpr14 void swap( basic_string_view & other ) nssv_noexcept\n     {\n-        using std::swap;\n-        swap( data_, other.data_ );\n-        swap( size_, other.size_ );\n+        const basic_string_view tmp(other);\n+        other = *this;\n+        *this = tmp;\n     }\n \n     // 24.4.2.6 String operations:\n@@ -630,7 +729,11 @@ class basic_string_view\n \n     nssv_constexpr14 int compare( basic_string_view other ) const nssv_noexcept // (1)\n     {\n+#if nssv_CPP17_OR_GREATER\n         if ( const int result = Traits::compare( data(), other.data(), (std::min)( size(), other.size() ) ) )\n+#else\n+        if ( const int result = detail::compare( data(), other.data(), (std::min)( size(), other.size() ) ) )\n+#endif\n         {\n             return result;\n         }\n@@ -874,7 +977,7 @@ class basic_string_view\n     {\n         const basic_string_view v;\n \n-        nssv_constexpr explicit not_in_view( basic_string_view v ) : v( v ) {}\n+        nssv_constexpr explicit not_in_view( basic_string_view v_ ) : v( v_ ) {}\n \n         nssv_constexpr bool operator()( CharT c ) const\n         {\n@@ -964,37 +1067,37 @@ template< class CharT, class Traits >\n nssv_constexpr bool operator== (\n     basic_string_view <CharT, Traits> lhs,\n     basic_string_view <CharT, Traits> rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) == 0 ; }\n+{ return lhs.size() == rhs.size() && lhs.compare( rhs ) == 0; }\n \n template< class CharT, class Traits >\n nssv_constexpr bool operator!= (\n     basic_string_view <CharT, Traits> lhs,\n     basic_string_view <CharT, Traits> rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) != 0 ; }\n+{ return !( lhs == rhs ); }\n \n template< class CharT, class Traits >\n nssv_constexpr bool operator< (\n     basic_string_view <CharT, Traits> lhs,\n     basic_string_view <CharT, Traits> rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) < 0 ; }\n+{ return lhs.compare( rhs ) < 0; }\n \n template< class CharT, class Traits >\n nssv_constexpr bool operator<= (\n     basic_string_view <CharT, Traits> lhs,\n     basic_string_view <CharT, Traits> rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) <= 0 ; }\n+{ return lhs.compare( rhs ) <= 0; }\n \n template< class CharT, class Traits >\n nssv_constexpr bool operator> (\n     basic_string_view <CharT, Traits> lhs,\n     basic_string_view <CharT, Traits> rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) > 0 ; }\n+{ return lhs.compare( rhs ) > 0; }\n \n template< class CharT, class Traits >\n nssv_constexpr bool operator>= (\n     basic_string_view <CharT, Traits> lhs,\n     basic_string_view <CharT, Traits> rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) >= 0 ; }\n+{ return lhs.compare( rhs ) >= 0; }\n \n // Let S be basic_string_view<CharT, Traits>, and sv be an instance of S.\n // Implementations shall provide sufficient additional overloads marked\n@@ -1003,21 +1106,21 @@ nssv_constexpr bool operator>= (\n \n #if ! nssv_CPP11_OR_GREATER || nssv_BETWEEN( nssv_COMPILER_MSVC_VERSION, 100, 141 )\n \n-// accomodate for older compilers:\n+// accommodate for older compilers:\n \n // ==\n \n template< class CharT, class Traits>\n nssv_constexpr bool operator==(\n     basic_string_view<CharT, Traits> lhs,\n-    char const * rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) == 0; }\n+    CharT const * rhs ) nssv_noexcept\n+{ return lhs.size() == detail::length( rhs ) && lhs.compare( rhs ) == 0; }\n \n template< class CharT, class Traits>\n nssv_constexpr bool operator==(\n-    char const * lhs,\n+    CharT const * lhs,\n     basic_string_view<CharT, Traits> rhs ) nssv_noexcept\n-{ return rhs.compare( lhs ) == 0; }\n+{ return detail::length( lhs ) == rhs.size() && rhs.compare( lhs ) == 0; }\n \n template< class CharT, class Traits>\n nssv_constexpr bool operator==(\n@@ -1036,38 +1139,38 @@ nssv_constexpr bool operator==(\n template< class CharT, class Traits>\n nssv_constexpr bool operator!=(\n     basic_string_view<CharT, Traits> lhs,\n-    char const * rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) != 0; }\n+    CharT const * rhs ) nssv_noexcept\n+{ return !( lhs == rhs ); }\n \n template< class CharT, class Traits>\n nssv_constexpr bool operator!=(\n-    char const * lhs,\n+    CharT const * lhs,\n     basic_string_view<CharT, Traits> rhs ) nssv_noexcept\n-{ return rhs.compare( lhs ) != 0; }\n+{ return !( lhs == rhs ); }\n \n template< class CharT, class Traits>\n nssv_constexpr bool operator!=(\n     basic_string_view<CharT, Traits> lhs,\n     std::basic_string<CharT, Traits> rhs ) nssv_noexcept\n-{ return lhs.size() != rhs.size() && lhs.compare( rhs ) != 0; }\n+{ return !( lhs == rhs ); }\n \n template< class CharT, class Traits>\n nssv_constexpr bool operator!=(\n     std::basic_string<CharT, Traits> rhs,\n     basic_string_view<CharT, Traits> lhs ) nssv_noexcept\n-{ return lhs.size() != rhs.size() || rhs.compare( lhs ) != 0; }\n+{ return !( lhs == rhs ); }\n \n // <\n \n template< class CharT, class Traits>\n nssv_constexpr bool operator<(\n     basic_string_view<CharT, Traits> lhs,\n-    char const * rhs ) nssv_noexcept\n+    CharT const * rhs ) nssv_noexcept\n { return lhs.compare( rhs ) < 0; }\n \n template< class CharT, class Traits>\n nssv_constexpr bool operator<(\n-    char const * lhs,\n+    CharT const * lhs,\n     basic_string_view<CharT, Traits> rhs ) nssv_noexcept\n { return rhs.compare( lhs ) > 0; }\n \n@@ -1088,12 +1191,12 @@ nssv_constexpr bool operator<(\n template< class CharT, class Traits>\n nssv_constexpr bool operator<=(\n     basic_string_view<CharT, Traits> lhs,\n-    char const * rhs ) nssv_noexcept\n+    CharT const * rhs ) nssv_noexcept\n { return lhs.compare( rhs ) <= 0; }\n \n template< class CharT, class Traits>\n nssv_constexpr bool operator<=(\n-    char const * lhs,\n+    CharT const * lhs,\n     basic_string_view<CharT, Traits> rhs ) nssv_noexcept\n { return rhs.compare( lhs ) >= 0; }\n \n@@ -1114,12 +1217,12 @@ nssv_constexpr bool operator<=(\n template< class CharT, class Traits>\n nssv_constexpr bool operator>(\n     basic_string_view<CharT, Traits> lhs,\n-    char const * rhs ) nssv_noexcept\n+    CharT const * rhs ) nssv_noexcept\n { return lhs.compare( rhs ) > 0; }\n \n template< class CharT, class Traits>\n nssv_constexpr bool operator>(\n-    char const * lhs,\n+    CharT const * lhs,\n     basic_string_view<CharT, Traits> rhs ) nssv_noexcept\n { return rhs.compare( lhs ) < 0; }\n \n@@ -1140,12 +1243,12 @@ nssv_constexpr bool operator>(\n template< class CharT, class Traits>\n nssv_constexpr bool operator>=(\n     basic_string_view<CharT, Traits> lhs,\n-    char const * rhs ) nssv_noexcept\n+    CharT const * rhs ) nssv_noexcept\n { return lhs.compare( rhs ) >= 0; }\n \n template< class CharT, class Traits>\n nssv_constexpr bool operator>=(\n-    char const * lhs,\n+    CharT const * lhs,\n     basic_string_view<CharT, Traits> rhs ) nssv_noexcept\n { return rhs.compare( lhs ) <= 0; }\n \n@@ -1165,7 +1268,7 @@ nssv_constexpr bool operator>=(\n \n #define nssv_BASIC_STRING_VIEW_I(T,U)  typename std::decay< basic_string_view<T,U> >::type\n \n-#if nssv_BETWEEN( nssv_COMPILER_MSVC_VERSION, 140, 150 )\n+#if defined(_MSC_VER)       // issue 40\n # define nssv_MSVC_ORDER(x)  , int=x\n #else\n # define nssv_MSVC_ORDER(x)  /*, int=x*/\n@@ -1177,7 +1280,7 @@ template< class CharT, class Traits  nssv_MSVC_ORDER(1) >\n nssv_constexpr bool operator==(\n          basic_string_view  <CharT, Traits> lhs,\n     nssv_BASIC_STRING_VIEW_I(CharT, Traits) rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) == 0; }\n+{ return lhs.size() == rhs.size() && lhs.compare( rhs ) == 0; }\n \n template< class CharT, class Traits  nssv_MSVC_ORDER(2) >\n nssv_constexpr bool operator==(\n@@ -1191,69 +1294,69 @@ template< class CharT, class Traits  nssv_MSVC_ORDER(1) >\n nssv_constexpr bool operator!= (\n          basic_string_view  < CharT, Traits > lhs,\n     nssv_BASIC_STRING_VIEW_I( CharT, Traits ) rhs ) nssv_noexcept\n-{ return lhs.size() != rhs.size() || lhs.compare( rhs ) != 0 ; }\n+{ return !( lhs == rhs ); }\n \n template< class CharT, class Traits  nssv_MSVC_ORDER(2) >\n nssv_constexpr bool operator!= (\n     nssv_BASIC_STRING_VIEW_I( CharT, Traits ) lhs,\n          basic_string_view  < CharT, Traits > rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) != 0 ; }\n+{ return !( lhs == rhs ); }\n \n // <\n \n template< class CharT, class Traits  nssv_MSVC_ORDER(1) >\n nssv_constexpr bool operator< (\n          basic_string_view  < CharT, Traits > lhs,\n     nssv_BASIC_STRING_VIEW_I( CharT, Traits ) rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) < 0 ; }\n+{ return lhs.compare( rhs ) < 0; }\n \n template< class CharT, class Traits  nssv_MSVC_ORDER(2) >\n nssv_constexpr bool operator< (\n     nssv_BASIC_STRING_VIEW_I( CharT, Traits ) lhs,\n          basic_string_view  < CharT, Traits > rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) < 0 ; }\n+{ return lhs.compare( rhs ) < 0; }\n \n // <=\n \n template< class CharT, class Traits  nssv_MSVC_ORDER(1) >\n nssv_constexpr bool operator<= (\n          basic_string_view  < CharT, Traits > lhs,\n     nssv_BASIC_STRING_VIEW_I( CharT, Traits ) rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) <= 0 ; }\n+{ return lhs.compare( rhs ) <= 0; }\n \n template< class CharT, class Traits  nssv_MSVC_ORDER(2) >\n nssv_constexpr bool operator<= (\n     nssv_BASIC_STRING_VIEW_I( CharT, Traits ) lhs,\n          basic_string_view  < CharT, Traits > rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) <= 0 ; }\n+{ return lhs.compare( rhs ) <= 0; }\n \n // >\n \n template< class CharT, class Traits  nssv_MSVC_ORDER(1) >\n nssv_constexpr bool operator> (\n          basic_string_view  < CharT, Traits > lhs,\n     nssv_BASIC_STRING_VIEW_I( CharT, Traits ) rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) > 0 ; }\n+{ return lhs.compare( rhs ) > 0; }\n \n template< class CharT, class Traits  nssv_MSVC_ORDER(2) >\n nssv_constexpr bool operator> (\n     nssv_BASIC_STRING_VIEW_I( CharT, Traits ) lhs,\n          basic_string_view  < CharT, Traits > rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) > 0 ; }\n+{ return lhs.compare( rhs ) > 0; }\n \n // >=\n \n template< class CharT, class Traits  nssv_MSVC_ORDER(1) >\n nssv_constexpr bool operator>= (\n          basic_string_view  < CharT, Traits > lhs,\n     nssv_BASIC_STRING_VIEW_I( CharT, Traits ) rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) >= 0 ; }\n+{ return lhs.compare( rhs ) >= 0; }\n \n template< class CharT, class Traits  nssv_MSVC_ORDER(2) >\n nssv_constexpr bool operator>= (\n     nssv_BASIC_STRING_VIEW_I( CharT, Traits ) lhs,\n          basic_string_view  < CharT, Traits > rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) >= 0 ; }\n+{ return lhs.compare( rhs ) >= 0; }\n \n #undef nssv_MSVC_ORDER\n #undef nssv_BASIC_STRING_VIEW_I\n@@ -1262,6 +1365,8 @@ nssv_constexpr bool operator>= (\n \n // 24.4.4 Inserters and extractors:\n \n+#if ! nssv_CONFIG_NO_STREAM_INSERTION\n+\n namespace detail {\n \n template< class Stream >\n@@ -1311,6 +1416,8 @@ operator<<(\n     return detail::write_to_stream( os, sv );\n }\n \n+#endif // nssv_CONFIG_NO_STREAM_INSERTION\n+\n // Several typedefs for common character types are provided:\n \n typedef basic_string_view<char>      string_view;\n@@ -1459,7 +1566,9 @@ using sv_lite::operator<=;\n using sv_lite::operator>;\n using sv_lite::operator>=;\n \n+#if ! nssv_CONFIG_NO_STREAM_INSERTION\n using sv_lite::operator<<;\n+#endif\n \n #if nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS\n using sv_lite::to_string;\n@@ -1526,4 +1635,4 @@ struct hash< nonstd::u32string_view >\n nssv_RESTORE_WARNINGS()\n \n #endif // nssv_HAVE_STD_STRING_VIEW\n-#endif // NONSTD_SV_LITE_H_INCLUDED\n\\ No newline at end of file\n+#endif // NONSTD_SV_LITE_H_INCLUDED\n--- vendor/simdjson/include/simdjson/padded_string-inl.h\n@@ -115,11 +115,11 @@ inline padded_string::operator padded_string_view() const noexcept {\n   return padded_string_view(data(), length(), length() + SIMDJSON_PADDING);\n }\n \n-inline simdjson_result<padded_string> padded_string::load(const std::string &filename) noexcept {\n+inline simdjson_result<padded_string> padded_string::load(std::string_view filename) noexcept {\n   // Open the file\n   SIMDJSON_PUSH_DISABLE_WARNINGS\n   SIMDJSON_DISABLE_DEPRECATED_WARNING // Disable CRT_SECURE warning on MSVC: manually verified this is safe\n-  std::FILE *fp = std::fopen(filename.c_str(), \"rb\");\n+  std::FILE *fp = std::fopen(filename.data(), \"rb\");\n   SIMDJSON_POP_DISABLE_WARNINGS\n \n   if (fp == nullptr) {\n--- vendor/simdjson/include/simdjson/padded_string.h\n@@ -111,7 +111,7 @@ struct padded_string final {\n    *\n    * @param path the path to the file.\n    **/\n-  inline static simdjson_result<padded_string> load(const std::string &path) noexcept;\n+  inline static simdjson_result<padded_string> load(std::string_view path) noexcept;\n \n private:\n   padded_string &operator=(const padded_string &o) = delete;\n--- vendor/simdjson/include/simdjson/ppc64/numberparsing.h\n@@ -25,7 +25,7 @@ parse_eight_digits_unrolled(const uint8_t *chars) {\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n \n-#define SWAR_NUMBER_PARSING\n+#define SIMDJSON_SWAR_NUMBER_PARSING 1\n \n #include \"simdjson/generic/numberparsing.h\"\n \n--- vendor/simdjson/include/simdjson/ppc64/simd.h\n@@ -422,14 +422,15 @@ template <typename T> struct simd8x64 {\n            (this->chunks[2] | this->chunks[3]);\n   }\n \n-  simdjson_really_inline void compress(uint64_t mask, T *output) const {\n+  simdjson_really_inline uint64_t compress(uint64_t mask, T *output) const {\n     this->chunks[0].compress(uint16_t(mask), output);\n     this->chunks[1].compress(uint16_t(mask >> 16),\n                              output + 16 - count_ones(mask & 0xFFFF));\n     this->chunks[2].compress(uint16_t(mask >> 32),\n                              output + 32 - count_ones(mask & 0xFFFFFFFF));\n     this->chunks[3].compress(uint16_t(mask >> 48),\n                              output + 48 - count_ones(mask & 0xFFFFFFFFFFFF));\n+    return 64 - count_ones(mask);\n   }\n \n   simdjson_really_inline uint64_t to_bitmask() const {\n--- vendor/simdjson/include/simdjson/simdjson_version.h\n@@ -4,22 +4,22 @@\n #define SIMDJSON_SIMDJSON_VERSION_H\n \n /** The version of simdjson being used (major.minor.revision) */\n-#define SIMDJSON_VERSION 0.9.6\n+#define SIMDJSON_VERSION 1.0.0\n \n namespace simdjson {\n enum {\n   /**\n    * The major version (MAJOR.minor.revision) of simdjson being used.\n    */\n-  SIMDJSON_VERSION_MAJOR = 0,\n+  SIMDJSON_VERSION_MAJOR = 1,\n   /**\n    * The minor version (major.MINOR.revision) of simdjson being used.\n    */\n-  SIMDJSON_VERSION_MINOR = 9,\n+  SIMDJSON_VERSION_MINOR = 0,\n   /**\n    * The revision (major.minor.REVISION) of simdjson being used.\n    */\n-  SIMDJSON_VERSION_REVISION = 6\n+  SIMDJSON_VERSION_REVISION = 0\n };\n } // namespace simdjson\n \n--- vendor/simdjson/include/simdjson/westmere/numberparsing.h\n@@ -27,7 +27,7 @@ static simdjson_really_inline uint32_t parse_eight_digits_unrolled(const uint8_t\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n \n-#define SWAR_NUMBER_PARSING\n+#define SIMDJSON_SWAR_NUMBER_PARSING 1\n \n #include \"simdjson/generic/numberparsing.h\"\n \n--- vendor/simdjson/include/simdjson/westmere/simd.h\n@@ -284,11 +284,12 @@ namespace simd {\n       return (this->chunks[0] | this->chunks[1]) | (this->chunks[2] | this->chunks[3]);\n     }\n \n-    simdjson_really_inline void compress(uint64_t mask, T * output) const {\n+    simdjson_really_inline uint64_t compress(uint64_t mask, T * output) const {\n       this->chunks[0].compress(uint16_t(mask), output);\n       this->chunks[1].compress(uint16_t(mask >> 16), output + 16 - count_ones(mask & 0xFFFF));\n       this->chunks[2].compress(uint16_t(mask >> 32), output + 32 - count_ones(mask & 0xFFFFFFFF));\n       this->chunks[3].compress(uint16_t(mask >> 48), output + 48 - count_ones(mask & 0xFFFFFFFFFFFF));\n+      return 64 - count_ones(mask);\n     }\n \n     simdjson_really_inline uint64_t to_bitmask() const {\n--- vendor/simdjson/src/CMakeLists.txt\n@@ -1,161 +0,0 @@\n-#\n-# For callers who intend to #include simdjson.cpp.\n-#\n-# target_link_libraries(my-program simdjson-include-source) gives you the header and source\n-# directories. It does not specify any compiler flags.\n-#\n-\n-add_library(simdjson-include-source INTERFACE)\n-target_link_libraries(simdjson-include-source INTERFACE simdjson-headers)\n-target_include_directories(simdjson-include-source INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>)\n-# If a CMake user installs simdjson and then does...\n-#   find_package(simdjson CONFIG REQUIRED)\n-#   find_package(Threads REQUIRED)\n-#   target_link_libraries(test PRIVATE simdjson-include-source)\n-# It is not clear what it should do? Does the user get access to the src files?\n-# install(TARGETS simdjson-include-source EXPORT simdjson-config)\n-\n-#\n-# For callers who intend to compile simdjson.cpp themselves.\n-#\n-# target_link_libraries(my-object simdjson-source) gives you the header and source directories, plus\n-# the .cpp sources. It does not specify any compiler flags.\n-#\n-add_library(simdjson-source INTERFACE)\n-target_sources(simdjson-source INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>/simdjson.cpp)\n-target_link_libraries(simdjson-source INTERFACE simdjson-include-source)\n-# Note that simdjson.cpp is *not* installed so installing simdjson-include-source is not great.\n-# If a CMake user installs simdjson and then does...\n-#   find_package(simdjson CONFIG REQUIRED)\n-#   find_package(Threads REQUIRED)\n-#   target_link_libraries(test PRIVATE simdjson-source)\n-# It might fail with  Cannot find source file: simdjson.cpp\n-# See issue https://github.com/simdjson/simdjson/issues/1383\n-# install(TARGETS simdjson-source EXPORT simdjson-config)\n-\n-#\n-# simdjson is the distributed library compiled with flags.\n-#\n-# target_link_libraries(my-object simdjson) gives you the .so or .a to link against, plus the header\n-# directory. It does not specify any compiler flags, even though simdjson.so/a was compiled with\n-# target_link_libraries(simdjson PRIVATE simdjson-flags).\n-#\n-\n-if(SIMDJSON_BUILD_STATIC)\n-  MESSAGE( STATUS \"Building a static library.\" )\n-  ###\n-  # In the case of a static library, if you do \"target_link_libraries(simdjson PRIVATE simdjson-source simdjson-internal-flags)\"\n-  # without also calling \"install(TARGETS simdjson-source EXPORT simdjson-config)\" you get an error\n-  # to the effect that you are trying to install 'simdjson' which depends on 'simdjson-source' while\n-  # not installing 'simdjson-source', so it fails. So we bypass entirely simdjson-source since we do\n-  # not want to install them.\n-  ####\n-  add_library(simdjson STATIC simdjson.cpp)\n-  target_include_directories(simdjson PRIVATE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>)\n-else()\n-  MESSAGE( STATUS \"Building a dynamic library.\" )\n-  add_library(simdjson SHARED \"\")\n-  if(MSVC)\n-    MESSAGE( STATUS \"Building a Windows DLL using Visual Studio, exporting all symbols automatically.\" )\n-    set_target_properties(simdjson PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS 1)\n-    # Setting the dllexport, users of the library should never need to set SIMDJSON_BUILDING_WINDOWS_DYNAMIC_LIBRARY\n-    # once the DLL is built. Note the private scope on the next line.\n-    target_compile_definitions(simdjson PRIVATE SIMDJSON_BUILDING_WINDOWS_DYNAMIC_LIBRARY=1)\n-    #\n-    # The simdjson-flags are exported as part of the CMake install. Therefore users of\n-    # the library should pick up the SIMDJSON_USING_WINDOWS_DYNAMIC_LIBRARY=1 value.\n-    # It should appear in simdjson-config.cmake (an installed file) as (for example)\n-    #      set_target_properties(simdjson::simdjson-flags PROPERTIES\n-    #        INTERFACE_COMPILE_DEFINITIONS \"SIMDJSON_THREADS_ENABLED=1\"\n-    #        INTERFACE_COMPILE_DEFINITIONS \"SIMDJSON_USING_WINDOWS_DYNAMIC_LIBRARY=1\"\n-    #        INTERFACE_LINK_LIBRARIES \"Threads::Threads\"\n-    #      )\n-    #\n-    target_compile_definitions(simdjson-flags INTERFACE SIMDJSON_USING_WINDOWS_DYNAMIC_LIBRARY=1)\n-  endif()\n-  ###\n-  # Somehow, for a dynamic library, the next line is entirely fine (but not for a static one).\n-  ###\n-  target_link_libraries(simdjson PRIVATE simdjson-source simdjson-internal-flags)\n-endif()\n-target_link_libraries(simdjson PUBLIC simdjson-headers simdjson-flags) # Only expose the headers, not sources\n-\n-\n-##\n-## In systems like R, libraries must not use stderr or abort to be acceptable.\n-## Thus we make it a hard rule that one is not allowed to call abort or stderr.\n-## The sanitized builds are allowed to abort.\n-##\n-if(NOT SIMDJSON_SANITIZE)\n-  find_program(GREP grep)\n-  find_program(NM nm)\n-  if((NOT GREP) OR (NOT NM))\n-    message(\"grep and nm are unavailable on this system.\")\n-  else()\n-    add_test(\n-      NAME \"avoid_abort\"\n-      # Under FreeBSD, the __cxa_guard_abort symbol may appear but it is fine.\n-      # So we want to look for <space><possibly _>abort as a test.\n-      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} ' _*abort' || exit 0  && exit 1\"\n-      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n-    )\n-    add_test(\n-      NAME \"avoid_cout\"\n-      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} ' _*cout' || exit 0  && exit 1\"\n-      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n-    )\n-    add_test(\n-      NAME \"avoid_cerr\"\n-      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} ' _*cerr' || exit 0  && exit 1\"\n-      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n-    )\n-    add_test(\n-      NAME \"avoid_printf\"\n-      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} ' _*printf' || exit 0  && exit 1\"\n-      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n-    )\n-    add_test(\n-      NAME \"avoid_stdout\"\n-      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} stdout || exit 0 && exit 1\"\n-      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n-    )\n-    add_test(\n-      NAME \"avoid_stderr\"\n-      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} stderr || exit 0 && exit 1\"\n-      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n-    )\n-  endif()\n-endif()\n-\n-if(NOT MSVC)\n-  ## We output the library at the root of the current directory where cmake is invoked\n-  ## This is handy but Visual Studio will happily ignore us\n-  set_target_properties(simdjson PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})\n-  MESSAGE( STATUS \"Library output directory: \" ${PROJECT_BINARY_DIR})\n-\n-  ############\n-  # Please do not delete the following, our users want version numbers. See\n-  # https://github.com/simdjson/simdjson/issues/1014\n-  # https://github.com/simdjson/simdjson/issues/52\n-  ###########\n-  set_target_properties(simdjson PROPERTIES VERSION ${SIMDJSON_LIB_VERSION}\tSOVERSION ${SIMDJSON_LIB_SOVERSION})\n-  ##########\n-  # End of the do-not-delete message.\n-  #########\n-endif()\n-\n-#\n-# Installation\n-#\n-install(TARGETS simdjson\n-  EXPORT simdjson-config\n-  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n-  LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n-  RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n-)\n-\n-install(EXPORT simdjson-config\n-  FILE simdjson-targets.cmake\n-  NAMESPACE simdjson::\n-  DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/simdjson\n-)\n--- vendor/simdjson/src/arm64/dom_parser_implementation.cpp\n@@ -133,7 +133,7 @@ simdjson_warn_unused error_code implementation::minify(const uint8_t *buf, size_\n   return arm64::stage1::json_minifier::minify<64>(buf, len, dst, dst_len);\n }\n \n-simdjson_warn_unused error_code dom_parser_implementation::stage1(const uint8_t *_buf, size_t _len, bool streaming) noexcept {\n+simdjson_warn_unused error_code dom_parser_implementation::stage1(const uint8_t *_buf, size_t _len, stage1_mode streaming) noexcept {\n   this->buf = _buf;\n   this->len = _len;\n   return arm64::stage1::json_structural_indexer::index<64>(buf, len, *this, streaming);\n@@ -152,7 +152,7 @@ simdjson_warn_unused error_code dom_parser_implementation::stage2_next(dom::docu\n }\n \n simdjson_warn_unused error_code dom_parser_implementation::parse(const uint8_t *_buf, size_t _len, dom::document &_doc) noexcept {\n-  auto error = stage1(_buf, _len, false);\n+  auto error = stage1(_buf, _len, stage1_mode::regular);\n   if (error) { return error; }\n   return stage2(_doc);\n }\n--- vendor/simdjson/src/arm64/implementation.cpp\n@@ -10,12 +10,14 @@ simdjson_warn_unused error_code implementation::create_dom_parser_implementation\n ) const noexcept {\n   dst.reset( new (std::nothrow) dom_parser_implementation() );\n   if (!dst) { return MEMALLOC; }\n-  dst->set_capacity(capacity);\n-  dst->set_max_depth(max_depth);\n+  if (auto err = dst->set_capacity(capacity))\n+    return err;\n+  if (auto err = dst->set_max_depth(max_depth))\n+    return err;\n   return SUCCESS;\n }\n \n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n \n-#include \"simdjson/arm64/end.h\"\n\\ No newline at end of file\n+#include \"simdjson/arm64/end.h\"\n--- vendor/simdjson/src/fallback/dom_parser_implementation.cpp\n@@ -13,7 +13,7 @@ namespace stage1 {\n class structural_scanner {\n public:\n \n-simdjson_really_inline structural_scanner(dom_parser_implementation &_parser, bool _partial)\n+simdjson_really_inline structural_scanner(dom_parser_implementation &_parser, stage1_mode _partial)\n   : buf{_parser.buf},\n     next_structural_index{_parser.structural_indexes.get()},\n     parser{_parser},\n@@ -43,7 +43,7 @@ simdjson_really_inline void validate_utf8_character() {\n   if ((buf[idx] & 0b00100000) == 0) {\n     // missing continuation\n     if (simdjson_unlikely(idx+1 > len || !is_continuation(buf[idx+1]))) {\n-      if (idx+1 > len && partial) { idx = len; return; }\n+      if (idx+1 > len && is_streaming(partial)) { idx = len; return; }\n       error = UTF8_ERROR;\n       idx++;\n       return;\n@@ -58,7 +58,7 @@ simdjson_really_inline void validate_utf8_character() {\n   if ((buf[idx] & 0b00010000) == 0) {\n     // missing continuation\n     if (simdjson_unlikely(idx+2 > len || !is_continuation(buf[idx+1]) || !is_continuation(buf[idx+2]))) {\n-      if (idx+2 > len && partial) { idx = len; return; }\n+      if (idx+2 > len && is_streaming(partial)) { idx = len; return; }\n       error = UTF8_ERROR;\n       idx++;\n       return;\n@@ -74,7 +74,7 @@ simdjson_really_inline void validate_utf8_character() {\n   // 4-byte\n   // missing continuation\n   if (simdjson_unlikely(idx+3 > len || !is_continuation(buf[idx+1]) || !is_continuation(buf[idx+2]) || !is_continuation(buf[idx+3]))) {\n-    if (idx+2 > len && partial) { idx = len; return; }\n+    if (idx+2 > len && is_streaming(partial)) { idx = len; return; }\n     error = UTF8_ERROR;\n     idx++;\n     return;\n@@ -147,24 +147,56 @@ simdjson_really_inline error_code scan() {\n         break;\n     }\n   }\n-  *next_structural_index = len;\n   // We pad beyond.\n   // https://github.com/simdjson/simdjson/issues/906\n+  // See json_structural_indexer.h for an explanation.\n+  *next_structural_index = len; // assumed later in partial == stage1_mode::streaming_final\n   next_structural_index[1] = len;\n   next_structural_index[2] = 0;\n   parser.n_structural_indexes = uint32_t(next_structural_index - parser.structural_indexes.get());\n   if (simdjson_unlikely(parser.n_structural_indexes == 0)) { return EMPTY; }\n   parser.next_structural_index = 0;\n-  if (partial) {\n+  if (partial == stage1_mode::streaming_partial) {\n     if(unclosed_string) {\n       parser.n_structural_indexes--;\n       if (simdjson_unlikely(parser.n_structural_indexes == 0)) { return CAPACITY; }\n     }\n+    // We truncate the input to the end of the last complete document (or zero).\n     auto new_structural_indexes = find_next_document_index(parser);\n     if (new_structural_indexes == 0 && parser.n_structural_indexes > 0) {\n-      return CAPACITY; // If the buffer is partial but the document is incomplete, it's too big to parse.\n+      if(parser.structural_indexes[0] == 0) {\n+        // If the buffer is partial and we started at index 0 but the document is\n+        // incomplete, it's too big to parse.\n+        return CAPACITY;\n+      } else {\n+        // It is possible that the document could be parsed, we just had a lot\n+        // of white space.\n+        parser.n_structural_indexes = 0;\n+        return EMPTY;\n+      }\n     }\n     parser.n_structural_indexes = new_structural_indexes;\n+  } else if(partial == stage1_mode::streaming_final) {\n+    if(unclosed_string) { parser.n_structural_indexes--; }\n+    // We truncate the input to the end of the last complete document (or zero).\n+    // Because partial == stage1_mode::streaming_final, it means that we may\n+    // silently ignore trailing garbage. Though it sounds bad, we do it\n+    // deliberately because many people who have streams of JSON documents\n+    // will truncate them for processing. E.g., imagine that you are uncompressing\n+    // the data from a size file or receiving it in chunks from the network. You\n+    // may not know where exactly the last document will be. Meanwhile the\n+    // document_stream instances allow people to know the JSON documents they are\n+    // parsing (see the iterator.source() method).\n+    parser.n_structural_indexes = find_next_document_index(parser);\n+    // We store the initial n_structural_indexes so that the client can see\n+    // whether we used truncation. If initial_n_structural_indexes == parser.n_structural_indexes,\n+    // then this will query parser.structural_indexes[parser.n_structural_indexes] which is len,\n+    // otherwise, it will copy some prior index.\n+    parser.structural_indexes[parser.n_structural_indexes + 1] = parser.structural_indexes[parser.n_structural_indexes];\n+    // This next line is critical, do not change it unless you understand what you are\n+    // doing.\n+    parser.structural_indexes[parser.n_structural_indexes] = uint32_t(len);\n+    if (parser.n_structural_indexes == 0) { return EMPTY; }\n   } else if(unclosed_string) { error = UNCLOSED_STRING; }\n   return error;\n }\n@@ -176,13 +208,13 @@ simdjson_really_inline error_code scan() {\n   uint32_t len;\n   uint32_t idx{0};\n   error_code error{SUCCESS};\n-  bool partial;\n+  stage1_mode partial;\n }; // structural_scanner\n \n } // namespace stage1\n } // unnamed namespace\n \n-simdjson_warn_unused error_code dom_parser_implementation::stage1(const uint8_t *_buf, size_t _len, bool partial) noexcept {\n+simdjson_warn_unused error_code dom_parser_implementation::stage1(const uint8_t *_buf, size_t _len, stage1_mode partial) noexcept {\n   this->buf = _buf;\n   this->len = _len;\n   stage1::structural_scanner scanner(*this, partial);\n@@ -328,7 +360,7 @@ simdjson_warn_unused error_code dom_parser_implementation::stage2_next(dom::docu\n }\n \n simdjson_warn_unused error_code dom_parser_implementation::parse(const uint8_t *_buf, size_t _len, dom::document &_doc) noexcept {\n-  auto error = stage1(_buf, _len, false);\n+  auto error = stage1(_buf, _len, stage1_mode::regular);\n   if (error) { return error; }\n   return stage2(_doc);\n }\n--- vendor/simdjson/src/fallback/implementation.cpp\n@@ -10,12 +10,14 @@ simdjson_warn_unused error_code implementation::create_dom_parser_implementation\n ) const noexcept {\n   dst.reset( new (std::nothrow) dom_parser_implementation() );\n   if (!dst) { return MEMALLOC; }\n-  dst->set_capacity(capacity);\n-  dst->set_max_depth(max_depth);\n+  if (auto err = dst->set_capacity(capacity))\n+    return err;\n+  if (auto err = dst->set_max_depth(max_depth))\n+    return err;\n   return SUCCESS;\n }\n \n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n \n-#include \"simdjson/fallback/end.h\"\n\\ No newline at end of file\n+#include \"simdjson/fallback/end.h\"\n--- vendor/simdjson/src/from_chars.cpp\n@@ -134,6 +134,86 @@ decimal parse_decimal(const char *&p) noexcept {\n   return answer;\n }\n \n+// This should always succeed since it follows a call to parse_number.\n+// Will not read at or beyond the \"end\" pointer.\n+decimal parse_decimal(const char *&p, const char * end) noexcept {\n+  decimal answer;\n+  answer.num_digits = 0;\n+  answer.decimal_point = 0;\n+  answer.truncated = false;\n+  if(p == end) { return answer; } // should never happen\n+  answer.negative = (*p == '-');\n+  if ((*p == '-') || (*p == '+')) {\n+    ++p;\n+  }\n+\n+  while ((p != end) && (*p == '0')) {\n+    ++p;\n+  }\n+  while ((p != end) && is_integer(*p)) {\n+    if (answer.num_digits < max_digits) {\n+      answer.digits[answer.num_digits] = uint8_t(*p - '0');\n+    }\n+    answer.num_digits++;\n+    ++p;\n+  }\n+  if ((p != end) && (*p == '.')) {\n+    ++p;\n+    if(p == end) { return answer; } // should never happen\n+    const char *first_after_period = p;\n+    // if we have not yet encountered a zero, we have to skip it as well\n+    if (answer.num_digits == 0) {\n+      // skip zeros\n+      while (*p == '0') {\n+        ++p;\n+      }\n+    }\n+    while ((p != end) && is_integer(*p)) {\n+      if (answer.num_digits < max_digits) {\n+        answer.digits[answer.num_digits] = uint8_t(*p - '0');\n+      }\n+      answer.num_digits++;\n+      ++p;\n+    }\n+    answer.decimal_point = int32_t(first_after_period - p);\n+  }\n+  if(answer.num_digits > 0) {\n+    const char *preverse = p - 1;\n+    int32_t trailing_zeros = 0;\n+    while ((*preverse == '0') || (*preverse == '.')) {\n+      if(*preverse == '0') { trailing_zeros++; };\n+      --preverse;\n+    }\n+    answer.decimal_point += int32_t(answer.num_digits);\n+    answer.num_digits -= uint32_t(trailing_zeros);\n+  }\n+  if(answer.num_digits > max_digits ) {\n+    answer.num_digits = max_digits;\n+    answer.truncated = true;\n+  }\n+  if ((p != end) && (('e' == *p) || ('E' == *p))) {\n+    ++p;\n+    if(p == end) { return answer; } // should never happen\n+    bool neg_exp = false;\n+    if ('-' == *p) {\n+      neg_exp = true;\n+      ++p;\n+    } else if ('+' == *p) {\n+      ++p;\n+    }\n+    int32_t exp_number = 0; // exponential part\n+    while ((p != end) && is_integer(*p)) {\n+      uint8_t digit = uint8_t(*p - '0');\n+      if (exp_number < 0x10000) {\n+        exp_number = 10 * exp_number + digit;\n+      }\n+      ++p;\n+    }\n+    answer.decimal_point += (neg_exp ? -exp_number : exp_number);\n+  }\n+  return answer;\n+}\n+\n namespace {\n \n // remove all final zeroes\n@@ -473,6 +553,12 @@ adjusted_mantissa parse_long_mantissa(const char *first) {\n   return compute_float<binary>(d);\n }\n \n+template <typename binary>\n+adjusted_mantissa parse_long_mantissa(const char *first, const char *end) {\n+  decimal d = parse_decimal(first, end);\n+  return compute_float<binary>(d);\n+}\n+\n double from_chars(const char *first) noexcept {\n   bool negative = first[0] == '-';\n   if (negative) {\n@@ -489,5 +575,22 @@ double from_chars(const char *first) noexcept {\n   return value;\n }\n \n+\n+double from_chars(const char *first, const char *end) noexcept {\n+  bool negative = first[0] == '-';\n+  if (negative) {\n+    first++;\n+  }\n+  adjusted_mantissa am = parse_long_mantissa<binary_format<double>>(first, end);\n+  uint64_t word = am.mantissa;\n+  word |= uint64_t(am.power2)\n+          << binary_format<double>::mantissa_explicit_bits();\n+  word = negative ? word | (uint64_t(1) << binary_format<double>::sign_index())\n+                  : word;\n+  double value;\n+  std::memcpy(&value, &word, sizeof(double));\n+  return value;\n+}\n+\n } // internal\n } // simdjson\n\\ No newline at end of file\n--- vendor/simdjson/src/generic/stage1/find_next_document_index.h\n@@ -13,8 +13,8 @@ namespace {\n   *\n   * Simply put, we iterate over the structural characters, starting from\n   * the end. We consider that we found the end of a JSON document when the\n-  * first element of the pair is NOT one of these characters: '{' '[' ';' ','\n-  * and when the second element is NOT one of these characters: '}' '}' ';' ','.\n+  * first element of the pair is NOT one of these characters: '{' '[' ':' ','\n+  * and when the second element is NOT one of these characters: '}' ']' ':' ','.\n   *\n   * This simple comparison works most of the time, but it does not cover cases\n   * where the batch's structural indexes contain a perfect amount of documents.\n@@ -28,7 +28,8 @@ namespace {\n   * batch.\n   */\n simdjson_really_inline uint32_t find_next_document_index(dom_parser_implementation &parser) {\n-  // TODO don't count separately, just figure out depth\n+  // Variant: do not count separately, just figure out depth\n+  if(parser.n_structural_indexes == 0) { return 0; }\n   auto arr_cnt = 0;\n   auto obj_cnt = 0;\n   for (auto i = parser.n_structural_indexes - 1; i > 0; i--) {\n@@ -65,6 +66,25 @@ simdjson_really_inline uint32_t find_next_document_index(dom_parser_implementati\n     // Last document is incomplete; mark the document at i + 1 as the next one\n     return i;\n   }\n+  // If we made it to the end, we want to finish counting to see if we have a full document.\n+  switch (parser.buf[parser.structural_indexes[0]]) {\n+    case '}':\n+      obj_cnt--;\n+      break;\n+    case ']':\n+      arr_cnt--;\n+      break;\n+    case '{':\n+      obj_cnt++;\n+      break;\n+    case '[':\n+      arr_cnt++;\n+      break;\n+  }\n+  if (!arr_cnt && !obj_cnt) {\n+    // We have a complete document.\n+    return parser.n_structural_indexes;\n+  }\n   return 0;\n }\n \n--- vendor/simdjson/src/generic/stage1/json_minifier.h\n@@ -27,8 +27,7 @@ class json_minifier {\n \n simdjson_really_inline void json_minifier::next(const simd::simd8x64<uint8_t>& in, const json_block& block) {\n   uint64_t mask = block.whitespace();\n-  in.compress(mask, dst);\n-  dst += 64 - count_ones(mask);\n+  dst += in.compress(mask, dst);\n }\n \n simdjson_really_inline error_code json_minifier::finish(uint8_t *dst_start, size_t &dst_len) {\n--- vendor/simdjson/src/generic/stage1/json_structural_indexer.h\n@@ -31,8 +31,62 @@ class bit_indexer {\n     // it helps tremendously.\n     if (bits == 0)\n         return;\n+#if defined(SIMDJSON_PREFER_REVERSE_BITS)\n+    /**\n+     * ARM lacks a fast trailing zero instruction, but it has a fast\n+     * bit reversal instruction and a fast leading zero instruction.\n+     * Thus it may be profitable to reverse the bits (once) and then\n+     * to rely on a sequence of instructions that call the leading\n+     * zero instruction.\n+     *\n+     * Performance notes:\n+     * The chosen routine is not optimal in terms of data dependency\n+     * since zero_leading_bit might require two instructions. However,\n+     * it tends to minimize the total number of instructions which is\n+     * beneficial.\n+     */\n+\n+    uint64_t rev_bits = reverse_bits(bits);\n     int cnt = static_cast<int>(count_ones(bits));\n+    int i = 0;\n+    // Do the first 8 all together\n+    for (; i<8; i++) {\n+      int lz = leading_zeroes(rev_bits);\n+      this->tail[i] = static_cast<uint32_t>(idx) + lz;\n+      rev_bits = zero_leading_bit(rev_bits, lz);\n+    }\n+    // Do the next 8 all together (we hope in most cases it won't happen at all\n+    // and the branch is easily predicted).\n+    if (simdjson_unlikely(cnt > 8)) {\n+      i = 8;\n+      for (; i<16; i++) {\n+        int lz = leading_zeroes(rev_bits);\n+        this->tail[i] = static_cast<uint32_t>(idx) + lz;\n+        rev_bits = zero_leading_bit(rev_bits, lz);\n+      }\n+\n+\n+      // Most files don't have 16+ structurals per block, so we take several basically guaranteed\n+      // branch mispredictions here. 16+ structurals per block means either punctuation ({} [] , :)\n+      // or the start of a value (\"abc\" true 123) every four characters.\n+      if (simdjson_unlikely(cnt > 16)) {\n+        i = 16;\n+        while (rev_bits != 0) {\n+          int lz = leading_zeroes(rev_bits);\n+          this->tail[i++] = static_cast<uint32_t>(idx) + lz;\n+          rev_bits = zero_leading_bit(rev_bits, lz);\n+        }\n+      }\n+    }\n+    this->tail += cnt;\n+#else // SIMDJSON_PREFER_REVERSE_BITS\n+    /**\n+     * Under recent x64 systems, we often have both a fast trailing zero\n+     * instruction and a fast 'clear-lower-bit' instruction so the following\n+     * algorithm can be competitive.\n+     */\n \n+    int cnt = static_cast<int>(count_ones(bits));\n     // Do the first 8 all together\n     for (int i=0; i<8; i++) {\n       this->tail[i] = idx + trailing_zeroes(bits);\n@@ -61,6 +115,7 @@ class bit_indexer {\n     }\n \n     this->tail += cnt;\n+#endif\n   }\n };\n \n@@ -74,14 +129,14 @@ class json_structural_indexer {\n    *   you are processing substrings, you may want to call on a function like trimmed_length_safe_utf8.\n    */\n   template<size_t STEP_SIZE>\n-  static error_code index(const uint8_t *buf, size_t len, dom_parser_implementation &parser, bool partial) noexcept;\n+  static error_code index(const uint8_t *buf, size_t len, dom_parser_implementation &parser, stage1_mode partial) noexcept;\n \n private:\n   simdjson_really_inline json_structural_indexer(uint32_t *structural_indexes);\n   template<size_t STEP_SIZE>\n   simdjson_really_inline void step(const uint8_t *block, buf_block_reader<STEP_SIZE> &reader) noexcept;\n   simdjson_really_inline void next(const simd::simd8x64<uint8_t>& in, const json_block& block, size_t idx);\n-  simdjson_really_inline error_code finish(dom_parser_implementation &parser, size_t idx, size_t len, bool partial);\n+  simdjson_really_inline error_code finish(dom_parser_implementation &parser, size_t idx, size_t len, stage1_mode partial);\n \n   json_scanner scanner{};\n   utf8_checker checker{};\n@@ -131,23 +186,29 @@ simdjson_really_inline size_t trim_partial_utf8(const uint8_t *buf, size_t len)\n // workout.\n //\n template<size_t STEP_SIZE>\n-error_code json_structural_indexer::index(const uint8_t *buf, size_t len, dom_parser_implementation &parser, bool partial) noexcept {\n+error_code json_structural_indexer::index(const uint8_t *buf, size_t len, dom_parser_implementation &parser, stage1_mode partial) noexcept {\n   if (simdjson_unlikely(len > parser.capacity())) { return CAPACITY; }\n-  if (partial) { len = trim_partial_utf8(buf, len); }\n-\n+  // We guard the rest of the code so that we can assume that len > 0 throughout.\n+  if (len == 0) { return EMPTY; }\n+  if (is_streaming(partial)) {\n+    len = trim_partial_utf8(buf, len);\n+    // If you end up with an empty window after trimming\n+    // the partial UTF-8 bytes, then chances are good that you\n+    // have an UTF-8 formatting error.\n+    if(len == 0) { return UTF8_ERROR; }\n+  }\n   buf_block_reader<STEP_SIZE> reader(buf, len);\n   json_structural_indexer indexer(parser.structural_indexes.get());\n \n   // Read all but the last block\n   while (reader.has_full_block()) {\n     indexer.step<STEP_SIZE>(reader.full_block(), reader);\n   }\n-\n-  // Take care of the last block (will always be there unless file is empty)\n+  // Take care of the last block (will always be there unless file is empty which is\n+  // not supposed to happen.)\n   uint8_t block[STEP_SIZE];\n-  if (simdjson_unlikely(reader.get_remainder(block) == 0)) { return EMPTY; }\n+  if (simdjson_unlikely(reader.get_remainder(block) == 0)) { return UNEXPECTED_ERROR; }\n   indexer.step<STEP_SIZE>(block, reader);\n-\n   return indexer.finish(parser, reader.block_index(), len, partial);\n }\n \n@@ -178,14 +239,13 @@ simdjson_really_inline void json_structural_indexer::next(const simd::simd8x64<u\n   unescaped_chars_error |= block.non_quote_inside_string(unescaped);\n }\n \n-simdjson_really_inline error_code json_structural_indexer::finish(dom_parser_implementation &parser, size_t idx, size_t len, bool partial) {\n+simdjson_really_inline error_code json_structural_indexer::finish(dom_parser_implementation &parser, size_t idx, size_t len, stage1_mode partial) {\n   // Write out the final iteration's structurals\n   indexer.write(uint32_t(idx-64), prev_structurals);\n-\n   error_code error = scanner.finish();\n   // We deliberately break down the next expression so that it is\n   // human readable.\n-  const bool should_we_exit =  partial ?\n+  const bool should_we_exit = is_streaming(partial) ?\n     ((error != SUCCESS) && (error != UNCLOSED_STRING)) // when partial we tolerate UNCLOSED_STRING\n     : (error != SUCCESS); // if partial is false, we must have SUCCESS\n   const bool have_unclosed_string = (error == UNCLOSED_STRING);\n@@ -194,9 +254,10 @@ simdjson_really_inline error_code json_structural_indexer::finish(dom_parser_imp\n   if (unescaped_chars_error) {\n     return UNESCAPED_CHARS;\n   }\n-\n   parser.n_structural_indexes = uint32_t(indexer.tail - parser.structural_indexes.get());\n   /***\n+   * The On Demand API requires special padding.\n+   *\n    * This is related to https://github.com/simdjson/simdjson/issues/906\n    * Basically, we want to make sure that if the parsing continues beyond the last (valid)\n    * structural character, it quickly stops.\n@@ -209,8 +270,11 @@ simdjson_really_inline error_code json_structural_indexer::finish(dom_parser_imp\n    * if the repeated character is [. But if so, the document must start with [. But if the document\n    * starts with [, it should end with ]. If we enforce that rule, then we would get\n    * ][[ which is invalid.\n+   *\n+   * This is illustrated with the test array_iterate_unclosed_error() on the following input:\n+   * R\"({ \"a\": [,,)\"\n    **/\n-  parser.structural_indexes[parser.n_structural_indexes] = uint32_t(len);\n+  parser.structural_indexes[parser.n_structural_indexes] = uint32_t(len); // used later in partial == stage1_mode::streaming_final\n   parser.structural_indexes[parser.n_structural_indexes + 1] = uint32_t(len);\n   parser.structural_indexes[parser.n_structural_indexes + 2] = 0;\n   parser.next_structural_index = 0;\n@@ -221,19 +285,56 @@ simdjson_really_inline error_code json_structural_indexer::finish(dom_parser_imp\n   if (simdjson_unlikely(parser.structural_indexes[parser.n_structural_indexes - 1] > len)) {\n     return UNEXPECTED_ERROR;\n   }\n-  if (partial) {\n+  if (partial == stage1_mode::streaming_partial) {\n     // If we have an unclosed string, then the last structural\n     // will be the quote and we want to make sure to omit it.\n     if(have_unclosed_string) {\n       parser.n_structural_indexes--;\n       // a valid JSON file cannot have zero structural indexes - we should have found something\n       if (simdjson_unlikely(parser.n_structural_indexes == 0u)) { return CAPACITY; }\n     }\n+    // We truncate the input to the end of the last complete document (or zero).\n     auto new_structural_indexes = find_next_document_index(parser);\n     if (new_structural_indexes == 0 && parser.n_structural_indexes > 0) {\n-      return CAPACITY; // If the buffer is partial but the document is incomplete, it's too big to parse.\n+      if(parser.structural_indexes[0] == 0) {\n+        // If the buffer is partial and we started at index 0 but the document is\n+        // incomplete, it's too big to parse.\n+        return CAPACITY;\n+      } else {\n+        // It is possible that the document could be parsed, we just had a lot\n+        // of white space.\n+        parser.n_structural_indexes = 0;\n+        return EMPTY;\n+      }\n     }\n+\n     parser.n_structural_indexes = new_structural_indexes;\n+  } else if (partial == stage1_mode::streaming_final) {\n+    if(have_unclosed_string) { parser.n_structural_indexes--; }\n+    // We truncate the input to the end of the last complete document (or zero).\n+    // Because partial == stage1_mode::streaming_final, it means that we may\n+    // silently ignore trailing garbage. Though it sounds bad, we do it\n+    // deliberately because many people who have streams of JSON documents\n+    // will truncate them for processing. E.g., imagine that you are uncompressing\n+    // the data from a size file or receiving it in chunks from the network. You\n+    // may not know where exactly the last document will be. Meanwhile the\n+    // document_stream instances allow people to know the JSON documents they are\n+    // parsing (see the iterator.source() method).\n+    parser.n_structural_indexes = find_next_document_index(parser);\n+    // We store the initial n_structural_indexes so that the client can see\n+    // whether we used truncation. If initial_n_structural_indexes == parser.n_structural_indexes,\n+    // then this will query parser.structural_indexes[parser.n_structural_indexes] which is len,\n+    // otherwise, it will copy some prior index.\n+    parser.structural_indexes[parser.n_structural_indexes + 1] = parser.structural_indexes[parser.n_structural_indexes];\n+    // This next line is critical, do not change it unless you understand what you are\n+    // doing.\n+    parser.structural_indexes[parser.n_structural_indexes] = uint32_t(len);\n+    if (simdjson_unlikely(parser.n_structural_indexes == 0u)) {\n+        // We tolerate an unclosed string at the very end of the stream. Indeed, users\n+        // often load their data in bulk without being careful and they want us to ignore\n+        // the trailing garbage.\n+        return EMPTY;\n+    }\n   }\n   checker.check_eof();\n   return checker.errors();\n--- vendor/simdjson/src/generic/stage1/utf8_lookup4_algorithm.h\n@@ -167,7 +167,6 @@ using namespace simd;\n         }\n         this->prev_incomplete = is_incomplete(input.chunks[simd8x64<uint8_t>::NUM_CHUNKS-1]);\n         this->prev_input_block = input.chunks[simd8x64<uint8_t>::NUM_CHUNKS-1];\n-\n       }\n     }\n     // do not forget to call check_eof!\n--- vendor/simdjson/src/generic/stage2/json_iterator.h\n@@ -125,12 +125,12 @@ simdjson_warn_unused simdjson_really_inline error_code json_iterator::walk_docum\n   {\n     auto value = advance();\n \n-    // Make sure the outer hash or array is closed before continuing; otherwise, there are ways we\n+    // Make sure the outer object or array is closed before continuing; otherwise, there are ways we\n     // could get into memory corruption. See https://github.com/simdjson/simdjson/issues/906\n     if (!STREAMING) {\n       switch (*value) {\n-        case '{': if (last_structural() != '}') { return TAPE_ERROR; }; break;\n-        case '[': if (last_structural() != ']') { return TAPE_ERROR; }; break;\n+        case '{': if (last_structural() != '}') { log_value(\"starting brace unmatched\"); return TAPE_ERROR; }; break;\n+        case '[': if (last_structural() != ']') { log_value(\"starting bracket unmatched\"); return TAPE_ERROR; }; break;\n       }\n     }\n \n--- vendor/simdjson/src/haswell/dom_parser_implementation.cpp\n@@ -134,7 +134,7 @@ simdjson_warn_unused error_code implementation::minify(const uint8_t *buf, size_\n   return haswell::stage1::json_minifier::minify<128>(buf, len, dst, dst_len);\n }\n \n-simdjson_warn_unused error_code dom_parser_implementation::stage1(const uint8_t *_buf, size_t _len, bool streaming) noexcept {\n+simdjson_warn_unused error_code dom_parser_implementation::stage1(const uint8_t *_buf, size_t _len, stage1_mode streaming) noexcept {\n   this->buf = _buf;\n   this->len = _len;\n   return haswell::stage1::json_structural_indexer::index<128>(_buf, _len, *this, streaming);\n@@ -153,7 +153,7 @@ simdjson_warn_unused error_code dom_parser_implementation::stage2_next(dom::docu\n }\n \n simdjson_warn_unused error_code dom_parser_implementation::parse(const uint8_t *_buf, size_t _len, dom::document &_doc) noexcept {\n-  auto error = stage1(_buf, _len, false);\n+  auto error = stage1(_buf, _len, stage1_mode::regular);\n   if (error) { return error; }\n   return stage2(_doc);\n }\n--- vendor/simdjson/src/haswell/implementation.cpp\n@@ -10,8 +10,10 @@ simdjson_warn_unused error_code implementation::create_dom_parser_implementation\n ) const noexcept {\n   dst.reset( new (std::nothrow) dom_parser_implementation() );\n   if (!dst) { return MEMALLOC; }\n-  dst->set_capacity(capacity);\n-  dst->set_max_depth(max_depth);\n+  if (auto err = dst->set_capacity(capacity))\n+    return err;\n+  if (auto err = dst->set_max_depth(max_depth))\n+    return err;\n   return SUCCESS;\n }\n \n--- vendor/simdjson/src/internal/error_tables.cpp\n@@ -30,7 +30,10 @@ namespace internal {\n     { UNEXPECTED_ERROR, \"Unexpected error, consider reporting this problem as you may have found a bug in simdjson\" },\n     { PARSER_IN_USE, \"Cannot parse a new document while a document is still in use.\" },\n     { OUT_OF_ORDER_ITERATION, \"Objects and arrays can only be iterated when they are first encountered.\" },\n-    { INSUFFICIENT_PADDING, \"simdjson requires the input JSON string to have at least SIMDJSON_PADDING extra bytes allocated, beyond the string's length.\" }\n+    { INSUFFICIENT_PADDING, \"simdjson requires the input JSON string to have at least SIMDJSON_PADDING extra bytes allocated, beyond the string's length. Consider using the simdjson::padded_string class if needed.\" },\n+    { INCOMPLETE_ARRAY_OR_OBJECT, \"JSON document ended early in the middle of an object or array.\" },\n+    { SCALAR_DOCUMENT_AS_VALUE, \"A JSON document made of a scalar (number, Boolean, null or string) is treated as a value. Use get_bool(), get_double(), etc. on the document instead. \"},\n+    { OUT_OF_BOUNDS, \"Attempted to access location outside of document.\"}\n   }; // error_messages[]\n \n } // namespace internal\n--- vendor/simdjson/src/ppc64/dom_parser_implementation.cpp\n@@ -104,7 +104,7 @@ simdjson_warn_unused error_code implementation::minify(const uint8_t *buf, size_\n   return ppc64::stage1::json_minifier::minify<64>(buf, len, dst, dst_len);\n }\n \n-simdjson_warn_unused error_code dom_parser_implementation::stage1(const uint8_t *_buf, size_t _len, bool streaming) noexcept {\n+simdjson_warn_unused error_code dom_parser_implementation::stage1(const uint8_t *_buf, size_t _len, stage1_mode streaming) noexcept {\n   this->buf = _buf;\n   this->len = _len;\n   return ppc64::stage1::json_structural_indexer::index<64>(buf, len, *this, streaming);\n@@ -123,7 +123,7 @@ simdjson_warn_unused error_code dom_parser_implementation::stage2_next(dom::docu\n }\n \n simdjson_warn_unused error_code dom_parser_implementation::parse(const uint8_t *_buf, size_t _len, dom::document &_doc) noexcept {\n-  auto error = stage1(_buf, _len, false);\n+  auto error = stage1(_buf, _len, stage1_mode::regular);\n   if (error) { return error; }\n   return stage2(_doc);\n }\n--- vendor/simdjson/src/ppc64/implementation.cpp\n@@ -10,12 +10,14 @@ simdjson_warn_unused error_code implementation::create_dom_parser_implementation\n ) const noexcept {\n   dst.reset( new (std::nothrow) dom_parser_implementation() );\n   if (!dst) { return MEMALLOC; }\n-  dst->set_capacity(capacity);\n-  dst->set_max_depth(max_depth);\n+  if (auto err = dst->set_capacity(capacity))\n+    return err;\n+  if (auto err = dst->set_max_depth(max_depth))\n+    return err;\n   return SUCCESS;\n }\n \n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n \n-#include \"simdjson/ppc64/end.h\"\n\\ No newline at end of file\n+#include \"simdjson/ppc64/end.h\"\n--- vendor/simdjson/src/to_chars.cpp\n@@ -1,6 +1,8 @@\n #include <cstring>\n #include <cstdint>\n #include <array>\n+#include <cmath>\n+\n namespace simdjson {\n namespace internal {\n /*!\n@@ -858,9 +860,9 @@ inline char *format_buffer(char *buf, int len, int decimal_exponent,\n \n     std::memset(buf + k, '0', static_cast<size_t>(n) - static_cast<size_t>(k));\n     // Make it look like a floating-point number (#362, #378)\n-    buf[n + 0] = '.';\n-    buf[n + 1] = '0';\n-    return buf + (static_cast<size_t>(n) + 2);\n+    // buf[n + 0] = '.';\n+    // buf[n + 1] = '0';\n+    return buf + (static_cast<size_t>(n));\n   }\n \n   if (0 < n && n <= max_exp) {\n@@ -913,7 +915,8 @@ format. Returns an iterator pointing past-the-end of the decimal representation.\n */\n char *to_chars(char *first, const char *last, double value) {\n   static_cast<void>(last); // maybe unused - fix warning\n-  if (value <= -0) {\n+  bool negative = std::signbit(value);\n+  if (negative) {\n     value = -value;\n     *first++ = '-';\n   }\n@@ -922,8 +925,10 @@ char *to_chars(char *first, const char *last, double value) {\n   {\n     *first++ = '0';\n     // Make it look like a floating-point number (#362, #378)\n-    *first++ = '.';\n-    *first++ = '0';\n+    if(negative) {\n+      *first++ = '.';\n+      *first++ = '0';\n+    }\n     return first;\n   }\n   // Compute v = buffer * 10^decimal_exponent.\n--- vendor/simdjson/src/westmere/dom_parser_implementation.cpp\n@@ -133,7 +133,7 @@ simdjson_warn_unused error_code implementation::minify(const uint8_t *buf, size_\n   return westmere::stage1::json_minifier::minify<64>(buf, len, dst, dst_len);\n }\n \n-simdjson_warn_unused error_code dom_parser_implementation::stage1(const uint8_t *_buf, size_t _len, bool streaming) noexcept {\n+simdjson_warn_unused error_code dom_parser_implementation::stage1(const uint8_t *_buf, size_t _len, stage1_mode streaming) noexcept {\n   this->buf = _buf;\n   this->len = _len;\n   return westmere::stage1::json_structural_indexer::index<64>(_buf, _len, *this, streaming);\n@@ -152,7 +152,7 @@ simdjson_warn_unused error_code dom_parser_implementation::stage2_next(dom::docu\n }\n \n simdjson_warn_unused error_code dom_parser_implementation::parse(const uint8_t *_buf, size_t _len, dom::document &_doc) noexcept {\n-  auto error = stage1(_buf, _len, false);\n+  auto error = stage1(_buf, _len, stage1_mode::regular);\n   if (error) { return error; }\n   return stage2(_doc);\n }\n--- vendor/simdjson/src/westmere/implementation.cpp\n@@ -10,12 +10,14 @@ simdjson_warn_unused error_code implementation::create_dom_parser_implementation\n ) const noexcept {\n   dst.reset( new (std::nothrow) dom_parser_implementation() );\n   if (!dst) { return MEMALLOC; }\n-  dst->set_capacity(capacity);\n-  dst->set_max_depth(max_depth);\n+  if (auto err = dst->set_capacity(capacity))\n+    return err;\n+  if (auto err = dst->set_max_depth(max_depth))\n+    return err;\n   return SUCCESS;\n }\n \n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n \n-#include \"simdjson/westmere/end.h\"\n\\ No newline at end of file\n+#include \"simdjson/westmere/end.h\"\n--- vendor/simdjson/tools/CMakeLists.txt\n@@ -1,10 +1,13 @@\n if(TARGET cxxopts) # we only build the tools if cxxopts is available\n-  message(STATUS \"We have cxxopts as a dependency and we are buiding the tools (e.g., json2json).\")\n-  link_libraries(simdjson simdjson-internal-flags simdjson-windows-headers cxxopts)\n-  add_executable(json2json json2json.cpp)\n-  add_executable(jsonstats jsonstats.cpp)\n-  add_executable(jsonpointer jsonpointer.cpp)\n-  add_executable(minify minify.cpp)\n+  message(STATUS \"We have cxxopts as a dependency and we are building the tools (e.g., json2json).\")\n+  foreach(tool IN ITEMS json2json jsonstats jsonpointer minify)\n+    add_executable(\"${tool}\" \"${tool}.cpp\")\n+    simdjson_apply_props(\"${tool}\")\n+    target_link_libraries(\n+        \"${tool}\" PRIVATE\n+        simdjson simdjson-internal-flags simdjson-windows-headers cxxopts\n+    )\n+  endforeach()\n else()\n   message(STATUS \"We are missing cxxopts as a dependency so the tools (e.g., json2json) are omitted.\")\n-endif()\n\\ No newline at end of file\n+endif()\n--- vendor/simdjson/tools/json2json.cpp\n@@ -31,6 +31,7 @@ int main(int argc, const char *argv[]) {\n   cxxopts::Options options(progName, progUsage);\n \n   options.add_options()\n+    (\"z,ondemand\", \"Use On Demand front-end.\", cxxopts::value<bool>()->default_value(\"false\"))\n   \t(\"d,rawdump\", \"Dumps the raw content of the tape.\", cxxopts::value<bool>()->default_value(\"false\"))\n   \t(\"f,file\", \"File name.\", cxxopts::value<std::string>())\n   \t(\"h,help\", \"Print usage.\")\n@@ -44,7 +45,7 @@ int main(int argc, const char *argv[]) {\n   \tstd::cerr << options.help() << std::endl;\n   \treturn EXIT_SUCCESS;\n   }\n-\n+  bool ondemand = result[\"ondemand\"].as<bool>();\n   bool rawdump = result[\"rawdump\"].as<bool>();\n \n   if(!result.count(\"file\")) {\n@@ -54,7 +55,17 @@ int main(int argc, const char *argv[]) {\n   }\n \n   const char *filename = result[\"file\"].as<std::string>().c_str();\n-\n+  if(ondemand) {\n+    simdjson::ondemand::parser parser;\n+    simdjson::padded_string docdata;\n+    auto error = simdjson::padded_string::load(filename).get(docdata);\n+    if(error != simdjson::SUCCESS) { std::cout << error << std::endl; return EXIT_FAILURE; }\n+    simdjson::ondemand::document doc;\n+    error = parser.iterate(docdata).get(doc);\n+    if(error != simdjson::SUCCESS) { std::cout << error << std::endl; return EXIT_FAILURE; }\n+    std::cout << doc;\n+    return EXIT_SUCCESS;\n+  }\n   simdjson::dom::parser parser;\n   simdjson::dom::element doc;\n   auto error = parser.load(filename).get(doc); // do the parsing, return false on error\n--- vendor/simdjson/tools/release.py\n@@ -145,11 +145,8 @@ def topaddedversionstring(major, minor, rev):\n     sonumber += 1\n \n for line in fileinput.input(cmakefile, inplace=1, backup='.bak'):\n-    line = re.sub('SIMDJSON_SEMANTIC_VERSION \"\\d+\\.\\d+\\.\\d+','SIMDJSON_SEMANTIC_VERSION \"'+newversionstring, line.rstrip())\n+    line = re.sub('    VERSION \\d+\\.\\d+\\.\\d+','    VERSION '+newmajorversionstring+'.'+mewminorversionstring+'.'+newrevversionstring, line.rstrip())\n     line = re.sub('SIMDJSON_LIB_VERSION \"\\d+','SIMDJSON_LIB_VERSION \"'+str(sonumber), line)\n-    line = re.sub('set\\(PROJECT_VERSION_MAJOR \\d+','set(PROJECT_VERSION_MAJOR '+newmajorversionstring, line)\n-    line = re.sub('set\\(PROJECT_VERSION_MINOR \\d+','set(PROJECT_VERSION_MINOR '+mewminorversionstring, line)\n-    line = re.sub('set\\(PROJECT_VERSION_PATCH \\d+','set(PROJECT_VERSION_PATCH '+newrevversionstring, line)\n     line = re.sub('set\\(SIMDJSON_LIB_SOVERSION \\\"\\d+\\\"','set(SIMDJSON_LIB_SOVERSION \\\"'+str(sonumber)+'\\\"', line)\n     print(line)\n \n--- vendor/simdjson/windows/getopt.h\n@@ -112,13 +112,8 @@ char    *optarg;\t\t/* argument associated with option */\n extern char __declspec(dllimport) *__progname;\n #endif\n \n-// D. Lemire (April 2020): adding __clang__\n-// D. Lemire (June 2020): adding __MINGW32__ and __MINGW64__\n-#if defined(__CYGWIN__) || defined(__clang__) || defined(__MINGW32__) || defined(__MINGW64__)\n+// next line modified D. Lemire (last modified on June 1st 2021)\n static char EMSG[] = \"\";\n-#else\n-#define\tEMSG\t\t\"\"\n-#endif\n \n static int getopt_internal(int, char * const *, const char *,\n \t\t\t   const struct option *, int *, int);"
    ],
    "files_changed": [
      {
        "filename": "vendor/README.txt",
        "status": "modified",
        "additions": 8,
        "deletions": 10,
        "changes": 18,
        "patch": "@@ -169,17 +169,15 @@ consumption:\n The following patches have been manually applied:\n \n * simdjson-cmake-version.patch\n-* simdjson-iostream.patch\n-* simdjson-reenter-child-ub.patch\n \n Copyright: Copyright 2018-2019 The simdjson authors; various\n-Download URL: https://github.com/simdjson/simdjson/archive/refs/tags/v0.9.6.tar.gz\n-Download date: July 17, 2021\n-Git commit: e9b893ff1b13c6a70135827c62b3f3d65938d135\n-License file: simdjson/LICENSE; simdjson/src/to_chars.cpp; simdjson/windows/toni_ronnko_dirent.h; simdjson/windows/getopt.h; simdjson/include/simdjson/internal/isadetection.h\n-License type: Apache-2.0; MIT; MIT; MIT(Old Style with legal disclaimer 2)/BSD-2-Clause; BSD-3-Clause\n+Download URL: https://codeload.github.com/simdjson/simdjson/tar.gz/refs/tags/v1.0.0\n+Download date: September 28, 2021\n+Git commit: 3bd8b0b575f43403705dcce57d427944c11421f8\n+License file: simdjson/LICENSE; simdjson/src/to_chars.cpp; simdjson/windows/toni_ronnko_dirent.h; simdjson/windows/getopt.h; simdjson/include/simdjson/internal/isadetection.h; simdjson/include/simdjson/nonstd/string_view.hpp\n+License type: Apache-2.0; MIT; MIT; MIT(Old Style with legal disclaimer 2)/BSD-2-Clause; BSD-3-Clause; BSL-1.0\n Location: simdjson\n Project URL: https://github.com/simdjson/simdjson\n-Release URL: https://github.com/simdjson/simdjson/releases/tag/v0.9.6\n-Release date: June 6, 2021\n-Version: 0.9.6\n+Release URL: https://github.com/simdjson/simdjson/releases/tag/v1.0.0\n+Release date: September 7, 2021\n+Version: 1.0.0"
      },
      {
        "filename": "vendor/simdjson-cmake-version.patch",
        "status": "modified",
        "additions": 47,
        "deletions": 16,
        "changes": 63,
        "patch": "@@ -3,23 +3,54 @@ CMake version 3.10.2 on Ubuntu 18.04 Bionic.\n \n --- a/CMakeLists.txt\n +++ b/CMakeLists.txt\n-@@ -1,4 +1,4 @@\n--cmake_minimum_required(VERSION 3.13)\n+@@ -1,11 +1,10 @@\n+-cmake_minimum_required(VERSION 3.14)\n +cmake_minimum_required(VERSION 3.9)\n- # CMP0025: Compiler id for Apple Clang is now AppleClang.\n- # https://cmake.org/cmake/help/v3.17/policy/CMP0025.html\n- cmake_policy(SET CMP0025 NEW)\n-@@ -52,13 +52,6 @@ configure_package_config_file(\"${PROJECT_SOURCE_DIR}/cmake/simdjson-config.cmake\n-       INSTALL_DESTINATION \"${CMAKE_INSTALL_LIBDIR}/cmake/simdjson\"\n-       NO_SET_AND_CHECK_MACRO\n-       NO_CHECK_REQUIRED_COMPONENTS_MACRO)\n+\n+ project(\n+     simdjson\n+     # The version number is modified by tools/release.py\n+     VERSION 1.0.0\n+     DESCRIPTION \"Parsing gigabytes of JSON per second\"\n+-    HOMEPAGE_URL \"https://simdjson.org/\"\n+     LANGUAGES CXX C\n+ )\n+\n+@@ -123,23 +122,8 @@ install(\n+     COMPONENT simdjson_Development\n+ )\n+\n+-install(\n+-    TARGETS simdjson\n+-    EXPORT simdjsonTargets\n+-    RUNTIME COMPONENT simdjson_Runtime\n+-    LIBRARY COMPONENT simdjson_Runtime\n+-    NAMELINK_COMPONENT simdjson_Development\n+-    ARCHIVE COMPONENT simdjson_Development\n+-    INCLUDES DESTINATION \"${CMAKE_INSTALL_INCLUDEDIR}\"\n+-)\n+-\n+ configure_file(cmake/simdjson-config.cmake.in simdjson-config.cmake @ONLY)\n+\n -write_basic_package_version_file(\n--      \"${PROJECT_BINARY_DIR}/simdjson-config-version.cmake\"\n--      VERSION ${SIMDJSON_SEMANTIC_VERSION}\n--      COMPATIBILITY SameMinorVersion)\n--install(FILES \"${PROJECT_BINARY_DIR}/simdjson-config.cmake\"\n--              \"${PROJECT_BINARY_DIR}/simdjson-config-version.cmake\"\n--        DESTINATION \"${CMAKE_INSTALL_LIBDIR}/cmake/simdjson\")\n+-    simdjson-config-version.cmake\n+-    COMPATIBILITY SameMinorVersion\n+-)\n+-\n+ set(\n+     SIMDJSON_INSTALL_CMAKEDIR \"${CMAKE_INSTALL_LIBDIR}/cmake/simdjson\"\n+     CACHE STRING \"CMake package config location relative to the install prefix\"\n+@@ -154,13 +138,6 @@ install(\n+     COMPONENT simdjson_Development\n+ )\n \n+-install(\n+-    EXPORT simdjsonTargets\n+-    NAMESPACE simdjson::\n+-    DESTINATION \"${SIMDJSON_INSTALL_CMAKEDIR}\"\n+-    COMPONENT example_Development\n+-)\n+-\n+ #\n+ # CPack\n  #\n- # Compile tools / tests / benchmarks"
      },
      {
        "filename": "vendor/simdjson-iostream.patch",
        "status": "removed",
        "additions": 0,
        "deletions": 213,
        "changes": 213,
        "patch": "@@ -1,213 +0,0 @@\n-commit 727ddcba86ee7fc7b2b4ebb8e5b2d3314cdc9c98\n-Author: Matthew \"strager\" Glazar <strager.nds@gmail.com>\n-Date:   Wed Aug 11 22:12:50 2021 -0700\n-\n-    Reduce #include bloat (<iostream>)\n-\n-    Including <iostream> has two problems:\n-\n-    * Compile times are worse because of over-inclusion\n-    * Binary sizes are worse when statically linking libstdc++ because\n-      iostreams cannot be dead-code-stripped\n-\n-    simdjson only needs std::ostream. Include the header declaring only what\n-    we need (<ostream>), omitting stuff we don't need (std::cout and its\n-    initialization, for example).\n-\n-    This commit should not change behavior, but it might break users who\n-    assume that including <simdjson/simdjson.h> will make std::cout\n-    available (such as many of simdjson's own files).\n-\n-diff --git a/benchmark/bench_dom_api.cpp b/benchmark/bench_dom_api.cpp\n-index b8f5937b..7224f88c 100644\n---- a/benchmark/bench_dom_api.cpp\n-+++ b/benchmark/bench_dom_api.cpp\n-@@ -1,4 +1,5 @@\n- #include <benchmark/benchmark.h>\n-+#include <iostream>\n- #include \"simdjson.h\"\n- #include <sstream>\n-\n-diff --git a/benchmark/bench_parse_call.cpp b/benchmark/bench_parse_call.cpp\n-index 514d4796..d98a5d47 100644\n---- a/benchmark/bench_parse_call.cpp\n-+++ b/benchmark/bench_parse_call.cpp\n-@@ -1,4 +1,5 @@\n- #include <benchmark/benchmark.h>\n-+#include <iostream>\n- #include \"simdjson.h\"\n- using namespace simdjson;\n- using namespace benchmark;\n-diff --git a/fuzz/fuzz_implementations.cpp b/fuzz/fuzz_implementations.cpp\n-index c1525aa7..bfbe3b1a 100644\n---- a/fuzz/fuzz_implementations.cpp\n-+++ b/fuzz/fuzz_implementations.cpp\n-@@ -11,6 +11,7 @@\n- #include <cstddef>\n- #include <cstdint>\n- #include <cstdlib>\n-+#include <iostream>\n- #include <string>\n- #include <array>\n- #include \"supported_implementations.h\"\n-diff --git a/fuzz/fuzz_minifyimpl.cpp b/fuzz/fuzz_minifyimpl.cpp\n-index 444d5030..d8750086 100644\n---- a/fuzz/fuzz_minifyimpl.cpp\n-+++ b/fuzz/fuzz_minifyimpl.cpp\n-@@ -12,6 +12,7 @@\n- #include \"simdjson.h\"\n- #include <cstddef>\n- #include <cstdlib>\n-+#include <iostream>\n- #include <vector>\n- #include \"supported_implementations.h\"\n-\n-diff --git a/fuzz/fuzz_utf8.cpp b/fuzz/fuzz_utf8.cpp\n-index 397b39a1..d83db7e0 100644\n---- a/fuzz/fuzz_utf8.cpp\n-+++ b/fuzz/fuzz_utf8.cpp\n-@@ -10,6 +10,7 @@\n- #include \"simdjson.h\"\n- #include <cstddef>\n- #include <cstdlib>\n-+#include <iostream>\n- #include \"supported_implementations.h\"\n-\n- extern \"C\" int VerboseTestOneInput(const uint8_t *Data, size_t Size) {\n-diff --git a/include/simdjson/dom/parsedjson_iterator.h b/include/simdjson/dom/parsedjson_iterator.h\n-index b5846048..667875a4 100644\n---- a/include/simdjson/dom/parsedjson_iterator.h\n-+++ b/include/simdjson/dom/parsedjson_iterator.h\n-@@ -5,7 +5,7 @@\n-\n- #include <cstring>\n- #include <string>\n--#include <iostream>\n-+#include <ostream>\n- #include <iterator>\n- #include <limits>\n- #include <stdexcept>\n-diff --git a/include/simdjson/internal/jsonformatutils.h b/include/simdjson/internal/jsonformatutils.h\n-index c87c6445..b30e1c5d 100644\n---- a/include/simdjson/internal/jsonformatutils.h\n-+++ b/include/simdjson/internal/jsonformatutils.h\n-@@ -2,7 +2,7 @@\n- #define SIMDJSON_INTERNAL_JSONFORMATUTILS_H\n-\n- #include <iomanip>\n--#include <iostream>\n-+#include <ostream>\n- #include <sstream>\n-\n- namespace simdjson {\n-diff --git a/tests/dom/jsoncheck.cpp b/tests/dom/jsoncheck.cpp\n-index 6c15a007..0d37833b 100644\n---- a/tests/dom/jsoncheck.cpp\n-+++ b/tests/dom/jsoncheck.cpp\n-@@ -10,6 +10,7 @@\n-\n- #include <cstdio>\n- #include <cstdlib>\n-+#include <iostream>\n-\n- #include \"simdjson.h\"\n-\n-diff --git a/tests/dom/minefieldcheck.cpp b/tests/dom/minefieldcheck.cpp\n-index cc53096d..50bc4fba 100644\n---- a/tests/dom/minefieldcheck.cpp\n-+++ b/tests/dom/minefieldcheck.cpp\n-@@ -10,6 +10,7 @@\n-\n- #include <cstdio>\n- #include <cstdlib>\n-+#include <iostream>\n-\n- #include \"simdjson.h\"\n- /**\n-diff --git a/tests/dom/numberparsingcheck.cpp b/tests/dom/numberparsingcheck.cpp\n-index 14a8fb80..6be7e59e 100644\n---- a/tests/dom/numberparsingcheck.cpp\n-+++ b/tests/dom/numberparsingcheck.cpp\n-@@ -3,6 +3,7 @@\n- #include <cmath>\n- #include <cstdio>\n- #include <cstdlib>\n-+#include <iostream>\n-\n- #ifndef JSON_TEST_NUMBERS\n- #define JSON_TEST_NUMBERS\n-diff --git a/tests/dom/parse_many_test.cpp b/tests/dom/parse_many_test.cpp\n-index 96affa00..e7bc7143 100644\n---- a/tests/dom/parse_many_test.cpp\n-+++ b/tests/dom/parse_many_test.cpp\n-@@ -10,6 +10,7 @@\n-\n- #include <cstdio>\n- #include <cstdlib>\n-+#include <iostream>\n-\n- #include \"simdjson.h\"\n-\n-diff --git a/tests/dom/random_string_number_tests.cpp b/tests/dom/random_string_number_tests.cpp\n-index d269f9a7..af2260b5 100644\n---- a/tests/dom/random_string_number_tests.cpp\n-+++ b/tests/dom/random_string_number_tests.cpp\n-@@ -4,6 +4,7 @@\n- #include <cstdio>\n- #include <cstdlib>\n- #include <cstdint>\n-+#include <iostream>\n- #include <random>\n- #include <climits>\n- #include <unistd.h>\n-@@ -194,4 +195,4 @@ int main(int argc, char *argv[]) {\n-   }\n-   std::cout << \"Failure.\" << std::endl;\n-   return EXIT_FAILURE;\n--}\n-\\ No newline at end of file\n-+}\n-diff --git a/tests/ondemand/test_ondemand.h b/tests/ondemand/test_ondemand.h\n-index 3ddec316..2ef2e8a7 100644\n---- a/tests/ondemand/test_ondemand.h\n-+++ b/tests/ondemand/test_ondemand.h\n-@@ -1,6 +1,7 @@\n- #ifndef ONDEMAND_TEST_ONDEMAND_H\n- #define ONDEMAND_TEST_ONDEMAND_H\n-\n-+#include <iostream>\n- #include <unistd.h>\n- #include \"simdjson.h\"\n- #include \"cast_tester.h\"\n-diff --git a/tests/test_macros.h b/tests/test_macros.h\n-index 322e4a5b..80472458 100644\n---- a/tests/test_macros.h\n-+++ b/tests/test_macros.h\n-@@ -1,6 +1,8 @@\n- #ifndef TEST_MACROS_H\n- #define TEST_MACROS_H\n-\n-+#include <iostream>\n-+\n- #ifndef SIMDJSON_BENCHMARK_DATA_DIR\n- #define SIMDJSON_BENCHMARK_DATA_DIR \"jsonexamples/\"\n- #endif\n-@@ -121,4 +123,4 @@ simdjson_really_inline bool assert_iterate_error(T &arr, simdjson::error_code ex\n- #define TEST_FAIL(MESSAGE)              do { std::cerr << \"FAIL: \" << (MESSAGE) << std::endl; return false; } while (0);\n- #define TEST_SUCCEED()                  do { return true; } while (0);\n-\n--#endif // TEST_MACROS_H\n-\\ No newline at end of file\n-+#endif // TEST_MACROS_H\n-diff --git a/tests/unicode_tests.cpp b/tests/unicode_tests.cpp\n-index 065f4ef9..47e9410c 100644\n---- a/tests/unicode_tests.cpp\n-+++ b/tests/unicode_tests.cpp\n-@@ -1,6 +1,7 @@\n- #include \"simdjson.h\"\n- #include <cstddef>\n- #include <cstdint>\n-+#include <iostream>\n- #include <random>\n-\n- class RandomUTF8 final {"
      },
      {
        "filename": "vendor/simdjson-reenter-child-ub.patch",
        "status": "removed",
        "additions": 0,
        "deletions": 96,
        "changes": 96,
        "patch": "@@ -1,96 +0,0 @@\n-commit 16e23231537d9415aec71b94f8a266076452380b\n-Author: strager <strager.nds@gmail.com>\n-Date:   Thu May 27 05:34:28 2021 -0700\n-\n-    Fix UB in dev checks when iterating empty object (#1587)\n-\n-    When find_field_unordered is used on an empty object, it calls\n-    json_iterator::reenter_child. reenter_child asserts that it doesn't\n-    rewind too far back by consulting parser->start_positions.\n-\n-    When the On Demand parser sees an empty object, it fails to update\n-    parser->start_positions. This means that the assertion in\n-    json_iterator::reenter_child reads stale data, or potentially\n-    uninitialized memory. Reading uninitialized memory can cause spurious\n-    assertion failures and Valgrind memcheck reports:\n-\n-        Running missing_keys_for_empty_top_level_object ...\n-        ==170679== Conditional jump or move depends on uninitialised value(s)\n-        ==170679==    at 0x4943D7: reenter_child (json_iterator-inl.h:208)\n-        ==170679==    by 0x4943D7: find_field_unordered_raw (value_iterator-inl.h:197)\n-        ==170679==    by 0x4943D7: find_field_unordered (object-inl.h:13)\n-        ==170679==    by 0x4943D7: find_field_unordered (object-inl.h:96)\n-        ==170679==    by 0x4943D7: find_field_unordered (value-inl.h:110)\n-        ==170679==    by 0x4943D7: find_field_unordered (document-inl.h:105)\n-        ==170679==    by 0x4943D7: object_tests::missing_keys_for_empty_top_level_object() (ondemand_object_tests.cpp:117)\n-        ==170679==    by 0x4CA761: object_tests::run() (ondemand_object_tests.cpp:1085)\n-        ==170679==    by 0x8BA314: int test_main<bool ()>(int, char**, bool ( const&)()) (test_ondemand.h:81)\n-        ==170679==    by 0x4CA9C8: main (ondemand_object_tests.cpp:1119)\n-        ==170679==\n-\n-    Fix the read of uninitialized or stale memory by updating\n-    parser->start_positions regardless of whether we see an empty object or\n-    an object with some keys.\n-\n-    This commit only affects builds where development checks\n-    (SIMDJSON_DEVELOPMENT_CHECKS) are enabled. Builds where development\n-    checks are disabled are unaffected by this bug.\n-\n-diff --git a/include/simdjson/generic/ondemand/value_iterator-inl.h b/include/simdjson/generic/ondemand/value_iterator-inl.h\n-index e97cb265..007c6d4b 100644\n---- a/include/simdjson/generic/ondemand/value_iterator-inl.h\n-+++ b/include/simdjson/generic/ondemand/value_iterator-inl.h\n-@@ -25,6 +25,9 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator\n-\n- simdjson_warn_unused simdjson_really_inline bool value_iterator::started_object() noexcept {\n-   assert_at_container_start();\n-+#ifdef SIMDJSON_DEVELOPMENT_CHECKS\n-+  _json_iter->set_start_position(_depth, _start_position);\n-+#endif\n-   if (*_json_iter->peek() == '}') {\n-     logger::log_value(*_json_iter, \"empty object\");\n-     _json_iter->advance();\n-@@ -32,9 +35,6 @@ simdjson_warn_unused simdjson_really_inline bool value_iterator::started_object(\n-     return false;\n-   }\n-   logger::log_start_value(*_json_iter, \"object\");\n--#ifdef SIMDJSON_DEVELOPMENT_CHECKS\n--  _json_iter->set_start_position(_depth, _start_position);\n--#endif\n-   return true;\n- }\n-\n-diff --git a/tests/ondemand/ondemand_object_tests.cpp b/tests/ondemand/ondemand_object_tests.cpp\n-index 78210a47..b405d493 100644\n---- a/tests/ondemand/ondemand_object_tests.cpp\n-+++ b/tests/ondemand/ondemand_object_tests.cpp\n-@@ -107,6 +107,21 @@ namespace object_tests {\n-     return true;\n-   }\n-\n-+  bool missing_keys_for_empty_top_level_object() {\n-+    TEST_START();\n-+    simdjson::ondemand::parser parser;\n-+    simdjson::padded_string docdata = \"{}\"_padded;\n-+    simdjson::ondemand::document doc;\n-+    auto error = parser.iterate(docdata).get(doc);\n-+    if(error != simdjson::SUCCESS) { return false; }\n-+    error = doc.find_field_unordered(\"keynotfound\").error();\n-+    if(error != simdjson::NO_SUCH_FIELD) {\n-+      std::cout << error << std::endl;\n-+      return false;\n-+    }\n-+    return true;\n-+  }\n-+\n- #if SIMDJSON_EXCEPTIONS\n-   // used in issue_1521\n-   // difficult to use as a lambda because it is recursive.\n-@@ -1067,6 +1082,7 @@ namespace object_tests {\n-            missing_key_continue() &&\n-            no_missing_keys() &&\n-            missing_keys() &&\n-+           missing_keys_for_empty_top_level_object() &&\n- #if SIMDJSON_EXCEPTIONS\n-            fixed_broken_issue_1521() &&\n-            issue_1521() &&"
      },
      {
        "filename": "vendor/simdjson.cmake",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "patch": "@@ -1,8 +1,8 @@\n # Copyright (C) 2020  Matthew \"strager\" Glazar\n # See end of file for extended copyright information.\n \n-set(SIMDJSON_JUST_LIBRARY ON CACHE INTERNAL \"\")\n-set(SIMDJSON_BUILD_STATIC ON CACHE INTERNAL \"\")\n+set(SIMDJSON_DEVELOPER_MODE OFF CACHE INTERNAL \"\")\n+set(BUILD_SHARED_LIBS OFF)\n \n add_subdirectory(simdjson EXCLUDE_FROM_ALL)\n \n@@ -11,11 +11,11 @@ target_compile_definitions(simdjson PUBLIC SIMDJSON_EXCEPTIONS=0)\n # HACK(strager): Avoid various warnings when including <simdjson.h>.\n get_property(\n   SIMDJSON_INCLUDE_DIRECTORIES\n-  TARGET simdjson-headers\n+  TARGET simdjson\n   PROPERTY INTERFACE_INCLUDE_DIRECTORIES\n )\n set_property(\n-  TARGET simdjson-headers\n+  TARGET simdjson\n   APPEND PROPERTY\n   INTERFACE_SYSTEM_INCLUDE_DIRECTORIES\n   \"${SIMDJSON_INCLUDE_DIRECTORIES}\""
      },
      {
        "filename": "vendor/simdjson/.appveyor.yml",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "patch": "@@ -15,29 +15,29 @@ environment:\n     - job_name: VS2019\n       CMAKE_ARGS: -A %Platform%\n     - job_name: VS2019ARM\n-      CMAKE_ARGS: -A ARM64 -DCMAKE_CROSSCOMPILING=1 -D SIMDJSON_GOOGLE_BENCHMARKS=OFF # Does Google Benchmark builds under VS ARM?\n+      CMAKE_ARGS: -A ARM64   -DSIMDJSON_DEVELOPER_MODE=ON -DCMAKE_CROSSCOMPILING=1 -D SIMDJSON_GOOGLE_BENCHMARKS=OFF # Does Google Benchmark builds under VS ARM?\n     - job_name: VS2017 (Static, No Threads)\n       image: Visual Studio 2017\n-      CMAKE_ARGS: -A %Platform% -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_ENABLE_THREADS=OFF\n+      CMAKE_ARGS: -A %Platform%   -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF -DSIMDJSON_ENABLE_THREADS=OFF\n       CTEST_ARGS: -LE explicitonly\n     - job_name: VS2019 (Win32)\n       platform: Win32\n-      CMAKE_ARGS: -A %Platform% -DSIMDJSON_BUILD_STATIC=OFF -DSIMDJSON_ENABLE_THREADS=ON # This should be the default. Testing anyway.\n+      CMAKE_ARGS: -A %Platform%   -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=ON -DSIMDJSON_ENABLE_THREADS=ON # This should be the default. Testing anyway.\n       CTEST_ARGS: -LE explicitonly\n     - job_name: VS2019 (Win32, No Exceptions)\n       platform: Win32\n-      CMAKE_ARGS: -A %Platform% -DSIMDJSON_BUILD_STATIC=OFF -DSIMDJSON_ENABLE_THREADS=ON -DSIMDJSON_EXCEPTIONS=OFF\n+      CMAKE_ARGS: -A %Platform%   -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=ON -DSIMDJSON_ENABLE_THREADS=ON -DSIMDJSON_EXCEPTIONS=OFF\n       CTEST_ARGS: -LE explicitonly\n     - job_name: VS2015\n       image: Visual Studio 2015\n-      CMAKE_ARGS: -A %Platform% -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_ENABLE_THREADS=OFF\n+      CMAKE_ARGS: -A %Platform%   -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF -DSIMDJSON_ENABLE_THREADS=OFF\n       CTEST_ARGS: -LE explicitonly\n \n build_script:\n   - mkdir build\n   - cd build\n   - cmake --version\n-  - cmake %CMAKE_ARGS% --parallel ..\n+  - cmake %CMAKE_ARGS% ..\n   - cmake -LH ..\n   - cmake --build . --config %Configuration% --verbose --parallel\n "
      },
      {
        "filename": "vendor/simdjson/.circleci/config.yml",
        "status": "modified",
        "additions": 25,
        "deletions": 25,
        "changes": 50,
        "patch": "@@ -1,7 +1,7 @@\n version: 2.1\n \n \n-# We constantly run out of memory so please do not use parallelism (-j, -j4). \n+# We constantly run out of memory so please do not use parallelism (-j, -j4).\n \n # Reusable image / compiler definitions\n executors:\n@@ -11,7 +11,7 @@ executors:\n         environment:\n           CXX: g++-8\n           CC: gcc-8\n-          BUILD_FLAGS: \n+          CMAKE_BUILD_FLAGS:\n           CTEST_FLAGS: --output-on-failure\n \n   gcc9:\n@@ -20,7 +20,7 @@ executors:\n         environment:\n           CXX: g++-9\n           CC: gcc-9\n-          BUILD_FLAGS:\n+          CMAKE_BUILD_FLAGS:\n           CTEST_FLAGS: --output-on-failure\n \n   gcc10:\n@@ -29,7 +29,7 @@ executors:\n         environment:\n           CXX: g++-10\n           CC: gcc-10\n-          BUILD_FLAGS:\n+          CMAKE_BUILD_FLAGS:\n           CTEST_FLAGS: --output-on-failure\n \n   clang10:\n@@ -38,7 +38,7 @@ executors:\n         environment:\n           CXX: clang++-10\n           CC: clang-10\n-          BUILD_FLAGS:\n+          CMAKE_BUILD_FLAGS:\n           CTEST_FLAGS: --output-on-failure\n \n   clang9:\n@@ -47,16 +47,16 @@ executors:\n         environment:\n           CXX: clang++-9\n           CC: clang-9\n-          BUILD_FLAGS:\n-          CTEST_FLAGS: --output-on-failure \n+          CMAKE_BUILD_FLAGS:\n+          CTEST_FLAGS: --output-on-failure\n \n   clang6:\n     docker:\n       - image: conanio/clang60\n         environment:\n           CXX: clang++-6.0\n           CC: clang-6.0\n-          BUILD_FLAGS:\n+          CMAKE_BUILD_FLAGS:\n           CTEST_FLAGS: --output-on-failure\n \n # Reusable test commands (and initializer for clang 6)\n@@ -88,13 +88,13 @@ commands:\n     steps:\n       - cmake_prep\n       - dependency_restore\n-      - run: cmake $CMAKE_FLAGS -DCMAKE_INSTALL_PREFIX:PATH=destination -B build . \n+      - run: cmake  -DSIMDJSON_DEVELOPER_MODE=ON $CMAKE_FLAGS -DCMAKE_INSTALL_PREFIX:PATH=destination -B build .\n       - dependency_cache # dependencies are produced in the configure step\n \n   cmake_build:\n     steps:\n       - cmake_build_cache\n-      - run: cmake --build build\n+      - run: cmake  --build build\n \n   cmake_test:\n     steps:\n@@ -129,8 +129,8 @@ commands:\n     steps:\n       - cmake_build_cache\n       - run: |\n-          cmake --build  build --target checkperf &&\n-          cd build && \n+          cmake -DSIMDJSON_ENABLE_DOM_CHECKPERF=ON --build  build --target checkperf &&\n+          cd build &&\n           ctest --output-on-failure -R checkperf\n \n   # we not only want cmake to build and run tests, but we want also a successful installation from which we can build, link and run programs\n@@ -164,60 +164,60 @@ jobs:\n   gcc10-perftest:\n     description: Build and run performance tests on GCC 10 and AVX 2 with a cmake static build, this test performance regression\n     executor: gcc10\n-    environment: { CMAKE_FLAGS: -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_BUILD_STATIC=ON }\n+    environment: { CMAKE_FLAGS: -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DBUILD_SHARED_LIBS=OFF }\n     steps: [ cmake_perftest ]\n   gcc10:\n     description: Build and run tests on GCC 10 and AVX 2 with a cmake static build\n     executor: gcc10\n-    environment: { CMAKE_FLAGS: -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_BUILD_STATIC=ON }\n+    environment: { CMAKE_FLAGS: -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DBUILD_SHARED_LIBS=OFF }\n     steps: [ cmake_test, cmake_install_test, cmake_installed_test_cxx20 ]\n   clang6:\n     description: Build and run tests on clang 6 and AVX 2 with a cmake static build\n     executor: clang6\n-    environment: { CMAKE_FLAGS: -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_BUILD_STATIC=ON }\n+    environment: { CMAKE_FLAGS: -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DBUILD_SHARED_LIBS=OFF }\n     steps: [ cmake_test, cmake_install_test ]\n   clang10:\n     description: Build and run tests on clang 10 and AVX 2 with a cmake static build\n     executor: clang10\n-    environment: { CMAKE_FLAGS: -DSIMDJSON_GOOGLE_BENCHMARKS=ON  -DSIMDJSON_BUILD_STATIC=ON }\n+    environment: { CMAKE_FLAGS: -DSIMDJSON_GOOGLE_BENCHMARKS=ON  -DBUILD_SHARED_LIBS=OFF }\n     steps: [ cmake_test, cmake_install_test, cmake_installed_test_cxx20 ]\n   # libcpp\n   libcpp-clang10:\n     description: Build and run tests on clang 10 and AVX 2 with a cmake static build and libc++\n     executor: clang10\n-    environment: { CMAKE_FLAGS: -DSIMDJSON_USE_LIBCPP=ON  -DSIMDJSON_BUILD_STATIC=ON }\n+    environment: { CMAKE_FLAGS: -DSIMDJSON_USE_LIBCPP=ON  -DBUILD_SHARED_LIBS=OFF }\n     steps: [ cmake_test, cmake_install_test, cmake_installed_test_cxx20 ]\n   # sanitize\n   sanitize-gcc10:\n     description: Build and run tests on GCC 10 and AVX 2 with a cmake sanitize build\n     executor: gcc10\n-    environment: { CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF -DSIMDJSON_SANITIZE=ON, BUILD_FLAGS: \"\", CTEST_FLAGS: --output-on-failure -LE explicitonly }\n+    environment: { CMAKE_FLAGS: -DCMAKE_BUILD_TYPE=Debug -DBUILD_SHARED_LIBS=ON -DSIMDJSON_SANITIZE=ON, CTEST_FLAGS: --output-on-failure -LE explicitonly }\n     steps: [ cmake_test ]\n   sanitize-clang10:\n     description: Build and run tests on clang 10 and AVX 2 with a cmake sanitize build\n     executor: clang10\n-    environment: { CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF -DSIMDJSON_SANITIZE=ON, CTEST_FLAGS: --output-on-failure -LE explicitonly }\n+    environment: { CMAKE_FLAGS: -DBUILD_SHARED_LIBS=ON -DSIMDJSON_NO_FORCE_INLINING=ON -DSIMDJSON_SANITIZE=ON, CTEST_FLAGS: --output-on-failure -LE explicitonly }\n     steps: [ cmake_test ]\n   threadsanitize-gcc10:\n     description: Build and run tests on GCC 10 and AVX 2 with a cmake sanitize build\n     executor: gcc10\n-    environment: { CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF -DSIMDJSON_SANITIZE_THREADS=ON, BUILD_FLAGS: \"\", CTEST_FLAGS: --output-on-failure -LE explicitonly }\n+    environment: { CMAKE_FLAGS: -DBUILD_SHARED_LIBS=ON -DSIMDJSON_SANITIZE_THREADS=ON, CTEST_FLAGS: --output-on-failure -LE explicitonly }\n     steps: [ cmake_test ]\n   threadsanitize-clang10:\n     description: Build and run tests on clang 10 and AVX 2 with a cmake sanitize build\n     executor: clang10\n-    environment: { CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF -DSIMDJSON_SANITIZE_THREADS=ON, CTEST_FLAGS: --output-on-failure -LE explicitonly }\n+    environment: { CMAKE_FLAGS: -DBUILD_SHARED_LIBS=ON  -DSIMDJSON_NO_FORCE_INLINING=ON -DSIMDJSON_SANITIZE_THREADS=ON, CTEST_FLAGS: --output-on-failure -LE explicitonly }\n     steps: [ cmake_test ]\n   # dynamic\n   dynamic-gcc10:\n     description: Build and run tests on GCC 10 and AVX 2 with a cmake dynamic build\n     executor: gcc10\n-    environment: { CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF }\n+    environment: { CMAKE_FLAGS: -DBUILD_SHARED_LIBS=ON }\n     steps: [ cmake_test, cmake_install_test ]\n   dynamic-clang10:\n     description: Build and run tests on clang 10 and AVX 2 with a cmake dynamic build\n     executor: clang10\n-    environment: { CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF }\n+    environment: { CMAKE_FLAGS: -DBUILD_SHARED_LIBS=ON }\n     steps: [ cmake_test, cmake_install_test ]\n \n   # unthreaded\n@@ -262,12 +262,12 @@ jobs:\n   sanitize-haswell-gcc10:\n     description: Build and run tests on GCC 10 and AVX 2 with a cmake sanitize build\n     executor: gcc10\n-    environment: {  CXXFLAGS: -march=haswell, CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF -DSIMDJSON_SANITIZE=ON, BUILD_FLAGS: \"\", CTEST_FLAGS: --output-on-failure -LE explicitonly }\n+    environment: {  CXXFLAGS: -march=haswell, CMAKE_FLAGS: -DCMAKE_BUILD_TYPE=Debug -DBUILD_SHARED_LIBS=ON -DSIMDJSON_SANITIZE=ON, CTEST_FLAGS: --output-on-failure -LE explicitonly }\n     steps: [ cmake_test ]\n   sanitize-haswell-clang10:\n     description: Build and run tests on clang 10 and AVX 2 with a cmake sanitize build\n     executor: clang10\n-    environment: { CXXFLAGS: -march=haswell, CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF -DSIMDJSON_SANITIZE=ON, CTEST_FLAGS: --output-on-failure -LE explicitonly }\n+    environment: { CXXFLAGS: -march=haswell, CMAKE_FLAGS: -DBUILD_SHARED_LIBS=ON  -DSIMDJSON_NO_FORCE_INLINING=ON -DSIMDJSON_SANITIZE=ON, CTEST_FLAGS: --output-on-failure -LE explicitonly }\n     steps: [ cmake_test ]\n \n workflows:"
      },
      {
        "filename": "vendor/simdjson/.drone.yml",
        "status": "modified",
        "additions": 17,
        "deletions": 17,
        "changes": 34,
        "patch": "@@ -8,7 +8,7 @@ steps:\n     CC: gcc\n     CXX: g++\n     BUILD_FLAGS: -- -j\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=ON\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=OFF\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly \n   commands:\n     - scripts/addcmakeppa.sh \"$(env -i sh -c '. /etc/os-release; echo $VERSION_CODENAME')\"\n@@ -29,7 +29,7 @@ steps:\n     CC: clang-6.0\n     CXX: clang++-6.0\n     BUILD_FLAGS: -- -j\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=ON\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=OFF\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly \n   commands:\n     - scripts/addcmakeppa.sh \"$(env -i sh -c '. /etc/os-release; echo $VERSION_CODENAME')\"\n@@ -50,7 +50,7 @@ steps:\n     CC: gcc\n     CXX: g++\n     BUILD_FLAGS: -- -j\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_IMPLEMENTATION=haswell;westmere;fallback\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=OFF -DSIMDJSON_IMPLEMENTATION=haswell;westmere;fallback\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n   commands:\n     - echo \"deb http://deb.debian.org/debian buster-backports main\" >> /etc/apt/sources.list\n@@ -77,7 +77,7 @@ steps:\n     CC: clang-6.0\n     CXX: clang++-6.0\n     BUILD_FLAGS: -- -j\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_IMPLEMENTATION=haswell;westmere;fallback\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=OFF -DSIMDJSON_IMPLEMENTATION=haswell;westmere;fallback\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n   commands:\n     - mkdir build\n@@ -100,7 +100,7 @@ steps:\n     CC: gcc\n     CXX: g++\n     BUILD_FLAGS: -- -j\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=ON\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n   commands:\n     - echo \"deb http://deb.debian.org/debian buster-backports main\" >> /etc/apt/sources.list\n@@ -122,7 +122,7 @@ steps:\n   environment:\n     CC: clang-9\n     CXX: clang++-9\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=ON\n     BUILD_FLAGS: -- -j\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n   commands:\n@@ -142,7 +142,7 @@ steps:\n     CC: gcc\n     CXX: g++\n     BUILD_FLAGS: -- -j\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_IMPLEMENTATION=haswell;westmere;fallback\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=OFF -DSIMDJSON_IMPLEMENTATION=haswell;westmere;fallback\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n   commands:\n     - echo \"deb http://deb.debian.org/debian buster-backports main\" >> /etc/apt/sources.list\n@@ -213,7 +213,7 @@ steps:\n     CC: gcc\n     CXX: g++\n     BUILD_FLAGS: -- -j\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_IMPLEMENTATION=arm64;fallback\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=OFF -DSIMDJSON_IMPLEMENTATION=arm64;fallback\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n   commands:\n     - echo \"deb http://deb.debian.org/debian buster-backports main\" >> /etc/apt/sources.list\n@@ -237,7 +237,7 @@ steps:\n   environment:\n     CC: clang-6.0\n     CXX: clang++-6.0\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=ON\n     BUILD_FLAGS: -- -j\n     CTEST_FLAGS: -j4 --output-on-failure  -LE explicitonly\n   commands:\n@@ -260,7 +260,7 @@ steps:\n     CC: gcc\n     CXX: g++\n     BUILD_FLAGS: -- -j\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=ON\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n   commands:\n     - echo \"deb http://deb.debian.org/debian buster-backports main\" >> /etc/apt/sources.list\n@@ -281,7 +281,7 @@ steps:\n   environment:\n     CC: clang-6.0\n     CXX: clang++-6.0\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=OFF\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=ON\n     BUILD_FLAGS: -- -j\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n   commands:\n@@ -302,7 +302,7 @@ steps:\n   image: gcc:8\n   environment:\n     BUILD_FLAGS: -- -j\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_IMPLEMENTATION=arm64;fallback\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=OFF -DSIMDJSON_IMPLEMENTATION=arm64;fallback\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n     CC: gcc\n     CXX: g++\n@@ -356,7 +356,7 @@ steps:\n     CC: clang-9\n     CXX: clang++-9\n     BUILD_FLAGS: -- -j 4\n-    CMAKE_FLAGS: -GNinja -DSIMDJSON_BUILD_STATIC=ON\n+    CMAKE_FLAGS: -GNinja -DBUILD_SHARED_LIBS=OFF\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n     CXXFLAGS: -stdlib=libc++\n   commands:\n@@ -377,7 +377,7 @@ steps:\n     CC: clang-9\n     CXX: clang++-9\n     BUILD_FLAGS: -- -j\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=ON\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=OFF\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n     CXXFLAGS: -stdlib=libc++\n   commands:\n@@ -398,7 +398,7 @@ steps:\n     CC: clang-7\n     CXX: clang++-7\n     BUILD_FLAGS: -- -j\n-    CMAKE_FLAGS: -DSIMDJSON_BUILD_STATIC=ON\n+    CMAKE_FLAGS: -DBUILD_SHARED_LIBS=OFF\n     CTEST_FLAGS: -j4 --output-on-failure -LE explicitonly\n     CXXFLAGS: -stdlib=libc++\n   commands:\n@@ -444,8 +444,8 @@ steps:\n   commands:\n     - apt-get -qq update\n     - apt-get install -q -y clang cmake git wget zip ninja-build\n-    - wget --quiet https://dl.bintray.com/pauldreik/simdjson-fuzz-corpus/corpus/corpus.tar\n-    - tar xf corpus.tar && rm corpus.tar\n+    - wget -O corpus.tar.gz https://readonly:readonly@www.pauldreik.se/fuzzdata/index.php?project=simdjson\n+    - tar xf corpus.tar.gz && rm corpus.tar.gz\n     - fuzz/build_like_ossfuzz.sh\n     - mkdir -p common_out\n     - for fuzzer in build/fuzz/fuzz_* ; do echo $fuzzer;$fuzzer common_out out/* -max_total_time=40; done"
      },
      {
        "filename": "vendor/simdjson/.github/ISSUE_TEMPLATE/bug_report.md",
        "status": "modified",
        "additions": 19,
        "deletions": 4,
        "changes": 23,
        "patch": "@@ -18,19 +18,34 @@ Before submitting an issue, please ensure that you have read the documentation:\n **Describe the bug**\n A clear and concise description of what the bug is.\n \n-Note that a compiler warning is not a bug.\n+A compiler or static-analyzer warning is not a bug.\n+\n+We are committed to providing good documentation. We accept the lack of documentation or a misleading documentation as a bug (a 'documentation bug').\n+\n+We accept the identification of an issue by a sanitizer or some checker tool (e.g., valgrind) as a bug, but you must first ensure that it is not a false positive.\n+\n+We recommend that you run your tests using different optimization levels.\n+\n+Before reporting a bug, please ensure that you have read our documentation.\n \n **To Reproduce**\n Steps to reproduce the behaviour: provide a code sample if possible.\n \n-If we cannot reproduce the issue, then we cannot address it.\n+If we cannot reproduce the issue, then we cannot address it. Note that a stack trace from your own program is not enough. A sample of your source code is insufficient: please provide a complete test for us to reproduce the issue. Please reduce the issue: use as small and as simple an example of the bug as possible.\n+\n+It should be possible to trigger the bug by using solely simdjson with our default build setup. If you can only observe the bug within some specific context, with some other software, please reduce the issue first.\n+\n+**simjson release**\n+\n+Unless you plan to contribute to simdjson, you should only work from releases. Please be mindful that our main branch may have additional features, bugs and documentation items.\n \n-Note that a stack trace from your own program is not enough.\n+It is fine to report bugs against our main branch, but if that is what you are doing, please be explicit.\n \n-**Configuration (please complete the following information if relevant):**\n+**Configuration (please complete the following information if relevant)**\n  - OS: [e.g. Ubuntu 16.04.6 LTS]\n  - Compiler [e.g. Apple clang version 11.0.3 (clang-1103.0.32.59) x86_64-apple-darwin19.4.0]\n  - Version [e.g. 22]\n+ - Optimization setting (e.g., -O3)\n \n We support up-to-date 64-bit ARM and x64 FreeBSD, macOS, Windows and Linux systems. Please ensure that your configuration is supported before labelling the issue as a bug. In particular, we do not support legacy 32-bit systems.\n "
      },
      {
        "filename": "vendor/simdjson/.github/workflows/alpine.yml",
        "status": "modified",
        "additions": 2,
        "deletions": 8,
        "changes": 10,
        "patch": "@@ -1,12 +1,6 @@\n name: Alpine Linux\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   ubuntu-build:\n@@ -31,7 +25,7 @@ jobs:\n           ./alpine.sh apk add build-base cmake g++ linux-headers git bash\n       - name: cmake\n         run: |\n-          ./alpine.sh cmake -B build_for_alpine\n+          ./alpine.sh cmake -DSIMDJSON_DEVELOPER_MODE=ON -B build_for_alpine\n       - name: build\n         run: |\n           ./alpine.sh cmake --build build_for_alpine"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/fix-trailing-whitespace.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "patch": "@@ -1,9 +1,6 @@\n name: Detect trailing whitespace\n \n-on:\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   whitespace:"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/fuzzers.yml",
        "status": "modified",
        "additions": 18,
        "deletions": 16,
        "changes": 34,
        "patch": "@@ -44,19 +44,25 @@ jobs:\n         path: dependencies/.cache\n         key: ${{ hashFiles('dependencies/CMakeLists.txt') }}\n \n+    - uses: actions/cache@v2\n+      id: cache-corpus\n+      with:\n+        path: out/\n+        key: corpus-${{ github.run_id }}\n+        restore-keys: corpus-\n+    \n+    - name: show statistics for the cached corpus\n+      run: |\n+        echo number of files in github action corpus cache:\n+        find out -type f |wc -l\n+    \n     - name: Create and prepare the initial seed corpus\n       run: |\n         fuzz/build_corpus.sh\n         mv corpus.zip seed_corpus.zip\n         mkdir seedcorpus\n         unzip -q -d seedcorpus seed_corpus.zip\n \n-    - name: Download the corpus from the last run\n-      run: |\n-        wget --quiet https://dl.bintray.com/pauldreik/simdjson-fuzz-corpus/corpus/corpus.tar\n-        tar xf corpus.tar\n-        rm corpus.tar\n-\n     - name: List clang versions\n       run: |\n         ls /usr/bin/clang*\n@@ -70,7 +76,7 @@ jobs:\n       run: |\n         set -eux\n         for fuzzer in $defaultimplfuzzers $implfuzzers; do\n-          mkdir -p out/$fuzzer # in case this is a new fuzzer, or corpus.tar is broken\n+          mkdir -p out/$fuzzer # in case this is a new fuzzer, or the github action cached corpus is broken\n           # get input from everyone else (corpus cross pollination)\n           others=$(find out -type d -not -name $fuzzer -not -name out -not -name cmin)\n           build-fast/fuzz/fuzz_$fuzzer out/$fuzzer $others seedcorpus -max_total_time=30 $MAXLEN\n@@ -123,6 +129,11 @@ jobs:\n         name: corpus\n         path: corpus.tar\n \n+    - name: Store the corpus externally\n+      run: |\n+        gzip --keep corpus.tar\n+        curl -F\"filedata=@corpus.tar.gz\" https://simdjson:${{ secrets.fuzzdatapassword }}@www.pauldreik.se/fuzzdata/index.php\n+\n     # This takes a subset of the minimized corpus and run it through valgrind. It is slow,\n     # therefore take a \"random\" subset. The random selection is accomplished by sorting on filenames,\n     # which are hashes of the content.\n@@ -143,15 +154,6 @@ jobs:\n         path: valgrind.tar\n         if-no-files-found: ignore\n \n-    - name: Upload the corpus and results to bintray if we are on master\n-      if: ${{ github.event_name == 'schedule' }} \n-      run: |\n-        echo uploading each artifact twice, otherwise it will not be published\n-        curl -T corpus.tar -upauldreik:${{ secrets.bintrayApiKey }} https://api.bintray.com/content/pauldreik/simdjson-fuzz-corpus/corpus/0/corpus/corpus.tar\";publish=1;override=1\"\n-        curl -T corpus.tar -upauldreik:${{ secrets.bintrayApiKey }} https://api.bintray.com/content/pauldreik/simdjson-fuzz-corpus/corpus/0/corpus/corpus.tar\";publish=1;override=1\"\n-        curl -T valgrind.tar -upauldreik:${{ secrets.bintrayApiKey }} https://api.bintray.com/content/pauldreik/simdjson-fuzz-corpus/corpus/0/corpus/valgrind.tar\";publish=1;override=1\"\n-        curl -T valgrind.tar -upauldreik:${{ secrets.bintrayApiKey }} https://api.bintray.com/content/pauldreik/simdjson-fuzz-corpus/corpus/0/corpus/valgrind.tar\";publish=1;override=1\"\n-\n     - name: Archive any crashes as an artifact\n       uses: actions/upload-artifact@v2\n       if: always()"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/macos-11.yml",
        "status": "added",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "patch": "@@ -0,0 +1,34 @@\n+name: Macos (Xcode 11)\n+\n+on: [push, pull_request]\n+\n+jobs:\n+  macos-build:\n+    if: >-\n+      ! contains(toJSON(github.event.commits.*.message), '[skip ci]') &&\n+      ! contains(toJSON(github.event.commits.*.message), '[skip github]')\n+    runs-on: macos-latest\n+    steps:\n+      - uses: actions/checkout@v2\n+      - uses: actions/cache@v2\n+        with:\n+          path: dependencies/.cache\n+          key: ${{ hashFiles('dependencies/CMakeLists.txt') }}\n+      - name: Use cmake\n+        run: |\n+          xcversion select 11.2.1\n+          mkdir builddebug &&\n+          cd builddebug &&\n+          cmake -DCMAKE_BUILD_TYPE=Debug -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF ..  &&\n+          cmake --build .   &&\n+          ctest -j --output-on-failure -LE explicitonly   &&\n+          cd .. &&\n+          mkdir build &&\n+          cd build &&\n+          cmake  -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n+          cmake --build .   &&\n+          ctest -j --output-on-failure -LE explicitonly   &&\n+          cmake --install . &&\n+          echo -e '#include <simdjson.h>\\nint main(int argc,char**argv) {simdjson::dom::parser parser;simdjson::dom::element tweets = parser.load(argv[1]); }' > tmp.cpp && c++ -Idestination/include -Ldestination/lib -std=c++17 -Wl,-rpath,destination/lib -o linkandrun tmp.cpp -lsimdjson && ./linkandrun jsonexamples/twitter.json &&\n+          cd ../tests/installation_tests/find &&\n+          mkdir build && cd build && cmake -DCMAKE_INSTALL_PREFIX:PATH=../../../build/destination .. &&  cmake --build ."
      },
      {
        "filename": "vendor/simdjson/.github/workflows/macos.yml",
        "status": "added",
        "additions": 33,
        "deletions": 0,
        "changes": 33,
        "patch": "@@ -0,0 +1,33 @@\n+name: Macos\n+\n+on: [push, pull_request]\n+\n+jobs:\n+  macos-build:\n+    if: >-\n+      ! contains(toJSON(github.event.commits.*.message), '[skip ci]') &&\n+      ! contains(toJSON(github.event.commits.*.message), '[skip github]')\n+    runs-on: macos-latest\n+    steps:\n+      - uses: actions/checkout@v2\n+      - uses: actions/cache@v2\n+        with:\n+          path: dependencies/.cache\n+          key: ${{ hashFiles('dependencies/CMakeLists.txt') }}\n+      - name: Use cmake\n+        run: |\n+          mkdir builddebug &&\n+          cd builddebug &&\n+          cmake -DCMAKE_BUILD_TYPE=Debug -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF ..  &&\n+          cmake --build .   &&\n+          ctest -j --output-on-failure -LE explicitonly   &&\n+          cd .. &&\n+          mkdir build &&\n+          cd build &&\n+          cmake  -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n+          cmake --build .   &&\n+          ctest -j --output-on-failure -LE explicitonly   &&\n+          cmake --install . &&\n+          echo -e '#include <simdjson.h>\\nint main(int argc,char**argv) {simdjson::dom::parser parser;simdjson::dom::element tweets = parser.load(argv[1]); }' > tmp.cpp && c++ -Idestination/include -Ldestination/lib -std=c++17 -Wl,-rpath,destination/lib -o linkandrun tmp.cpp -lsimdjson && ./linkandrun jsonexamples/twitter.json &&\n+          cd ../tests/installation_tests/find &&\n+          mkdir build && cd build && cmake -DCMAKE_INSTALL_PREFIX:PATH=../../../build/destination .. &&  cmake --build ."
      },
      {
        "filename": "vendor/simdjson/.github/workflows/mingw-ci.yml",
        "status": "modified",
        "additions": 5,
        "deletions": 10,
        "changes": 15,
        "patch": "@@ -1,12 +1,7 @@\n name: MinGW32-CI\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n+\n \n # Important: scoop will either install 32-bit GCC or 64-bit GCC, not both.\n \n@@ -22,7 +17,7 @@ jobs:\n     runs-on: windows-2016\n \n     env:\n-      CMAKE_GENERATOR: Ninja # This is critical, try ' cmake  -GNinja-DSIMDJSON_BUILD_STATIC=ON .. ' if using the command line\n+      CMAKE_GENERATOR: Ninja # This is critical, try ' cmake  -GNinja-DBUILD_SHARED_LIBS=OFF .. ' if using the command line\n       CC: gcc\n       CXX: g++\n \n@@ -47,7 +42,7 @@ jobs:\n         run: |\n           Invoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh')\n           scoop install sudo --global\n-          sudo scoop install git --global \n+          sudo scoop install git --global\n           sudo scoop install ninja --global\n           sudo scoop install cmake --global\n           sudo scoop install gcc --arch 32bit --global\n@@ -63,6 +58,6 @@ jobs:\n           git --version\n           mkdir build32\n           cd build32\n-          cmake -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_ENABLE_THREADS=OFF ..\n+          cmake -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_ENABLE_THREADS=OFF ..\n           cmake --build . --target acceptance_tests --verbose\n           ctest -L acceptance --output-on-failure"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/mingw64-ci.yml",
        "status": "modified",
        "additions": 5,
        "deletions": 10,
        "changes": 15,
        "patch": "@@ -1,12 +1,7 @@\n name: MinGW64-CI\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n+\n \n # Important: scoop will either install 32-bit GCC or 64-bit GCC, not both.\n \n@@ -22,7 +17,7 @@ jobs:\n     runs-on: windows-2016\n \n     env:\n-      CMAKE_GENERATOR: Ninja # This is critical, try ' cmake  -GNinja-DSIMDJSON_BUILD_STATIC=ON .. ' if using the command line\n+      CMAKE_GENERATOR: Ninja # This is critical, try ' cmake  -GNinja-DBUILD_SHARED_LIBS=OFF .. ' if using the command line\n       CC: gcc\n       CXX: g++\n \n@@ -63,12 +58,12 @@ jobs:\n           git --version\n           mkdir build64\n           cd build64\n-          cmake -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_ENABLE_THREADS=OFF ..\n+          cmake -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_ENABLE_THREADS=OFF ..\n           cmake --build . --target acceptance_tests --verbose\n           ctest -L acceptance --output-on-failure\n           cd ..\n           mkdir build64debug\n           cd build64debug\n-          cmake -DCMAKE_BUILD_TYPE=Debug -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_ENABLE_THREADS=OFF ..\n+          cmake -DSIMDJSON_DEVELOPER_MODE=ON -DCMAKE_BUILD_TYPE=Debug -DBUILD_SHARED_LIBS=OFF -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_ENABLE_THREADS=OFF ..\n           cmake --build . --target acceptance_tests --verbose\n           ctest -L acceptance --output-on-failure"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/msys2-clang.yml",
        "status": "modified",
        "additions": 7,
        "deletions": 12,
        "changes": 19,
        "patch": "@@ -1,12 +1,7 @@\n name: MSYS2-CLANG-CI\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n+\n \n jobs:\n   windows-mingw:\n@@ -20,16 +15,16 @@ jobs:\n       matrix:\n         include:\n           - msystem: \"MINGW64\"\n-            install: mingw-w64-x86_64-cmake mingw-w64-x86_64-ninja mingw-w64-x86_64-clang\n+            install: mingw-w64-x86_64-libxml2 mingw-w64-x86_64-cmake mingw-w64-x86_64-ninja mingw-w64-x86_64-clang\n             type: Release\n           - msystem: \"MINGW32\"\n-            install: mingw-w64-i686-cmake mingw-w64-i686-ninja mingw-w64-i686-clang\n+            install: mingw-w64-i686-libxml2 mingw-w64-i686-cmake mingw-w64-i686-ninja mingw-w64-i686-clang\n             type: Release\n           - msystem: \"MINGW64\"\n-            install: mingw-w64-x86_64-cmake mingw-w64-x86_64-ninja mingw-w64-x86_64-clang\n+            install: mingw-w64-x86_64-libxml2 mingw-w64-x86_64-cmake mingw-w64-x86_64-ninja mingw-w64-x86_64-clang\n             type: Debug\n           - msystem: \"MINGW32\"\n-            install: mingw-w64-i686-cmake mingw-w64-i686-ninja mingw-w64-i686-clang\n+            install: mingw-w64-i686-libxml2 mingw-w64-i686-cmake mingw-w64-i686-ninja mingw-w64-i686-clang\n             type: Debug\n     env:\n       CMAKE_GENERATOR: Ninja\n@@ -49,6 +44,6 @@ jobs:\n         run: |\n           mkdir build\n           cd build\n-          cmake -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_BUILD_TYPE=${{ matrix.type }} -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_DO_NOT_USE_THREADS_NO_MATTER_WHAT=ON ..\n+          cmake -DSIMDJSON_DEVELOPER_MODE=ON -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_BUILD_TYPE=${{ matrix.type }} -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_DO_NOT_USE_THREADS_NO_MATTER_WHAT=ON ..\n           cmake --build . --verbose\n           ctest -j4 --output-on-failure -LE explicitonly"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/msys2.yml",
        "status": "modified",
        "additions": 2,
        "deletions": 8,
        "changes": 10,
        "patch": "@@ -1,12 +1,6 @@\n name: MSYS2-CI\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   windows-mingw:\n@@ -52,6 +46,6 @@ jobs:\n         run: |\n           mkdir build\n           cd build\n-          cmake -DCMAKE_BUILD_TYPE=${{ matrix.type }} -DSIMDJSON_BUILD_STATIC=ON -DSIMDJSON_DO_NOT_USE_THREADS_NO_MATTER_WHAT=ON ..\n+          cmake -DSIMDJSON_DEVELOPER_MODE=ON -DCMAKE_BUILD_TYPE=${{ matrix.type }} -DBUILD_SHARED_LIBS=OFF -DSIMDJSON_DO_NOT_USE_THREADS_NO_MATTER_WHAT=ON ..\n           cmake --build . --verbose\n           ctest -j4 --output-on-failure -LE explicitonly"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/power-fuzz.yml",
        "status": "modified",
        "additions": 11,
        "deletions": 5,
        "changes": 16,
        "patch": "@@ -32,13 +32,19 @@ jobs:\n           run: |\n             export CLANGSUFFIX=\"-7\"\n             apt-get -qq update\n-            apt-get install -q -y clang-7 libfuzzer-7-dev cmake git wget zip ninja-build\n+            apt-get install -q -y clang-7 libfuzzer-7-dev git wget zip ninja-build gnupg software-properties-common\n+            wget -q -O - \"https://raw.githubusercontent.com/simdjson/debian-ppa/master/key.gpg\" | apt-key add -\n+            apt-add-repository \"deb https://raw.githubusercontent.com/simdjson/debian-ppa/master simdjson main\"\n+            apt-get -qq update\n+            apt-get purge cmake cmake-data\n+            apt-get -t simdjson -y install cmake\n             mkdir -p build ; cd build\n             cmake .. -GNinja \\\n                   -DCMAKE_CXX_COMPILER=clang++$CLANGSUFFIX \\\n                   -DCMAKE_C_COMPILER=clang$CLANGSUFFIX \\\n-                  -DSIMDJSON_BUILD_STATIC=Off \\\n-                  -DENABLE_FUZZING=On \\\n+                  -DBUILD_SHARED_LIBS=OFF \\\n+                  -DSIMDJSON_DEVELOPER_MODE=ON \\\n+                  -DSIMDJSON_ENABLE_FUZZING=On \\\n                   -DSIMDJSON_COMPETITION=OFF \\\n                   -DSIMDJSON_GOOGLE_BENCHMARKS=OFF \\\n                   -DSIMDJSON_DISABLE_DEPRECATED_API=On \\\n@@ -50,8 +56,8 @@ jobs:\n             cd ..\n             builddir=build\n             cmake --build $builddir\n-            wget --quiet https://dl.bintray.com/pauldreik/simdjson-fuzz-corpus/corpus/corpus.tar\n-            tar xf corpus.tar && rm corpus.tar\n+            wget -O corpus.tar.gz https://readonly:readonly@www.pauldreik.se/fuzzdata/index.php?project=simdjson\n+            tar xf corpus.tar.gz\n             fuzzernames=$(cmake --build $builddir --target print_all_fuzzernames |tail -n1)\n             for fuzzer in $fuzzernames ; do\n                exe=$builddir/fuzz/$fuzzer"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/ubuntu18-checkperf.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -24,6 +24,6 @@ jobs:\n         run: |\n           mkdir build &&\n           cd build &&\n-          cmake  -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_BUILD_STATIC=ON -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n+          cmake  -DSIMDJSON_DEVELOPER_MODE=ON -DSIMDJSON_ENABLE_DOM_CHECKPERF=ON -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n           cmake --build . --target checkperf  &&\n           ctest --output-on-failure -R checkperf  ubuntu18-checkperf.yml"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/ubuntu18-oldclang.yml",
        "status": "added",
        "additions": 31,
        "deletions": 0,
        "changes": 31,
        "patch": "@@ -0,0 +1,31 @@\n+name: Ubuntu 18.04 CI (LLVM 7)\n+\n+on: [push, pull_request]\n+\n+jobs:\n+  ubuntu-build:\n+    if: >-\n+      ! contains(toJSON(github.event.commits.*.message), '[skip ci]') &&\n+      ! contains(toJSON(github.event.commits.*.message), '[skip github]')\n+    runs-on: ubuntu-18.04\n+\n+    env:\n+      CC: clang-7\n+      CXX: clang++-7\n+    steps:\n+      - uses: actions/checkout@v2\n+      - uses: actions/cache@v2\n+        with:\n+          path: dependencies/.cache\n+          key: ${{ hashFiles('dependencies/CMakeLists.txt') }}\n+      - name: install clang 7\n+        run: |\n+          sudo apt update\n+          sudo apt install clang-7\n+      - name: Use cmake\n+        run: |\n+          mkdir build &&\n+          cd build &&\n+          cmake  -DSIMDJSON_DEVELOPER_MODE=ON -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n+          cmake --build .   &&\n+          ctest -j --output-on-failure -LE explicitonly"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/ubuntu18-threadsani.yml",
        "status": "modified",
        "additions": 4,
        "deletions": 9,
        "changes": 13,
        "patch": "@@ -1,12 +1,7 @@\n name: Ubuntu 18.04 CI (GCC 7) with Thread Sanitizer\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n+\n \n jobs:\n   ubuntu-build:\n@@ -24,7 +19,7 @@ jobs:\n         run: |\n           mkdir build &&\n           cd build &&\n-          cmake  -DSIMDJSON_SANITIZE_THREADS=ON ..  &&\n-          cmake --build . --target document_stream_tests --target parse_many_test  &&\n+          cmake  -DSIMDJSON_DEVELOPER_MODE=ON -DSIMDJSON_SANITIZE_THREADS=ON ..  &&\n+          cmake --build . --target document_stream_tests --target ondemand_document_stream_tests --target parse_many_test  &&\n           ctest --output-on-failure  -R parse_many_test  &&\n           ctest --output-on-failure  -R document_stream_tests\n\\ No newline at end of file"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/ubuntu18.yml",
        "status": "modified",
        "additions": 2,
        "deletions": 8,
        "changes": 10,
        "patch": "@@ -1,12 +1,6 @@\n name: Ubuntu 18.04 CI (GCC 7)\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   ubuntu-build:\n@@ -24,7 +18,7 @@ jobs:\n         run: |\n           mkdir build &&\n           cd build &&\n-          cmake  -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_BUILD_STATIC=ON -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n+          cmake  -DSIMDJSON_DEVELOPER_MODE=ON -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n           cmake --build .   &&\n           ctest -j --output-on-failure -LE explicitonly   &&\n           make install  &&"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/ubuntu20-checkperf.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -24,6 +24,6 @@ jobs:\n         run: |\n           mkdir build &&\n           cd build &&\n-          cmake  -DCMAKE_CXX_FLAGS=\"-Werror=old-style-cast -pedantic -Wpedantic\" -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_BUILD_STATIC=ON -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n+          cmake  -DSIMDJSON_DEVELOPER_MODE=ON -DSIMDJSON_ENABLE_DOM_CHECKPERF=ON -DCMAKE_CXX_FLAGS=\"-Werror=old-style-cast -pedantic -Wpedantic\" -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n           cmake --build . --target checkperf  &&\n           ctest --output-on-failure -R checkperf"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/ubuntu20-noexcept.yml",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "patch": "@@ -1,12 +1,6 @@\n name: Ubuntu 20.04 CI (GCC 9) without exceptions\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   ubuntu-build:\n@@ -22,9 +16,15 @@ jobs:\n           key: ${{ hashFiles('dependencies/CMakeLists.txt') }}\n       - name: Use cmake\n         run: |\n+          mkdir builddebug &&\n+          cd builddebug &&\n+          cmake -DCMAKE_BUILD_TYPE=Debug -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_DEVELOPER_MODE=ON -DSIMDJSON_EXCEPTIONS=OFF -DBUILD_SHARED_LIBS=OFF ..  &&\n+          cmake --build .   &&\n+          ctest -j --output-on-failure -LE explicitonly   &&\n+          cd .. &&\n           mkdir build &&\n           cd build &&\n-          cmake  -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_EXCEPTIONS=OFF -DSIMDJSON_BUILD_STATIC=ON -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n+          cmake  -DSIMDJSON_DEVELOPER_MODE=ON -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_EXCEPTIONS=OFF -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n           cmake --build .   &&\n           ctest -j --output-on-failure -LE explicitonly   &&\n           make install  &&"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/ubuntu20-nothread.yml",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "patch": "@@ -1,12 +1,6 @@\n-name: Ubuntu 20.04 CI (GCC 9) without threads\n+name: Ubuntu 20.04 CI (GCC 9) Without Threads\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   ubuntu-build:\n@@ -22,9 +16,15 @@ jobs:\n           key: ${{ hashFiles('dependencies/CMakeLists.txt') }}\n       - name: Use cmake\n         run: |\n+          mkdir builddebug &&\n+          cd builddebug &&\n+          cmake -DCMAKE_BUILD_TYPE=Debug -DSIMDJSON_GOOGLE_BENCHMARKS=OFF  -DSIMDJSON_ENABLE_THREADS=OFF -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF ..  &&\n+          cmake --build .   &&\n+          ctest -j --output-on-failure -LE explicitonly   &&\n+          cd .. &&\n           mkdir build &&\n           cd build &&\n-          cmake  -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_ENABLE_THREADS=OFF -DSIMDJSON_BUILD_STATIC=ON -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n+          cmake  -DSIMDJSON_DEVELOPER_MODE=ON -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_ENABLE_THREADS=OFF -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n           cmake --build .   &&\n           ctest -j --output-on-failure -LE explicitonly   &&\n           make install  &&"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/ubuntu20-sani.yml",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "patch": "@@ -0,0 +1,23 @@\n+name: Ubuntu 20.04 CI (GCC 9) With Memory Sanitizer\n+\n+on: [push, pull_request]\n+\n+jobs:\n+  ubuntu-build:\n+    if: >-\n+      ! contains(toJSON(github.event.commits.*.message), '[skip ci]') &&\n+      ! contains(toJSON(github.event.commits.*.message), '[skip github]')\n+    runs-on: ubuntu-20.04\n+    steps:\n+      - uses: actions/checkout@v2\n+      - uses: actions/cache@v2\n+        with:\n+          path: dependencies/.cache\n+          key: ${{ hashFiles('dependencies/CMakeLists.txt') }}\n+      - name: Use cmake\n+        run: |\n+          mkdir builddebug &&\n+          cd builddebug &&\n+          cmake -DSIMDJSON_SANITIZE=ON -DCMAKE_BUILD_TYPE=Debug -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF ..  &&\n+          cmake --build .   &&\n+          ctest -j --output-on-failure -LE explicitonly\n\\ No newline at end of file"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/ubuntu20-threadsani.yml",
        "status": "modified",
        "additions": 3,
        "deletions": 9,
        "changes": 12,
        "patch": "@@ -1,12 +1,6 @@\n name: Ubuntu 20.04 CI (GCC 9) with Thread Sanitizer\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   ubuntu-build:\n@@ -24,7 +18,7 @@ jobs:\n         run: |\n           mkdir build &&\n           cd build &&\n-          cmake  -DSIMDJSON_SANITIZE_THREADS=ON ..  &&\n-          cmake --build . --target document_stream_tests --target parse_many_test  &&\n+          cmake  -DSIMDJSON_DEVELOPER_MODE=ON -DSIMDJSON_SANITIZE_THREADS=ON ..  &&\n+          cmake --build . --target document_stream_tests  --target ondemand_document_stream_tests --target parse_many_test  &&\n           ctest --output-on-failure  -R parse_many_test  &&\n           ctest --output-on-failure  -R document_stream_tests\n\\ No newline at end of file"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/ubuntu20.yml",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "patch": "@@ -1,12 +1,6 @@\n name: Ubuntu 20.04 CI (GCC 9)\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   ubuntu-build:\n@@ -22,9 +16,15 @@ jobs:\n           key: ${{ hashFiles('dependencies/CMakeLists.txt') }}\n       - name: Use cmake\n         run: |\n+          mkdir builddebug &&\n+          cd builddebug &&\n+          cmake -DCMAKE_BUILD_TYPE=Debug -DSIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF ..  &&\n+          cmake --build .   &&\n+          ctest -j --output-on-failure -LE explicitonly   &&\n+          cd .. &&\n           mkdir build &&\n           cd build &&\n-          cmake  -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_BUILD_STATIC=ON -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n+          cmake  -DSIMDJSON_GOOGLE_BENCHMARKS=ON -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX:PATH=destination ..  &&\n           cmake --build .   &&\n           ctest -j --output-on-failure -LE explicitonly   &&\n           cmake --install . &&"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/vs15-ci.yml",
        "status": "modified",
        "additions": 7,
        "deletions": 9,
        "changes": 16,
        "patch": "@@ -1,12 +1,6 @@\n name: VS15-CI\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   ci:\n@@ -28,15 +22,19 @@ jobs:\n       uses: actions/checkout@v2\n     - name: Configure\n       run: |\n-        cmake -G \"${{matrix.gen}}\" -A ${{matrix.arch}} -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_BUILD_STATIC=${{matrix.static}} -B build\n+        cmake -G \"${{matrix.gen}}\" -A ${{matrix.arch}} -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_DEVELOPER_MODE=ON -DSIMDJSON_BUILD_STATIC=${{matrix.static}} -B build\n     - name: Build Debug\n       run: cmake --build build --config Debug --verbose\n     - name: Build Release\n       run: cmake --build build --config Release --verbose\n-    - name: Run tests\n+    - name: Run Release tests\n       run: |\n         cd build\n         ctest -C Release  -LE explicitonly  --output-on-failure\n+    - name: Run Debug tests\n+      run: |\n+        cd build\n+        ctest -C Debug  -LE explicitonly  --output-on-failure\n     - name: Install\n       run: |\n         cmake --install build --config Release"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/vs16-arm-ci.yml",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "patch": "@@ -0,0 +1,21 @@\n+name: VS16-ARM-CI\n+\n+on: [push, pull_request]\n+\n+jobs:\n+   ci:\n+     name: windows-vs16\n+     runs-on: windows-latest\n+     strategy:\n+       fail-fast: false\n+       matrix:\n+         include:\n+           - {arch: ARM}\n+           - {arch: ARM64}\n+     steps:\n+       - name: checkout\n+         uses: actions/checkout@v2\n+       - name: Use cmake\n+         run: |\n+           cmake -A ${{ matrix.arch }} -DCMAKE_CROSSCOMPILING=1 -DSIMDJSON_DEVELOPER_MODE=ON -D SIMDJSON_GOOGLE_BENCHMARKS=OFF -DSIMDJSON_EXCEPTIONS=OFF -B build  &&\n+           cmake --build build --verbose\n\\ No newline at end of file"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/vs16-ci.yml",
        "status": "modified",
        "additions": 7,
        "deletions": 9,
        "changes": 16,
        "patch": "@@ -1,12 +1,6 @@\n name: VS16-CI\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   ci:\n@@ -28,15 +22,19 @@ jobs:\n       uses: actions/checkout@v2\n     - name: Configure\n       run: |\n-        cmake -G \"${{matrix.gen}}\" -A ${{matrix.arch}} -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_BUILD_STATIC=${{matrix.static}} -B build\n+        cmake -G \"${{matrix.gen}}\" -A ${{matrix.arch}} -DSIMDJSON_DEVELOPER_MODE=ON -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_BUILD_STATIC=${{matrix.static}} -B build\n     - name: Build Debug\n       run: cmake --build build --config Debug --verbose\n     - name: Build Release\n       run: cmake --build build --config Release --verbose\n-    - name: Run tests\n+    - name: Run Release tests\n       run: |\n         cd build\n         ctest -C Release  -LE explicitonly  --output-on-failure\n+    - name: Run Debug tests\n+      run: |\n+        cd build\n+        ctest -C Debug  -LE explicitonly  --output-on-failure\n     - name: Install\n       run: |\n         cmake --install build --config Release"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/vs16-clang-ci.yml",
        "status": "modified",
        "additions": 3,
        "deletions": 9,
        "changes": 12,
        "patch": "@@ -1,12 +1,6 @@\n name: VS16-CLANG-CI\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   ci:\n@@ -29,9 +23,9 @@ jobs:\n         buildDirectory: \"${{ github.workspace }}/../../_temp/windows\"\n         cmakeBuildType: Release\n         buildWithCMake: true\n-        cmakeAppendedArgs:  -T ClangCL -DSIMDJSON_COMPETITION=OFF  -DSIMDJSON_BUILD_STATIC=ON\n+        cmakeAppendedArgs:  -T ClangCL -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF\n         buildWithCMakeArgs: --config Release\n-    \n+\n     - name: 'Run CTest'\n       run: ctest -C Release -LE explicitonly  --output-on-failure\n       working-directory: \"${{ github.workspace }}/../../_temp/windows\"\n\\ No newline at end of file"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/vs16-ninja-ci.yml",
        "status": "modified",
        "additions": 2,
        "deletions": 8,
        "changes": 10,
        "patch": "@@ -1,12 +1,6 @@\n name: VS16-Ninja-CI\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   ci:\n@@ -29,7 +23,7 @@ jobs:\n         buildDirectory: \"${{ github.workspace }}/../../_temp/windows\"\n         cmakeBuildType: Release\n         buildWithCMake: true\n-        cmakeAppendedArgs:  -G Ninja -DSIMDJSON_COMPETITION=OFF   -DSIMDJSON_BUILD_STATIC=ON\n+        cmakeAppendedArgs:  -G Ninja -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_DEVELOPER_MODE=ON -DBUILD_SHARED_LIBS=OFF\n         buildWithCMakeArgs: --config Release\n     - name: 'Run CTest'\n       run: ctest -C Release  -LE explicitonly  --output-on-failure"
      },
      {
        "filename": "vendor/simdjson/.github/workflows/vs16-noexcept-ci.yml",
        "status": "modified",
        "additions": 2,
        "deletions": 8,
        "changes": 10,
        "patch": "@@ -1,12 +1,6 @@\n name: VS16-NoExcept-CI\n \n-on:\n-  push:\n-    branches:\n-      - master\n-  pull_request:\n-    branches:\n-      - master\n+on: [push, pull_request]\n \n jobs:\n   ci:\n@@ -27,7 +21,7 @@ jobs:\n         cmakeBuildType: Release\n         buildWithCMake: true\n         cmakeGenerator: VS16Win64\n-        cmakeAppendedArgs: -DSIMDJSON_COMPETITION=OFF  -DSIMDJSON_EXCEPTIONS=OFF\n+        cmakeAppendedArgs: -DSIMDJSON_COMPETITION=OFF -DSIMDJSON_DEVELOPER_MODE=ON  -DSIMDJSON_EXCEPTIONS=OFF\n         buildWithCMakeArgs: --config Release\n \n     - name: 'Run CTest'"
      },
      {
        "filename": "vendor/simdjson/.travis.yml",
        "status": "modified",
        "additions": 27,
        "deletions": 25,
        "changes": 52,
        "patch": "@@ -48,17 +48,18 @@ matrix:\n         - COMPILER=\"CC=gcc-10 && CXX=g++-10\"\n       compiler: gcc-10\n \n-    - os: linux\n-      addons:\n-        apt:\n-          sources:\n-            - ubuntu-toolchain-r-test\n-          packages:\n-            - g++-10\n-      env:\n-        - COMPILER=\"CC=gcc-10 && CXX=g++-10\"\n-        - SANITIZE=\"on\"\n-      compiler: gcc-10-sanitize\n+# The sanitizer runs fail systematically\n+#    - os: linux\n+#      addons:\n+#        apt:\n+#          sources:\n+#            - ubuntu-toolchain-r-test\n+#          packages:\n+#            - g++-10\n+#      env:\n+#        - COMPILER=\"CC=gcc-10 && CXX=g++-10\"\n+#        - SANITIZE=\"on\"\n+#      compiler: gcc-10-sanitize\n \n     - os: linux\n       addons:\n@@ -143,19 +144,20 @@ matrix:\n         - STATIC=\"on\"\n       compiler: clang-10-static\n \n-    - os: linux\n-      addons:\n-        apt:\n-          packages:\n-            - clang-10\n-          sources:\n-            - ubuntu-toolchain-r-test\n-            - sourceline: 'deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-10 main'\n-              key_url: 'https://apt.llvm.org/llvm-snapshot.gpg.key'\n-      env:\n-        - COMPILER=\"CC=clang-10 && CXX=clang++-10\"\n-        - SANITIZE=\"on\"\n-      compiler: clang-10-sanitize\n+# The clang sanitizer runs fail frequently at setup time\n+#    - os: linux\n+#      addons:\n+#        apt:\n+#          packages:\n+#            - clang-10\n+#          sources:\n+#            - ubuntu-toolchain-r-test\n+#            - sourceline: 'deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-10 main'\n+#              key_url: 'https://apt.llvm.org/llvm-snapshot.gpg.key'\n+#      env:\n+#        - COMPILER=\"CC=clang-10 && CXX=clang++-10\"\n+#        - SANITIZE=\"on\"\n+#      compiler: clang-10-sanitize\n \n before_install:\n   - eval \"${COMPILER}\"\n@@ -174,7 +176,7 @@ install:\n       export ASAN_OPTIONS=\"detect_leaks=0\";\n     fi\n   - if [[ \"${STATIC}\" == \"on\" ]]; then\n-      export CMAKE_FLAGS=\"${CMAKE_FLAGS} -DSIMDJSON_BUILD_STATIC=ON\";\n+      export CMAKE_FLAGS=\"${CMAKE_FLAGS} -DBUILD_SHARED_LIBS=OFF\";\n     fi\n   - export CTEST_FLAGS=\"-j4 --output-on-failure -LE explicitonly\"\n "
      },
      {
        "filename": "vendor/simdjson/.vscode/extensions.json",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "patch": "@@ -0,0 +1,17 @@\n+{\n+\t// See https://go.microsoft.com/fwlink/?LinkId=827846 to learn about workspace recommendations.\n+\t// Extension identifier format: ${publisher}.${name}. Example: vscode.csharp\n+\n+\t// List of extensions which should be recommended for users of this workspace.\n+\t\"recommendations\": [\n+\t\t// Syntax\n+\t\t\"ms-vscode.cpptools\",\n+\t\t\"ms-vscode.cmake-tools\",\n+\t\t\"ms-python.python\",\n+\t\t\"twxs.cmake\"\n+\t],\n+\t// List of extensions recommended by VS Code that should not be recommended for users of this workspace.\n+\t\"unwantedRecommendations\": [\n+\n+\t]\n+}\n\\ No newline at end of file"
      },
      {
        "filename": "vendor/simdjson/.vscode/settings.json",
        "status": "added",
        "additions": 91,
        "deletions": 0,
        "changes": 91,
        "patch": "@@ -0,0 +1,91 @@\n+{\n+    \"editor.rulers\": [\n+        {\"column\": 95 },\n+        {\"column\": 120 }\n+    ],\n+    \"files.trimTrailingWhitespace\": true,\n+    \"files.associations\": {\n+        \"array\": \"cpp\",\n+        \"iterator\": \"cpp\",\n+        \"chrono\": \"cpp\",\n+        \"optional\": \"cpp\",\n+        \"__locale\": \"cpp\",\n+        \"__tuple\": \"cpp\",\n+        \"__bit_reference\": \"cpp\",\n+        \"__config\": \"cpp\",\n+        \"__debug\": \"cpp\",\n+        \"__errc\": \"cpp\",\n+        \"__functional_base\": \"cpp\",\n+        \"__hash_table\": \"cpp\",\n+        \"__mutex_base\": \"cpp\",\n+        \"__node_handle\": \"cpp\",\n+        \"__nullptr\": \"cpp\",\n+        \"__split_buffer\": \"cpp\",\n+        \"__string\": \"cpp\",\n+        \"__threading_support\": \"cpp\",\n+        \"__tree\": \"cpp\",\n+        \"algorithm\": \"cpp\",\n+        \"atomic\": \"cpp\",\n+        \"bit\": \"cpp\",\n+        \"bitset\": \"cpp\",\n+        \"cctype\": \"cpp\",\n+        \"cinttypes\": \"cpp\",\n+        \"clocale\": \"cpp\",\n+        \"cmath\": \"cpp\",\n+        \"codecvt\": \"cpp\",\n+        \"complex\": \"cpp\",\n+        \"condition_variable\": \"cpp\",\n+        \"cstdarg\": \"cpp\",\n+        \"cstddef\": \"cpp\",\n+        \"cstdint\": \"cpp\",\n+        \"cstdio\": \"cpp\",\n+        \"cstdlib\": \"cpp\",\n+        \"cstring\": \"cpp\",\n+        \"ctime\": \"cpp\",\n+        \"cwchar\": \"cpp\",\n+        \"cwctype\": \"cpp\",\n+        \"deque\": \"cpp\",\n+        \"exception\": \"cpp\",\n+        \"forward_list\": \"cpp\",\n+        \"fstream\": \"cpp\",\n+        \"functional\": \"cpp\",\n+        \"initializer_list\": \"cpp\",\n+        \"iomanip\": \"cpp\",\n+        \"ios\": \"cpp\",\n+        \"iosfwd\": \"cpp\",\n+        \"iostream\": \"cpp\",\n+        \"istream\": \"cpp\",\n+        \"limits\": \"cpp\",\n+        \"list\": \"cpp\",\n+        \"locale\": \"cpp\",\n+        \"map\": \"cpp\",\n+        \"memory\": \"cpp\",\n+        \"mutex\": \"cpp\",\n+        \"new\": \"cpp\",\n+        \"numeric\": \"cpp\",\n+        \"ostream\": \"cpp\",\n+        \"random\": \"cpp\",\n+        \"ratio\": \"cpp\",\n+        \"regex\": \"cpp\",\n+        \"set\": \"cpp\",\n+        \"sstream\": \"cpp\",\n+        \"stack\": \"cpp\",\n+        \"stdexcept\": \"cpp\",\n+        \"streambuf\": \"cpp\",\n+        \"string\": \"cpp\",\n+        \"string_view\": \"cpp\",\n+        \"system_error\": \"cpp\",\n+        \"thread\": \"cpp\",\n+        \"tuple\": \"cpp\",\n+        \"type_traits\": \"cpp\",\n+        \"typeinfo\": \"cpp\",\n+        \"unordered_map\": \"cpp\",\n+        \"unordered_set\": \"cpp\",\n+        \"utility\": \"cpp\",\n+        \"valarray\": \"cpp\",\n+        \"vector\": \"cpp\",\n+        \"*.ipp\": \"cpp\",\n+        \"__functional_base_03\": \"cpp\",\n+        \"filesystem\": \"cpp\"\n+    }\n+}\n\\ No newline at end of file"
      },
      {
        "filename": "vendor/simdjson/CMakeLists.txt",
        "status": "modified",
        "additions": 241,
        "deletions": 71,
        "changes": 312,
        "patch": "@@ -1,97 +1,267 @@\n cmake_minimum_required(VERSION 3.9)\n-# CMP0025: Compiler id for Apple Clang is now AppleClang.\n-# https://cmake.org/cmake/help/v3.17/policy/CMP0025.html\n-cmake_policy(SET CMP0025 NEW)\n-project(simdjson\n-  DESCRIPTION \"Parsing gigabytes of JSON per second\"\n-  LANGUAGES CXX C\n+\n+project(\n+    simdjson\n+    # The version number is modified by tools/release.py\n+    VERSION 1.0.0\n+    DESCRIPTION \"Parsing gigabytes of JSON per second\"\n+    LANGUAGES CXX C\n+)\n+\n+set(SIMDJSON_GITHUB_REPOSITORY \"https://github.com/simdjson/simdjson\")\n+\n+string(\n+    COMPARE EQUAL\n+    \"${CMAKE_SOURCE_DIR}\" \"${CMAKE_CURRENT_SOURCE_DIR}\"\n+    is_top_project\n )\n \n-set(PROJECT_VERSION_MAJOR 0)\n-set(PROJECT_VERSION_MINOR 9)\n-set(PROJECT_VERSION_PATCH 6)\n-set(SIMDJSON_SEMANTIC_VERSION \"0.9.6\" CACHE STRING \"simdjson semantic version\")\n-set(SIMDJSON_LIB_VERSION \"8.0.0\" CACHE STRING \"simdjson library version\")\n-set(SIMDJSON_LIB_SOVERSION \"8\" CACHE STRING \"simdjson library soversion\")\n-set(SIMDJSON_GITHUB_REPOSITORY https://github.com/simdjson/simdjson)\n+# ---- Options, variables ----\n+\n+# These version numbers are modified by tools/release.py\n+set(SIMDJSON_LIB_VERSION \"9.0.0\" CACHE STRING \"simdjson library version\")\n+set(SIMDJSON_LIB_SOVERSION \"9\" CACHE STRING \"simdjson library soversion\")\n \n+option(SIMDJSON_ENABLE_THREADS \"Link with thread support\" ON)\n+\n+include(cmake/simdjson-props.cmake)\n+include(cmake/implementation-flags.cmake)\n+include(cmake/exception-flags.cmake)\n+\n+option(SIMDJSON_DISABLE_DEPRECATED_API \"Disables deprecated APIs\" OFF)\n+if(SIMDJSON_DISABLE_DEPRECATED_API)\n+  simdjson_add_props(\n+      target_compile_definitions PUBLIC\n+      SIMDJSON_DISABLE_DEPRECATED_API=1\n+  )\n+endif()\n+\n+option(SIMDJSON_DEVELOPMENT_CHECKS \"Enable development-time aids, such as \\\n+checks for incorrect API usage. Enabled by default in DEBUG.\" OFF)\n+if(SIMDJSON_DEVELOPMENT_CHECKS)\n+  simdjson_add_props(\n+      target_compile_definitions PUBLIC\n+      SIMDJSON_DEVELOPMENT_CHECKS\n+  )\n+endif()\n+\n+if(is_top_project)\n+  option(SIMDJSON_DEVELOPER_MODE \"Enable targets for developing simdjson\" OFF)\n+  option(BUILD_SHARED_LIBS \"Build simdjson as a shared library\" OFF)\n+\n+  if(\"$ENV{CI}\")\n+    set(SIMDJSON_DEVELOPER_MODE ON CACHE INTERNAL \"\")\n+  endif()\n+endif()\n+\n+include(cmake/handle-deprecations.cmake)\n+\n+if(SIMDJSON_DEVELOPER_MODE)\n+  include(cmake/developer-options.cmake)\n+else()\n+  message(STATUS \"Building only the library. Advanced users may want to turn SIMDJSON_DEVELOPER_MODE to ON, e.g., via -D SIMDJSON_DEVELOPER_MODE=ON.\")\n+endif()\n+\n+# ---- simdjson library ----\n+\n+add_library(simdjson src/simdjson.cpp)\n+add_library(simdjson::simdjson ALIAS simdjson)\n+\n+set_target_properties(\n+    simdjson PROPERTIES\n+    VERSION \"${SIMDJSON_LIB_VERSION}\"\n+    SOVERSION \"${SIMDJSON_LIB_SOVERSION}\"\n+    # FIXME: symbols should be hidden by default\n+    WINDOWS_EXPORT_ALL_SYMBOLS YES\n+)\n+\n+# FIXME: Use proper CMake integration for exports\n+if(MSVC AND BUILD_SHARED_LIBS)\n+  target_compile_definitions(\n+      simdjson\n+      PRIVATE SIMDJSON_BUILDING_WINDOWS_DYNAMIC_LIBRARY=1\n+      INTERFACE SIMDJSON_USING_WINDOWS_DYNAMIC_LIBRARY=1\n+  )\n+endif()\n+\n+simdjson_add_props(\n+    target_include_directories\n+    PUBLIC \"$<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>\"\n+    PRIVATE \"$<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/src>\"\n+)\n+\n+simdjson_add_props(target_compile_features PUBLIC cxx_std_11)\n+\n+# workaround for GNU GCC poor AVX load/store code generation\n+if(\n+    CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\"\n+    AND CMAKE_SYSTEM_PROCESSOR MATCHES \"^(i.86|x86(_64)?)$\"\n+)\n+  simdjson_add_props(\n+      target_compile_options PRIVATE\n+      -mno-avx256-split-unaligned-load -mno-avx256-split-unaligned-store\n+  )\n+endif()\n+\n+if(SIMDJSON_ENABLE_THREADS)\n+  find_package(Threads REQUIRED)\n+  simdjson_add_props(target_link_libraries PUBLIC Threads::Threads)\n+  simdjson_add_props(target_compile_definitions PUBLIC SIMDJSON_THREADS_ENABLED=1)\n+endif()\n+\n+simdjson_apply_props(simdjson)\n+\n+# ---- Install rules ----\n+\n+include(CMakePackageConfigHelpers)\n include(GNUInstallDirs)\n-include(cmake/simdjson-flags.cmake)\n-include(cmake/simdjson-user-cmakecache.cmake)\n \n+install(\n+    FILES singleheader/simdjson.h\n+    DESTINATION \"${CMAKE_INSTALL_INCLUDEDIR}\"\n+    COMPONENT simdjson_Development\n+)\n+\n+configure_file(cmake/simdjson-config.cmake.in simdjson-config.cmake @ONLY)\n \n+set(\n+    SIMDJSON_INSTALL_CMAKEDIR \"${CMAKE_INSTALL_LIBDIR}/cmake/simdjson\"\n+    CACHE STRING \"CMake package config location relative to the install prefix\"\n+)\n+mark_as_advanced(SIMDJSON_INSTALL_CMAKEDIR)\n \n-if(SIMDJSON_JUST_LIBRARY)\n-  message( STATUS \"Building just the library, omitting all tests, tools and benchmarks.\" )\n-else(SIMDJSON_JUST_LIBRARY)\n-  # Setup tests\n-  enable_testing()\n-  add_subdirectory(jsonchecker)\n-  add_subdirectory(jsonexamples)\n-  add_library(test-data INTERFACE)\n-  target_link_libraries(test-data INTERFACE jsonchecker-data jsonchecker-minefield-data jsonexamples-data)\n-endif(SIMDJSON_JUST_LIBRARY)\n+install(\n+    FILES\n+    \"${PROJECT_BINARY_DIR}/simdjson-config.cmake\"\n+    \"${PROJECT_BINARY_DIR}/simdjson-config-version.cmake\"\n+    DESTINATION \"${SIMDJSON_INSTALL_CMAKEDIR}\"\n+    COMPONENT simdjson_Development\n+)\n \n-# Create the top level simdjson library (must be done at this level to use both src/ and include/\n-# directories) and tools\n #\n-add_subdirectory(include)\n-add_subdirectory(src)\n-add_subdirectory(windows)\n-if(NOT(SIMDJSON_JUST_LIBRARY))\n-  add_subdirectory(dependencies) ## This needs to be before tools because of cxxopts\n-  add_subdirectory(tools)  ## This needs to be before tests because of cxxopts\n-  add_subdirectory(singleheader)\n+# CPack\n+#\n+if(is_top_project)\n+  set(CPACK_PACKAGE_VENDOR \"Daniel Lemire\")\n+  set(CPACK_PACKAGE_CONTACT \"lemire@gmail.com\")\n+  set(CPACK_RESOURCE_FILE_LICENSE \"${PROJECT_SOURCE_DIR}/LICENSE\")\n+  set(CPACK_RESOURCE_FILE_README \"${PROJECT_SOURCE_DIR}/README.md\")\n+\n+  set(CPACK_RPM_PACKAGE_LICENSE \"${PROJECT_SOURCE_DIR}/LICENSE\")\n+\n+  set(CPACK_SOURCE_GENERATOR \"TGZ;ZIP\")\n+\n+  include(CPack)\n endif()\n-install(FILES singleheader/simdjson.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n \n-option(SIMDJSON_ENABLE_THREADS \"Link with thread support\" ON)\n-include(CMakePackageConfigHelpers)\n-configure_package_config_file(\"${PROJECT_SOURCE_DIR}/cmake/simdjson-config.cmake.in\"\n-      \"${PROJECT_BINARY_DIR}/simdjson-config.cmake\"\n-      INSTALL_DESTINATION \"${CMAKE_INSTALL_LIBDIR}/cmake/simdjson\"\n-      NO_SET_AND_CHECK_MACRO\n-      NO_CHECK_REQUIRED_COMPONENTS_MACRO)\n+# ---- Developer mode extras ----\n+\n+if(NOT SIMDJSON_DEVELOPER_MODE)\n+  return()\n+elseif(NOT is_top_project)\n+  message(AUTHOR_WARNING \"Developer mode is intended for developers of simdjson\")\n+endif()\n+\n+simdjson_apply_props(simdjson-internal-flags)\n+\n+set(\n+    SIMDJSON_USER_CMAKECACHE\n+    \"${CMAKE_BINARY_DIR}/.simdjson-user-CMakeCache.txt\"\n+)\n+add_custom_target(\n+    simdjson-user-cmakecache\n+    COMMAND \"${CMAKE_COMMAND}\"\n+    -D \"BINARY_DIR=${CMAKE_BINARY_DIR}\"\n+    -D \"USER_CMAKECACHE=${SIMDJSON_USER_CMAKECACHE}\"\n+    -P \"${PROJECT_SOURCE_DIR}/cmake/simdjson-user-cmakecache.cmake\"\n+    VERBATIM\n+)\n+\n+# Setup tests\n+enable_testing()\n+# So we can build just tests with \"make all_tests\"\n+add_custom_target(all_tests)\n+\n+add_subdirectory(windows)\n+add_subdirectory(dependencies) ## This needs to be before tools because of cxxopts\n+add_subdirectory(tools)  ## This needs to be before tests because of cxxopts\n+\n+# Data: jsonexamples is left with only the bare essential.\n+# most of the data has been moved to https://github.com/simdjson/simdjson-data\n+add_subdirectory(jsonexamples)\n+\n+\n+add_subdirectory(singleheader)\n+\n+\n \n #\n # Compile tools / tests / benchmarks\n #\n-if(NOT(SIMDJSON_JUST_LIBRARY))\n-  add_subdirectory(tests)\n-  add_subdirectory(examples)\n-  add_subdirectory(benchmark)\n-  add_subdirectory(fuzz)\n-endif()\n+add_subdirectory(tests)\n+add_subdirectory(examples)\n+add_subdirectory(benchmark)\n+add_subdirectory(fuzz)\n \n #\n # Source files should be just ASCII\n #\n find_program(FIND find)\n find_program(FILE file)\n find_program(GREP grep)\n-if((FIND) AND (FILE) AND (GREP))\n+if(FIND AND FILE AND GREP)\n+  add_test(\n+      NAME just_ascii\n+      COMMAND sh -c \"\\\n+${FIND} include src windows tools singleheader tests examples benchmark \\\n+-path benchmark/checkperf-reference -prune -name '*.h' -o -name '*.cpp' \\\n+-type f -exec ${FILE} '{}' \\; | ${GREP} -qv ASCII || exit 0  && exit 1\"\n+      WORKING_DIRECTORY \"${PROJECT_SOURCE_DIR}\"\n+  )\n+endif()\n+\n+##\n+## In systems like R, libraries must not use stderr or abort to be acceptable.\n+## Thus we make it a hard rule that one is not allowed to call abort or stderr.\n+## The sanitized builds are allowed to abort.\n+##\n+if(NOT SIMDJSON_SANITIZE)\n+  find_program(GREP grep)\n+  find_program(NM nm)\n+  if((NOT GREP) OR (NOT NM))\n+    message(\"grep and nm are unavailable on this system.\")\n+  else()\n+    add_test(\n+      NAME \"avoid_abort\"\n+      # Under FreeBSD, the __cxa_guard_abort symbol may appear but it is fine.\n+      # So we want to look for <space><possibly _>abort as a test.\n+      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} ' _*abort' || exit 0  && exit 1\"\n+      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n+    )\n+    add_test(\n+      NAME \"avoid_cout\"\n+      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} ' _*cout' || exit 0  && exit 1\"\n+      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n+    )\n+    add_test(\n+      NAME \"avoid_cerr\"\n+      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} ' _*cerr' || exit 0  && exit 1\"\n+      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n+    )\n+    add_test(\n+      NAME \"avoid_printf\"\n+      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} ' _*printf' || exit 0  && exit 1\"\n+      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n+    )\n     add_test(\n-      NAME \"just_ascii\"\n-      COMMAND sh -c \"${FIND}  include src windows tools singleheader tests examples benchmark -path benchmark/checkperf-reference -prune -name '*.h'  -o -name '*.cpp' -type f  -exec ${FILE} '{}' \\; |${GREP} -v ASCII || exit 0  && exit 1\"\n-      WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n+      NAME \"avoid_stdout\"\n+      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} stdout || exit 0 && exit 1\"\n+      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n     )\n+    add_test(\n+      NAME \"avoid_stderr\"\n+      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} stderr || exit 0 && exit 1\"\n+      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n+    )\n+  endif()\n endif()\n-\n-\n-#\n-# CPack\n-#\n-set(CPACK_PACKAGE_VENDOR \"Daniel Lemire\")\n-set(CPACK_PACKAGE_CONTACT \"lemire@gmail.com\")\n-set(CPACK_PACKAGE_DESCRIPTION_SUMMARY \"Parsing gigabytes of JSON per second\")\n-set(CPACK_PACKAGE_VERSION_MAJOR ${PROJECT_VERSION_MAJOR})\n-set(CPACK_PACKAGE_VERSION_MINOR ${PROJECT_VERSION_MINOR})\n-set(CPACK_PACKAGE_VERSION_PATCH ${PROJECT_VERSION_PATCH})\n-set(CPACK_RESOURCE_FILE_LICENSE \"${CMAKE_CURRENT_SOURCE_DIR}/LICENSE\")\n-set(CPACK_RESOURCE_FILE_README \"${CMAKE_CURRENT_SOURCE_DIR}/README.md\")\n-\n-set(CPACK_RPM_PACKAGE_LICENSE \"${CMAKE_CURRENT_SOURCE_DIR}/LICENSE\")\n-\n-set(CPACK_SOURCE_GENERATOR \"TGZ;ZIP\")\n-\n-include(CPack)"
      },
      {
        "filename": "vendor/simdjson/CONTRIBUTING.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -69,7 +69,7 @@ Pull requests are always invited. However, we ask that you follow these guidelin\n    3. Other types of changes must be clearly motivated. We openly discourage changes with no identifiable benefits.\n - Changes should be focused and minimal. You should change as few lines of code as possible. Please do not reformat or touch files needlessly.\n - New features must be accompanied of new tests, in general.\n-- Your code should pass our continuous-integration tests. It is your responsability to ensure that your proposal pass the tests. We do not merge pull requests that would break our build.\n+- Your code should pass our continuous-integration tests. It is your responsibility to ensure that your proposal pass the tests. We do not merge pull requests that would break our build.\n    - An exception to this would be changes to non-code files, such as documentation and assets, or trivial changes to code, such as comments, where it is encouraged to explicitly ask for skipping a CI run using the `[skip ci]` prefix in your Pull Request title **and** in the first line of the most recent commit in a push. Example for such a commit: `[skip ci] Fixed typo in power_of_ten's docs`\n    This benefits the project in such a way that the CI pipeline is not burdened by running jobs on changes that don't change any behavior in the code, which reduces wait times for other Pull Requests that do change behavior and require testing.\n "
      },
      {
        "filename": "vendor/simdjson/CONTRIBUTORS",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -36,5 +36,6 @@ Nong Li\n Furkan Ta\u015fkale\n Brendan Knapp\n Danila Kutenin\n+Pavel Pavlov\n # if you have contributed to the project and your name does not \n # appear in this list, please let us know!"
      },
      {
        "filename": "vendor/simdjson/Dockerfile",
        "status": "removed",
        "additions": 0,
        "deletions": 88,
        "changes": 88,
        "patch": "@@ -1,88 +0,0 @@\n-###\n-#\n-# Though simdjson requires only commonly available compilers and tools, it can\n-# be convenient to build it and test it inside a docker container: it makes it\n-# possible to test and benchmark simdjson under even relatively out-of-date\n-# Linux servers. It should also work under macOS and Windows, though not\n-# at native speeds, maybe.\n-#\n-# Assuming that you have a working docker server, this file\n-# allows you to build, test and benchmark simdjson.\n-#\n-#  We build the library and associated files in the dockerbuild subdirectory.\n-# It may be necessary to delete it before creating the image:\n-#\n-# rm -r -f dockerbuild\n-#\n-# The need to delete the directory has nothing to do with docker per se: it is\n-# simply cleaner in CMake to start from a fresh directory. This is important: if you\n-# reuse the same directory with different configurations, you may get broken builds.\n-#\n-#\n-# Then you can build the image as follows:\n-#\n-# docker build -t simdjson --build-arg USER_ID=$(id -u)  --build-arg GROUP_ID=$(id -g) .\n-#\n-# Please note that the image does not contain a copy of the code. However, the image will contain the\n-# the compiler and the build system. This means that if you change the source code, after you have built\n-# the image, you won't need to rebuild the image. In fact, unless you want to try a different compiler, you\n-# do not need to ever rebuild the image, even if you do a lot of work on the source code.\n-#\n-# We specify the users to avoid having files owned by a privileged user (root) in our directory. Some\n-# people like to run their machine as the \"root\" user. We do not think it is cool.\n-#\n-# Then you need to build the project:\n-#\n-# docker run  -v $(pwd):/project:Z  simdjson\n-#\n-# Should you change a source file, you may need to call this command again. Because the output\n-# files are persistent between calls to this command (they reside in the dockerbuild directory),\n-# this command can be fast.\n-#\n-# Next you can test it as follows:\n-#\n-# docker run -it -v $(pwd):/project:Z   simdjson sh -c \"cd dockerbuild && ctest . --output-on-failure -LE explicitonly\"\n-#\n-# The run the complete tests requires you to have built all of simdjson.\n-#\n-# Building all of simdjson takes a long time. Instead, you can build just one target:\n-#\n-# docker run -it -v $(pwd):/project:Z  simdjson sh -c \"[ -d dockerbuild ] || mkdir dockerbuild && cd dockerbuild && cmake ..  && cmake --build . --target parse\"\n-#\n-# Note that it is safe to remove dockerbuild before call the previous command, as the repository gets rebuild. It is also possible, by changing the command, to use a different directory name.\n-#\n-# You can run performance tests:\n-#\n-# docker run -it --privileged -v $(pwd):/project:Z  simdjson sh -c \"cd dockerbuild && for i in ../jsonexamples/*.json; do echo \\$i; ./benchmark/parse \\$i;  done\"\n-#\n-# The \"--privileged\" is recommended so you can get performance counters under Linux.\n-#\n-# You can also grab a fresh copy of simdjson and rebuild it, to make comparisons:\n-#\n-# docker run -it -v $(pwd):/project:Z  simdjson sh -c \"git clone https://github.com/simdjson/simdjson.git && cd simdjson && mkdir build && cd build && cmake .. && cmake --build . --target parse \"\n-#\n-# Then you can run comparisons:\n-#\n-# docker run -it --privileged -v $(pwd):/project:Z  simdjson sh -c \"for i in jsonexamples/*.json; do echo \\$i; dockerbuild/benchmark/parse \\$i| grep GB| head -n 1; simdjson/build/benchmark/parse \\$i | grep GB |head -n 1;  done\"\n-#\n-####\n-FROM ubuntu:20.10\n-################\n-# We would prefer to use the conan io images but they do not support 64-bit ARM? The small gcc images appear to\n-# be broken on ARM.\n-# Furthermore, we would not expect users to frequently rebuild the container, so using ubuntu is probably fine.\n-###############\n-ARG USER_ID\n-ARG GROUP_ID\n-RUN apt-get update -qq\n-RUN DEBIAN_FRONTEND=\"noninteractive\" apt-get -y install tzdata\n-RUN apt-get install -y cmake g++ git\n-RUN mkdir project\n-\n-RUN addgroup --gid $GROUP_ID user; exit 0\n-RUN adduser --disabled-password --gecos '' --uid $USER_ID --gid $GROUP_ID user; exit 0\n-USER user\n-RUN gcc --version\n-WORKDIR /project\n-\n-CMD [\"sh\",\"-c\",\"[ -d dockerbuild ] || mkdir dockerbuild && cd dockerbuild && cmake .. && cmake --build . \"]"
      },
      {
        "filename": "vendor/simdjson/HACKING.md",
        "status": "modified",
        "additions": 27,
        "deletions": 15,
        "changes": 42,
        "patch": "@@ -32,6 +32,18 @@ Stage 1 also does unicode validation.\n \n Stage 2 handles all of the rest: number parsings, recognizing atoms like true, false, null, and so forth.\n \n+Developer mode\n+--------------\n+\n+Build system targets that are only useful for developers of the simdjson\n+library are behind the `SIMDJSON_DEVELOPER_MODE` option. Enabling this option\n+makes tests, examples, benchmarks and other developer targets available. Not\n+enabling this option means that you are a consumer of simdjson and thus you\n+only get the library targets and options.\n+\n+Developer mode is forced to be on when the `CI` environment variable is set to\n+a value that CMake recognizes as \"on\", which is set to `true` in all of the CI\n+workflows used by simdjson.\n \n Directory Structure and Source\n ------------------------------\n@@ -74,19 +86,19 @@ Other important files and directories:\n   ```bash\n   mkdir build\n   cd build\n-  cmake ..\n+  cmake -D SIMDJSON_DEVELOPER_MODE=ON ..\n   cmake --build . --config Release\n-  benchmark/parse ../jsonexamples/twitter.json\n+  benchmark/dom/parse ../jsonexamples/twitter.json\n   ```\n   The last line becomes `./benchmark/Release/parse.exe ../jsonexample/twitter.json` under Windows. You may also use Google Benchmark:\n   ```bash\n   mkdir build\n   cd build\n-  cmake ..\n+  cmake -D SIMDJSON_DEVELOPER_MODE=ON ..\n   cmake --build . --target bench_parse_call --config Release\n   ./benchmark/bench_parse_call\n   ```\n-  The last line becomes `./benchmark/Release/bench_parse_call.exe` under Windows. Under Windows, you can also build with the clang compiler by adding `-T ClangCL` to the call to `cmake ..`: `cmake .. - TClangCL`.\n+  The last line becomes `./benchmark/Release/bench_parse_call.exe` under Windows. Under Windows, you can also build with the clang compiler by adding `-T ClangCL` to the call to `cmake ..`: `cmake -T ClangCL ..`.\n * **fuzz:** The source for fuzz testing. This lets us explore important edge and middle cases\n * **fuzz:** The source for fuzz testing. This lets us explore important edge and middle cases\n   automatically, and is run in CI.\n@@ -147,7 +159,7 @@ processor.\n \n At this point, we are require to use one of two main strategies.\n \n-1. On POSIX systems, the main compilers (LLVM clang, GNU gcc) allow us to use any intrinsic function after including the header, but they fail to inline the resulting instruction if the target processor does not support them. Because we compile for a generic processor, we would not be able to use most intrinsic functions. Thankfully, more recent versions of these compilers allow us to flag a region of code with a specific target, so that we can compile only some of the code with support for advanced instructions. Thus in our C++, one might notice macros like `TARGET_HASWELL`. It is then our responsability, at runtime, to only run the regions of code (that we call kernels) matching the properties of the runtime processor. The benefit of this approach is that the compiler not only let us use intrinsic functions, but it can also optimize the rest of the code in the kernel with advanced instructions we enabled.\n+1. On POSIX systems, the main compilers (LLVM clang, GNU gcc) allow us to use any intrinsic function after including the header, but they fail to inline the resulting instruction if the target processor does not support them. Because we compile for a generic processor, we would not be able to use most intrinsic functions. Thankfully, more recent versions of these compilers allow us to flag a region of code with a specific target, so that we can compile only some of the code with support for advanced instructions. Thus in our C++, one might notice macros like `TARGET_HASWELL`. It is then our responsibility, at runtime, to only run the regions of code (that we call kernels) matching the properties of the runtime processor. The benefit of this approach is that the compiler not only let us use intrinsic functions, but it can also optimize the rest of the code in the kernel with advanced instructions we enabled.\n \n 2. Under Visual Studio, the problem is somewhat simpler. Visual Studio will not only provide the intrinsic functions, but it will also allow us to use them. They will compile just fine. It is at runtime that they may cause a crash. So we do not need to mark regions of code for compilation toward advanced processors (e.g., with  `TARGET_HASWELL` macros). The downside of the Visual Studio approach is that the compiler is not allowed to use advanced instructions others than those we specify. In principle, this means that Visual Studio has weaker optimization opportunities.\n \n@@ -168,7 +180,7 @@ systematically regenerated on releases. To ensure you have the latest code, you\n ```bash\n mkdir build\n cd build\n-cmake ..\n+cmake -D SIMDJSON_DEVELOPER_MODE=ON ..\n cmake --build . # needed, because currently dependencies do not work fully for the amalgamate target\n cmake --build . --target amalgamate\n ```\n@@ -209,31 +221,31 @@ Building: While in the project repository, do the following:\n ```\n mkdir build\n cd build\n-cmake ..\n+cmake -D SIMDJSON_DEVELOPER_MODE=ON ..\n cmake --build .\n ctest\n ```\n \n-CMake will build a library. By default, it builds a shared library (e.g., libsimdjson.so on Linux).\n+CMake will build a library. By default, it builds a static library (e.g., libsimdjson.a on Linux).\n \n-You can build a static library:\n+You can build a shared library:\n \n ```\n-mkdir buildstatic\n-cd buildstatic\n-cmake -DSIMDJSON_BUILD_STATIC=ON ..\n+mkdir buildshared\n+cd buildshared\n+cmake -D BUILD_SHARED_LIBS=ON -D SIMDJSON_DEVELOPER_MODE=ON ..\n cmake --build .\n ctest\n ```\n \n-In some cases, you may want to specify your compiler, especially if the default compiler on your system is too old.  You need to tell cmake which compiler you wish to use by setting the CC and CXX variables. Under bash, you can do so with commands such as `export CC=gcc-7` and `export CXX=g++-7`. You can also do it as part of the `cmake` command: `cmake .. -DCMAKE_CXX_COMPILER=g++`.  You may proceed as follows:\n+In some cases, you may want to specify your compiler, especially if the default compiler on your system is too old.  You need to tell cmake which compiler you wish to use by setting the CC and CXX variables. Under bash, you can do so with commands such as `export CC=gcc-7` and `export CXX=g++-7`. You can also do it as part of the `cmake` command: `cmake -DCMAKE_CXX_COMPILER=g++ ..`.  You may proceed as follows:\n \n ```\n brew install gcc@8\n mkdir build\n cd build\n export CXX=g++-8 CC=gcc-8\n-cmake ..\n+cmake -D SIMDJSON_DEVELOPER_MODE=ON ..\n cmake --build .\n ctest\n ```\n@@ -269,7 +281,7 @@ Furthermore, if you have installed LLVM clang on Windows, for example as a compo\n \n - `mkdir build`\n - `cd build`\n-- `cmake ..  -T ClangCL`\n+- `cmake -T ClangCL ..`\n - `cmake --build . -config Release`\n \n "
      },
      {
        "filename": "vendor/simdjson/README.md",
        "status": "modified",
        "additions": 12,
        "deletions": 7,
        "changes": 19,
        "patch": "@@ -1,9 +1,9 @@\n-[![Fuzzing Status](https://oss-fuzz-build-logs.storage.googleapis.com/badges/simdjson.svg)](https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&q=proj%3Asimdjson&can=2)\n+\n ![Ubuntu 18.04 CI](https://github.com/simdjson/simdjson/workflows/Ubuntu%2018.04%20CI%20(GCC%207)/badge.svg)\n [![Ubuntu 20.04 CI](https://github.com/simdjson/simdjson/workflows/Ubuntu%2020.04%20CI%20(GCC%209)/badge.svg)](https://simdjson.org/plots.html)\n ![VS16-CI](https://github.com/simdjson/simdjson/workflows/VS16-CI/badge.svg)\n ![MinGW64-CI](https://github.com/simdjson/simdjson/workflows/MinGW64-CI/badge.svg)\n-[![][license img]][license]  [![Doxygen Documentation](https://img.shields.io/badge/docs-doxygen-green.svg)](https://simdjson.org/api/0.9.0/index.html)\n+[![][license img]][license]  [![Doxygen Documentation](https://img.shields.io/badge/docs-doxygen-green.svg)](https://simdjson.org/api/1.0.0/index.html)\n \n simdjson : Parsing gigabytes of JSON per second\n ===============================================\n@@ -27,7 +27,6 @@ Table of Contents\n -----------------\n \n * [Quick Start](#quick-start)\n-  * [On Demand](#on-demand)\n * [Documentation](#documentation)\n * [Performance results](#performance-results)\n * [Real-world usage](#real-world-usage)\n@@ -54,6 +53,7 @@ The simdjson library is easily consumable with a single .h and .cpp file.\n 2. Create `quickstart.cpp`:\n \n ```c++\n+#include <iostream>\n #include \"simdjson.h\"\n using namespace simdjson;\n int main(void) {\n@@ -79,7 +79,7 @@ Usage documentation is available:\n * [Performance](doc/performance.md) shows some more advanced scenarios and how to tune for them.\n * [Implementation Selection](doc/implementation-selection.md) describes runtime CPU detection and\n   how you can work with it.\n-* [API](https://simdjson.org/api/0.9.0/annotated.html) contains the automatically generated API documentation.\n+* [API](https://simdjson.org/api/1.0.0/annotated.html) contains the automatically generated API documentation.\n \n Performance results\n -------------------\n@@ -137,6 +137,7 @@ We distinguish between \"bindings\" (which just wrap the C++ code) and a port to a\n - [simdjson-go](https://github.com/minio/simdjson-go): Go port using Golang assembly.\n - [rcppsimdjson](https://github.com/eddelbuettel/rcppsimdjson): R bindings.\n - [simdjson_erlang](https://github.com/ChomperT/simdjson_erlang): erlang bindings.\n+- [lua-simdjson](https://github.com/FourierTransformer/lua-simdjson): lua bindings.\n \n \n About simdjson\n@@ -152,13 +153,13 @@ and implementation of simdjson is in our research article:\n \n We have an in-depth paper focused on the UTF-8 validation:\n \n-- John Keiser, Daniel Lemire, [Validating UTF-8 In Less Than One Instruction Per Byte](https://arxiv.org/abs/2010.03090), Software: Practice & Experience (to appear)\n+- John Keiser, Daniel Lemire, [Validating UTF-8 In Less Than One Instruction Per Byte](https://arxiv.org/abs/2010.03090), Software: Practice & Experience 51 (5), 2021.\n \n We also have an informal [blog post providing some background and context](https://branchfree.org/2019/02/25/paper-parsing-gigabytes-of-json-per-second/).\n \n For the video inclined, <br />\n [![simdjson at QCon San Francisco 2019](http://img.youtube.com/vi/wlvKAT7SZIQ/0.jpg)](http://www.youtube.com/watch?v=wlvKAT7SZIQ)<br />\n-(it was the best voted talk, we're kinda proud of it).\n+(It was the best voted talk, we're kinda proud of it.)\n \n Funding\n -------\n@@ -182,4 +183,8 @@ This code is made available under the [Apache License 2.0](https://www.apache.or\n \n Under Windows, we build some tools using the windows/dirent_portable.h file (which is outside our library code): it under the liberal (business-friendly) MIT license.\n \n-For compilers that do not support [C++17](https://en.wikipedia.org/wiki/C%2B%2B17), we bundle the string-view library which is published under the Boost license (http://www.boost.org/LICENSE_1_0.txt). Like the Apache license, the Boost license is a permissive license allowing commercial redistribution.\n+For compilers that do not support [C++17](https://en.wikipedia.org/wiki/C%2B%2B17), we bundle the string-view library which is published under the [Boost license](http://www.boost.org/LICENSE_1_0.txt). Like the Apache license, the Boost license is a permissive license allowing commercial redistribution.\n+\n+For efficient number serialization, we bundle Florian Loitsch's implementation of the Grisu2 algorithm for binary to decimal floating-point numbers. The implementation was slightly modified by JSON for Modern C++ library. Both Florian Loitsch's implementation and JSON for Modern C++ are provided under the MIT license.\n+\n+For runtime dispatching, we use some code from the PyTorch project licensed under 3-clause BSD."
      },
      {
        "filename": "vendor/simdjson/cmake/developer-options.cmake",
        "status": "added",
        "additions": 180,
        "deletions": 0,
        "changes": 180,
        "patch": "@@ -0,0 +1,180 @@\n+#\n+# Flags used by exes and by the simdjson library (project-wide flags)\n+#\n+add_library(simdjson-internal-flags INTERFACE)\n+\n+\n+option(SIMDJSON_CHECK_EOF \"Check for the end of the input buffer. The setting is unnecessary since we require padding of the inputs. You should expect tests to fail with this option turned on.\" OFF)\n+if(SIMDJSON_CHECK_EOF)\n+  add_compile_definitions(SIMDJSON_CHECK_EOF=1)\n+endif()\n+\n+option(SIMDJSON_SANITIZE_UNDEFINED \"Sanitize undefined behavior\" OFF)\n+if(SIMDJSON_SANITIZE_UNDEFINED)\n+  add_compile_options(-fsanitize=undefined -fno-sanitize-recover=all)\n+  add_link_options(-fsanitize=undefined -fno-sanitize-recover=all)\n+endif()\n+\n+option(SIMDJSON_SANITIZE \"Sanitize addresses\" OFF)\n+if(SIMDJSON_SANITIZE)\n+  if(CMAKE_CXX_COMPILER_ID STREQUAL \"AppleClang\")\n+    message(STATUS \"The address sanitizer under Apple's clang appears to be \\\n+incompatible with the undefined-behavior sanitizer.\")\n+    message(STATUS \"You may set SIMDJSON_SANITIZE_UNDEFINED to sanitize \\\n+undefined behavior.\")\n+    add_compile_options(\n+        -fsanitize=address -fno-omit-frame-pointer -fno-sanitize-recover=all\n+    )\n+    add_compile_definitions(ASAN_OPTIONS=detect_leaks=1)\n+    link_libraries(\n+        -fsanitize=address -fno-omit-frame-pointer -fno-sanitize-recover=all\n+    )\n+  else()\n+    message(\n+        STATUS\n+        \"Setting both the address sanitizer and the undefined sanitizer.\"\n+    )\n+    add_compile_options(\n+        -fsanitize=address -fno-omit-frame-pointer\n+        -fsanitize=undefined -fno-sanitize-recover=all\n+    )\n+    link_libraries(\n+        -fsanitize=address -fno-omit-frame-pointer\n+        -fsanitize=undefined -fno-sanitize-recover=all\n+    )\n+  endif()\n+\n+  # Ubuntu bug for GCC 5.0+ (safe for all versions)\n+  if(CMAKE_COMPILER_IS_GNUCC)\n+    link_libraries(-fuse-ld=gold)\n+  endif()\n+endif()\n+\n+if(SIMDJSON_SANITIZE_THREADS)\n+  message(STATUS \"Setting both the thread sanitizer \\\n+and the undefined-behavior sanitizer.\")\n+  add_compile_options(\n+      -fsanitize=thread -fsanitize=undefined -fno-sanitize-recover=all\n+  )\n+  link_libraries(\n+      -fsanitize=thread -fsanitize=undefined -fno-sanitize-recover=all\n+  )\n+\n+  # Ubuntu bug for GCC 5.0+ (safe for all versions)\n+  if(CMAKE_COMPILER_IS_GNUCC)\n+    link_libraries(-fuse-ld=gold)\n+  endif()\n+endif()\n+\n+get_cmake_property(is_multi_config GENERATOR_IS_MULTI_CONFIG)\n+if(NOT is_multi_config AND NOT CMAKE_BUILD_TYPE)\n+  # Deliberately not including SIMDJSON_SANITIZE_THREADS since thread behavior\n+  # depends on the build type.\n+  if(SIMDJSON_SANITIZE OR SIMDJSON_SANITIZE_UNDEFINED)\n+    message(STATUS \"No build type selected and you have enabled the sanitizer, \\\n+default to Debug. Consider setting CMAKE_BUILD_TYPE.\")\n+    set(CMAKE_BUILD_TYPE Debug CACHE STRING \"Choose the type of build.\" FORCE)\n+  else()\n+    message(STATUS \"No build type selected, default to Release\")\n+    set(CMAKE_BUILD_TYPE Release CACHE STRING \"Choose the type of build.\" FORCE)\n+  endif()\n+endif()\n+\n+if(NOT MSVC)\n+  option(SIMDJSON_USE_LIBCPP \"Use the libc++ library\" OFF)\n+endif()\n+\n+if(MSVC AND BUILD_SHARED_LIBS)\n+  # This will require special handling.\n+  set(SIMDJSON_WINDOWS_DLL TRUE)\n+endif()\n+\n+# We compile tools, tests, etc. with C++ 17. Override yourself if you need on a\n+# target.\n+set(CMAKE_CXX_STANDARD 17)\n+set(CMAKE_CXX_STANDARD_REQUIRED ON)\n+set(CMAKE_CXX_EXTENSIONS OFF)\n+set(CMAKE_MACOSX_RPATH OFF)\n+set(CMAKE_THREAD_PREFER_PTHREAD ON)\n+set(THREADS_PREFER_PTHREAD_FLAG ON)\n+\n+# LTO seems to create all sorts of fun problems. Let us\n+# disable temporarily.\n+#include(CheckIPOSupported)\n+#check_ipo_supported(RESULT ltoresult)\n+#if(ltoresult)\n+#  set(CMAKE_INTERPROCEDURAL_OPTIMIZATION TRUE)\n+#endif()\n+\n+option(SIMDJSON_VISUAL_STUDIO_BUILD_WITH_DEBUG_INFO_FOR_PROFILING \"\\\n+Under Visual Studio, add Zi to the compile flag and DEBUG to the link file to \\\n+add debugging information to the release build for easier profiling inside \\\n+tools like VTune\" OFF)\n+if(MSVC)\n+  if(MSVC_TOOLSET_VERSION STRLESS \"142\")\n+    set(SIMDJSON_LEGACY_VISUAL_STUDIO TRUE)\n+    message (STATUS \"A legacy Visual Studio version was detected. \\\n+We recommend Visual Studio 2019 or better on a 64-bit system.\")\n+  endif()\n+  if(MSVC_TOOLSET_VERSION STREQUAL \"140\")\n+    # Visual Studio 2015 issues warnings and we tolerate it\n+    # cmake -G \"Visual Studio 14\" ..\n+    target_compile_options(simdjson-internal-flags INTERFACE /W0 /sdl)\n+  else()\n+    # Recent version of Visual Studio expected (2017, 2019...). Prior versions\n+    # are unsupported.\n+    # https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warning-level-4-c4714?view=vs-2019\n+    target_compile_options(simdjson-internal-flags INTERFACE /WX /W3 /sdl /w34714)\n+    if(MSVC_VERSION GREATER 1910)\n+      target_compile_options(simdjson-internal-flags INTERFACE /permissive-)\n+    endif()\n+  endif()\n+  if(SIMDJSON_VISUAL_STUDIO_BUILD_WITH_DEBUG_INFO_FOR_PROFILING)\n+    add_link_options(/DEBUG)\n+    add_compile_options(/Zi)\n+  endif()\n+else()\n+  if(NOT WIN32)\n+    target_compile_options(simdjson-internal-flags INTERFACE -fPIC)\n+  endif()\n+  target_compile_options(\n+      simdjson-internal-flags INTERFACE\n+      -Werror -Wall -Wextra -Weffc++ -Wsign-compare -Wshadow -Wwrite-strings\n+      -Wpointer-arith -Winit-self -Wconversion -Wno-sign-conversion\n+  )\n+endif()\n+\n+#\n+# Other optional flags\n+#\n+option(SIMDJSON_BASH \"Allow usage of bash within CMake\" ON)\n+\n+option(\n+    SIMDJSON_VERBOSE_LOGGING\n+    \"Enable verbose logging for internal simdjson library development.\"\n+    OFF\n+)\n+if(SIMDJSON_VERBOSE_LOGGING)\n+  add_compile_definitions(SIMDJSON_VERBOSE_LOGGING=1\n+  )\n+endif()\n+\n+if(SIMDJSON_USE_LIBCPP)\n+  link_libraries(-stdlib=libc++ -lc++abi)\n+  # instead of the above line, we could have used\n+  # set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -stdlib=libc++\n+  # -lc++abi\")\n+  # The next line is needed empirically.\n+  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -stdlib=libc++\")\n+  # we update CMAKE_SHARED_LINKER_FLAGS, this gets updated later as well\n+  set(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -lc++abi\")\n+endif()\n+\n+# prevent shared libraries from depending on Intel provided libraries\n+if(CMAKE_C_COMPILER_ID MATCHES \"Intel\")\n+  set(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -static-intel\")\n+endif()\n+\n+include(CheckSymbolExists)\n+check_symbol_exists(fork unistd.h HAVE_POSIX_FORK)\n+check_symbol_exists(wait sys/wait.h HAVE_POSIX_WAIT)"
      },
      {
        "filename": "vendor/simdjson/cmake/exception-flags.cmake",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "patch": "@@ -0,0 +1,28 @@\n+option(SIMDJSON_EXCEPTIONS \"Enable simdjson's exception-throwing interface\" ON)\n+if(NOT SIMDJSON_EXCEPTIONS)\n+  message(STATUS \"simdjson exception interface turned off. \\\n+Code that does not check error codes will not compile.\")\n+  simdjson_add_props(target_compile_definitions PUBLIC SIMDJSON_EXCEPTIONS=0)\n+  if(MSVC)\n+    if(NOT is_top_project)\n+      message(AUTHOR_WARNING \"Turning SIMDJSON_EXCEPTIONS off requires \\\n+editing CMAKE_CXX_FLAGS\")\n+    endif()\n+\n+    # CMake currently /EHsc as a default flag in CMAKE_CXX_FLAGS on MSVC.\n+    # Replacing this with a more general abstraction is a WIP\n+    # (see https://gitlab.kitware.com/cmake/cmake/-/issues/20610)\n+    # /EHs enables standard C++ stack unwinding when catching exceptions\n+    # (non-structured exception handling)\n+    # /EHc used in conjection with /EHs indicates that extern \"C\" functions\n+    # never throw (terminate-on-throw)\n+    # Here, we disable both with the - argument negation operator\n+    string(REPLACE \"/EHsc\" \"/EHs-c-\" CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS})\n+\n+    # Because we cannot change the flag above on an individual target (yet), the\n+    # definition below must similarly be added globally\n+    add_definitions(-D_HAS_EXCEPTIONS=0)\n+  elseif(CMAKE_COMPILER_IS_GNUCC)\n+    simdjson_add_props(target_link_libraries PRIVATE -fno-exceptions)\n+  endif()\n+endif()"
      },
      {
        "filename": "vendor/simdjson/cmake/handle-deprecations.cmake",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "patch": "@@ -0,0 +1,23 @@\n+if(DEFINED SIMDJSON_BUILD_STATIC)\n+  message(DEPRECATION \"SIMDJSON_BUILD_STATIC is deprecated, setting \\\n+BUILD_SHARED_LIBS with its value and unsetting it\")\n+  set(shared ON)\n+  if(SIMDJSON_BUILD_STATIC)\n+    set(shared OFF)\n+  endif()\n+\n+  set(BUILD_SHARED_LIBS \"${shared}\" CACHE BOOL \"\" FORCE)\n+  unset(SIMDJSON_BUILD_STATIC CACHE)\n+endif()\n+\n+if(DEFINED SIMDJSON_JUST_LIBRARY)\n+  message(DEPRECATION \"SIMDJSON_JUST_LIBRARY is deprecated, setting \\\n+SIMDJSON_DEVELOPER_MODE with its value and unsetting it\")\n+  set(dev_mode ON)\n+  if(SIMDJSON_JUST_LIBRARY)\n+    set(dev_mode OFF)\n+  endif()\n+\n+  set(SIMDJSON_DEVELOPER_MODE \"${dev_mode}\" CACHE BOOL \"\" FORCE)\n+  unset(SIMDJSON_JUST_LIBRARY CACHE)\n+endif()"
      },
      {
        "filename": "vendor/simdjson/cmake/implementation-flags.cmake",
        "status": "added",
        "additions": 106,
        "deletions": 0,
        "changes": 106,
        "patch": "@@ -0,0 +1,106 @@\n+#\n+# Implementation selection\n+#\n+set(SIMDJSON_ALL_IMPLEMENTATIONS fallback westmere haswell arm64 ppc64)\n+\n+set(\n+    SIMDJSON_IMPLEMENTATION \"\"\n+    CACHE STRING \"\\\n+Semicolon-separated list of implementations to include \\\n+(${SIMDJSON_ALL_IMPLEMENTATIONS}). If this is not set, any implementations \\\n+that are supported at compile time and may be selected at runtime will be \\\n+included.\"\n+)\n+set(\n+    SIMDJSON_EXCLUDE_IMPLEMENTATION \"\"\n+    CACHE STRING \"\\\n+Semicolon-separated list of implementations to exclude \\\n+(haswell/westmere/arm64/ppc64/fallback). By default, excludes any \\\n+implementations that are unsupported at compile time or cannot be selected at \\\n+runtime.\"\n+)\n+\n+foreach(var IN ITEMS IMPLEMENTATION EXCLUDE_IMPLEMENTATION)\n+  set(var \"SIMDJSON_${var}\")\n+  foreach(impl IN LISTS \"${var}\")\n+    if(NOT impl IN_LIST SIMDJSON_ALL_IMPLEMENTATIONS)\n+      message(ERROR \"\\\n+Implementation ${impl} found in ${var} not supported by simdjson. \\\n+Possible implementations: ${SIMDJSON_ALL_IMPLEMENTATIONS}\")\n+    endif()\n+  endforeach()\n+endforeach()\n+\n+macro(flag_action action var val)\n+  message(STATUS \"${action} implementation ${impl} due to ${var}=${${var}}\")\n+  simdjson_add_props(\n+      target_compile_definitions PUBLIC\n+      \"SIMDJSON_IMPLEMENTATION_${impl_upper}=${val}\"\n+  )\n+endmacro()\n+\n+foreach(impl IN LISTS SIMDJSON_ALL_IMPLEMENTATIONS)\n+  string(TOUPPER \"${impl}\" impl_upper)\n+  if(impl IN_LIST SIMDJSON_EXCLUDE_IMPLEMENTATION)\n+    flag_action(Excluding SIMDJSON_EXCLUDE_IMPLEMENTATION 0)\n+  elseif(impl IN_LIST SIMDJSON_IMPLEMENTATION)\n+    flag_action(Including SIMDJSON_IMPLEMENTATION 1)\n+  elseif(SIMDJSON_IMPLEMENTATION)\n+    flag_action(Excluding SIMDJSON_IMPLEMENTATION 0)\n+  endif()\n+endforeach()\n+\n+# TODO make it so this generates the necessary compiler flags to select the\n+# given impl as the builtin automatically!\n+set(\n+    SIMDJSON_BUILTIN_IMPLEMENTATION \"\"\n+    CACHE STRING \"\\\n+Select the implementation that will be used for user code. Defaults to the \\\n+most universal implementation in SIMDJSON_IMPLEMENTATION (in the order \\\n+${SIMDJSON_ALL_IMPLEMENTATIONS}) if specified; otherwise, by default the \\\n+compiler will pick the best implementation that can always be selected given \\\n+the compiler flags.\"\n+)\n+if(NOT SIMDJSON_BUILTIN_IMPLEMENTATION STREQUAL \"\")\n+  simdjson_add_props(\n+      target_compile_definitions PUBLIC\n+      \"SIMDJSON_BUILTIN_IMPLEMENTATION=${SIMDJSON_BUILTIN_IMPLEMENTATION}\"\n+  )\n+else()\n+  # Pick the most universal implementation out of the selected implementations\n+  # (if any)\n+  foreach(impl IN LISTS SIMDJSON_ALL_IMPLEMENTATIONS)\n+    if(\n+        impl IN_LIST SIMDJSON_IMPLEMENTATION\n+        AND NOT impl IN_LIST SIMDJSON_EXCLUDE_IMPLEMENTATION\n+    )\n+      message(STATUS \"\\\n+Selected implementation ${impl} as builtin implementation based on \\\n+${SIMDJSON_IMPLEMENTATION}\")\n+      simdjson_add_props(\n+          target_compile_definitions PUBLIC\n+          \"SIMDJSON_BUILTIN_IMPLEMENTATION=${impl}\"\n+      )\n+      break()\n+    endif()\n+  endforeach()\n+endif()\n+\n+foreach(impl IN LISTS SIMDJSON_ALL_IMPLEMENTATIONS)\n+  string(TOUPPER \"${impl}\" impl_upper)\n+  option(\n+      \"SIMDJSON_IMPLEMENTATION_${impl_upper}\"\n+      \"Include the ${impl} implementation\"\n+      ON\n+  )\n+  mark_as_advanced(\"SIMDJSON_IMPLEMENTATION_${impl_upper}\")\n+  if(NOT \"${SIMDJSON_IMPLEMENTATION_${impl_upper}}\")\n+    message(DEPRECATION \"\\\n+SIMDJSON_IMPLEMENTATION_${impl_upper} is deprecated. \\\n+Use SIMDJSON_IMPLEMENTATION=-${impl} instead\")\n+     simdjson_add_props(\n+        target_compile_definitions PUBLIC\n+        \"SIMDJSON_IMPLEMENTATION_${impl_upper}=0\"\n+    )\n+  endif()\n+endforeach()"
      },
      {
        "filename": "vendor/simdjson/cmake/simdjson-config.cmake.in",
        "status": "modified",
        "additions": 4,
        "deletions": 7,
        "changes": 11,
        "patch": "@@ -1,9 +1,6 @@\n-@PACKAGE_INIT@\n-\n include(CMakeFindDependencyMacro)\n-if(@SIMDJSON_ENABLE_THREADS@)\n-    set(CMAKE_THREAD_PREFER_PTHREAD TRUE)\n-    find_dependency(Threads)\n+if(\"@SIMDJSON_ENABLE_THREADS@\")\n+  find_dependency(Threads)\n endif()\n-# Import targets.\n-include(\"${CMAKE_CURRENT_LIST_DIR}/@PROJECT_NAME@-targets.cmake\")\n+\n+include(\"${CMAKE_CURRENT_LIST_DIR}/simdjsonTargets.cmake\")"
      },
      {
        "filename": "vendor/simdjson/cmake/simdjson-flags.cmake",
        "status": "removed",
        "additions": 0,
        "deletions": 275,
        "changes": 275,
        "patch": "@@ -1,275 +0,0 @@\n-\n-if(CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR)\n-  message (STATUS \"The simdjson repository appears to be standalone.\")\n-  option(SIMDJSON_JUST_LIBRARY \"Build just the library, omit tests, tools and benchmarks\" OFF)\n-  message (STATUS \"By default, we attempt to build everything.\")\n-else()\n-  message (STATUS \"The simdjson repository appears to be used as a subdirectory.\")\n-  option(SIMDJSON_JUST_LIBRARY \"Build just the library, omit tests, tools and benchmarks\" ON)\n-  message (STATUS \"By default, we just build the library.\")\n-endif()\n-\n-#\n-# Flags used by exes and by the simdjson library (project-wide flags)\n-#\n-add_library(simdjson-flags INTERFACE)\n-add_library(simdjson-internal-flags INTERFACE)\n-target_link_libraries(simdjson-internal-flags INTERFACE simdjson-flags)\n-\n-option(SIMDJSON_SANITIZE_UNDEFINED \"Sanitize undefined behavior\" OFF)\n-if(SIMDJSON_SANITIZE_UNDEFINED)\n-  target_compile_options(simdjson-flags INTERFACE -fsanitize=undefined -fno-sanitize-recover=all)\n-  target_link_libraries(simdjson-flags INTERFACE -fsanitize=undefined -fno-sanitize-recover=all)\n-endif()\n-\n-option(SIMDJSON_SANITIZE \"Sanitize addresses\" OFF)\n-if(SIMDJSON_SANITIZE)\n-  if(CMAKE_CXX_COMPILER_ID STREQUAL \"AppleClang\")\n-    message(STATUS \"The address sanitizer under Apple's clang appears to be incompatible with the undefined-behavior sanitizer.\")\n-    message(STATUS \"You may set SIMDJSON_SANITIZE_UNDEFINED to sanitize undefined behavior.\")\n-    target_compile_options(simdjson-flags INTERFACE -fsanitize=address  -fno-omit-frame-pointer -fno-sanitize-recover=all)\n-    target_compile_definitions(simdjson-flags INTERFACE ASAN_OPTIONS=detect_leaks=1)\n-    target_link_libraries(simdjson-flags INTERFACE -fsanitize=address  -fno-omit-frame-pointer -fno-sanitize-recover=all)\n-  else()\n-    message(STATUS \"Setting both the address sanitizer and the undefined sanitizer.\")\n-    target_compile_options(simdjson-flags INTERFACE -fsanitize=address -fno-omit-frame-pointer -fsanitize=undefined -fno-sanitize-recover=all)\n-    target_link_libraries(simdjson-flags INTERFACE -fsanitize=address -fno-omit-frame-pointer -fsanitize=undefined -fno-sanitize-recover=all)\n-  endif()\n-  # Ubuntu bug for GCC 5.0+ (safe for all versions)\n-  if (CMAKE_COMPILER_IS_GNUCC)\n-    target_link_libraries(simdjson-flags INTERFACE -fuse-ld=gold)\n-  endif()\n-endif()\n-\n-\n-if(SIMDJSON_SANITIZE_THREADS)\n-  message(STATUS \"Setting both the thread sanitizer and the undefined-behavior sanitizer.\")\n-  target_compile_options(simdjson-flags INTERFACE -fsanitize=thread -fsanitize=undefined -fno-sanitize-recover=all)\n-  target_link_libraries(simdjson-flags INTERFACE -fsanitize=thread -fsanitize=undefined -fno-sanitize-recover=all)\n-\n-  # Ubuntu bug for GCC 5.0+ (safe for all versions)\n-  if (CMAKE_COMPILER_IS_GNUCC)\n-    target_link_libraries(simdjson-flags INTERFACE -fuse-ld=gold)\n-  endif()\n-endif()\n-\n-if (NOT CMAKE_BUILD_TYPE)\n-  # Deliberately not including SIMDJSON_SANITIZE_THREADS since thread behavior depends on the build type.\n-  if(SIMDJSON_SANITIZE OR SIMDJSON_SANITIZE_UNDEFINED)\n-    message(STATUS \"No build type selected and you have enabled the sanitizer, default to Debug. Consider setting CMAKE_BUILD_TYPE.\")\n-    set(CMAKE_BUILD_TYPE Debug CACHE STRING \"Choose the type of build.\" FORCE)\n-  else()\n-    message(STATUS \"No build type selected, default to Release\")\n-    set(CMAKE_BUILD_TYPE Release CACHE STRING \"Choose the type of build.\" FORCE)\n-  endif()\n-endif()\n-\n-if(MSVC)\n-  option(SIMDJSON_BUILD_STATIC \"Build a static library\" ON) # turning it on disables the production of a dynamic library\n-else()\n-  option(SIMDJSON_BUILD_STATIC \"Build a static library\" OFF) # turning it on disables the production of a dynamic library\n-  option(SIMDJSON_USE_LIBCPP \"Use the libc++ library\" OFF)\n-endif()\n-\n-if(MSVC AND NOT(SIMDJSON_BUILD_STATIC))\n-  # This will require special handling.\n-  set(SIMDJSON_WINDOWS_DLL TRUE)\n-endif()\n-\n-set(CMAKE_MODULE_PATH \"${CMAKE_CURRENT_SOURCE_DIR}/tools/cmake\")\n-\n-# We compile tools, tests, etc. with C++ 17. Override yourself if you need on a target.\n-set(CMAKE_CXX_STANDARD 17)\n-set(CMAKE_CXX_STANDARD_REQUIRED ON)\n-set(CMAKE_CXX_EXTENSIONS OFF)\n-set(CMAKE_MACOSX_RPATH OFF)\n-set(CMAKE_THREAD_PREFER_PTHREAD ON)\n-set(THREADS_PREFER_PTHREAD_FLAG ON)\n-\n-# LTO seems to create all sorts of fun problems. Let us\n-# disable temporarily.\n-#include(CheckIPOSupported)\n-#check_ipo_supported(RESULT ltoresult)\n-#if(ltoresult)\n-#  set(CMAKE_INTERPROCEDURAL_OPTIMIZATION TRUE)\n-#endif()\n-\n-option(SIMDJSON_VISUAL_STUDIO_BUILD_WITH_DEBUG_INFO_FOR_PROFILING \"Under Visual Studio, add Zi to the compile flag and DEBUG to the link file to add debugging information to the release build for easier profiling inside tools like VTune\" OFF)\n-if(MSVC)\n-  if(\"${MSVC_TOOLSET_VERSION}\" STRLESS \"142\")\n-    set(SIMDJSON_LEGACY_VISUAL_STUDIO TRUE)\n-    message (STATUS \"A legacy Visual Studio version was detected. We recommend Visual Studio 2019 or better on a 64-bit system.\")\n-  endif()\n-  if(\"${MSVC_TOOLSET_VERSION}\" STREQUAL \"140\")\n-    # Visual Studio 2015 issues warnings and we tolerate it,  cmake -G\"Visual Studio 14\" ..\n-    target_compile_options(simdjson-internal-flags INTERFACE /W0 /sdl)\n-  else()\n-    # Recent version of Visual Studio expected (2017, 2019...). Prior versions are unsupported.\n-    target_compile_options(simdjson-internal-flags INTERFACE /WX /W3 /sdl /w34714) # https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warning-level-4-c4714?view=vs-2019\n-  endif()\n-  if(SIMDJSON_VISUAL_STUDIO_BUILD_WITH_DEBUG_INFO_FOR_PROFILING)\n-    target_link_options(simdjson-flags  INTERFACE    /DEBUG )\n-    target_compile_options(simdjson-flags INTERFACE  /Zi)\n-  endif(SIMDJSON_VISUAL_STUDIO_BUILD_WITH_DEBUG_INFO_FOR_PROFILING)\n-else(MSVC)\n-  if(NOT WIN32)\n-    target_compile_options(simdjson-internal-flags INTERFACE -fPIC)\n-  endif()\n-  target_compile_options(simdjson-internal-flags INTERFACE -Werror -Wall -Wextra -Weffc++)\n-  target_compile_options(simdjson-internal-flags INTERFACE -Wsign-compare -Wshadow -Wwrite-strings -Wpointer-arith -Winit-self -Wconversion -Wno-sign-conversion)\n-endif(MSVC)\n-\n-\n-# workaround for GNU GCC poor AVX load/store code generation\n-if ((CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\") AND (CMAKE_SYSTEM_PROCESSOR MATCHES \"^(i.86|x86(_64)?)$\"))\n-  target_compile_options(simdjson-flags INTERFACE -mno-avx256-split-unaligned-load -mno-avx256-split-unaligned-store)\n-endif()\n-\n-#\n-# Optional flags\n-#\n-\n-#\n-# Implementation selection\n-#\n-set(SIMDJSON_ALL_IMPLEMENTATIONS \"fallback;westmere;haswell;arm64;ppc64\")\n-\n-set(SIMDJSON_IMPLEMENTATION \"\" CACHE STRING \"Semicolon-separated list of implementations to include (${SIMDJSON_ALL_IMPLEMENTATIONS}). If this is not set, any implementations that are supported at compile time and may be selected at runtime will be included.\")\n-foreach(implementation ${SIMDJSON_IMPLEMENTATION})\n-  if(NOT (implementation IN_LIST SIMDJSON_ALL_IMPLEMENTATIONS))\n-    message(ERROR \"Implementation ${implementation} not supported by simdjson. Possible implementations: ${SIMDJSON_ALL_IMPLEMENTATIONS}\")\n-  endif()\n-endforeach(implementation)\n-\n-set(SIMDJSON_EXCLUDE_IMPLEMENTATION \"\" CACHE STRING \"Semicolon-separated list of implementations to exclude (haswell/westmere/arm64/ppc64/fallback). By default, excludes any implementations that are unsupported at compile time or cannot be selected at runtime.\")\n-foreach(implementation ${SIMDJSON_EXCLUDE_IMPLEMENTATION})\n-  if(NOT (implementation IN_LIST SIMDJSON_ALL_IMPLEMENTATIONS))\n-    message(ERROR \"Implementation ${implementation} not supported by simdjson. Possible implementations: ${SIMDJSON_ALL_IMPLEMENTATIONS}\")\n-  endif()\n-endforeach(implementation)\n-\n-foreach(implementation ${SIMDJSON_ALL_IMPLEMENTATIONS})\n-  string(TOUPPER ${implementation} implementation_upper)\n-  if(implementation IN_LIST SIMDJSON_EXCLUDE_IMPLEMENTATION)\n-    message(STATUS \"Excluding implementation ${implementation} due to SIMDJSON_EXCLUDE_IMPLEMENTATION=${SIMDJSON_EXCLUDE_IMPLEMENTATION}\")\n-    target_compile_definitions(simdjson-flags INTERFACE \"SIMDJSON_IMPLEMENTATION_${implementation_upper}=0\")\n-  elseif(implementation IN_LIST SIMDJSON_IMPLEMENTATION)\n-    message(STATUS \"Including implementation ${implementation} due to SIMDJSON_IMPLEMENTATION=${SIMDJSON_IMPLEMENTATION}\")\n-    target_compile_definitions(simdjson-flags INTERFACE \"SIMDJSON_IMPLEMENTATION_${implementation_upper}=1\")\n-  elseif(SIMDJSON_IMPLEMENTATION)\n-    message(STATUS \"Excluding implementation ${implementation} due to SIMDJSON_IMPLEMENTATION=${SIMDJSON_IMPLEMENTATION}\")\n-    target_compile_definitions(simdjson-flags INTERFACE \"SIMDJSON_IMPLEMENTATION_${implementation_upper}=0\")\n-  endif()\n-endforeach(implementation)\n-\n-# TODO make it so this generates the necessary compiler flags to select the given implementation as the builtin automatically!\n-option(SIMDJSON_BUILTIN_IMPLEMENTATION \"Select the implementation that will be used for user code. Defaults to the most universal implementation in SIMDJSON_IMPLEMENTATION (in the order ${SIMDJSON_ALL_IMPLEMENTATIONS}) if specified; otherwise, by default the compiler will pick the best implementation that can always be selected given the compiler flags.\" \"\")\n-if(SIMDJSON_BUILTIN_IMPLEMENTATION)\n-  target_compile_definitions(simdjson-flags INTERFACE \"SIMDJSON_BUILTIN_IMPLEMENTATION=${SIMDJSON_BUILTIN_IMPLEMENTATION}\")\n-else()\n-  # Pick the most universal implementation out of the selected implementations (if any)\n-  foreach(implementation ${SIMDJSON_ALL_IMPLEMENTATIONS})\n-    if(implementation IN_LIST SIMDJSON_IMPLEMENTATION AND NOT (implementation IN_LIST SIMDJSON_EXCLUDE_IMPLEMENTATION))\n-      message(STATUS \"Selected implementation ${implementation} as builtin implementation based on ${SIMDJSON_IMPLEMENTATION}.\")\n-      target_compile_definitions(simdjson-flags INTERFACE \"SIMDJSON_BUILTIN_IMPLEMENTATION=${implementation}\")\n-      break()\n-    endif()\n-  endforeach(implementation)\n-endif(SIMDJSON_BUILTIN_IMPLEMENTATION)\n-\n-option(SIMDJSON_IMPLEMENTATION_HASWELL \"Include the haswell implementation\" ON)\n-if(NOT SIMDJSON_IMPLEMENTATION_HASWELL)\n-  message(DEPRECATION \"SIMDJSON_IMPLEMENTATION_HASWELL is deprecated. Use SIMDJSON_IMPLEMENTATION=-haswell instead.\")\n-  target_compile_definitions(simdjson-flags INTERFACE SIMDJSON_IMPLEMENTATION_HASWELL=0)\n-endif()\n-option(SIMDJSON_IMPLEMENTATION_WESTMERE \"Include the westmere implementation\" ON)\n-if(NOT SIMDJSON_IMPLEMENTATION_WESTMERE)\n-  message(DEPRECATION \"SIMDJSON_IMPLEMENTATION_WESTMERE is deprecated. SIMDJSON_IMPLEMENTATION=-westmere instead.\")\n-  target_compile_definitions(simdjson-flags INTERFACE SIMDJSON_IMPLEMENTATION_WESTMERE=0)\n-endif()\n-option(SIMDJSON_IMPLEMENTATION_ARM64 \"Include the arm64 implementation\" ON)\n-if(NOT SIMDJSON_IMPLEMENTATION_ARM64)\n-  message(DEPRECATION \"SIMDJSON_IMPLEMENTATION_ARM64 is deprecated. Use SIMDJSON_IMPLEMENTATION=-arm64 instead.\")\n-  target_compile_definitions(simdjson-flags INTERFACE SIMDJSON_IMPLEMENTATION_ARM64=0)\n-endif()\n-option(SIMDJSON_IMPLEMENTATION_PPC64 \"Include the arm64 implementation\" ON)\n-if(NOT SIMDJSON_IMPLEMENTATION_PPC64)\n-  message(DEPRECATION \"SIMDJSON_IMPLEMENTATION_PPC64 is deprecated. Use SIMDJSON_IMPLEMENTATION=-ppc64 instead.\")\n-  target_compile_definitions(simdjson-flags INTERFACE SIMDJSON_IMPLEMENTATION_PPC64=0)\n-endif()\n-option(SIMDJSON_IMPLEMENTATION_FALLBACK \"Include the fallback implementation\" ON)\n-if(NOT SIMDJSON_IMPLEMENTATION_FALLBACK)\n-  message(DEPRECATION \"SIMDJSON_IMPLEMENTATION_FALLBACK is deprecated. Use SIMDJSON_IMPLEMENTATION=-fallback instead.\")\n-  target_compile_definitions(simdjson-flags INTERFACE SIMDJSON_IMPLEMENTATION_FALLBACK=0)\n-endif()\n-\n-#\n-# Other optional flags\n-#\n-option(SIMDJSON_DEVELOPMENT_CHECKS \"Enable development-time aids, such as checks for incorrect API usage. Enabled by default in DEBUG.\" OFF)\n-if(SIMDJSON_DEVELOPMENT_CHECKS)\n-  target_compile_definitions(simdjson-flags INTERFACE SIMDJSON_DEVELOPMENT_CHECKS)\n-endif()\n-\n-option(SIMDJSON_BASH \"Allow usage of bash within CMake\" ON)\n-\n-option(SIMDJSON_EXCEPTIONS \"Enable simdjson's exception-throwing interface\" ON)\n-if(NOT SIMDJSON_EXCEPTIONS)\n-  message(STATUS \"simdjson exception interface turned off. Code that does not check error codes will not compile.\")\n-  target_compile_definitions(simdjson-flags INTERFACE SIMDJSON_EXCEPTIONS=0)\n-  if(MSVC)\n-    # CMake currently /EHsc as a default flag in CMAKE_CXX_FLAGS on MSVC. Replacing this with a more general abstraction is a WIP (see https://gitlab.kitware.com/cmake/cmake/-/issues/20610)\n-    # /EHs enables standard C++ stack unwinding when catching exceptions (non-structured exception handling)\n-    # /EHc used in conjection with /EHs indicates that extern \"C\" functions never throw (terminate-on-throw)\n-    # Here, we disable both with the - argument negation operator\n-    string(REPLACE \"/EHsc\" \"/EHs-c-\" CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS})\n-\n-    # Because we cannot change the flag above on an invidual target (yet), the definition below must similarly be added globally\n-    add_definitions(-D_HAS_EXCEPTIONS=0)\n-  elseif (CMAKE_COMPILER_IS_GNUCC)\n-    target_link_libraries(simdjson-flags INTERFACE -fno-exceptions)\n-  endif()\n-endif()\n-\n-option(SIMDJSON_ENABLE_THREADS \"Link with thread support\" ON)\n-if(SIMDJSON_ENABLE_THREADS)\n-  set(CMAKE_THREAD_PREFER_PTHREAD TRUE)\n-  set(THREADS_PREFER_PTHREAD_FLAG TRUE)\n-  find_package(Threads REQUIRED)\n-  target_link_libraries(simdjson-flags INTERFACE Threads::Threads)\n-  target_compile_definitions(simdjson-flags INTERFACE SIMDJSON_THREADS_ENABLED=1) # This will be set in the code automatically.\n-endif()\n-\n-option(SIMDJSON_VERBOSE_LOGGING, \"Enable verbose logging for internal simdjson library development.\" OFF)\n-if (SIMDJSON_VERBOSE_LOGGING)\n-  target_compile_definitions(simdjson-flags INTERFACE SIMDJSON_VERBOSE_LOGGING=1)\n-endif()\n-\n-option(SIMDJSON_DISABLE_DEPRECATED_API \"Disables deprecated APIs\" Off)\n-if (SIMDJSON_DISABLE_DEPRECATED_API)\n-    target_compile_definitions(simdjson-flags INTERFACE SIMDJSON_DISABLE_DEPRECATED_API=1)\n-endif()\n-\n-if(SIMDJSON_USE_LIBCPP)\n-  target_link_libraries(simdjson-flags INTERFACE -stdlib=libc++ -lc++abi)\n-  # instead of the above line, we could have used\n-  # set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -stdlib=libc++  -lc++abi\")\n-  # The next line is needed empirically.\n-  set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -stdlib=libc++\")\n-  # we update CMAKE_SHARED_LINKER_FLAGS, this gets updated later as well\n-  set(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -lc++abi\")\n-endif(SIMDJSON_USE_LIBCPP)\n-\n-# prevent shared libraries from depending on Intel provided libraries\n-if(${CMAKE_C_COMPILER_ID} MATCHES \"Intel\") # icc / icpc\n-  set(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -static-intel\")\n-endif()\n-\n-include (CheckSymbolExists)\n-CHECK_SYMBOL_EXISTS(fork unistd.h HAVE_POSIX_FORK)\n-CHECK_SYMBOL_EXISTS(wait sys/wait.h HAVE_POSIX_WAIT)\n-\n-install(TARGETS simdjson-flags EXPORT simdjson-config)\n-\n-# I do not think we want to export our internal flags!\n-# install(TARGETS simdjson-internal-flags EXPORT simdjson-config)"
      },
      {
        "filename": "vendor/simdjson/cmake/simdjson-props.cmake",
        "status": "added",
        "additions": 48,
        "deletions": 0,
        "changes": 48,
        "patch": "@@ -0,0 +1,48 @@\n+#\n+# Accumulate flags\n+#\n+set(simdjson_props_script \"${PROJECT_BINARY_DIR}/simdjson-props.cmake\")\n+set(simdjson_props_content \"\")\n+set(simdjson_props_flushed NO)\n+\n+function(simdjson_add_props command)\n+  set(args \"\")\n+  math(EXPR limit \"${ARGC} - 1\")\n+  foreach(i RANGE 1 \"${limit}\")\n+    set(value \"${ARGV${i}}\")\n+    if(value MATCHES \"^(PRIVATE|PUBLIC)$\")\n+      string(TOLOWER \"${value}\" value)\n+      set(value \"\\${${value}}\")\n+    else()\n+      set(value \"[==[${value}]==]\")\n+    endif()\n+    string(APPEND args \" ${value}\")\n+  endforeach()\n+\n+  set(simdjson_props_flushed NO PARENT_SCOPE)\n+  set(\n+      simdjson_props_content\n+      \"${simdjson_props_content}${command}(\\\"\\${target}\\\"${args})\\n\"\n+      PARENT_SCOPE\n+  )\n+endfunction()\n+\n+macro(simdjson_flush_props)\n+  if(NOT simdjson_props_flushed)\n+    set(simdjson_props_flushed YES PARENT_SCOPE)\n+    file(WRITE \"${simdjson_props_script}\" \"${simdjson_props_content}\")\n+  endif()\n+endmacro()\n+\n+function(simdjson_apply_props target)\n+  set(private PRIVATE)\n+  set(public PUBLIC)\n+  get_target_property(TYPE \"${target}\" TYPE)\n+  if(TYPE STREQUAL \"INTERFACE_LIBRARY\")\n+    set(private INTERFACE)\n+    set(public INTERFACE)\n+  endif()\n+\n+  simdjson_flush_props()\n+  include(\"${simdjson_props_script}\")\n+endfunction()"
      },
      {
        "filename": "vendor/simdjson/cmake/simdjson-user-cmakecache.cmake",
        "status": "modified",
        "additions": 17,
        "deletions": 22,
        "changes": 39,
        "patch": "@@ -1,24 +1,19 @@\n #\n-# ${SIMDJSON_USER_CMAKECACHE} contains the *user-specified* simdjson options so you can call cmake on\n-# another branch or repository with the same options.\n+# ${USER_CMAKECACHE} contains the *user-specified* simdjson options so you can\n+# call cmake on another branch or repository with the same options.\n #\n-# Not supported on Windows at present, because the only thing that uses it is checkperf, which we\n-# don't run on Windows.\n-#\n-set(SIMDJSON_USER_CMAKECACHE ${CMAKE_CURRENT_BINARY_DIR}/.simdjson-user-CMakeCache.txt)\n-if (MSVC)\n-  add_custom_command(\n-    OUTPUT ${SIMDJSON_USER_CMAKECACHE}\n-    COMMAND findstr SIMDJSON_ ${PROJECT_BINARY_DIR}/CMakeCache.txt > ${SIMDJSON_USER_CMAKECACHE}.tmp\n-    COMMAND findstr /v SIMDJSON_LIB_ ${SIMDJSON_USER_CMAKECACHE}.tmp > ${SIMDJSON_USER_CMAKECACHE}\n-    VERBATIM # Makes it not do weird escaping with the command\n-  )\n-else()\n-  add_custom_command(\n-    OUTPUT ${SIMDJSON_USER_CMAKECACHE}\n-    COMMAND grep SIMDJSON_ ${PROJECT_BINARY_DIR}/CMakeCache.txt > ${SIMDJSON_USER_CMAKECACHE}.tmp\n-    COMMAND grep -v SIMDJSON_LIB_ ${SIMDJSON_USER_CMAKECACHE}.tmp > ${SIMDJSON_USER_CMAKECACHE}\n-    VERBATIM # Makes it not do weird escaping with the command\n-  )\n-endif()\n-add_custom_target(simdjson-user-cmakecache DEPENDS ${SIMDJSON_USER_CMAKECACHE})\n+\n+file(READ \"${BINARY_DIR}/CMakeCache.txt\" cache)\n+# Escape semicolons, so the lines can be safely iterated in CMake\n+string(REPLACE \";\" \"\\\\;\" cache \"${cache}\")\n+# Turn the contents into a list\n+string(REPLACE \"\\n\" \";\" cache \"${cache}\")\n+\n+message(STATUS \"${USER_CMAKECACHE}\")\n+\n+file(REMOVE \"${USER_CMAKECACHE}\")\n+foreach(line IN LISTS cache)\n+  if(line MATCHES \"^SIMDJSON_\" AND NOT line MATCHES \"^SIMDJSON_LIB_\")\n+    file(APPEND \"${USER_CMAKECACHE}\" \"${line}\\n\")\n+  endif()\n+endforeach()"
      },
      {
        "filename": "vendor/simdjson/examples/quickstart/quickstart.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "patch": "@@ -1,7 +1,8 @@\n+#include <iostream>\n #include \"simdjson.h\"\n \n int main(void) {\n   simdjson::dom::parser parser;\n   simdjson::dom::element tweets = parser.load(\"twitter.json\");\n   std::cout << tweets[\"search_metadata\"][\"count\"] << \" results.\" << std::endl;\n-}\n\\ No newline at end of file\n+}"
      },
      {
        "filename": "vendor/simdjson/examples/quickstart/quickstart2.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -1,3 +1,4 @@\n+#include <iostream>\n #include \"simdjson.h\"\n \n int main(void) {"
      },
      {
        "filename": "vendor/simdjson/examples/quickstart/quickstart2_noexceptions.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -1,3 +1,4 @@\n+#include <iostream>\n #include \"simdjson.h\"\n \n int main(void) {"
      },
      {
        "filename": "vendor/simdjson/examples/quickstart/quickstart_noexceptions.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -1,3 +1,4 @@\n+#include <iostream>\n #include \"simdjson.h\"\n \n int main(void) {"
      },
      {
        "filename": "vendor/simdjson/examples/quickstart/quickstart_ondemand.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -1,3 +1,4 @@\n+#include <iostream>\n #include \"simdjson.h\"\n using namespace simdjson;\n int main(void) {"
      },
      {
        "filename": "vendor/simdjson/examples/quickstart/quickstart_ondemand_noexceptions.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "patch": "@@ -1,3 +1,4 @@\n+#include <iostream>\n #include \"simdjson.h\"\n using namespace simdjson;\n int main(void) {"
      },
      {
        "filename": "vendor/simdjson/include/CMakeLists.txt",
        "status": "removed",
        "additions": 0,
        "deletions": 13,
        "changes": 13,
        "patch": "@@ -1,13 +0,0 @@\n-#\n-# Provides the simdjson headers.\n-#\n-# target_link_libraries(my-project simdjson-headers) grants the headers. It does not provide the\n-# source, libraries or any compiler flags.\n-#\n-add_library(simdjson-headers INTERFACE)\n-target_compile_features(simdjson-headers INTERFACE cxx_std_11) # headers require at least C++11\n-target_include_directories(simdjson-headers INTERFACE\n-  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\n-  $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCDIR}>)\n-\n-install(TARGETS simdjson-headers EXPORT simdjson-config INCLUDES DESTINATION include)"
      },
      {
        "filename": "vendor/simdjson/include/simdjson.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -4,7 +4,7 @@\n /**\n  * @mainpage\n  *\n- * Check the [README.md](https://github.com/lemire/simdjson/blob/master/README.md#simdjson--parsing-gigabytes-of-json-per-second).\n+ * Check the [README.md](https://github.com/simdjson/simdjson/blob/master/README.md#simdjson--parsing-gigabytes-of-json-per-second).\n  *\n  * Sample code. See https://github.com/simdjson/simdjson/blob/master/doc/basics.md for more examples.\n "
      },
      {
        "filename": "vendor/simdjson/include/simdjson/arm64/bitmanipulation.h",
        "status": "modified",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "patch": "@@ -46,6 +46,40 @@ simdjson_really_inline int count_ones(uint64_t input_num) {\n    return vaddv_u8(vcnt_u8(vcreate_u8(input_num)));\n }\n \n+\n+#if defined(__GNUC__) // catches clang and gcc\n+/**\n+ * ARM has a fast 64-bit \"bit reversal function\" that is handy. However,\n+ * it is not generally available as an intrinsic function under Visual\n+ * Studio (though this might be changing). Even under clang/gcc, we\n+ * apparently need to invoke inline assembly.\n+ */\n+/*\n+ * We use SIMDJSON_PREFER_REVERSE_BITS as a hint that algorithms that\n+ * work well with bit reversal may use it.\n+ */\n+#define SIMDJSON_PREFER_REVERSE_BITS 1\n+\n+/* reverse the bits */\n+simdjson_really_inline uint64_t reverse_bits(uint64_t input_num) {\n+  uint64_t rev_bits;\n+  __asm(\"rbit %0, %1\" : \"=r\"(rev_bits) : \"r\"(input_num));\n+  return rev_bits;\n+}\n+\n+/**\n+ * Flips bit at index 63 - lz. Thus if you have 'leading_zeroes' leading zeroes,\n+ * then this will set to zero the leading bit. It is possible for leading_zeroes to be\n+ * greating or equal to 63 in which case we trigger undefined behavior, but the output\n+ * of such undefined behavior is never used.\n+ **/\n+NO_SANITIZE_UNDEFINED\n+simdjson_really_inline uint64_t zero_leading_bit(uint64_t rev_bits, int leading_zeroes) {\n+  return rev_bits ^ (uint64_t(0x8000000000000000) >> leading_zeroes);\n+}\n+\n+#endif\n+\n simdjson_really_inline bool add_overflow(uint64_t value1, uint64_t value2, uint64_t *result) {\n #ifdef SIMDJSON_REGULAR_VISUAL_STUDIO\n   *result = value1 + value2;"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/arm64/numberparsing.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -19,7 +19,7 @@ static simdjson_really_inline uint32_t parse_eight_digits_unrolled(const uint8_t\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n \n-#define SWAR_NUMBER_PARSING\n+#define SIMDJSON_SWAR_NUMBER_PARSING 1\n \n #include \"simdjson/generic/numberparsing.h\"\n "
      },
      {
        "filename": "vendor/simdjson/include/simdjson/arm64/simd.h",
        "status": "modified",
        "additions": 44,
        "deletions": 6,
        "changes": 50,
        "patch": "@@ -57,6 +57,19 @@ simdjson_really_inline uint8x16_t make_uint8x16_t(uint8_t x1,  uint8_t x2,  uint\n   return x;\n }\n \n+simdjson_really_inline uint8x8_t make_uint8x8_t(uint8_t x1,  uint8_t x2,  uint8_t x3,  uint8_t x4,\n+                                         uint8_t x5,  uint8_t x6,  uint8_t x7,  uint8_t x8) {\n+  uint8x8_t x{};\n+  x = vset_lane_u8(x1, x, 0);\n+  x = vset_lane_u8(x2, x, 1);\n+  x = vset_lane_u8(x3, x, 2);\n+  x = vset_lane_u8(x4, x, 3);\n+  x = vset_lane_u8(x5, x, 4);\n+  x = vset_lane_u8(x6, x, 5);\n+  x = vset_lane_u8(x7, x, 6);\n+  x = vset_lane_u8(x8, x, 7);\n+  return x;\n+}\n \n // We have to do the same work for make_int8x16_t\n simdjson_really_inline int8x16_t make_int8x16_t(int8_t x1,  int8_t x2,  int8_t x3,  int8_t x4,\n@@ -289,6 +302,27 @@ simdjson_really_inline int8x16_t make_int8x16_t(int8_t x1,  int8_t x2,  int8_t x\n       vst1q_u8(reinterpret_cast<uint8_t*>(output), answer);\n     }\n \n+    // Copies all bytes corresponding to a 0 in the low half of the mask (interpreted as a\n+    // bitset) to output1, then those corresponding to a 0 in the high half to output2.\n+    template<typename L>\n+    simdjson_really_inline void compress_halves(uint16_t mask, L *output1, L *output2) const {\n+      using internal::thintable_epi8;\n+      uint8_t mask1 = uint8_t(mask); // least significant 8 bits\n+      uint8_t mask2 = uint8_t(mask >> 8); // most significant 8 bits\n+      uint8x8_t compactmask1 = vcreate_u8(thintable_epi8[mask1]);\n+      uint8x8_t compactmask2 = vcreate_u8(thintable_epi8[mask2]);\n+      // we increment by 0x08 the second half of the mask\n+#ifdef SIMDJSON_REGULAR_VISUAL_STUDIO\n+      uint8x8_t inc = make_uint8x8_t(0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08);\n+#else\n+      uint8x8_t inc = {0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08};\n+#endif\n+      compactmask2 = vadd_u8(compactmask2, inc);\n+      // store each result (with the second store possibly overlapping the first)\n+      vst1_u8((uint8_t*)output1, vqtbl1_u8(*this, compactmask1));\n+      vst1_u8((uint8_t*)output2, vqtbl1_u8(*this, compactmask2));\n+    }\n+\n     template<typename L>\n     simdjson_really_inline simd8<L> lookup_16(\n         L replace0,  L replace1,  L replace2,  L replace3,\n@@ -364,7 +398,7 @@ simdjson_really_inline int8x16_t make_int8x16_t(int8_t x1,  int8_t x2,  int8_t x\n     // Explicit conversion to/from unsigned\n     //\n     // Under Visual Studio/ARM64 uint8x16_t and int8x16_t are apparently the same type.\n-    // In theory, we could check this occurence with std::same_as and std::enabled_if but it is C++14\n+    // In theory, we could check this occurrence with std::same_as and std::enabled_if but it is C++14\n     // and relatively ugly and hard to read.\n #ifndef SIMDJSON_REGULAR_VISUAL_STUDIO\n     simdjson_really_inline explicit simd8(const uint8x16_t other): simd8(vreinterpretq_s8_u8(other)) {}\n@@ -439,11 +473,15 @@ simdjson_really_inline int8x16_t make_int8x16_t(int8_t x1,  int8_t x2,  int8_t x\n     }\n \n \n-    simdjson_really_inline void compress(uint64_t mask, T * output) const {\n-      this->chunks[0].compress(uint16_t(mask), output);\n-      this->chunks[1].compress(uint16_t(mask >> 16), output + 16 - count_ones(mask & 0xFFFF));\n-      this->chunks[2].compress(uint16_t(mask >> 32), output + 32 - count_ones(mask & 0xFFFFFFFF));\n-      this->chunks[3].compress(uint16_t(mask >> 48), output + 48 - count_ones(mask & 0xFFFFFFFFFFFF));\n+    simdjson_really_inline uint64_t compress(uint64_t mask, T * output) const {\n+      uint64_t popcounts = vget_lane_u64(vreinterpret_u64_u8(vcnt_u8(vcreate_u8(~mask))), 0);\n+      // compute the prefix sum of the popcounts of each byte\n+      uint64_t offsets = popcounts * 0x0101010101010101;\n+      this->chunks[0].compress_halves(uint16_t(mask), output, &output[popcounts & 0xFF]);\n+      this->chunks[1].compress_halves(uint16_t(mask >> 16), &output[(offsets >> 8) & 0xFF], &output[(offsets >> 16) & 0xFF]);\n+      this->chunks[2].compress_halves(uint16_t(mask >> 32), &output[(offsets >> 24) & 0xFF], &output[(offsets >> 32) & 0xFF]);\n+      this->chunks[3].compress_halves(uint16_t(mask >> 48), &output[(offsets >> 40) & 0xFF], &output[(offsets >> 48) & 0xFF]);\n+      return offsets >> 56;\n     }\n \n     simdjson_really_inline uint64_t to_bitmask() const {"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/common_defs.h",
        "status": "modified",
        "additions": 10,
        "deletions": 8,
        "changes": 18,
        "patch": "@@ -19,6 +19,8 @@ char *to_chars(char *first, const char *last, double value);\n  * Defined in src/from_chars\n  */\n double from_chars(const char *first) noexcept;\n+double from_chars(const char *first, const char* end) noexcept;\n+\n }\n \n #ifndef SIMDJSON_EXCEPTIONS\n@@ -38,7 +40,7 @@ constexpr size_t SIMDJSON_MAXSIZE_BYTES = 0xFFFFFFFF;\n  * the input buf should be readable up to buf + SIMDJSON_PADDING\n  * this is a stopgap; there should be a better description of the\n  * main loop and its behavior that abstracts over this\n- * See https://github.com/lemire/simdjson/issues/174\n+ * See https://github.com/simdjson/simdjson/issues/174\n  */\n constexpr size_t SIMDJSON_PADDING = 32;\n \n@@ -161,7 +163,7 @@ constexpr size_t DEFAULT_MAX_DEPTH = 1024;\n      * the regular visual studio or clang under visual\n      * studio, you still need to handle these issues.\n      *\n-     * Non-Windows sytems do not have this complexity.\n+     * Non-Windows systems do not have this complexity.\n      */\n     #if SIMDJSON_BUILDING_WINDOWS_DYNAMIC_LIBRARY\n     // We set SIMDJSON_BUILDING_WINDOWS_DYNAMIC_LIBRARY when we build a DLL under Windows.\n@@ -215,7 +217,7 @@ constexpr size_t DEFAULT_MAX_DEPTH = 1024;\n // now it is safe to trigger the include\n #include <string_view> // though the file is there, it does not follow that we got the implementation\n #if defined(_LIBCPP_STRING_VIEW)\n-// Ah! So we under libc++ which under its Library Fundamentals Technical Specification, which preceeded C++17,\n+// Ah! So we under libc++ which under its Library Fundamentals Technical Specification, which preceded C++17,\n // included string_view.\n // This means that we have string_view *even though* we may not have C++17.\n #define SIMDJSON_HAS_STRING_VIEW\n@@ -251,7 +253,8 @@ namespace std {\n #endif\n #endif\n \n-\n+// The SIMDJSON_CHECK_EOF macro is a feature flag for the \"don't require padding\"\n+// feature.\n \n #if SIMDJSON_CPLUSPLUS17\n // if we have C++, then fallthrough is a default attribute\n@@ -262,12 +265,11 @@ namespace std {\n #if __has_attribute(__fallthrough__)\n // we are good to go:\n # define simdjson_fallthrough                    __attribute__((__fallthrough__))\n-#endif\n-#endif\n+#endif // __has_attribute(__fallthrough__)\n+#endif // SIMDJSON_CPLUSPLUS17\n // on some systems, we simply do not have support for fallthrough, so use a default:\n #ifndef simdjson_fallthrough\n # define simdjson_fallthrough do {} while (0)  /* fallthrough */\n-#endif\n-\n+#endif // simdjson_fallthrough\n \n #endif // SIMDJSON_COMMON_DEFS_H"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/dom/document-inl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -37,7 +37,7 @@ inline error_code document::allocate(size_t capacity) noexcept {\n   // need a capacity of at least capacity + 1, but it is also possible to do\n   // worse with \"[7,7,7,7,6,7,7,7,6,7,7,6,[7,7,7,7,6,7,7,7,6,7,7,6,7,7,7,7,7,7,6\"\n   //where capacity + 1 tape elements are\n-  // generated, see issue https://github.com/lemire/simdjson/issues/345\n+  // generated, see issue https://github.com/simdjson/simdjson/issues/345\n   size_t tape_capacity = SIMDJSON_ROUNDUP_N(capacity + 3, 64);\n   // a document with only zero-length strings... could have capacity/3 string\n   // and we would need capacity/3 * 5 bytes on the string buffer"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/dom/document_stream-inl.h",
        "status": "modified",
        "additions": 21,
        "deletions": 8,
        "changes": 29,
        "patch": "@@ -187,7 +187,7 @@ inline void document_stream::start() noexcept {\n   // Always run the first stage 1 parse immediately\n   batch_start = 0;\n   error = run_stage1(*parser, batch_start);\n-  if(error == EMPTY) {\n+  while(error == EMPTY) {\n     // In exceptional cases, we may start with an empty block\n     batch_start = next_batch_start();\n     if (batch_start >= len) { return; }\n@@ -204,7 +204,6 @@ inline void document_stream::start() noexcept {\n     if (error) { return; }\n   }\n #endif // SIMDJSON_THREADS_ENABLED\n-\n   next();\n }\n \n@@ -213,13 +212,20 @@ simdjson_really_inline size_t document_stream::iterator::current_index() const n\n }\n \n simdjson_really_inline std::string_view document_stream::iterator::source() const noexcept {\n-  size_t next_doc_index = stream->batch_start + stream->parser->implementation->structural_indexes[stream->parser->implementation->next_structural_index];\n-  return std::string_view(reinterpret_cast<const char*>(stream->buf) + current_index(), next_doc_index - current_index() - 1);\n+  const char* start = reinterpret_cast<const char*>(stream->buf) + current_index();\n+  bool object_or_array = ((*start == '[') || (*start == '{'));\n+  if(object_or_array) {\n+    size_t next_doc_index = stream->batch_start + stream->parser->implementation->structural_indexes[stream->parser->implementation->next_structural_index - 1];\n+    return std::string_view(start, next_doc_index - current_index() + 1);\n+  } else {\n+    size_t next_doc_index = stream->batch_start + stream->parser->implementation->structural_indexes[stream->parser->implementation->next_structural_index];\n+    return std::string_view(reinterpret_cast<const char*>(stream->buf) + current_index(), next_doc_index - current_index() - 1);\n+  }\n }\n \n \n inline void document_stream::next() noexcept {\n-  // We always enter at once once in an error condition.\n+  // We always exit at once, once in an error condition.\n   if (error) { return; }\n \n   // Load the next document from the batch\n@@ -245,18 +251,25 @@ inline void document_stream::next() noexcept {\n     error = parser->implementation->stage2_next(parser->doc);\n   }\n }\n+inline size_t document_stream::size_in_bytes() const noexcept {\n+  return len;\n+}\n+\n+inline size_t document_stream::truncated_bytes() const noexcept {\n+  if(error == CAPACITY) { return len - batch_start; }\n+  return parser->implementation->structural_indexes[parser->implementation->n_structural_indexes] - parser->implementation->structural_indexes[parser->implementation->n_structural_indexes + 1];\n+}\n \n inline size_t document_stream::next_batch_start() const noexcept {\n   return batch_start + parser->implementation->structural_indexes[parser->implementation->n_structural_indexes];\n }\n \n inline error_code document_stream::run_stage1(dom::parser &p, size_t _batch_start) noexcept {\n-  // If this is the final batch, pass partial = false\n   size_t remaining = len - _batch_start;\n   if (remaining <= batch_size) {\n-    return p.implementation->stage1(&buf[_batch_start], remaining, false);\n+    return p.implementation->stage1(&buf[_batch_start], remaining, stage1_mode::streaming_final);\n   } else {\n-    return p.implementation->stage1(&buf[_batch_start], batch_size, true);\n+    return p.implementation->stage1(&buf[_batch_start], batch_size, stage1_mode::streaming_partial);\n   }\n }\n "
      },
      {
        "filename": "vendor/simdjson/include/simdjson/dom/document_stream.h",
        "status": "modified",
        "additions": 24,
        "deletions": 3,
        "changes": 27,
        "patch": "@@ -87,7 +87,29 @@ class document_stream {\n   simdjson_really_inline document_stream &operator=(document_stream &&other) noexcept = default;\n \n   simdjson_really_inline ~document_stream() noexcept;\n-\n+  /**\n+   * Returns the input size in bytes.\n+   */\n+  inline size_t size_in_bytes() const noexcept;\n+  /**\n+   * After iterating through the stream, this method\n+   * returns the number of bytes that were not parsed at the end\n+   * of the stream. If truncated_bytes() differs from zero,\n+   * then the input was truncated maybe because incomplete JSON\n+   * documents were found at the end of the stream. You\n+   * may need to process the bytes in the interval [size_in_bytes()-truncated_bytes(), size_in_bytes()).\n+   *\n+   * You should only call truncated_bytes() after streaming through all\n+   * documents, like so:\n+   *\n+   *   document_stream stream = parser.parse_many(json,window);\n+   *   for(auto doc : stream) {\n+   *      // do something with doc\n+   *   }\n+   *   size_t truncated = stream.truncated_bytes();\n+   *\n+   */\n+  inline size_t truncated_bytes() const noexcept;\n   /**\n    * An iterator through a forward-only stream of documents.\n    */\n@@ -101,7 +123,7 @@ class document_stream {\n     using iterator_category = std::input_iterator_tag;\n \n     /**\n-     * Default contructor.\n+     * Default constructor.\n      */\n     simdjson_really_inline iterator() noexcept;\n     /**\n@@ -245,7 +267,6 @@ class document_stream {\n   error_code error;\n   size_t batch_start{0};\n   size_t doc_index{};\n-\n #ifdef SIMDJSON_THREADS_ENABLED\n   /** Indicates whether we use threads. Note that this needs to be a constant during the execution of the parsing. */\n   bool use_thread;"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/dom/element.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -355,7 +355,7 @@ class element {\n    * The key will be matched against **unescaped** JSON:\n    *\n    *   dom::parser parser;\n-   *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"].get_uint64().first == 1\n+   *   int64_t(parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"]) == 1\n    *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\\\n\"].get_uint64().error() == NO_SUCH_FIELD\n    *\n    * @return The value associated with this field, or:\n@@ -370,7 +370,7 @@ class element {\n    * The key will be matched against **unescaped** JSON:\n    *\n    *   dom::parser parser;\n-   *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"].get_uint64().first == 1\n+   *   int64_t(parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"]) == 1\n    *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\\\n\"].get_uint64().error() == NO_SUCH_FIELD\n    *\n    * @return The value associated with this field, or:\n@@ -442,7 +442,7 @@ class element {\n    * The key will be matched against **unescaped** JSON:\n    *\n    *   dom::parser parser;\n-   *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"].get_uint64().first == 1\n+   *   int64_t(parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"]) == 1\n    *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\\\n\"].get_uint64().error() == NO_SUCH_FIELD\n    *\n    * @return The value associated with this field, or:"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/dom/object.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -123,7 +123,7 @@ class object {\n    * The key will be matched against **unescaped** JSON:\n    *\n    *   dom::parser parser;\n-   *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"].get_uint64().first == 1\n+   *   int64_t(parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"]) == 1\n    *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\\\n\"].get_uint64().error() == NO_SUCH_FIELD\n    *\n    * This function has linear-time complexity: the keys are checked one by one.\n@@ -140,7 +140,7 @@ class object {\n    * The key will be matched against **unescaped** JSON:\n    *\n    *   dom::parser parser;\n-   *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"].get_uint64().first == 1\n+   *   int64_t(parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"]) == 1\n    *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\\\n\"].get_uint64().error() == NO_SUCH_FIELD\n    *\n    * This function has linear-time complexity: the keys are checked one by one.\n@@ -182,7 +182,7 @@ class object {\n    * The key will be matched against **unescaped** JSON:\n    *\n    *   dom::parser parser;\n-   *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"].get_uint64().first == 1\n+   *   int64_t(parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\n\"]) == 1\n    *   parser.parse(R\"({ \"a\\n\": 1 })\"_padded)[\"a\\\\n\"].get_uint64().error() == NO_SUCH_FIELD\n    *\n    * This function has linear-time complexity: the keys are checked one by one."
      },
      {
        "filename": "vendor/simdjson/include/simdjson/dom/parsedjson_iterator.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -208,7 +208,7 @@ class [[deprecated(\"Use the new DOM navigation API instead (see doc/basics.md)\")\n   // throughout return true if we can do the navigation, false\n   // otherwise\n \n-  // Withing a given scope (series of nodes at the same depth within either an\n+  // Within a given scope (series of nodes at the same depth within either an\n   // array or an object), we move forward.\n   // Thus, given [true, null, {\"a\":1}, [1,2]], we would visit true, null, {\n   // and [. At the object ({) or at the array ([), you can issue a \"down\" to"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/dom/parser-inl.h",
        "status": "modified",
        "additions": 10,
        "deletions": 5,
        "changes": 15,
        "patch": "@@ -100,13 +100,18 @@ inline simdjson_result<element> parser::parse_into_document(document& provided_d\n   // Important: It is possible that provided_doc is actually the internal 'doc' within the parser!!!\n   error_code _error = ensure_capacity(provided_doc, len);\n   if (_error) { return _error; }\n-  std::unique_ptr<uint8_t[]> tmp_buf;\n   if (realloc_if_needed) {\n-    tmp_buf.reset(reinterpret_cast<uint8_t *>( internal::allocate_padded_buffer(len) ));\n-    if (tmp_buf.get() == nullptr) { return MEMALLOC; }\n-    std::memcpy(static_cast<void *>(tmp_buf.get()), buf, len);\n+    // Make sure we have enough capacity to copy len bytes\n+    if (!loaded_bytes || _loaded_bytes_capacity < len) {\n+      loaded_bytes.reset( internal::allocate_padded_buffer(len) );\n+      if (!loaded_bytes) {\n+        return MEMALLOC;\n+      }\n+      _loaded_bytes_capacity = len;\n+    }\n+    std::memcpy(static_cast<void *>(loaded_bytes.get()), buf, len);\n   }\n-  _error = implementation->parse(realloc_if_needed ? tmp_buf.get() : buf, len, provided_doc);\n+  _error = implementation->parse(realloc_if_needed ? reinterpret_cast<const uint8_t*>(loaded_bytes.get()): buf, len, provided_doc);\n \n   if (_error) { return _error; }\n "
      },
      {
        "filename": "vendor/simdjson/include/simdjson/dom/parser.h",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "patch": "@@ -335,7 +335,7 @@ class parser {\n    *         - other json errors if parsing fails. You should not rely on these errors to always the same for the\n    *           same document: they may vary under runtime dispatch (so they may vary depending on your system and hardware).\n    */\n-  inline simdjson_result<document_stream> load_many(const std::string &path, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept;\n+  inline simdjson_result<document_stream> load_many(const std::string &path, size_t batch_size = dom::DEFAULT_BATCH_SIZE) noexcept;\n \n   /**\n    * Parse a buffer containing many JSON documents.\n@@ -429,18 +429,18 @@ class parser {\n    *         - other json errors if parsing fails. You should not rely on these errors to always the same for the\n    *           same document: they may vary under runtime dispatch (so they may vary depending on your system and hardware).\n    */\n-  inline simdjson_result<document_stream> parse_many(const uint8_t *buf, size_t len, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept;\n+  inline simdjson_result<document_stream> parse_many(const uint8_t *buf, size_t len, size_t batch_size = dom::DEFAULT_BATCH_SIZE) noexcept;\n   /** @overload parse_many(const uint8_t *buf, size_t len, size_t batch_size) */\n-  inline simdjson_result<document_stream> parse_many(const char *buf, size_t len, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept;\n+  inline simdjson_result<document_stream> parse_many(const char *buf, size_t len, size_t batch_size = dom::DEFAULT_BATCH_SIZE) noexcept;\n   /** @overload parse_many(const uint8_t *buf, size_t len, size_t batch_size) */\n-  inline simdjson_result<document_stream> parse_many(const std::string &s, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept;\n+  inline simdjson_result<document_stream> parse_many(const std::string &s, size_t batch_size = dom::DEFAULT_BATCH_SIZE) noexcept;\n   inline simdjson_result<document_stream> parse_many(const std::string &&s, size_t batch_size) = delete;// unsafe\n   /** @overload parse_many(const uint8_t *buf, size_t len, size_t batch_size) */\n-  inline simdjson_result<document_stream> parse_many(const padded_string &s, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept;\n+  inline simdjson_result<document_stream> parse_many(const padded_string &s, size_t batch_size = dom::DEFAULT_BATCH_SIZE) noexcept;\n   inline simdjson_result<document_stream> parse_many(const padded_string &&s, size_t batch_size) = delete;// unsafe\n \n   /** @private We do not want to allow implicit conversion from C string to std::string. */\n-  simdjson_result<document_stream> parse_many(const char *buf, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept = delete;\n+  simdjson_result<document_stream> parse_many(const char *buf, size_t batch_size = dom::DEFAULT_BATCH_SIZE) noexcept = delete;\n \n   /**\n    * Ensure this parser has enough memory to process JSON documents up to `capacity` bytes in length\n@@ -536,7 +536,7 @@ class parser {\n \n   /**\n    * @private return an error code corresponding to the last parsing attempt, see\n-   * simdjson.h will return UNITIALIZED if no parsing was attempted\n+   * simdjson.h will return UNINITIALIZED if no parsing was attempted\n    */\n   [[deprecated(\"Use the result of parser.parse() instead\")]]\n   inline int get_error_code() const noexcept;"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/dom/serialization.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -37,7 +37,7 @@ class string_builder {\n   inline void append(simdjson::dom::element value);\n   /** Append an array to the builder (to be printed) **/\n   inline void append(simdjson::dom::array value);\n-  /** Append an objet to the builder (to be printed) **/\n+  /** Append an object to the builder (to be printed) **/\n   inline void append(simdjson::dom::object value);\n   /** Reset the builder (so that it would print the empty string) **/\n   simdjson_really_inline void clear();\n@@ -92,7 +92,7 @@ class mini_formatter {\n   /** Clears out the content. **/\n   simdjson_really_inline void clear();\n   /**\n-   * Get access to the buffer, it is own by the instance, but\n+   * Get access to the buffer, it is owned by the instance, but\n    * the user can make a copy.\n    **/\n   simdjson_really_inline std::string_view str() const;\n@@ -149,7 +149,7 @@ inline std::ostream& operator<<(std::ostream& out, simdjson::simdjson_result<sim\n  * Print JSON to an output stream.\n  *\n  * @param out The output stream.\n- * @param value The objet.\n+ * @param value The object.\n  * @throw if there is an error with the underlying output stream. simdjson itself will not throw.\n  */\n inline std::ostream& operator<<(std::ostream& out, simdjson::dom::object value)   {"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/error.h",
        "status": "modified",
        "additions": 35,
        "deletions": 33,
        "changes": 68,
        "patch": "@@ -10,33 +10,36 @@ namespace simdjson {\n  * All possible errors returned by simdjson.\n  */\n enum error_code {\n-  SUCCESS = 0,              ///< No error\n-  CAPACITY,                 ///< This parser can't support a document that big\n-  MEMALLOC,                 ///< Error allocating memory, most likely out of memory\n-  TAPE_ERROR,               ///< Something went wrong while writing to the tape (stage 2), this is a generic error\n-  DEPTH_ERROR,              ///< Your document exceeds the user-specified depth limitation\n-  STRING_ERROR,             ///< Problem while parsing a string\n-  T_ATOM_ERROR,             ///< Problem while parsing an atom starting with the letter 't'\n-  F_ATOM_ERROR,             ///< Problem while parsing an atom starting with the letter 'f'\n-  N_ATOM_ERROR,             ///< Problem while parsing an atom starting with the letter 'n'\n-  NUMBER_ERROR,             ///< Problem while parsing a number\n-  UTF8_ERROR,               ///< the input is not valid UTF-8\n-  UNINITIALIZED,            ///< unknown error, or uninitialized document\n-  EMPTY,                    ///< no structural element found\n-  UNESCAPED_CHARS,          ///< found unescaped characters in a string.\n-  UNCLOSED_STRING,          ///< missing quote at the end\n-  UNSUPPORTED_ARCHITECTURE, ///< unsupported architecture\n-  INCORRECT_TYPE,           ///< JSON element has a different type than user expected\n-  NUMBER_OUT_OF_RANGE,      ///< JSON number does not fit in 64 bits\n-  INDEX_OUT_OF_BOUNDS,      ///< JSON array index too large\n-  NO_SUCH_FIELD,            ///< JSON field not found in object\n-  IO_ERROR,                 ///< Error reading a file\n-  INVALID_JSON_POINTER,     ///< Invalid JSON pointer reference\n-  INVALID_URI_FRAGMENT,     ///< Invalid URI fragment\n-  UNEXPECTED_ERROR,         ///< indicative of a bug in simdjson\n-  PARSER_IN_USE,            ///< parser is already in use.\n-  OUT_OF_ORDER_ITERATION,   ///< tried to iterate an array or object out of order\n-  INSUFFICIENT_PADDING,     ///< The JSON doesn't have enough padding for simdjson to safely parse it.\n+  SUCCESS = 0,                ///< No error\n+  CAPACITY,                   ///< This parser can't support a document that big\n+  MEMALLOC,                   ///< Error allocating memory, most likely out of memory\n+  TAPE_ERROR,                 ///< Something went wrong while writing to the tape (stage 2), this is a generic error\n+  DEPTH_ERROR,                ///< Your document exceeds the user-specified depth limitation\n+  STRING_ERROR,               ///< Problem while parsing a string\n+  T_ATOM_ERROR,               ///< Problem while parsing an atom starting with the letter 't'\n+  F_ATOM_ERROR,               ///< Problem while parsing an atom starting with the letter 'f'\n+  N_ATOM_ERROR,               ///< Problem while parsing an atom starting with the letter 'n'\n+  NUMBER_ERROR,               ///< Problem while parsing a number\n+  UTF8_ERROR,                 ///< the input is not valid UTF-8\n+  UNINITIALIZED,              ///< unknown error, or uninitialized document\n+  EMPTY,                      ///< no structural element found\n+  UNESCAPED_CHARS,            ///< found unescaped characters in a string.\n+  UNCLOSED_STRING,            ///< missing quote at the end\n+  UNSUPPORTED_ARCHITECTURE,   ///< unsupported architecture\n+  INCORRECT_TYPE,             ///< JSON element has a different type than user expected\n+  NUMBER_OUT_OF_RANGE,        ///< JSON number does not fit in 64 bits\n+  INDEX_OUT_OF_BOUNDS,        ///< JSON array index too large\n+  NO_SUCH_FIELD,              ///< JSON field not found in object\n+  IO_ERROR,                   ///< Error reading a file\n+  INVALID_JSON_POINTER,       ///< Invalid JSON pointer reference\n+  INVALID_URI_FRAGMENT,       ///< Invalid URI fragment\n+  UNEXPECTED_ERROR,           ///< indicative of a bug in simdjson\n+  PARSER_IN_USE,              ///< parser is already in use.\n+  OUT_OF_ORDER_ITERATION,     ///< tried to iterate an array or object out of order\n+  INSUFFICIENT_PADDING,       ///< The JSON doesn't have enough padding for simdjson to safely parse it.\n+  INCOMPLETE_ARRAY_OR_OBJECT, ///< The document ends early.\n+  SCALAR_DOCUMENT_AS_VALUE,   ///< A scalar document is treated as a value.\n+  OUT_OF_BOUNDS,              ///< Attempted to access location outside of document.\n   NUM_ERROR_CODES\n };\n \n@@ -180,13 +183,13 @@ struct simdjson_result_base : protected std::pair<T, error_code> {\n \n   /**\n    * Get the result value. This function is safe if and only\n-   * the error() method returns a value that evoluates to false.\n+   * the error() method returns a value that evaluates to false.\n    */\n   simdjson_really_inline const T& value_unsafe() const& noexcept;\n \n   /**\n    * Take the result value (move it). This function is safe if and only\n-   * the error() method returns a value that evoluates to false.\n+   * the error() method returns a value that evaluates to false.\n    */\n   simdjson_really_inline T&& value_unsafe() && noexcept;\n \n@@ -271,13 +274,13 @@ struct simdjson_result : public internal::simdjson_result_base<T> {\n \n   /**\n    * Get the result value. This function is safe if and only\n-   * the error() method returns a value that evoluates to false.\n+   * the error() method returns a value that evaluates to false.\n    */\n   simdjson_really_inline const T& value_unsafe() const& noexcept;\n \n   /**\n    * Take the result value (move it). This function is safe if and only\n-   * the error() method returns a value that evoluates to false.\n+   * the error() method returns a value that evaluates to false.\n    */\n   simdjson_really_inline T&& value_unsafe() && noexcept;\n \n@@ -286,8 +289,7 @@ struct simdjson_result : public internal::simdjson_result_base<T> {\n #if SIMDJSON_EXCEPTIONS\n \n template<typename T>\n-inline std::ostream& operator<<(std::ostream& out, simdjson_result<T> value) noexcept { return out << value.value(); }\n-\n+inline std::ostream& operator<<(std::ostream& out, simdjson_result<T> value) { return out << value.value(); }\n #endif // SIMDJSON_EXCEPTIONS\n \n #ifndef SIMDJSON_DISABLE_DEPRECATED_API"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/fallback/numberparsing.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "patch": "@@ -27,7 +27,8 @@ static simdjson_really_inline uint32_t parse_eight_digits_unrolled(const uint8_t\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n \n-#define SWAR_NUMBER_PARSING\n+#define SIMDJSON_SWAR_NUMBER_PARSING 1\n+\n #include \"simdjson/generic/numberparsing.h\"\n \n #endif // SIMDJSON_FALLBACK_NUMBERPARSING_H"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/dom_parser_implementation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -32,7 +32,7 @@ class dom_parser_implementation final : public internal::dom_parser_implementati\n   dom_parser_implementation &operator=(const dom_parser_implementation &) = delete;\n \n   simdjson_warn_unused error_code parse(const uint8_t *buf, size_t len, dom::document &doc) noexcept final;\n-  simdjson_warn_unused error_code stage1(const uint8_t *buf, size_t len, bool partial) noexcept final;\n+  simdjson_warn_unused error_code stage1(const uint8_t *buf, size_t len, stage1_mode partial) noexcept final;\n   simdjson_warn_unused error_code stage2(dom::document &doc) noexcept final;\n   simdjson_warn_unused error_code stage2_next(dom::document &doc) noexcept final;\n   inline simdjson_warn_unused error_code set_capacity(size_t capacity) noexcept final;"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/implementation_simdjson_result_base-inl.h",
        "status": "modified",
        "additions": 7,
        "deletions": 2,
        "changes": 9,
        "patch": "@@ -49,18 +49,23 @@ simdjson_really_inline implementation_simdjson_result_base<T>::operator T&&() &&\n   return std::forward<implementation_simdjson_result_base<T>>(*this).take_value();\n }\n \n+#endif // SIMDJSON_EXCEPTIONS\n+\n template<typename T>\n simdjson_really_inline const T& implementation_simdjson_result_base<T>::value_unsafe() const& noexcept {\n   return this->first;\n }\n \n+template<typename T>\n+simdjson_really_inline T& implementation_simdjson_result_base<T>::value_unsafe() & noexcept {\n+  return this->first;\n+}\n+\n template<typename T>\n simdjson_really_inline T&& implementation_simdjson_result_base<T>::value_unsafe() && noexcept {\n   return std::forward<T>(this->first);\n }\n \n-#endif // SIMDJSON_EXCEPTIONS\n-\n template<typename T>\n simdjson_really_inline implementation_simdjson_result_base<T>::implementation_simdjson_result_base(T &&value, error_code error) noexcept\n     : first{std::forward<T>(value)}, second{error} {}"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/implementation_simdjson_result_base.h",
        "status": "modified",
        "additions": 14,
        "deletions": 8,
        "changes": 22,
        "patch": "@@ -97,22 +97,28 @@ struct implementation_simdjson_result_base {\n    */\n   simdjson_really_inline operator T&&() && noexcept(false);\n \n+\n+#endif // SIMDJSON_EXCEPTIONS\n+\n   /**\n    * Get the result value. This function is safe if and only\n-   * the error() method returns a value that evoluates to false.\n+   * the error() method returns a value that evaluates to false.\n    */\n   simdjson_really_inline const T& value_unsafe() const& noexcept;\n-\n+  /**\n+   * Get the result value. This function is safe if and only\n+   * the error() method returns a value that evaluates to false.\n+   */\n+  simdjson_really_inline T& value_unsafe() & noexcept;\n   /**\n    * Take the result value (move it). This function is safe if and only\n-   * the error() method returns a value that evoluates to false.\n+   * the error() method returns a value that evaluates to false.\n    */\n   simdjson_really_inline T&& value_unsafe() && noexcept;\n-\n-#endif // SIMDJSON_EXCEPTIONS\n-\n-  T first{};\n-  error_code second{UNINITIALIZED};\n+protected:\n+  /** users should never directly access first and second. **/\n+  T first{}; /** Users should never directly access 'first'. **/\n+  error_code second{UNINITIALIZED}; /** Users should never directly access 'second'. **/\n }; // struct implementation_simdjson_result_base\n \n } // namespace SIMDJSON_IMPLEMENTATION"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/numberparsing.h",
        "status": "modified",
        "additions": 417,
        "deletions": 26,
        "changes": 443,
        "patch": "@@ -3,6 +3,18 @@\n \n namespace simdjson {\n namespace SIMDJSON_IMPLEMENTATION {\n+\n+namespace ondemand {\n+/**\n+ * The type of a JSON number\n+ */\n+enum class number_type {\n+    floating_point_number=1, /// a binary64 number\n+    signed_integer,          /// a signed integer that fits in a 64-bit word using two's complement\n+    unsigned_integer         /// a positive integer larger or equal to 1<<63\n+};\n+}\n+\n namespace {\n /// @private\n namespace numberparsing {\n@@ -161,8 +173,8 @@ simdjson_really_inline bool compute_float_64(int64_t power, uint64_t i, bool neg\n   // Both i and power_of_five_128[index] have their most significant bit set to 1 which\n   // implies that the either the most or the second most significant bit of the product\n   // is 1. We pack values in this manner for efficiency reasons: it maximizes the use\n-  // we make of the product. It also makes it easy to reason aboutthe product: there\n-  // 0 or 1 leading zero in the product.\n+  // we make of the product. It also makes it easy to reason about the product: there\n+  // is 0 or 1 leading zero in the product.\n \n   // Unless the least significant 9 bits of the high (64-bit) part of the full\n   // product are all 1s, then we know that the most significant 55 bits are\n@@ -277,7 +289,7 @@ simdjson_really_inline bool compute_float_64(int64_t power, uint64_t i, bool neg\n   mantissa &= ~(1ULL << 52);\n   // we have to check that real_exponent is in range, otherwise we bail out\n   if (simdjson_unlikely(real_exponent > 2046)) {\n-    // We have an infinte value!!! We could actually throw an error here if we could.\n+    // We have an infinite value!!! We could actually throw an error here if we could.\n     return false;\n   }\n   d = to_double(mantissa, real_exponent, negative);\n@@ -305,6 +317,20 @@ static bool parse_float_fallback(const uint8_t *ptr, double *outDouble) {\n   // to handle that max may be a macro on windows).\n   return !(*outDouble > (std::numeric_limits<double>::max)() || *outDouble < std::numeric_limits<double>::lowest());\n }\n+static bool parse_float_fallback(const uint8_t *ptr, const uint8_t *end_ptr, double *outDouble) {\n+  *outDouble = simdjson::internal::from_chars(reinterpret_cast<const char *>(ptr), reinterpret_cast<const char *>(end_ptr));\n+  // We do not accept infinite values.\n+\n+  // Detecting finite values in a portable manner is ridiculously hard, ideally\n+  // we would want to do:\n+  // return !std::isfinite(*outDouble);\n+  // but that mysteriously fails under legacy/old libc++ libraries, see\n+  // https://github.com/simdjson/simdjson/issues/1286\n+  //\n+  // Therefore, fall back to this solution (the extra parens are there\n+  // to handle that max may be a macro on windows).\n+  return !(*outDouble > (std::numeric_limits<double>::max)() || *outDouble < std::numeric_limits<double>::lowest());\n+}\n \n // check quickly whether the next 8 chars are made of digits\n // at a glance, it looks better than Mula's\n@@ -353,14 +379,16 @@ simdjson_really_inline error_code parse_decimal(simdjson_unused const uint8_t *c\n   // the integer into a float in a lossless manner.\n   const uint8_t *const first_after_period = p;\n \n-#ifdef SWAR_NUMBER_PARSING\n+#ifdef SIMDJSON_SWAR_NUMBER_PARSING\n+#if SIMDJSON_SWAR_NUMBER_PARSING\n   // this helps if we have lots of decimals!\n   // this turns out to be frequent enough.\n   if (is_made_of_eight_digits_fast(p)) {\n     i = i * 100000000 + parse_eight_digits_unrolled(p);\n     p += 8;\n   }\n-#endif\n+#endif // SIMDJSON_SWAR_NUMBER_PARSING\n+#endif // #ifdef SIMDJSON_SWAR_NUMBER_PARSING\n   // Unrolling the first digit makes a small difference on some implementations (e.g. westmere)\n   if (parse_digit(*p, i)) { ++p; }\n   while (parse_digit(*p, i)) { p++; }\n@@ -427,9 +455,7 @@ simdjson_really_inline size_t significant_digits(const uint8_t * start_digits, s\n   // It is possible that the integer had an overflow.\n   // We have to handle the case where we have 0.0000somenumber.\n   const uint8_t *start = start_digits;\n-  while ((*start == '0') || (*start == '.')) {\n-    start++;\n-  }\n+  while ((*start == '0') || (*start == '.')) { ++start; }\n   // we over-decrement by one when there is a '.'\n   return digit_count - size_t(start - start_digits);\n }\n@@ -440,7 +466,7 @@ simdjson_really_inline error_code write_float(const uint8_t *const src, bool neg\n   // we could extend our code by using a 128-bit integer instead\n   // of a 64-bit integer. However, this is uncommon in practice.\n   //\n-  // 9999999999999999999 < 2**64 so we can accomodate 19 digits.\n+  // 9999999999999999999 < 2**64 so we can accommodate 19 digits.\n   // If we have a decimal separator, then digit_count - 1 is the number of digits, but we\n   // may not have a decimal separator!\n   if (simdjson_unlikely(digit_count > 19 && significant_digits(start_digits, digit_count) > 19)) {\n@@ -499,7 +525,12 @@ simdjson_really_inline error_code parse_number(const uint8_t *const, W &writer)\n simdjson_unused simdjson_really_inline simdjson_result<uint64_t> parse_unsigned(const uint8_t * const src) noexcept { return 0; }\n simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer(const uint8_t * const src) noexcept { return 0; }\n simdjson_unused simdjson_really_inline simdjson_result<double> parse_double(const uint8_t * const src) noexcept { return 0; }\n-\n+simdjson_unused simdjson_really_inline simdjson_result<uint64_t> parse_unsigned_in_string(const uint8_t * const src) noexcept { return 0; }\n+simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer_in_string(const uint8_t * const src) noexcept { return 0; }\n+simdjson_unused simdjson_really_inline simdjson_result<double> parse_double_in_string(const uint8_t * const src) noexcept { return 0; }\n+simdjson_unused simdjson_really_inline bool is_negative(const uint8_t * src) noexcept  { return false; }\n+simdjson_unused simdjson_really_inline simdjson_result<bool> is_integer(const uint8_t * src) noexcept  { return false; }\n+simdjson_unused simdjson_really_inline simdjson_result<ondemand::number_type> get_number_type(const uint8_t * src) noexcept { return ondemand::number_type::signed_integer; }\n #else\n \n // parse the number at src\n@@ -709,14 +740,59 @@ simdjson_unused simdjson_really_inline simdjson_result<uint64_t> parse_unsigned(\n   return i;\n }\n \n-// Parse any number from  -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\n-simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer(const uint8_t *src) noexcept {\n+\n+// Parse any number from 0 to 18,446,744,073,709,551,615\n+// Never read at src_end or beyond\n+simdjson_unused simdjson_really_inline simdjson_result<uint64_t> parse_unsigned(const uint8_t * const src, const uint8_t * const src_end) noexcept {\n+  const uint8_t *p = src;\n   //\n-  // Check for minus sign\n+  // Parse the integer part.\n   //\n-  bool negative = (*src == '-');\n-  const uint8_t *p = src + negative;\n+  // PERF NOTE: we don't use is_made_of_eight_digits_fast because large integers like 123456789 are rare\n+  const uint8_t *const start_digits = p;\n+  uint64_t i = 0;\n+  while ((p != src_end) && parse_digit(*p, i)) { p++; }\n \n+  // If there were no digits, or if the integer starts with 0 and has more than one digit, it's an error.\n+  // Optimization note: size_t is expected to be unsigned.\n+  size_t digit_count = size_t(p - start_digits);\n+  // The longest positive 64-bit number is 20 digits.\n+  // We do it this way so we don't trigger this branch unless we must.\n+  // Optimization note: the compiler can probably merge\n+  // ((digit_count == 0) || (digit_count > 20))\n+  // into a single  branch since digit_count is unsigned.\n+  if ((digit_count == 0) || (digit_count > 20)) { return INCORRECT_TYPE; }\n+  // Here digit_count > 0.\n+  if (('0' == *start_digits) && (digit_count > 1)) { return NUMBER_ERROR; }\n+  // We can do the following...\n+  // if (!jsoncharutils::is_structural_or_whitespace(*p)) {\n+  //  return (*p == '.' || *p == 'e' || *p == 'E') ? INCORRECT_TYPE : NUMBER_ERROR;\n+  // }\n+  // as a single table lookup:\n+  if ((p != src_end) && integer_string_finisher[*p] != SUCCESS) { return error_code(integer_string_finisher[*p]); }\n+\n+  if (digit_count == 20) {\n+    // Positive overflow check:\n+    // - A 20 digit number starting with 2-9 is overflow, because 18,446,744,073,709,551,615 is the\n+    //   biggest uint64_t.\n+    // - A 20 digit number starting with 1 is overflow if it is less than INT64_MAX.\n+    //   If we got here, it's a 20 digit number starting with the digit \"1\".\n+    // - If a 20 digit number starting with 1 overflowed (i*10+digit), the result will be smaller\n+    //   than 1,553,255,926,290,448,384.\n+    // - That is smaller than the smallest possible 20-digit number the user could write:\n+    //   10,000,000,000,000,000,000.\n+    // - Therefore, if the number is positive and lower than that, it's overflow.\n+    // - The value we are looking at is less than or equal to 9,223,372,036,854,775,808 (INT64_MAX).\n+    //\n+    if (src[0] != uint8_t('1') || i <= uint64_t(INT64_MAX)) { return INCORRECT_TYPE; }\n+  }\n+\n+  return i;\n+}\n+\n+// Parse any number from 0 to 18,446,744,073,709,551,615\n+simdjson_unused simdjson_really_inline simdjson_result<uint64_t> parse_unsigned_in_string(const uint8_t * const src) noexcept {\n+  const uint8_t *p = src + 1;\n   //\n   // Parse the integer part.\n   //\n@@ -728,28 +804,22 @@ simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer(co\n   // If there were no digits, or if the integer starts with 0 and has more than one digit, it's an error.\n   // Optimization note: size_t is expected to be unsigned.\n   size_t digit_count = size_t(p - start_digits);\n-  // The longest negative 64-bit number is 19 digits.\n   // The longest positive 64-bit number is 20 digits.\n   // We do it this way so we don't trigger this branch unless we must.\n-  size_t longest_digit_count = negative ? 19 : 20;\n   // Optimization note: the compiler can probably merge\n-  // ((digit_count == 0) || (digit_count > longest_digit_count))\n+  // ((digit_count == 0) || (digit_count > 20))\n   // into a single  branch since digit_count is unsigned.\n-  if ((digit_count == 0) || (digit_count > longest_digit_count)) { return INCORRECT_TYPE; }\n+  if ((digit_count == 0) || (digit_count > 20)) { return INCORRECT_TYPE; }\n   // Here digit_count > 0.\n   if (('0' == *start_digits) && (digit_count > 1)) { return NUMBER_ERROR; }\n   // We can do the following...\n   // if (!jsoncharutils::is_structural_or_whitespace(*p)) {\n   //  return (*p == '.' || *p == 'e' || *p == 'E') ? INCORRECT_TYPE : NUMBER_ERROR;\n   // }\n   // as a single table lookup:\n-  if(integer_string_finisher[*p] != SUCCESS) { return error_code(integer_string_finisher[*p]); }\n-  if (digit_count == longest_digit_count) {\n-    if (negative) {\n-      // Anything negative above INT64_MAX+1 is invalid\n-      if (i > uint64_t(INT64_MAX)+1) { return INCORRECT_TYPE; }\n-      return ~i+1;\n+  if (*p != '\"') { return NUMBER_ERROR; }\n \n+  if (digit_count == 20) {\n     // Positive overflow check:\n     // - A 20 digit number starting with 2-9 is overflow, because 18,446,744,073,709,551,615 is the\n     //   biggest uint64_t.\n@@ -762,9 +832,137 @@ simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer(co\n     // - Therefore, if the number is positive and lower than that, it's overflow.\n     // - The value we are looking at is less than or equal to 9,223,372,036,854,775,808 (INT64_MAX).\n     //\n-    } else if (src[0] != uint8_t('1') || i <= uint64_t(INT64_MAX)) { return INCORRECT_TYPE; }\n+    if (src[0] != uint8_t('1') || i <= uint64_t(INT64_MAX)) { return INCORRECT_TYPE; }\n   }\n \n+  return i;\n+}\n+\n+// Parse any number from  -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\n+simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer(const uint8_t *src) noexcept {\n+  //\n+  // Check for minus sign\n+  //\n+  bool negative = (*src == '-');\n+  const uint8_t *p = src + negative;\n+\n+  //\n+  // Parse the integer part.\n+  //\n+  // PERF NOTE: we don't use is_made_of_eight_digits_fast because large integers like 123456789 are rare\n+  const uint8_t *const start_digits = p;\n+  uint64_t i = 0;\n+  while (parse_digit(*p, i)) { p++; }\n+\n+  // If there were no digits, or if the integer starts with 0 and has more than one digit, it's an error.\n+  // Optimization note: size_t is expected to be unsigned.\n+  size_t digit_count = size_t(p - start_digits);\n+  // We go from\n+  // -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\n+  // so we can never represent numbers that have more than 19 digits.\n+  size_t longest_digit_count = 19;\n+  // Optimization note: the compiler can probably merge\n+  // ((digit_count == 0) || (digit_count > longest_digit_count))\n+  // into a single  branch since digit_count is unsigned.\n+  if ((digit_count == 0) || (digit_count > longest_digit_count)) { return INCORRECT_TYPE; }\n+  // Here digit_count > 0.\n+  if (('0' == *start_digits) && (digit_count > 1)) { return NUMBER_ERROR; }\n+  // We can do the following...\n+  // if (!jsoncharutils::is_structural_or_whitespace(*p)) {\n+  //  return (*p == '.' || *p == 'e' || *p == 'E') ? INCORRECT_TYPE : NUMBER_ERROR;\n+  // }\n+  // as a single table lookup:\n+  if(integer_string_finisher[*p] != SUCCESS) { return error_code(integer_string_finisher[*p]); }\n+  // Negative numbers have can go down to - INT64_MAX - 1 whereas positive numbers are limited to INT64_MAX.\n+  // Performance note: This check is only needed when digit_count == longest_digit_count but it is\n+  // so cheap that we might as well always make it.\n+  if(i > uint64_t(INT64_MAX) + uint64_t(negative)) { return INCORRECT_TYPE; }\n+  return negative ? (~i+1) : i;\n+}\n+\n+// Parse any number from  -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\n+// Never read at src_end or beyond\n+simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer(const uint8_t * const src, const uint8_t * const src_end) noexcept {\n+  //\n+  // Check for minus sign\n+  //\n+  if(src == src_end) { return NUMBER_ERROR; }\n+  bool negative = (*src == '-');\n+  const uint8_t *p = src + negative;\n+\n+  //\n+  // Parse the integer part.\n+  //\n+  // PERF NOTE: we don't use is_made_of_eight_digits_fast because large integers like 123456789 are rare\n+  const uint8_t *const start_digits = p;\n+  uint64_t i = 0;\n+  while ((p != src_end) && parse_digit(*p, i)) { p++; }\n+\n+  // If there were no digits, or if the integer starts with 0 and has more than one digit, it's an error.\n+  // Optimization note: size_t is expected to be unsigned.\n+  size_t digit_count = size_t(p - start_digits);\n+  // We go from\n+  // -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\n+  // so we can never represent numbers that have more than 19 digits.\n+  size_t longest_digit_count = 19;\n+  // Optimization note: the compiler can probably merge\n+  // ((digit_count == 0) || (digit_count > longest_digit_count))\n+  // into a single  branch since digit_count is unsigned.\n+  if ((digit_count == 0) || (digit_count > longest_digit_count)) { return INCORRECT_TYPE; }\n+  // Here digit_count > 0.\n+  if (('0' == *start_digits) && (digit_count > 1)) { return NUMBER_ERROR; }\n+  // We can do the following...\n+  // if (!jsoncharutils::is_structural_or_whitespace(*p)) {\n+  //  return (*p == '.' || *p == 'e' || *p == 'E') ? INCORRECT_TYPE : NUMBER_ERROR;\n+  // }\n+  // as a single table lookup:\n+  if((p != src_end) && integer_string_finisher[*p] != SUCCESS) { return error_code(integer_string_finisher[*p]); }\n+  // Negative numbers have can go down to - INT64_MAX - 1 whereas positive numbers are limited to INT64_MAX.\n+  // Performance note: This check is only needed when digit_count == longest_digit_count but it is\n+  // so cheap that we might as well always make it.\n+  if(i > uint64_t(INT64_MAX) + uint64_t(negative)) { return INCORRECT_TYPE; }\n+  return negative ? (~i+1) : i;\n+}\n+\n+// Parse any number from  -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\n+simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer_in_string(const uint8_t *src) noexcept {\n+  //\n+  // Check for minus sign\n+  //\n+  bool negative = (*(src + 1) == '-');\n+  const uint8_t *p = src + negative + 1;\n+\n+  //\n+  // Parse the integer part.\n+  //\n+  // PERF NOTE: we don't use is_made_of_eight_digits_fast because large integers like 123456789 are rare\n+  const uint8_t *const start_digits = p;\n+  uint64_t i = 0;\n+  while (parse_digit(*p, i)) { p++; }\n+\n+  // If there were no digits, or if the integer starts with 0 and has more than one digit, it's an error.\n+  // Optimization note: size_t is expected to be unsigned.\n+  size_t digit_count = size_t(p - start_digits);\n+  // We go from\n+  // -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\n+  // so we can never represent numbers that have more than 19 digits.\n+  size_t longest_digit_count = 19;\n+  // Optimization note: the compiler can probably merge\n+  // ((digit_count == 0) || (digit_count > longest_digit_count))\n+  // into a single  branch since digit_count is unsigned.\n+  if ((digit_count == 0) || (digit_count > longest_digit_count)) { return INCORRECT_TYPE; }\n+  // Here digit_count > 0.\n+  if (('0' == *start_digits) && (digit_count > 1)) { return NUMBER_ERROR; }\n+  // We can do the following...\n+  // if (!jsoncharutils::is_structural_or_whitespace(*p)) {\n+  //  return (*p == '.' || *p == 'e' || *p == 'E') ? INCORRECT_TYPE : NUMBER_ERROR;\n+  // }\n+  // as a single table lookup:\n+  if(*p != '\"') { return NUMBER_ERROR; }\n+  // Negative numbers have can go down to - INT64_MAX - 1 whereas positive numbers are limited to INT64_MAX.\n+  // Performance note: This check is only needed when digit_count == longest_digit_count but it is\n+  // so cheap that we might as well always make it.\n+  if(i > uint64_t(INT64_MAX) + uint64_t(negative)) { return INCORRECT_TYPE; }\n   return negative ? (~i+1) : i;\n }\n \n@@ -845,6 +1043,199 @@ simdjson_unused simdjson_really_inline simdjson_result<double> parse_double(cons\n   }\n   return d;\n }\n+\n+simdjson_unused simdjson_really_inline bool is_negative(const uint8_t * src) noexcept {\n+  return (*src == '-');\n+}\n+\n+simdjson_unused simdjson_really_inline simdjson_result<bool> is_integer(const uint8_t * src) noexcept {\n+  bool negative = (*src == '-');\n+  src += negative;\n+  const uint8_t *p = src;\n+  while(static_cast<uint8_t>(*p - '0') <= 9) { p++; }\n+  if ( p == src ) { return NUMBER_ERROR; }\n+  if (jsoncharutils::is_structural_or_whitespace(*p)) { return true; }\n+  return false;\n+}\n+\n+simdjson_unused simdjson_really_inline simdjson_result<ondemand::number_type> get_number_type(const uint8_t * src) noexcept {\n+  bool negative = (*src == '-');\n+  src += negative;\n+  const uint8_t *p = src;\n+  while(static_cast<uint8_t>(*p - '0') <= 9) { p++; }\n+  if ( p == src ) { return NUMBER_ERROR; }\n+  if (jsoncharutils::is_structural_or_whitespace(*p)) {\n+    int digit_count = int(p - src);\n+    if(digit_count >= 19) {\n+      const uint8_t * smaller_big_integer = reinterpret_cast<const uint8_t *>(\"9223372036854775808\");\n+      if((digit_count >= 20) || (memcmp(src, smaller_big_integer, 19) >= 0)) {\n+        return ondemand::number_type::unsigned_integer;\n+      }\n+    }\n+    return ondemand::number_type::signed_integer;\n+  }\n+  return ondemand::number_type::floating_point_number;\n+}\n+\n+// Never read at src_end or beyond\n+simdjson_unused simdjson_really_inline simdjson_result<double> parse_double(const uint8_t * src, const uint8_t * const src_end) noexcept {\n+  if(src == src_end) { return NUMBER_ERROR; }\n+  //\n+  // Check for minus sign\n+  //\n+  bool negative = (*src == '-');\n+  src += negative;\n+\n+  //\n+  // Parse the integer part.\n+  //\n+  uint64_t i = 0;\n+  const uint8_t *p = src;\n+  if(p == src_end) { return NUMBER_ERROR; }\n+  p += parse_digit(*p, i);\n+  bool leading_zero = (i == 0);\n+  while ((p != src_end) && parse_digit(*p, i)) { p++; }\n+  // no integer digits, or 0123 (zero must be solo)\n+  if ( p == src ) { return INCORRECT_TYPE; }\n+  if ( (leading_zero && p != src+1)) { return NUMBER_ERROR; }\n+\n+  //\n+  // Parse the decimal part.\n+  //\n+  int64_t exponent = 0;\n+  bool overflow;\n+  if (simdjson_likely((p != src_end) && (*p == '.'))) {\n+    p++;\n+    const uint8_t *start_decimal_digits = p;\n+    if ((p == src_end) || !parse_digit(*p, i)) { return NUMBER_ERROR; } // no decimal digits\n+    p++;\n+    while ((p != src_end) && parse_digit(*p, i)) { p++; }\n+    exponent = -(p - start_decimal_digits);\n+\n+    // Overflow check. More than 19 digits (minus the decimal) may be overflow.\n+    overflow = p-src-1 > 19;\n+    if (simdjson_unlikely(overflow && leading_zero)) {\n+      // Skip leading 0.00000 and see if it still overflows\n+      const uint8_t *start_digits = src + 2;\n+      while (*start_digits == '0') { start_digits++; }\n+      overflow = start_digits-src > 19;\n+    }\n+  } else {\n+    overflow = p-src > 19;\n+  }\n+\n+  //\n+  // Parse the exponent\n+  //\n+  if ((p != src_end) && (*p == 'e' || *p == 'E')) {\n+    p++;\n+    if(p == src_end) { return NUMBER_ERROR; }\n+    bool exp_neg = *p == '-';\n+    p += exp_neg || *p == '+';\n+\n+    uint64_t exp = 0;\n+    const uint8_t *start_exp_digits = p;\n+    while ((p != src_end) && parse_digit(*p, exp)) { p++; }\n+    // no exp digits, or 20+ exp digits\n+    if (p-start_exp_digits == 0 || p-start_exp_digits > 19) { return NUMBER_ERROR; }\n+\n+    exponent += exp_neg ? 0-exp : exp;\n+  }\n+\n+  if ((p != src_end) && jsoncharutils::is_not_structural_or_whitespace(*p)) { return NUMBER_ERROR; }\n+\n+  overflow = overflow || exponent < simdjson::internal::smallest_power || exponent > simdjson::internal::largest_power;\n+\n+  //\n+  // Assemble (or slow-parse) the float\n+  //\n+  double d;\n+  if (simdjson_likely(!overflow)) {\n+    if (compute_float_64(exponent, i, negative, d)) { return d; }\n+  }\n+  if (!parse_float_fallback(src-negative, src_end, &d)) {\n+    return NUMBER_ERROR;\n+  }\n+  return d;\n+}\n+\n+simdjson_unused simdjson_really_inline simdjson_result<double> parse_double_in_string(const uint8_t * src) noexcept {\n+  //\n+  // Check for minus sign\n+  //\n+  bool negative = (*(src + 1) == '-');\n+  src += negative + 1;\n+\n+  //\n+  // Parse the integer part.\n+  //\n+  uint64_t i = 0;\n+  const uint8_t *p = src;\n+  p += parse_digit(*p, i);\n+  bool leading_zero = (i == 0);\n+  while (parse_digit(*p, i)) { p++; }\n+  // no integer digits, or 0123 (zero must be solo)\n+  if ( p == src ) { return INCORRECT_TYPE; }\n+  if ( (leading_zero && p != src+1)) { return NUMBER_ERROR; }\n+\n+  //\n+  // Parse the decimal part.\n+  //\n+  int64_t exponent = 0;\n+  bool overflow;\n+  if (simdjson_likely(*p == '.')) {\n+    p++;\n+    const uint8_t *start_decimal_digits = p;\n+    if (!parse_digit(*p, i)) { return NUMBER_ERROR; } // no decimal digits\n+    p++;\n+    while (parse_digit(*p, i)) { p++; }\n+    exponent = -(p - start_decimal_digits);\n+\n+    // Overflow check. More than 19 digits (minus the decimal) may be overflow.\n+    overflow = p-src-1 > 19;\n+    if (simdjson_unlikely(overflow && leading_zero)) {\n+      // Skip leading 0.00000 and see if it still overflows\n+      const uint8_t *start_digits = src + 2;\n+      while (*start_digits == '0') { start_digits++; }\n+      overflow = start_digits-src > 19;\n+    }\n+  } else {\n+    overflow = p-src > 19;\n+  }\n+\n+  //\n+  // Parse the exponent\n+  //\n+  if (*p == 'e' || *p == 'E') {\n+    p++;\n+    bool exp_neg = *p == '-';\n+    p += exp_neg || *p == '+';\n+\n+    uint64_t exp = 0;\n+    const uint8_t *start_exp_digits = p;\n+    while (parse_digit(*p, exp)) { p++; }\n+    // no exp digits, or 20+ exp digits\n+    if (p-start_exp_digits == 0 || p-start_exp_digits > 19) { return NUMBER_ERROR; }\n+\n+    exponent += exp_neg ? 0-exp : exp;\n+  }\n+\n+  if (*p != '\"') { return NUMBER_ERROR; }\n+\n+  overflow = overflow || exponent < simdjson::internal::smallest_power || exponent > simdjson::internal::largest_power;\n+\n+  //\n+  // Assemble (or slow-parse) the float\n+  //\n+  double d;\n+  if (simdjson_likely(!overflow)) {\n+    if (compute_float_64(exponent, i, negative, d)) { return d; }\n+  }\n+  if (!parse_float_fallback(src-negative, &d)) {\n+    return NUMBER_ERROR;\n+  }\n+  return d;\n+}\n } //namespace {}\n #endif // SIMDJSON_SKIPNUMBERPARSING\n "
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand-inl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -12,3 +12,5 @@\n #include \"simdjson/generic/ondemand/field-inl.h\"\n #include \"simdjson/generic/ondemand/object-inl.h\"\n #include \"simdjson/generic/ondemand/parser-inl.h\"\n+#include \"simdjson/generic/ondemand/document_stream-inl.h\"\n+#include \"simdjson/generic/ondemand/serialization-inl.h\""
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "patch": "@@ -29,3 +29,5 @@ using depth_t = int32_t;\n #include \"simdjson/generic/ondemand/field.h\"\n #include \"simdjson/generic/ondemand/object.h\"\n #include \"simdjson/generic/ondemand/parser.h\"\n+#include \"simdjson/generic/ondemand/document_stream.h\"\n+#include \"simdjson/generic/ondemand/serialization.h\""
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/array-inl.h",
        "status": "modified",
        "additions": 104,
        "deletions": 3,
        "changes": 107,
        "patch": "@@ -57,8 +57,9 @@ simdjson_really_inline simdjson_result<array> array::start_root(value_iterator &\n   SIMDJSON_TRY( iter.start_root_array().get(has_value) );\n   return array(iter);\n }\n-simdjson_really_inline array array::started(value_iterator &iter) noexcept {\n-  simdjson_unused bool has_value = iter.started_array();\n+simdjson_really_inline simdjson_result<array> array::started(value_iterator &iter) noexcept {\n+  bool has_value;\n+  SIMDJSON_TRY(iter.started_array().get(has_value));\n   return array(iter);\n }\n \n@@ -71,6 +72,91 @@ simdjson_really_inline simdjson_result<array_iterator> array::begin() noexcept {\n simdjson_really_inline simdjson_result<array_iterator> array::end() noexcept {\n   return array_iterator(iter);\n }\n+simdjson_really_inline error_code array::consume() noexcept {\n+  auto error = iter.json_iter().skip_child(iter.depth()-1);\n+  if(error) { iter.abandon(); }\n+  return error;\n+}\n+\n+simdjson_really_inline simdjson_result<std::string_view> array::raw_json() noexcept {\n+  const uint8_t * starting_point{iter.peek_start()};\n+  auto error = consume();\n+  if(error) { return error; }\n+  // After 'consume()', we could be left pointing just beyond the document, but that\n+  // is ok because we are not going to dereference the final pointer position, we just\n+  // use it to compute the length in bytes.\n+  const uint8_t * final_point{iter._json_iter->unsafe_pointer()};\n+  return std::string_view(reinterpret_cast<const char*>(starting_point), size_t(final_point - starting_point));\n+}\n+\n+SIMDJSON_DISABLE_STRICT_OVERFLOW_WARNING\n+simdjson_really_inline simdjson_result<size_t> array::count_elements() & noexcept {\n+  size_t count{0};\n+  // Important: we do not consume any of the values.\n+  for(simdjson_unused auto v : *this) { count++; }\n+  // The above loop will always succeed, but we want to report errors.\n+  if(iter.error()) { return iter.error(); }\n+  // We need to move back at the start because we expect users to iterate through\n+  // the array after counting the number of elements.\n+  iter.reset_array();\n+  return count;\n+}\n+\n+simdjson_really_inline simdjson_result<bool> array::is_empty() & noexcept {\n+  bool is_not_empty;\n+  auto error = iter.reset_array().get(is_not_empty);\n+  if(error) { return error; }\n+  return !is_not_empty;\n+}\n+\n+inline simdjson_result<bool> array::reset() & noexcept {\n+  return iter.reset_array();\n+}\n+\n+inline simdjson_result<value> array::at_pointer(std::string_view json_pointer) noexcept {\n+  if (json_pointer[0] != '/') { return INVALID_JSON_POINTER; }\n+  json_pointer = json_pointer.substr(1);\n+  // - means \"the append position\" or \"the element after the end of the array\"\n+  // We don't support this, because we're returning a real element, not a position.\n+  if (json_pointer == \"-\") { return INDEX_OUT_OF_BOUNDS; }\n+\n+  // Read the array index\n+  size_t array_index = 0;\n+  size_t i;\n+  for (i = 0; i < json_pointer.length() && json_pointer[i] != '/'; i++) {\n+    uint8_t digit = uint8_t(json_pointer[i] - '0');\n+    // Check for non-digit in array index. If it's there, we're trying to get a field in an object\n+    if (digit > 9) { return INCORRECT_TYPE; }\n+    array_index = array_index*10 + digit;\n+  }\n+\n+  // 0 followed by other digits is invalid\n+  if (i > 1 && json_pointer[0] == '0') { return INVALID_JSON_POINTER; } // \"JSON pointer array index has other characters after 0\"\n+\n+  // Empty string is invalid; so is a \"/\" with no digits before it\n+  if (i == 0) { return INVALID_JSON_POINTER; } // \"Empty string in JSON pointer array index\"\n+  // Get the child\n+  auto child = at(array_index);\n+  // If there is an error, it ends here\n+  if(child.error()) {\n+    return child;\n+  }\n+\n+  // If there is a /, we're not done yet, call recursively.\n+  if (i < json_pointer.length()) {\n+    child = child.at_pointer(json_pointer.substr(i));\n+  }\n+  return child;\n+}\n+\n+simdjson_really_inline simdjson_result<value> array::at(size_t index) noexcept {\n+  size_t i = 0;\n+  for (auto value : *this) {\n+    if (i == index) { return value; }\n+    i++;\n+  }\n+  return INDEX_OUT_OF_BOUNDS;\n+}\n \n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n@@ -101,5 +187,20 @@ simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_\n   if (error()) { return error(); }\n   return first.end();\n }\n-\n+simdjson_really_inline  simdjson_result<size_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array>::count_elements() & noexcept {\n+  if (error()) { return error(); }\n+  return first.count_elements();\n+}\n+simdjson_really_inline  simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array>::is_empty() & noexcept {\n+  if (error()) { return error(); }\n+  return first.is_empty();\n+}\n+simdjson_really_inline  simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array>::at(size_t index) noexcept {\n+  if (error()) { return error(); }\n+  return first.at(index);\n+}\n+simdjson_really_inline  simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array>::at_pointer(std::string_view json_pointer) noexcept {\n+  if (error()) { return error(); }\n+  return first.at_pointer(json_pointer);\n+}\n } // namespace simdjson"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/array.h",
        "status": "modified",
        "additions": 89,
        "deletions": 1,
        "changes": 90,
        "patch": "@@ -31,8 +31,91 @@ class array {\n    * Part of the std::iterable interface.\n    */\n   simdjson_really_inline simdjson_result<array_iterator> end() noexcept;\n+  /**\n+   * This method scans the array and counts the number of elements.\n+   * The count_elements method should always be called before you have begun\n+   * iterating through the array: it is expected that you are pointing at\n+   * the beginning of the array.\n+   * The runtime complexity is linear in the size of the array. After\n+   * calling this function, if successful, the array is 'rewinded' at its\n+   * beginning as if it had never been accessed. If the JSON is malformed (e.g.,\n+   * there is a missing comma), then an error is returned and it is no longer\n+   * safe to continue.\n+   *\n+   * To check that an array is empty, it is more performant to use\n+   * the is_empty() method.\n+   */\n+  simdjson_really_inline simdjson_result<size_t> count_elements() & noexcept;\n+  /**\n+   * This method scans the beginning of the array and checks whether the\n+   * array is empty.\n+   * The runtime complexity is constant time. After\n+   * calling this function, if successful, the array is 'rewinded' at its\n+   * beginning as if it had never been accessed. If the JSON is malformed (e.g.,\n+   * there is a missing comma), then an error is returned and it is no longer\n+   * safe to continue.\n+   */\n+  simdjson_really_inline simdjson_result<bool> is_empty() & noexcept;\n+  /**\n+   * Reset the iterator so that we are pointing back at the\n+   * beginning of the array. You should still consume values only once even if you\n+   * can iterate through the array more than once. If you unescape a string\n+   * within the array more than once, you have unsafe code. Note that rewinding\n+   * an array means that you may need to reparse it anew: it is not a free\n+   * operation.\n+   *\n+   * @returns true if the array contains some elements (not empty)\n+   */\n+  inline simdjson_result<bool> reset() & noexcept;\n+  /**\n+   * Get the value associated with the given JSON pointer.  We use the RFC 6901\n+   * https://tools.ietf.org/html/rfc6901 standard, interpreting the current node\n+   * as the root of its own JSON document.\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"([ { \"foo\": { \"a\": [ 10, 20, 30 ] }} ])\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"/0/foo/a/1\") == 20\n+   *\n+   * Note that at_pointer() called on the document automatically calls the document's rewind\n+   * method between each call. It invalidates all previously accessed arrays, objects and values\n+   * that have not been consumed. Yet it is not the case when calling at_pointer on an array\n+   * instance: there is no rewind and no invalidation.\n+   *\n+   * You may only call at_pointer on an array after it has been created, but before it has\n+   * been first accessed. When calling at_pointer on an array, the pointer is advanced to\n+   * the location indicated by the JSON pointer (in case of success). It is no longer possible\n+   * to call at_pointer on the same array.\n+   *\n+   * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching.\n+   *\n+   * @return The value associated with the given JSON pointer, or:\n+   *         - NO_SUCH_FIELD if a field does not exist in an object\n+   *         - INDEX_OUT_OF_BOUNDS if an array index is larger than an array length\n+   *         - INCORRECT_TYPE if a non-integer is used to access an array\n+   *         - INVALID_JSON_POINTER if the JSON pointer is invalid and cannot be parsed\n+   */\n+  inline simdjson_result<value> at_pointer(std::string_view json_pointer) noexcept;\n+  /**\n+   * Consumes the array and returns a string_view instance corresponding to the\n+   * array as represented in JSON. It points inside the original document.\n+   */\n+  simdjson_really_inline simdjson_result<std::string_view> raw_json() noexcept;\n \n+  /**\n+   * Get the value at the given index. This function has linear-time complexity.\n+   * This function should only be called once as the array iterator is not reset between each call.\n+   *\n+   * @return The value at the given index, or:\n+   *         - INDEX_OUT_OF_BOUNDS if the array index is larger than an array length\n+   */\n+  simdjson_really_inline simdjson_result<value> at(size_t index) noexcept;\n protected:\n+  /**\n+   * Go to the end of the array, no matter where you are right now.\n+   */\n+  simdjson_really_inline error_code consume() noexcept;\n+\n   /**\n    * Begin array iteration.\n    *\n@@ -58,7 +141,7 @@ class array {\n    *\n    * @param iter The iterator. Must be after the initial [. Will be *moved* into the resulting array.\n    */\n-  static simdjson_really_inline array started(value_iterator &iter) noexcept;\n+  static simdjson_really_inline simdjson_result<array> started(value_iterator &iter) noexcept;\n \n   /**\n    * Create an array at the given Internal array creation. Call array::start() or array::started() instead of this.\n@@ -98,6 +181,11 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array> : public SIMDJS\n \n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> begin() noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> end() noexcept;\n+  inline simdjson_result<size_t> count_elements() & noexcept;\n+  inline simdjson_result<bool> is_empty() & noexcept;\n+  inline simdjson_result<bool> reset() & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at(size_t index) noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at_pointer(std::string_view json_pointer) noexcept;\n };\n \n } // namespace simdjson"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/array_iterator-inl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -20,9 +20,9 @@ simdjson_really_inline array_iterator &array_iterator::operator++() noexcept {\n   error_code error;\n   // PERF NOTE this is a safety rail ... users should exit loops as soon as they receive an error, so we'll never get here.\n   // However, it does not seem to make a perf difference, so we add it out of an abundance of caution.\n-  if ((error = iter.error()) ) { return *this; }\n-  if ((error = iter.skip_child() )) { return *this; }\n-  if ((error = iter.has_next_element().error() )) { return *this; }\n+  if (( error = iter.error() )) { return *this; }\n+  if (( error = iter.skip_child() )) { return *this; }\n+  if (( error = iter.has_next_element().error() )) { return *this; }\n   return *this;\n }\n "
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/document-inl.h",
        "status": "modified",
        "additions": 437,
        "deletions": 11,
        "changes": 448,
        "patch": "@@ -12,14 +12,48 @@ simdjson_really_inline document document::start(json_iterator &&iter) noexcept {\n   return document(std::forward<json_iterator>(iter));\n }\n \n+inline void document::rewind() noexcept {\n+  iter.rewind();\n+}\n+\n+inline std::string document::to_debug_string() noexcept {\n+  return iter.to_string();\n+}\n+\n+inline simdjson_result<const char *> document::current_location() noexcept {\n+  return iter.current_location();\n+}\n+\n+inline bool document::is_alive() noexcept {\n+  return iter.is_alive();\n+}\n simdjson_really_inline value_iterator document::resume_value_iterator() noexcept {\n-  return value_iterator(&iter, 1, iter.root_checkpoint());\n+  return value_iterator(&iter, 1, iter.root_position());\n }\n simdjson_really_inline value_iterator document::get_root_value_iterator() noexcept {\n   return resume_value_iterator();\n }\n-simdjson_really_inline value document::resume_value() noexcept {\n-  return resume_value_iterator();\n+simdjson_really_inline simdjson_result<object> document::start_or_resume_object() noexcept {\n+  if (iter.at_root()) {\n+    return get_object();\n+  } else {\n+    return object::resume(resume_value_iterator());\n+  }\n+}\n+simdjson_really_inline simdjson_result<value> document::get_value() noexcept {\n+  // Make sure we start any arrays or objects before returning, so that start_root_<object/array>()\n+  // gets called.\n+  iter.assert_at_document_depth();\n+  switch (*iter.peek()) {\n+    case '[':\n+    case '{':\n+      return value(get_root_value_iterator());\n+    default:\n+      // Unfortunately, scalar documents are a special case in simdjson and they cannot\n+      // be safely converted to value instances.\n+      return SCALAR_DOCUMENT_AS_VALUE;\n+      // return value(get_root_value_iterator());\n+  }\n }\n simdjson_really_inline simdjson_result<array> document::get_array() & noexcept {\n   auto value = get_root_value_iterator();\n@@ -32,12 +66,21 @@ simdjson_really_inline simdjson_result<object> document::get_object() & noexcept\n simdjson_really_inline simdjson_result<uint64_t> document::get_uint64() noexcept {\n   return get_root_value_iterator().get_root_uint64();\n }\n+simdjson_really_inline simdjson_result<uint64_t> document::get_uint64_in_string() noexcept {\n+  return get_root_value_iterator().get_root_uint64_in_string();\n+}\n simdjson_really_inline simdjson_result<int64_t> document::get_int64() noexcept {\n   return get_root_value_iterator().get_root_int64();\n }\n+simdjson_really_inline simdjson_result<int64_t> document::get_int64_in_string() noexcept {\n+  return get_root_value_iterator().get_root_int64_in_string();\n+}\n simdjson_really_inline simdjson_result<double> document::get_double() noexcept {\n   return get_root_value_iterator().get_root_double();\n }\n+simdjson_really_inline simdjson_result<double> document::get_double_in_string() noexcept {\n+  return get_root_value_iterator().get_root_double_in_string();\n+}\n simdjson_really_inline simdjson_result<std::string_view> document::get_string() noexcept {\n   return get_root_value_iterator().get_root_string();\n }\n@@ -59,13 +102,15 @@ template<> simdjson_really_inline simdjson_result<double> document::get() & noex\n template<> simdjson_really_inline simdjson_result<uint64_t> document::get() & noexcept { return get_uint64(); }\n template<> simdjson_really_inline simdjson_result<int64_t> document::get() & noexcept { return get_int64(); }\n template<> simdjson_really_inline simdjson_result<bool> document::get() & noexcept { return get_bool(); }\n+template<> simdjson_really_inline simdjson_result<value> document::get() & noexcept { return get_value(); }\n \n template<> simdjson_really_inline simdjson_result<raw_json_string> document::get() && noexcept { return get_raw_json_string(); }\n template<> simdjson_really_inline simdjson_result<std::string_view> document::get() && noexcept { return get_string(); }\n template<> simdjson_really_inline simdjson_result<double> document::get() && noexcept { return std::forward<document>(*this).get_double(); }\n template<> simdjson_really_inline simdjson_result<uint64_t> document::get() && noexcept { return std::forward<document>(*this).get_uint64(); }\n template<> simdjson_really_inline simdjson_result<int64_t> document::get() && noexcept { return std::forward<document>(*this).get_int64(); }\n template<> simdjson_really_inline simdjson_result<bool> document::get() && noexcept { return std::forward<document>(*this).get_bool(); }\n+template<> simdjson_really_inline simdjson_result<value> document::get() && noexcept { return get_value(); }\n \n template<typename T> simdjson_really_inline error_code document::get(T &out) & noexcept {\n   return get<T>().get(out);\n@@ -83,8 +128,33 @@ simdjson_really_inline document::operator double() noexcept(false) { return get_\n simdjson_really_inline document::operator std::string_view() noexcept(false) { return get_string(); }\n simdjson_really_inline document::operator raw_json_string() noexcept(false) { return get_raw_json_string(); }\n simdjson_really_inline document::operator bool() noexcept(false) { return get_bool(); }\n-#endif\n+simdjson_really_inline document::operator value() noexcept(false) { return get_value(); }\n \n+#endif\n+simdjson_really_inline simdjson_result<size_t> document::count_elements() & noexcept {\n+  auto a = get_array();\n+  simdjson_result<size_t> answer = a.count_elements();\n+  /* If there was an array, we are now left pointing at its first element. */\n+  if(answer.error() == SUCCESS) {\n+    iter._depth = 1 ; /* undoing the increment so we go back at the doc depth.*/\n+    iter.assert_at_document_depth();\n+  }\n+  return answer;\n+}\n+simdjson_really_inline simdjson_result<size_t> document::count_fields() & noexcept {\n+  auto a = get_object();\n+  simdjson_result<size_t> answer = a.count_fields();\n+  /* If there was an array, we are now left pointing at its first element. */\n+  if(answer.error() == SUCCESS) {\n+    iter._depth = 1 ; /* undoing the increment so we go back at the doc depth.*/\n+    iter.assert_at_document_depth();\n+  }\n+  return answer;\n+}\n+simdjson_really_inline simdjson_result<value> document::at(size_t index) & noexcept {\n+  auto a = get_array();\n+  return a.at(index);\n+}\n simdjson_really_inline simdjson_result<array_iterator> document::begin() & noexcept {\n   return get_array().begin();\n }\n@@ -93,33 +163,93 @@ simdjson_really_inline simdjson_result<array_iterator> document::end() & noexcep\n }\n \n simdjson_really_inline simdjson_result<value> document::find_field(std::string_view key) & noexcept {\n-  return resume_value().find_field(key);\n+  return start_or_resume_object().find_field(key);\n }\n simdjson_really_inline simdjson_result<value> document::find_field(const char *key) & noexcept {\n-  return resume_value().find_field(key);\n+  return start_or_resume_object().find_field(key);\n }\n simdjson_really_inline simdjson_result<value> document::find_field_unordered(std::string_view key) & noexcept {\n-  return resume_value().find_field_unordered(key);\n+  return start_or_resume_object().find_field_unordered(key);\n }\n simdjson_really_inline simdjson_result<value> document::find_field_unordered(const char *key) & noexcept {\n-  return resume_value().find_field_unordered(key);\n+  return start_or_resume_object().find_field_unordered(key);\n }\n simdjson_really_inline simdjson_result<value> document::operator[](std::string_view key) & noexcept {\n-  return resume_value()[key];\n+  return start_or_resume_object()[key];\n }\n simdjson_really_inline simdjson_result<value> document::operator[](const char *key) & noexcept {\n-  return resume_value()[key];\n+  return start_or_resume_object()[key];\n+}\n+\n+simdjson_really_inline error_code document::consume() noexcept {\n+  auto error = iter.skip_child(0);\n+  if(error) { iter.abandon(); }\n+  return error;\n+}\n+\n+simdjson_really_inline simdjson_result<std::string_view> document::raw_json() noexcept {\n+  auto _iter = get_root_value_iterator();\n+  const uint8_t * starting_point{_iter.peek_start()};\n+  auto error = consume();\n+  if(error) { return error; }\n+  // After 'consume()', we could be left pointing just beyond the document, but that\n+  // is ok because we are not going to dereference the final pointer position, we just\n+  // use it to compute the length in bytes.\n+  const uint8_t * final_point{iter.unsafe_pointer()};\n+  return std::string_view(reinterpret_cast<const char*>(starting_point), size_t(final_point - starting_point));\n }\n \n simdjson_really_inline simdjson_result<json_type> document::type() noexcept {\n   return get_root_value_iterator().type();\n }\n \n+simdjson_really_inline simdjson_result<bool> document::is_scalar() noexcept {\n+  json_type this_type;\n+  auto error = type().get(this_type);\n+  if(error) { return error; }\n+  return ! ((this_type == json_type::array) || (this_type == json_type::object));\n+}\n+\n+simdjson_really_inline bool document::is_negative() noexcept {\n+  return get_root_value_iterator().is_root_negative();\n+}\n+\n+simdjson_really_inline simdjson_result<bool> document::is_integer() noexcept {\n+  return get_root_value_iterator().is_root_integer();\n+}\n+\n+simdjson_really_inline simdjson_result<number_type> document::get_number_type() noexcept {\n+  return get_root_value_iterator().get_root_number_type();\n+}\n+\n+simdjson_really_inline simdjson_result<number> document::get_number() noexcept {\n+  return get_root_value_iterator().get_root_number();\n+}\n+\n+\n simdjson_really_inline simdjson_result<std::string_view> document::raw_json_token() noexcept {\n   auto _iter = get_root_value_iterator();\n   return std::string_view(reinterpret_cast<const char*>(_iter.peek_start()), _iter.peek_start_length());\n }\n \n+simdjson_really_inline simdjson_result<value> document::at_pointer(std::string_view json_pointer) noexcept {\n+  rewind(); // Rewind the document each time at_pointer is called\n+  if (json_pointer.empty()) {\n+    return this->get_value();\n+  }\n+  json_type t;\n+  SIMDJSON_TRY(type().get(t));\n+  switch (t)\n+  {\n+    case json_type::array:\n+      return (*this).get_array().at_pointer(json_pointer);\n+    case json_type::object:\n+      return (*this).get_object().at_pointer(json_pointer);\n+    default:\n+      return INVALID_JSON_POINTER;\n+  }\n+}\n+\n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n@@ -142,7 +272,23 @@ simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::docume\n     )\n {\n }\n-\n+simdjson_really_inline simdjson_result<size_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::count_elements() & noexcept {\n+  if (error()) { return error(); }\n+  return first.count_elements();\n+}\n+simdjson_really_inline simdjson_result<size_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::count_fields() & noexcept {\n+  if (error()) { return error(); }\n+  return first.count_fields();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::at(size_t index) & noexcept {\n+  if (error()) { return error(); }\n+  return first.at(index);\n+}\n+simdjson_really_inline error_code simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::rewind() noexcept {\n+  if (error()) { return error(); }\n+  first.rewind();\n+  return SUCCESS;\n+}\n simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::begin() & noexcept {\n   if (error()) { return error(); }\n   return first.begin();\n@@ -206,6 +352,10 @@ simdjson_really_inline simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTA\n   if (error()) { return error(); }\n   return first.get_bool();\n }\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::get_value() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_value();\n+}\n simdjson_really_inline bool simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::is_null() noexcept {\n   if (error()) { return error(); }\n   return first.is_null();\n@@ -249,6 +399,33 @@ simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::json_t\n   return first.type();\n }\n \n+simdjson_really_inline simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::is_scalar() noexcept {\n+  if (error()) { return error(); }\n+  return first.is_scalar();\n+}\n+\n+\n+simdjson_really_inline bool simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::is_negative() noexcept {\n+  if (error()) { return error(); }\n+  return first.is_negative();\n+}\n+\n+simdjson_really_inline simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::is_integer() noexcept {\n+  if (error()) { return error(); }\n+  return first.is_integer();\n+}\n+\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number_type> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::get_number_type() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_number_type();\n+}\n+\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::get_number() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_number();\n+}\n+\n+\n #if SIMDJSON_EXCEPTIONS\n simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::operator SIMDJSON_IMPLEMENTATION::ondemand::array() & noexcept(false) {\n   if (error()) { throw simdjson_error(error()); }\n@@ -282,11 +459,260 @@ simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::docume\n   if (error()) { throw simdjson_error(error()); }\n   return first;\n }\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::operator SIMDJSON_IMPLEMENTATION::ondemand::value() noexcept(false) {\n+  if (error()) { throw simdjson_error(error()); }\n+  return first;\n+}\n #endif\n \n+\n+simdjson_really_inline simdjson_result<const char *> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::current_location() noexcept {\n+  if (error()) { return error(); }\n+  return first.current_location();\n+}\n+\n simdjson_really_inline simdjson_result<std::string_view> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::raw_json_token() noexcept {\n   if (error()) { return error(); }\n   return first.raw_json_token();\n }\n \n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::at_pointer(std::string_view json_pointer) noexcept {\n+  if (error()) { return error(); }\n+  return first.at_pointer(json_pointer);\n+}\n+\n+\n } // namespace simdjson\n+\n+\n+namespace simdjson {\n+namespace SIMDJSON_IMPLEMENTATION {\n+namespace ondemand {\n+\n+simdjson_really_inline document_reference::document_reference() noexcept : doc{nullptr} {}\n+simdjson_really_inline document_reference::document_reference(document &d) noexcept : doc(&d) {}\n+simdjson_really_inline void document_reference::rewind() noexcept { doc->rewind(); }\n+simdjson_really_inline simdjson_result<array> document_reference::get_array() & noexcept { return doc->get_array(); }\n+simdjson_really_inline simdjson_result<object> document_reference::get_object() & noexcept { return doc->get_object(); }\n+simdjson_really_inline simdjson_result<uint64_t> document_reference::get_uint64() noexcept { return doc->get_uint64(); }\n+simdjson_really_inline simdjson_result<int64_t> document_reference::get_int64() noexcept { return doc->get_int64(); }\n+simdjson_really_inline simdjson_result<double> document_reference::get_double() noexcept { return doc->get_double(); }\n+simdjson_really_inline simdjson_result<std::string_view> document_reference::get_string() noexcept { return doc->get_string(); }\n+simdjson_really_inline simdjson_result<raw_json_string> document_reference::get_raw_json_string() noexcept { return doc->get_raw_json_string(); }\n+simdjson_really_inline simdjson_result<bool> document_reference::get_bool() noexcept { return doc->get_bool(); }\n+simdjson_really_inline simdjson_result<value> document_reference::get_value() noexcept { return doc->get_value(); }\n+simdjson_really_inline bool document_reference::is_null() noexcept { return doc->is_null(); }\n+\n+#if SIMDJSON_EXCEPTIONS\n+simdjson_really_inline document_reference::operator array() & noexcept(false) { return array(*doc); }\n+simdjson_really_inline document_reference::operator object() & noexcept(false) { return object(*doc); }\n+simdjson_really_inline document_reference::operator uint64_t() noexcept(false) { return uint64_t(*doc); }\n+simdjson_really_inline document_reference::operator int64_t() noexcept(false) { return int64_t(*doc); }\n+simdjson_really_inline document_reference::operator double() noexcept(false) { return double(*doc); }\n+simdjson_really_inline document_reference::operator std::string_view() noexcept(false) { return std::string_view(*doc); }\n+simdjson_really_inline document_reference::operator raw_json_string() noexcept(false) { return raw_json_string(*doc); }\n+simdjson_really_inline document_reference::operator bool() noexcept(false) { return bool(*doc); }\n+simdjson_really_inline document_reference::operator value() noexcept(false) { return value(*doc); }\n+#endif\n+simdjson_really_inline simdjson_result<size_t> document_reference::count_elements() & noexcept { return doc->count_elements(); }\n+simdjson_really_inline simdjson_result<size_t> document_reference::count_fields() & noexcept { return doc->count_fields(); }\n+simdjson_really_inline simdjson_result<value> document_reference::at(size_t index) & noexcept { return doc->at(index); }\n+simdjson_really_inline simdjson_result<array_iterator> document_reference::begin() & noexcept { return doc->begin(); }\n+simdjson_really_inline simdjson_result<array_iterator> document_reference::end() & noexcept { return doc->end(); }\n+simdjson_really_inline simdjson_result<value> document_reference::find_field(std::string_view key) & noexcept { return doc->find_field(key); }\n+simdjson_really_inline simdjson_result<value> document_reference::find_field(const char *key) & noexcept { return doc->find_field(key); }\n+simdjson_really_inline simdjson_result<value> document_reference::operator[](std::string_view key) & noexcept { return (*doc)[key]; }\n+simdjson_really_inline simdjson_result<value> document_reference::operator[](const char *key) & noexcept { return (*doc)[key]; }\n+simdjson_really_inline simdjson_result<value> document_reference::find_field_unordered(std::string_view key) & noexcept { return doc->find_field_unordered(key); }\n+simdjson_really_inline simdjson_result<value> document_reference::find_field_unordered(const char *key) & noexcept { return doc->find_field_unordered(key); }\n+simdjson_really_inline simdjson_result<json_type> document_reference::type() noexcept { return doc->type(); }\n+simdjson_really_inline simdjson_result<bool> document_reference::is_scalar() noexcept { return doc->is_scalar(); }\n+simdjson_really_inline simdjson_result<const char *> document_reference::current_location() noexcept { return doc->current_location(); };\n+simdjson_really_inline bool document_reference::is_negative() noexcept { return doc->is_negative(); }\n+simdjson_really_inline simdjson_result<bool> document_reference::is_integer() noexcept { return doc->is_integer(); }\n+simdjson_really_inline simdjson_result<number_type> document_reference::get_number_type() noexcept { return doc->get_number_type(); }\n+simdjson_really_inline simdjson_result<number> document_reference::get_number() noexcept { return doc->get_number(); }\n+simdjson_really_inline simdjson_result<std::string_view> document_reference::raw_json_token() noexcept { return doc->raw_json_token(); }\n+simdjson_really_inline simdjson_result<value> document_reference::at_pointer(std::string_view json_pointer) noexcept { return doc->at_pointer(json_pointer); }\n+simdjson_really_inline simdjson_result<std::string_view> document_reference::raw_json() noexcept { return doc->raw_json();}\n+simdjson_really_inline document_reference::operator document&() const noexcept { return *doc; }\n+\n+} // namespace ondemand\n+} // namespace SIMDJSON_IMPLEMENTATION\n+} // namespace simdjson\n+\n+\n+\n+namespace simdjson {\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::simdjson_result(SIMDJSON_IMPLEMENTATION::ondemand::document_reference value, error_code error)\n+  noexcept : implementation_simdjson_result_base<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>(std::forward<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>(value), error) {}\n+\n+\n+simdjson_really_inline simdjson_result<size_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::count_elements() & noexcept {\n+  if (error()) { return error(); }\n+  return first.count_elements();\n+}\n+simdjson_really_inline simdjson_result<size_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::count_fields() & noexcept {\n+  if (error()) { return error(); }\n+  return first.count_fields();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::at(size_t index) & noexcept {\n+  if (error()) { return error(); }\n+  return first.at(index);\n+}\n+simdjson_really_inline error_code simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::rewind() noexcept {\n+  if (error()) { return error(); }\n+  first.rewind();\n+  return SUCCESS;\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::begin() & noexcept {\n+  if (error()) { return error(); }\n+  return first.begin();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::end() & noexcept {\n+  return {};\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::find_field_unordered(std::string_view key) & noexcept {\n+  if (error()) { return error(); }\n+  return first.find_field_unordered(key);\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::find_field_unordered(const char *key) & noexcept {\n+  if (error()) { return error(); }\n+  return first.find_field_unordered(key);\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::operator[](std::string_view key) & noexcept {\n+  if (error()) { return error(); }\n+  return first[key];\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::operator[](const char *key) & noexcept {\n+  if (error()) { return error(); }\n+  return first[key];\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::find_field(std::string_view key) & noexcept {\n+  if (error()) { return error(); }\n+  return first.find_field(key);\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::find_field(const char *key) & noexcept {\n+  if (error()) { return error(); }\n+  return first.find_field(key);\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::get_array() & noexcept {\n+  if (error()) { return error(); }\n+  return first.get_array();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::get_object() & noexcept {\n+  if (error()) { return error(); }\n+  return first.get_object();\n+}\n+simdjson_really_inline simdjson_result<uint64_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::get_uint64() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_uint64();\n+}\n+simdjson_really_inline simdjson_result<int64_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::get_int64() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_int64();\n+}\n+simdjson_really_inline simdjson_result<double> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::get_double() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_double();\n+}\n+simdjson_really_inline simdjson_result<std::string_view> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::get_string() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_string();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::raw_json_string> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::get_raw_json_string() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_raw_json_string();\n+}\n+simdjson_really_inline simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::get_bool() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_bool();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::get_value() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_value();\n+}\n+simdjson_really_inline bool simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::is_null() noexcept {\n+  if (error()) { return error(); }\n+  return first.is_null();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::json_type> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::type() noexcept {\n+  if (error()) { return error(); }\n+  return first.type();\n+}\n+simdjson_really_inline simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::is_scalar() noexcept {\n+  if (error()) { return error(); }\n+  return first.is_scalar();\n+}\n+simdjson_really_inline bool simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::is_negative() noexcept {\n+  if (error()) { return error(); }\n+  return first.is_negative();\n+}\n+simdjson_really_inline simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::is_integer() noexcept {\n+  if (error()) { return error(); }\n+  return first.is_integer();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number_type> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::get_number_type() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_number_type();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::get_number() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_number();\n+}\n+#if SIMDJSON_EXCEPTIONS\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::operator SIMDJSON_IMPLEMENTATION::ondemand::array() & noexcept(false) {\n+  if (error()) { throw simdjson_error(error()); }\n+  return first;\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::operator SIMDJSON_IMPLEMENTATION::ondemand::object() & noexcept(false) {\n+  if (error()) { throw simdjson_error(error()); }\n+  return first;\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::operator uint64_t() noexcept(false) {\n+  if (error()) { throw simdjson_error(error()); }\n+  return first;\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::operator int64_t() noexcept(false) {\n+  if (error()) { throw simdjson_error(error()); }\n+  return first;\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::operator double() noexcept(false) {\n+  if (error()) { throw simdjson_error(error()); }\n+  return first;\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::operator std::string_view() noexcept(false) {\n+  if (error()) { throw simdjson_error(error()); }\n+  return first;\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::operator SIMDJSON_IMPLEMENTATION::ondemand::raw_json_string() noexcept(false) {\n+  if (error()) { throw simdjson_error(error()); }\n+  return first;\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::operator bool() noexcept(false) {\n+  if (error()) { throw simdjson_error(error()); }\n+  return first;\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::operator SIMDJSON_IMPLEMENTATION::ondemand::value() noexcept(false) {\n+  if (error()) { throw simdjson_error(error()); }\n+  return first;\n+}\n+#endif\n+\n+simdjson_really_inline simdjson_result<const char *> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::current_location() noexcept {\n+  if (error()) { return error(); }\n+  return first.current_location();\n+}\n+\n+simdjson_really_inline simdjson_result<std::string_view> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::raw_json_token() noexcept {\n+  if (error()) { return error(); }\n+  return first.raw_json_token();\n+}\n+\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference>::at_pointer(std::string_view json_pointer) noexcept {\n+  if (error()) { return error(); }\n+  return first.at_pointer(json_pointer);\n+}\n+\n+\n+} // namespace simdjson\n\\ No newline at end of file"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/document.h",
        "status": "modified",
        "additions": 351,
        "deletions": 9,
        "changes": 360,
        "patch": "@@ -10,9 +10,10 @@ class object;\n class value;\n class raw_json_string;\n class array_iterator;\n+class document_stream;\n \n /**\n- * A JSON document iteration.\n+ * A JSON document. It holds a json_iterator instance.\n  *\n  * Used by tokens to get text, and string buffer location.\n  *\n@@ -26,7 +27,7 @@ class document {\n    * Exists so you can declare a variable and later assign to it before use.\n    */\n   simdjson_really_inline document() noexcept = default;\n-  simdjson_really_inline document(const document &other) noexcept = delete;\n+  simdjson_really_inline document(const document &other) noexcept = delete; // pass your documents by reference, not by copy\n   simdjson_really_inline document(document &&other) noexcept = default;\n   simdjson_really_inline document &operator=(const document &other) noexcept = delete;\n   simdjson_really_inline document &operator=(document &&other) noexcept = default;\n@@ -52,20 +53,42 @@ class document {\n    * @returns INCORRECT_TYPE If the JSON value is not a 64-bit unsigned integer.\n    */\n   simdjson_really_inline simdjson_result<uint64_t> get_uint64() noexcept;\n+  /**\n+   * Cast this JSON value (inside string) to an unsigned integer.\n+   *\n+   * @returns A signed 64-bit integer.\n+   * @returns INCORRECT_TYPE If the JSON value is not a 64-bit unsigned integer.\n+   */\n+  simdjson_really_inline simdjson_result<uint64_t> get_uint64_in_string() noexcept;\n   /**\n    * Cast this JSON value to a signed integer.\n    *\n    * @returns A signed 64-bit integer.\n    * @returns INCORRECT_TYPE If the JSON value is not a 64-bit integer.\n    */\n   simdjson_really_inline simdjson_result<int64_t> get_int64() noexcept;\n+  /**\n+   * Cast this JSON value (inside string) to a signed integer.\n+   *\n+   * @returns A signed 64-bit integer.\n+   * @returns INCORRECT_TYPE If the JSON value is not a 64-bit integer.\n+   */\n+  simdjson_really_inline simdjson_result<int64_t> get_int64_in_string() noexcept;\n   /**\n    * Cast this JSON value to a double.\n    *\n    * @returns A double.\n    * @returns INCORRECT_TYPE If the JSON value is not a valid floating-point number.\n    */\n   simdjson_really_inline simdjson_result<double> get_double() noexcept;\n+\n+  /**\n+   * Cast this JSON value (inside string) to a double.\n+   *\n+   * @returns A double.\n+   * @returns INCORRECT_TYPE If the JSON value is not a valid floating-point number.\n+   */\n+  simdjson_really_inline simdjson_result<double> get_double_in_string() noexcept;\n   /**\n    * Cast this JSON value to a string.\n    *\n@@ -92,6 +115,14 @@ class document {\n    * @returns INCORRECT_TYPE if the JSON value is not true or false.\n    */\n   simdjson_really_inline simdjson_result<bool> get_bool() noexcept;\n+  /**\n+   * Cast this JSON value to a value when the document is an object or an array.\n+   *\n+   * @returns A value if a JSON array or object cannot be found.\n+   * @returns SCALAR_DOCUMENT_AS_VALUE error is the document is a scalar (see is_scalar() function).\n+   */\n+  simdjson_really_inline simdjson_result<value> get_value() noexcept;\n+\n   /**\n    * Checks if this JSON value is null.\n    *\n@@ -125,7 +156,9 @@ class document {\n   /**\n    * Get this value as the given type.\n    *\n-   * Supported types: object, array, raw_json_string, string_view, uint64_t, int64_t, double, bool\n+   * Supported types: object, array, raw_json_string, string_view, uint64_t, int64_t, double, bool, value\n+   *\n+   * Be mindful that the document instance must remain in scope while you are accessing object, array and value instances.\n    *\n    * @param out This is set to a value of the given type, parsed from the JSON. If there is an error, this may not be initialized.\n    * @returns INCORRECT_TYPE If the JSON value is not an object.\n@@ -197,8 +230,49 @@ class document {\n    * @exception simdjson_error(INCORRECT_TYPE) if the JSON value is not true or false.\n    */\n   simdjson_really_inline operator bool() noexcept(false);\n+  /**\n+   * Cast this JSON value to a value.\n+   *\n+   * @returns A value value.\n+   * @exception if a JSON value cannot be found\n+   */\n+  simdjson_really_inline operator value() noexcept(false);\n #endif\n-\n+  /**\n+   * This method scans the array and counts the number of elements.\n+   * The count_elements method should always be called before you have begun\n+   * iterating through the array: it is expected that you are pointing at\n+   * the beginning of the array.\n+   * The runtime complexity is linear in the size of the array. After\n+   * calling this function, if successful, the array is 'rewinded' at its\n+   * beginning as if it had never been accessed. If the JSON is malformed (e.g.,\n+   * there is a missing comma), then an error is returned and it is no longer\n+   * safe to continue.\n+   */\n+  simdjson_really_inline simdjson_result<size_t> count_elements() & noexcept;\n+   /**\n+   * This method scans the object and counts the number of key-value pairs.\n+   * The count_fields method should always be called before you have begun\n+   * iterating through the object: it is expected that you are pointing at\n+   * the beginning of the object.\n+   * The runtime complexity is linear in the size of the object. After\n+   * calling this function, if successful, the object is 'rewinded' at its\n+   * beginning as if it had never been accessed. If the JSON is malformed (e.g.,\n+   * there is a missing comma), then an error is returned and it is no longer\n+   * safe to continue.\n+   *\n+   * To check that an object is empty, it is more performant to use\n+   * the is_empty() method.\n+   */\n+  simdjson_really_inline simdjson_result<size_t> count_fields() & noexcept;\n+  /**\n+   * Get the value at the given index in the array. This function has linear-time complexity.\n+   * This function should only be called once as the array iterator is not reset between each call.\n+   *\n+   * @return The value at the given index, or:\n+   *         - INDEX_OUT_OF_BOUNDS if the array index is larger than an array length\n+   */\n+  simdjson_really_inline simdjson_result<value> at(size_t index) & noexcept;\n   /**\n    * Begin array iteration.\n    *\n@@ -274,6 +348,77 @@ class document {\n    */\n   simdjson_really_inline simdjson_result<json_type> type() noexcept;\n \n+  /**\n+   * Checks whether the document is a scalar (string, number, null, Boolean).\n+   * Returns false when there it is an array or object.\n+   *\n+   * @returns true if the type is string, number, null, Boolean\n+   * @error TAPE_ERROR when the JSON value is a bad token like \"}\" \",\" or \"alse\".\n+   */\n+  simdjson_really_inline simdjson_result<bool> is_scalar() noexcept;\n+\n+  /**\n+   * Checks whether the document is a negative number.\n+   *\n+   * @returns true if the number if negative.\n+   */\n+  simdjson_really_inline bool is_negative() noexcept;\n+  /**\n+   * Checks whether the document is an integer number. Note that\n+   * this requires to partially parse the number string. If\n+   * the value is determined to be an integer, it may still\n+   * not parse properly as an integer in subsequent steps\n+   * (e.g., it might overflow).\n+   *\n+   * @returns true if the number if negative.\n+   */\n+  simdjson_really_inline simdjson_result<bool> is_integer() noexcept;\n+  /**\n+   * Determine the number type (integer or floating-point number).\n+   *\n+   * get_number_type() is number_type::unsigned_integer if we have\n+   * an integer greater or equal to 9223372036854775808\n+   * get_number_type() is number_type::signed_integer if we have an\n+   * integer that is less than 9223372036854775808\n+   * Otherwise, get_number_type() has value number_type::floating_point_number\n+   *\n+   * This function req\n+   * uires processing the number string, but it is expected\n+   * to be faster than get_number().get_number_type() because it is does not\n+   * parse the number value.\n+   *\n+   * @returns the type of the number\n+   */\n+  simdjson_really_inline simdjson_result<number_type> get_number_type() noexcept;\n+\n+  /**\n+   * Attempt to parse an ondemand::number. An ondemand::number may\n+   * contain an integer value or a floating-point value, the simdjson\n+   * library will autodetect the type. Thus it is a dynamically typed\n+   * number. Before accessing the value, you must determine the detected\n+   * type.\n+   *\n+   * number.get_number_type() is number_type::signed_integer if we have\n+   * a integer in [-9223372036854775808,9223372036854775808)\n+   * You can recover the value by calling number.get_int64() and you\n+   * have that number.is_int64() is true.\n+   *\n+   * number.get_number_type() is number_type::unsigned_integer if we have\n+   * an integer in [9223372036854775808,18446744073709551616)\n+   * You can recover the value by calling number.get_uint64() and you\n+   * have that number.is_uint64() is true.\n+   *\n+   * Otherwise, number.get_number_type() has value number_type::floating_point_number\n+   * and we have a binary64 number.\n+   * You can recover the value by calling number.get_double() and you\n+   * have that number.is_double() is true.\n+   *\n+   * You must check the type before accessing the value: it is an error\n+   * to call \"get_int64()\" when number.get_number_type() is not\n+   * number_type::signed_integer and when number.is_int64() is false.\n+   */\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<number> get_number() noexcept;\n+\n   /**\n    * Get the raw JSON for this token.\n    *\n@@ -298,13 +443,77 @@ class document {\n    */\n   simdjson_really_inline simdjson_result<std::string_view> raw_json_token() noexcept;\n \n+  /**\n+   * Reset the iterator inside the document instance so we are pointing back at the\n+   * beginning of the document, as if it had just been created. It invalidates all\n+   * values, objects and arrays that you have created so far (including unescaped strings).\n+   */\n+  inline void rewind() noexcept;\n+  /**\n+   * Returns debugging information.\n+   */\n+  inline std::string to_debug_string() noexcept;\n+  /**\n+   * Some unrecoverable error conditions may render the document instance unusable.\n+   * The is_alive() method returns true when the document is still suitable.\n+   */\n+  inline bool is_alive() noexcept;\n+\n+  /**\n+   * Returns the current location in the document if in bounds.\n+   */\n+  inline simdjson_result<const char *> current_location() noexcept;\n+\n+  /**\n+   * Get the value associated with the given JSON pointer.  We use the RFC 6901\n+   * https://tools.ietf.org/html/rfc6901 standard.\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"foo\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"/foo/a/1\") == 20\n+   *\n+   * It is allowed for a key to be the empty string:\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"//a/1\") == 20\n+   *\n+   * Note that at_pointer() automatically calls rewind between each call. Thus\n+   * all values, objects and arrays that you have created so far (including unescaped strings)\n+   * are invalidated. After calling at_pointer, you need to consume the result: string values\n+   * should be stored in your own variables, arrays should be decoded and stored in your own array-like\n+   * structures and so forth.\n+   *\n+   * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching\n+   *\n+   * @return The value associated with the given JSON pointer, or:\n+   *         - NO_SUCH_FIELD if a field does not exist in an object\n+   *         - INDEX_OUT_OF_BOUNDS if an array index is larger than an array length\n+   *         - INCORRECT_TYPE if a non-integer is used to access an array\n+   *         - INVALID_JSON_POINTER if the JSON pointer is invalid and cannot be parsed\n+   *         - SCALAR_DOCUMENT_AS_VALUE if the json_pointer is empty and the document is not a scalar (see is_scalar() function).\n+   */\n+  simdjson_really_inline simdjson_result<value> at_pointer(std::string_view json_pointer) noexcept;\n+  /**\n+   * Consumes the document and returns a string_view instance corresponding to the\n+   * document as represented in JSON. It points inside the original byte array containg\n+   * the JSON document.\n+   */\n+  simdjson_really_inline simdjson_result<std::string_view> raw_json() noexcept;\n protected:\n+  /**\n+   * Consumes the document.\n+   */\n+  simdjson_really_inline error_code consume() noexcept;\n+\n   simdjson_really_inline document(ondemand::json_iterator &&iter) noexcept;\n   simdjson_really_inline const uint8_t *text(uint32_t idx) const noexcept;\n \n   simdjson_really_inline value_iterator resume_value_iterator() noexcept;\n   simdjson_really_inline value_iterator get_root_value_iterator() noexcept;\n-  simdjson_really_inline value resume_value() noexcept;\n+  simdjson_really_inline simdjson_result<object> start_or_resume_object() noexcept;\n   static simdjson_really_inline document start(ondemand::json_iterator &&iter) noexcept;\n \n   //\n@@ -313,16 +522,76 @@ class document {\n   json_iterator iter{}; ///< Current position in the document\n   static constexpr depth_t DOCUMENT_DEPTH = 0; ///< document depth is always 0\n \n-  friend struct simdjson_result<document>;\n   friend class array_iterator;\n   friend class value;\n   friend class ondemand::parser;\n   friend class object;\n   friend class array;\n   friend class field;\n   friend class token;\n+  friend class document_stream;\n };\n \n+\n+/**\n+ * A document_reference is a thin wrapper around a document reference instance.\n+ */\n+class document_reference {\n+public:\n+  simdjson_really_inline document_reference() noexcept;\n+  simdjson_really_inline document_reference(document &d) noexcept;\n+  simdjson_really_inline document_reference(const document_reference &other) noexcept = default;\n+  simdjson_really_inline void rewind() noexcept;\n+  simdjson_really_inline simdjson_result<array> get_array() & noexcept;\n+  simdjson_really_inline simdjson_result<object> get_object() & noexcept;\n+  simdjson_really_inline simdjson_result<uint64_t> get_uint64() noexcept;\n+  simdjson_really_inline simdjson_result<int64_t> get_int64() noexcept;\n+  simdjson_really_inline simdjson_result<double> get_double() noexcept;\n+  simdjson_really_inline simdjson_result<std::string_view> get_string() noexcept;\n+  simdjson_really_inline simdjson_result<raw_json_string> get_raw_json_string() noexcept;\n+  simdjson_really_inline simdjson_result<bool> get_bool() noexcept;\n+  simdjson_really_inline simdjson_result<value> get_value() noexcept;\n+\n+  simdjson_really_inline bool is_null() noexcept;\n+  simdjson_really_inline simdjson_result<std::string_view> raw_json() noexcept;\n+  simdjson_really_inline operator document&() const noexcept;\n+\n+#if SIMDJSON_EXCEPTIONS\n+  simdjson_really_inline operator array() & noexcept(false);\n+  simdjson_really_inline operator object() & noexcept(false);\n+  simdjson_really_inline operator uint64_t() noexcept(false);\n+  simdjson_really_inline operator int64_t() noexcept(false);\n+  simdjson_really_inline operator double() noexcept(false);\n+  simdjson_really_inline operator std::string_view() noexcept(false);\n+  simdjson_really_inline operator raw_json_string() noexcept(false);\n+  simdjson_really_inline operator bool() noexcept(false);\n+  simdjson_really_inline operator value() noexcept(false);\n+#endif\n+  simdjson_really_inline simdjson_result<size_t> count_elements() & noexcept;\n+  simdjson_really_inline simdjson_result<size_t> count_fields() & noexcept;\n+  simdjson_really_inline simdjson_result<value> at(size_t index) & noexcept;\n+  simdjson_really_inline simdjson_result<array_iterator> begin() & noexcept;\n+  simdjson_really_inline simdjson_result<array_iterator> end() & noexcept;\n+  simdjson_really_inline simdjson_result<value> find_field(std::string_view key) & noexcept;\n+  simdjson_really_inline simdjson_result<value> find_field(const char *key) & noexcept;\n+  simdjson_really_inline simdjson_result<value> operator[](std::string_view key) & noexcept;\n+  simdjson_really_inline simdjson_result<value> operator[](const char *key) & noexcept;\n+  simdjson_really_inline simdjson_result<value> find_field_unordered(std::string_view key) & noexcept;\n+  simdjson_really_inline simdjson_result<value> find_field_unordered(const char *key) & noexcept;\n+\n+  simdjson_really_inline simdjson_result<json_type> type() noexcept;\n+  simdjson_really_inline simdjson_result<bool> is_scalar() noexcept;\n+\n+  simdjson_really_inline simdjson_result<const char *> current_location() noexcept;\n+  simdjson_really_inline bool is_negative() noexcept;\n+  simdjson_really_inline simdjson_result<bool> is_integer() noexcept;\n+  simdjson_really_inline simdjson_result<number_type> get_number_type() noexcept;\n+  simdjson_really_inline simdjson_result<number> get_number() noexcept;\n+  simdjson_really_inline simdjson_result<std::string_view> raw_json_token() noexcept;\n+  simdjson_really_inline simdjson_result<value> at_pointer(std::string_view json_pointer) noexcept;\n+private:\n+  document *doc{nullptr};\n+};\n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n@@ -335,15 +604,18 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document> : public SIM\n   simdjson_really_inline simdjson_result(SIMDJSON_IMPLEMENTATION::ondemand::document &&value) noexcept; ///< @private\n   simdjson_really_inline simdjson_result(error_code error) noexcept; ///< @private\n   simdjson_really_inline simdjson_result() noexcept = default;\n+  simdjson_really_inline error_code rewind() noexcept;\n \n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array> get_array() & noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> get_object() & noexcept;\n   simdjson_really_inline simdjson_result<uint64_t> get_uint64() noexcept;\n   simdjson_really_inline simdjson_result<int64_t> get_int64() noexcept;\n   simdjson_really_inline simdjson_result<double> get_double() noexcept;\n+  simdjson_really_inline simdjson_result<double> get_double_from_string() noexcept;\n   simdjson_really_inline simdjson_result<std::string_view> get_string() noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::raw_json_string> get_raw_json_string() noexcept;\n   simdjson_really_inline simdjson_result<bool> get_bool() noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> get_value() noexcept;\n   simdjson_really_inline bool is_null() noexcept;\n \n   template<typename T> simdjson_really_inline simdjson_result<T> get() & noexcept;\n@@ -361,8 +633,11 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document> : public SIM\n   simdjson_really_inline operator std::string_view() noexcept(false);\n   simdjson_really_inline operator SIMDJSON_IMPLEMENTATION::ondemand::raw_json_string() noexcept(false);\n   simdjson_really_inline operator bool() noexcept(false);\n+  simdjson_really_inline operator SIMDJSON_IMPLEMENTATION::ondemand::value() noexcept(false);\n #endif\n-\n+  simdjson_really_inline simdjson_result<size_t> count_elements() & noexcept;\n+  simdjson_really_inline simdjson_result<size_t> count_fields() & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at(size_t index) & noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> begin() & noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> end() & noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field(std::string_view key) & noexcept;\n@@ -371,11 +646,78 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document> : public SIM\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> operator[](const char *key) & noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(std::string_view key) & noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(const char *key) & noexcept;\n-\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::json_type> type() noexcept;\n-\n+  simdjson_really_inline simdjson_result<bool> is_scalar() noexcept;\n+  simdjson_really_inline simdjson_result<const char *> current_location() noexcept;\n+  simdjson_really_inline bool is_negative() noexcept;\n+  simdjson_really_inline simdjson_result<bool> is_integer() noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number_type> get_number_type() noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number> get_number() noexcept;\n   /** @copydoc simdjson_really_inline std::string_view document::raw_json_token() const noexcept */\n   simdjson_really_inline simdjson_result<std::string_view> raw_json_token() noexcept;\n+\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at_pointer(std::string_view json_pointer) noexcept;\n };\n \n+\n } // namespace simdjson\n+\n+\n+\n+namespace simdjson {\n+\n+template<>\n+struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference> : public SIMDJSON_IMPLEMENTATION::implementation_simdjson_result_base<SIMDJSON_IMPLEMENTATION::ondemand::document_reference> {\n+public:\n+  simdjson_really_inline simdjson_result(SIMDJSON_IMPLEMENTATION::ondemand::document_reference value, error_code error) noexcept;\n+  simdjson_really_inline simdjson_result() noexcept = default;\n+  simdjson_really_inline error_code rewind() noexcept;\n+\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array> get_array() & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> get_object() & noexcept;\n+  simdjson_really_inline simdjson_result<uint64_t> get_uint64() noexcept;\n+  simdjson_really_inline simdjson_result<int64_t> get_int64() noexcept;\n+  simdjson_really_inline simdjson_result<double> get_double() noexcept;\n+  simdjson_really_inline simdjson_result<std::string_view> get_string() noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::raw_json_string> get_raw_json_string() noexcept;\n+  simdjson_really_inline simdjson_result<bool> get_bool() noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> get_value() noexcept;\n+  simdjson_really_inline bool is_null() noexcept;\n+\n+#if SIMDJSON_EXCEPTIONS\n+  simdjson_really_inline operator SIMDJSON_IMPLEMENTATION::ondemand::array() & noexcept(false);\n+  simdjson_really_inline operator SIMDJSON_IMPLEMENTATION::ondemand::object() & noexcept(false);\n+  simdjson_really_inline operator uint64_t() noexcept(false);\n+  simdjson_really_inline operator int64_t() noexcept(false);\n+  simdjson_really_inline operator double() noexcept(false);\n+  simdjson_really_inline operator std::string_view() noexcept(false);\n+  simdjson_really_inline operator SIMDJSON_IMPLEMENTATION::ondemand::raw_json_string() noexcept(false);\n+  simdjson_really_inline operator bool() noexcept(false);\n+  simdjson_really_inline operator SIMDJSON_IMPLEMENTATION::ondemand::value() noexcept(false);\n+#endif\n+  simdjson_really_inline simdjson_result<size_t> count_elements() & noexcept;\n+  simdjson_really_inline simdjson_result<size_t> count_fields() & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at(size_t index) & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> begin() & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> end() & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field(std::string_view key) & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field(const char *key) & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> operator[](std::string_view key) & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> operator[](const char *key) & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(std::string_view key) & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(const char *key) & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::json_type> type() noexcept;\n+  simdjson_really_inline simdjson_result<bool> is_scalar() noexcept;\n+  simdjson_really_inline simdjson_result<const char *> current_location() noexcept;\n+  simdjson_really_inline bool is_negative() noexcept;\n+  simdjson_really_inline simdjson_result<bool> is_integer() noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number_type> get_number_type() noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number> get_number() noexcept;\n+  /** @copydoc simdjson_really_inline std::string_view document_reference::raw_json_token() const noexcept */\n+  simdjson_really_inline simdjson_result<std::string_view> raw_json_token() noexcept;\n+\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at_pointer(std::string_view json_pointer) noexcept;\n+};\n+\n+\n+} // namespace simdjson\n\\ No newline at end of file"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/document_stream-inl.h",
        "status": "added",
        "additions": 407,
        "deletions": 0,
        "changes": 407,
        "patch": "@@ -0,0 +1,407 @@\n+#include <algorithm>\n+#include <limits>\n+#include <stdexcept>\n+namespace simdjson {\n+namespace SIMDJSON_IMPLEMENTATION {\n+namespace ondemand {\n+\n+#ifdef SIMDJSON_THREADS_ENABLED\n+\n+inline void stage1_worker::finish() {\n+  // After calling \"run\" someone would call finish() to wait\n+  // for the end of the processing.\n+  // This function will wait until either the thread has done\n+  // the processing or, else, the destructor has been called.\n+  std::unique_lock<std::mutex> lock(locking_mutex);\n+  cond_var.wait(lock, [this]{return has_work == false;});\n+}\n+\n+inline stage1_worker::~stage1_worker() {\n+  // The thread may never outlive the stage1_worker instance\n+  // and will always be stopped/joined before the stage1_worker\n+  // instance is gone.\n+  stop_thread();\n+}\n+\n+inline void stage1_worker::start_thread() {\n+  std::unique_lock<std::mutex> lock(locking_mutex);\n+  if(thread.joinable()) {\n+    return; // This should never happen but we never want to create more than one thread.\n+  }\n+  thread = std::thread([this]{\n+      while(true) {\n+        std::unique_lock<std::mutex> thread_lock(locking_mutex);\n+        // We wait for either \"run\" or \"stop_thread\" to be called.\n+        cond_var.wait(thread_lock, [this]{return has_work || !can_work;});\n+        // If, for some reason, the stop_thread() method was called (i.e., the\n+        // destructor of stage1_worker is called, then we want to immediately destroy\n+        // the thread (and not do any more processing).\n+        if(!can_work) {\n+          break;\n+        }\n+        this->owner->stage1_thread_error = this->owner->run_stage1(*this->stage1_thread_parser,\n+              this->_next_batch_start);\n+        this->has_work = false;\n+        // The condition variable call should be moved after thread_lock.unlock() for performance\n+        // reasons but thread sanitizers may report it as a data race if we do.\n+        // See https://stackoverflow.com/questions/35775501/c-should-condition-variable-be-notified-under-lock\n+        cond_var.notify_one(); // will notify \"finish\"\n+        thread_lock.unlock();\n+      }\n+    }\n+  );\n+}\n+\n+\n+inline void stage1_worker::stop_thread() {\n+  std::unique_lock<std::mutex> lock(locking_mutex);\n+  // We have to make sure that all locks can be released.\n+  can_work = false;\n+  has_work = false;\n+  cond_var.notify_all();\n+  lock.unlock();\n+  if(thread.joinable()) {\n+    thread.join();\n+  }\n+}\n+\n+inline void stage1_worker::run(document_stream * ds, parser * stage1, size_t next_batch_start) {\n+  std::unique_lock<std::mutex> lock(locking_mutex);\n+  owner = ds;\n+  _next_batch_start = next_batch_start;\n+  stage1_thread_parser = stage1;\n+  has_work = true;\n+  // The condition variable call should be moved after thread_lock.unlock() for performance\n+  // reasons but thread sanitizers may report it as a data race if we do.\n+  // See https://stackoverflow.com/questions/35775501/c-should-condition-variable-be-notified-under-lock\n+  cond_var.notify_one(); // will notify the thread lock that we have work\n+  lock.unlock();\n+}\n+\n+#endif  // SIMDJSON_THREADS_ENABLED\n+\n+simdjson_really_inline document_stream::document_stream(\n+  ondemand::parser &_parser,\n+  const uint8_t *_buf,\n+  size_t _len,\n+  size_t _batch_size\n+) noexcept\n+  : parser{&_parser},\n+    buf{_buf},\n+    len{_len},\n+    batch_size{_batch_size <= MINIMAL_BATCH_SIZE ? MINIMAL_BATCH_SIZE : _batch_size},\n+    error{SUCCESS}\n+    #ifdef SIMDJSON_THREADS_ENABLED\n+    , use_thread(_parser.threaded) // we need to make a copy because _parser.threaded can change\n+    #endif\n+{\n+#ifdef SIMDJSON_THREADS_ENABLED\n+  if(worker.get() == nullptr) {\n+    error = MEMALLOC;\n+  }\n+#endif\n+}\n+\n+simdjson_really_inline document_stream::document_stream() noexcept\n+  : parser{nullptr},\n+    buf{nullptr},\n+    len{0},\n+    batch_size{0},\n+    error{UNINITIALIZED}\n+    #ifdef SIMDJSON_THREADS_ENABLED\n+    , use_thread(false)\n+    #endif\n+{\n+}\n+\n+simdjson_really_inline document_stream::~document_stream() noexcept\n+{\n+  #ifdef SIMDJSON_THREADS_ENABLED\n+  worker.reset();\n+  #endif\n+}\n+\n+inline size_t document_stream::size_in_bytes() const noexcept {\n+  return len;\n+}\n+\n+inline size_t document_stream::truncated_bytes() const noexcept {\n+  if(error == CAPACITY) { return len - batch_start; }\n+  return parser->implementation->structural_indexes[parser->implementation->n_structural_indexes] - parser->implementation->structural_indexes[parser->implementation->n_structural_indexes + 1];\n+}\n+\n+simdjson_really_inline document_stream::iterator::iterator() noexcept\n+  : stream{nullptr}, finished{true} {\n+}\n+\n+simdjson_really_inline document_stream::iterator::iterator(document_stream* _stream, bool is_end) noexcept\n+  : stream{_stream}, finished{is_end} {\n+}\n+\n+simdjson_really_inline simdjson_result<ondemand::document_reference> document_stream::iterator::operator*() noexcept {\n+  //if(stream->error) { return stream->error; }\n+  return simdjson_result<ondemand::document_reference>(stream->doc, stream->error);\n+}\n+\n+simdjson_really_inline document_stream::iterator& document_stream::iterator::operator++() noexcept {\n+  // If there is an error, then we want the iterator\n+  // to be finished, no matter what. (E.g., we do not\n+  // keep generating documents with errors, or go beyond\n+  // a document with errors.)\n+  //\n+  // Users do not have to call \"operator*()\" when they use operator++,\n+  // so we need to end the stream in the operator++ function.\n+  //\n+  // Note that setting finished = true is essential otherwise\n+  // we would enter an infinite loop.\n+  if (stream->error) { finished = true; }\n+  // Note that stream->error() is guarded against error conditions\n+  // (it will immediately return if stream->error casts to false).\n+  // In effect, this next function does nothing when (stream->error)\n+  // is true (hence the risk of an infinite loop).\n+  stream->next();\n+  // If that was the last document, we're finished.\n+  // It is the only type of error we do not want to appear\n+  // in operator*.\n+  if (stream->error == EMPTY) { finished = true; }\n+  // If we had any other kind of error (not EMPTY) then we want\n+  // to pass it along to the operator* and we cannot mark the result\n+  // as \"finished\" just yet.\n+  return *this;\n+}\n+\n+simdjson_really_inline bool document_stream::iterator::operator!=(const document_stream::iterator &other) const noexcept {\n+  return finished != other.finished;\n+}\n+\n+simdjson_really_inline document_stream::iterator document_stream::begin() noexcept {\n+  start();\n+  // If there are no documents, we're finished.\n+  return iterator(this, error == EMPTY);\n+}\n+\n+simdjson_really_inline document_stream::iterator document_stream::end() noexcept {\n+  return iterator(this, true);\n+}\n+\n+inline void document_stream::start() noexcept {\n+  if (error) { return; }\n+  error = parser->allocate(batch_size);\n+  if (error) { return; }\n+  // Always run the first stage 1 parse immediately\n+  batch_start = 0;\n+  error = run_stage1(*parser, batch_start);\n+  while(error == EMPTY) {\n+    // In exceptional cases, we may start with an empty block\n+    batch_start = next_batch_start();\n+    if (batch_start >= len) { return; }\n+    error = run_stage1(*parser, batch_start);\n+  }\n+  if (error) { return; }\n+  doc_index = batch_start;\n+  doc = document(json_iterator(&buf[batch_start], parser));\n+  doc.iter._streaming = true;\n+\n+  #ifdef SIMDJSON_THREADS_ENABLED\n+  if (use_thread && next_batch_start() < len) {\n+    // Kick off the first thread on next batch if needed\n+    error = stage1_thread_parser.allocate(batch_size);\n+    if (error) { return; }\n+    worker->start_thread();\n+    start_stage1_thread();\n+    if (error) { return; }\n+  }\n+  #endif // SIMDJSON_THREADS_ENABLED\n+}\n+\n+inline void document_stream::next() noexcept {\n+  // We always enter at once once in an error condition.\n+  if (error) { return; }\n+  next_document();\n+  if (error) { return; }\n+  auto cur_struct_index = doc.iter._root - parser->implementation->structural_indexes.get();\n+  doc_index = batch_start + parser->implementation->structural_indexes[cur_struct_index];\n+\n+  // Check if at end of structural indexes (i.e. at end of batch)\n+  if(cur_struct_index >= static_cast<int64_t>(parser->implementation->n_structural_indexes)) {\n+    error = EMPTY;\n+    // Load another batch (if available)\n+    while (error == EMPTY) {\n+      batch_start = next_batch_start();\n+      if (batch_start >= len) { break; }\n+      #ifdef SIMDJSON_THREADS_ENABLED\n+      if(use_thread) {\n+        load_from_stage1_thread();\n+      } else {\n+        error = run_stage1(*parser, batch_start);\n+      }\n+      #else\n+      error = run_stage1(*parser, batch_start);\n+      #endif\n+      /**\n+       * Whenever we move to another window, we need to update all pointers to make\n+       * it appear as if the input buffer started at the beginning of the window.\n+       *\n+       * Take this input:\n+       *\n+       * {\"z\":5}  {\"1\":1,\"2\":2,\"4\":4} [7,  10,   9]  [15,  11,   12, 13]  [154,  110,   112, 1311]\n+       *\n+       * Say you process the following window...\n+       *\n+       * '{\"z\":5}  {\"1\":1,\"2\":2,\"4\":4} [7,  10,   9]'\n+       *\n+       * When you do so, the json_iterator has a pointer at the beginning of the memory region\n+       * (pointing at the beginning of '{\"z\"...'.\n+       *\n+       * When you move to the window that starts at...\n+       *\n+       * '[7,  10,   9]  [15,  11,   12, 13] ...\n+       *\n+       * then it is not sufficient to just run stage 1. You also need to re-anchor the\n+       * json_iterator so that it believes we are starting at '[7,  10,   9]...'.\n+       *\n+       * Under the DOM front-end, this gets done automatically because the parser owns\n+       * the pointer the data, and when you call stage1 and then stage2 on the same\n+       * parser, then stage2 will run on the pointer acquired by stage1.\n+       *\n+       * That is, stage1 calls \"this->buf = _buf\" so the parser remembers the buffer that\n+       * we used. But json_iterator has no callback when stage1 is called on the parser.\n+       * In fact, I think that the parser is unaware of json_iterator.\n+       *\n+       *\n+       * So we need to re-anchor the json_iterator after each call to stage 1 so that\n+       * all of the pointers are in sync.\n+       */\n+      doc.iter = json_iterator(&buf[batch_start], parser);\n+      doc.iter._streaming = true;\n+      /**\n+       * End of resync.\n+       */\n+\n+      if (error) { continue; } // If the error was EMPTY, we may want to load another batch.\n+      doc_index = batch_start;\n+    }\n+  }\n+}\n+\n+inline void document_stream::next_document() noexcept {\n+  // Go to next place where depth=0 (document depth)\n+  error = doc.iter.skip_child(0);\n+  if (error) { return; }\n+  // Always set depth=1 at the start of document\n+  doc.iter._depth = 1;\n+  // Resets the string buffer at the beginning, thus invalidating the strings.\n+  doc.iter._string_buf_loc = parser->string_buf.get();\n+  doc.iter._root = doc.iter.position();\n+}\n+\n+inline size_t document_stream::next_batch_start() const noexcept {\n+  return batch_start + parser->implementation->structural_indexes[parser->implementation->n_structural_indexes];\n+}\n+\n+inline error_code document_stream::run_stage1(ondemand::parser &p, size_t _batch_start) noexcept {\n+  // This code only updates the structural index in the parser, it does not update any json_iterator\n+  // instance.\n+  size_t remaining = len - _batch_start;\n+  if (remaining <= batch_size) {\n+    return p.implementation->stage1(&buf[_batch_start], remaining, stage1_mode::streaming_final);\n+  } else {\n+    return p.implementation->stage1(&buf[_batch_start], batch_size, stage1_mode::streaming_partial);\n+  }\n+}\n+\n+simdjson_really_inline size_t document_stream::iterator::current_index() const noexcept {\n+  return stream->doc_index;\n+}\n+\n+simdjson_really_inline std::string_view document_stream::iterator::source() const noexcept {\n+  auto depth = stream->doc.iter.depth();\n+  auto cur_struct_index = stream->doc.iter._root - stream->parser->implementation->structural_indexes.get();\n+\n+  // If at root, process the first token to determine if scalar value\n+  if (stream->doc.iter.at_root()) {\n+    switch (stream->buf[stream->batch_start + stream->parser->implementation->structural_indexes[cur_struct_index]]) {\n+      case '{': case '[':   // Depth=1 already at start of document\n+        break;\n+      case '}': case ']':\n+        depth--;\n+        break;\n+      default:    // Scalar value document\n+        // TODO: Remove any trailing whitespaces\n+        // This returns a string spanning from start of value to the beginning of the next document (excluded)\n+        return std::string_view(reinterpret_cast<const char*>(stream->buf) + current_index(), stream->parser->implementation->structural_indexes[++cur_struct_index] - current_index() - 1);\n+    }\n+    cur_struct_index++;\n+  }\n+\n+  while (cur_struct_index <= static_cast<int64_t>(stream->parser->implementation->n_structural_indexes)) {\n+    switch (stream->buf[stream->batch_start + stream->parser->implementation->structural_indexes[cur_struct_index]]) {\n+      case '{': case '[':\n+        depth++;\n+        break;\n+      case '}': case ']':\n+        depth--;\n+        break;\n+    }\n+    if (depth == 0) { break; }\n+    cur_struct_index++;\n+  }\n+\n+  return std::string_view(reinterpret_cast<const char*>(stream->buf) + current_index(), stream->parser->implementation->structural_indexes[cur_struct_index] - current_index() + stream->batch_start + 1);;\n+}\n+\n+inline error_code document_stream::iterator::error() const noexcept {\n+  return stream->error;\n+}\n+\n+#ifdef SIMDJSON_THREADS_ENABLED\n+\n+inline void document_stream::load_from_stage1_thread() noexcept {\n+  worker->finish();\n+  // Swap to the parser that was loaded up in the thread. Make sure the parser has\n+  // enough memory to swap to, as well.\n+  std::swap(stage1_thread_parser,*parser);\n+  error = stage1_thread_error;\n+  if (error) { return; }\n+\n+  // If there's anything left, start the stage 1 thread!\n+  if (next_batch_start() < len) {\n+    start_stage1_thread();\n+  }\n+}\n+\n+inline void document_stream::start_stage1_thread() noexcept {\n+  // we call the thread on a lambda that will update\n+  // this->stage1_thread_error\n+  // there is only one thread that may write to this value\n+  // TODO this is NOT exception-safe.\n+  this->stage1_thread_error = UNINITIALIZED; // In case something goes wrong, make sure it's an error\n+  size_t _next_batch_start = this->next_batch_start();\n+\n+  worker->run(this, & this->stage1_thread_parser, _next_batch_start);\n+}\n+\n+#endif // SIMDJSON_THREADS_ENABLED\n+\n+} // namespace ondemand\n+} // namespace SIMDJSON_IMPLEMENTATION\n+} // namespace simdjson\n+\n+namespace simdjson {\n+\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_stream>::simdjson_result(\n+  error_code error\n+) noexcept :\n+    implementation_simdjson_result_base<SIMDJSON_IMPLEMENTATION::ondemand::document_stream>(error)\n+{\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_stream>::simdjson_result(\n+  SIMDJSON_IMPLEMENTATION::ondemand::document_stream &&value\n+) noexcept :\n+    implementation_simdjson_result_base<SIMDJSON_IMPLEMENTATION::ondemand::document_stream>(\n+      std::forward<SIMDJSON_IMPLEMENTATION::ondemand::document_stream>(value)\n+    )\n+{\n+}\n+\n+}\n\\ No newline at end of file"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/document_stream.h",
        "status": "added",
        "additions": 330,
        "deletions": 0,
        "changes": 330,
        "patch": "@@ -0,0 +1,330 @@\n+#include \"simdjson/error.h\"\n+#ifdef SIMDJSON_THREADS_ENABLED\n+#include <thread>\n+#include <mutex>\n+#include <condition_variable>\n+#endif\n+\n+namespace simdjson {\n+namespace SIMDJSON_IMPLEMENTATION {\n+namespace ondemand {\n+\n+class parser;\n+class json_iterator;\n+class document;\n+\n+#ifdef SIMDJSON_THREADS_ENABLED\n+/** @private Custom worker class **/\n+struct stage1_worker {\n+  stage1_worker() noexcept = default;\n+  stage1_worker(const stage1_worker&) = delete;\n+  stage1_worker(stage1_worker&&) = delete;\n+  stage1_worker operator=(const stage1_worker&) = delete;\n+  ~stage1_worker();\n+  /**\n+   * We only start the thread when it is needed, not at object construction, this may throw.\n+   * You should only call this once.\n+   **/\n+  void start_thread();\n+  /**\n+   * Start a stage 1 job. You should first call 'run', then 'finish'.\n+   * You must call start_thread once before.\n+   */\n+  void run(document_stream * ds, parser * stage1, size_t next_batch_start);\n+  /** Wait for the run to finish (blocking). You should first call 'run', then 'finish'. **/\n+  void finish();\n+\n+private:\n+\n+  /**\n+   * Normally, we would never stop the thread. But we do in the destructor.\n+   * This function is only safe assuming that you are not waiting for results. You\n+   * should have called run, then finish, and be done.\n+   **/\n+  void stop_thread();\n+\n+  std::thread thread{};\n+  /** These three variables define the work done by the thread. **/\n+  ondemand::parser * stage1_thread_parser{};\n+  size_t _next_batch_start{};\n+  document_stream * owner{};\n+  /**\n+   * We have two state variables. This could be streamlined to one variable in the future but\n+   * we use two for clarity.\n+   */\n+  bool has_work{false};\n+  bool can_work{true};\n+\n+  /**\n+   * We lock using a mutex.\n+   */\n+  std::mutex locking_mutex{};\n+  std::condition_variable cond_var{};\n+\n+  friend class document_stream;\n+};\n+#endif  // SIMDJSON_THREADS_ENABLED\n+\n+/**\n+ * A forward-only stream of documents.\n+ *\n+ * Produced by parser::iterate_many.\n+ *\n+ */\n+class document_stream {\n+public:\n+  /**\n+   * Construct an uninitialized document_stream.\n+   *\n+   *  ```c++\n+   *  document_stream docs;\n+   *  auto error = parser.iterate_many(json).get(docs);\n+   *  ```\n+   */\n+  simdjson_really_inline document_stream() noexcept;\n+  /** Move one document_stream to another. */\n+  simdjson_really_inline document_stream(document_stream &&other) noexcept = default;\n+  /** Move one document_stream to another. */\n+  simdjson_really_inline document_stream &operator=(document_stream &&other) noexcept = default;\n+\n+  simdjson_really_inline ~document_stream() noexcept;\n+\n+  /**\n+   * Returns the input size in bytes.\n+   */\n+  inline size_t size_in_bytes() const noexcept;\n+\n+  /**\n+   * After iterating through the stream, this method\n+   * returns the number of bytes that were not parsed at the end\n+   * of the stream. If truncated_bytes() differs from zero,\n+   * then the input was truncated maybe because incomplete JSON\n+   * documents were found at the end of the stream. You\n+   * may need to process the bytes in the interval [size_in_bytes()-truncated_bytes(), size_in_bytes()).\n+   *\n+   * You should only call truncated_bytes() after streaming through all\n+   * documents, like so:\n+   *\n+   *   document_stream stream = parser.iterate_many(json,window);\n+   *   for(auto & doc : stream) {\n+   *      // do something with doc\n+   *   }\n+   *   size_t truncated = stream.truncated_bytes();\n+   *\n+   */\n+  inline size_t truncated_bytes() const noexcept;\n+\n+  class iterator {\n+  public:\n+    using value_type = simdjson_result<document>;\n+    using reference  = value_type;\n+\n+    using difference_type   = std::ptrdiff_t;\n+\n+    using iterator_category = std::input_iterator_tag;\n+\n+    /**\n+     * Default constructor.\n+     */\n+    simdjson_really_inline iterator() noexcept;\n+    /**\n+     * Get the current document (or error).\n+     */\n+    simdjson_really_inline simdjson_result<ondemand::document_reference> operator*() noexcept;\n+    /**\n+     * Advance to the next document (prefix).\n+     */\n+    inline iterator& operator++() noexcept;\n+    /**\n+     * Check if we're at the end yet.\n+     * @param other the end iterator to compare to.\n+     */\n+    simdjson_really_inline bool operator!=(const iterator &other) const noexcept;\n+    /**\n+     * @private\n+     *\n+     * Gives the current index in the input document in bytes.\n+     *\n+     *   document_stream stream = parser.parse_many(json,window);\n+     *   for(auto i = stream.begin(); i != stream.end(); ++i) {\n+     *      auto doc = *i;\n+     *      size_t index = i.current_index();\n+     *   }\n+     *\n+     * This function (current_index()) is experimental and the usage\n+     * may change in future versions of simdjson: we find the API somewhat\n+     * awkward and we would like to offer something friendlier.\n+     */\n+     simdjson_really_inline size_t current_index() const noexcept;\n+\n+     /**\n+     * @private\n+     *\n+     * Gives a view of the current document at the current position.\n+     *\n+     *   document_stream stream = parser.iterate_many(json,window);\n+     *   for(auto i = stream.begin(); i != stream.end(); ++i) {\n+     *      std::string_view v = i.source();\n+     *   }\n+     *\n+     * The returned string_view instance is simply a map to the (unparsed)\n+     * source string: it may thus include white-space characters and all manner\n+     * of padding.\n+     *\n+     * This function (source()) is experimental and the usage\n+     * may change in future versions of simdjson: we find the API somewhat\n+     * awkward and we would like to offer something friendlier.\n+     *\n+     */\n+     simdjson_really_inline std::string_view source() const noexcept;\n+\n+    /**\n+     * Returns error of the stream (if any).\n+     */\n+     inline error_code error() const noexcept;\n+\n+  private:\n+    simdjson_really_inline iterator(document_stream *s, bool finished) noexcept;\n+    /** The document_stream we're iterating through. */\n+    document_stream* stream;\n+    /** Whether we're finished or not. */\n+    bool finished;\n+\n+    friend class document;\n+    friend class document_stream;\n+    friend class json_iterator;\n+  };\n+\n+  /**\n+   * Start iterating the documents in the stream.\n+   */\n+  simdjson_really_inline iterator begin() noexcept;\n+  /**\n+   * The end of the stream, for iterator comparison purposes.\n+   */\n+  simdjson_really_inline iterator end() noexcept;\n+\n+private:\n+\n+  document_stream &operator=(const document_stream &) = delete; // Disallow copying\n+  document_stream(const document_stream &other) = delete; // Disallow copying\n+\n+  /**\n+   * Construct a document_stream. Does not allocate or parse anything until the iterator is\n+   * used.\n+   *\n+   * @param parser is a reference to the parser instance used to generate this document_stream\n+   * @param buf is the raw byte buffer we need to process\n+   * @param len is the length of the raw byte buffer in bytes\n+   * @param batch_size is the size of the windows (must be strictly greater or equal to the largest JSON document)\n+   */\n+  simdjson_really_inline document_stream(\n+    ondemand::parser &parser,\n+    const uint8_t *buf,\n+    size_t len,\n+    size_t batch_size\n+  ) noexcept;\n+\n+  /**\n+   * Parse the first document in the buffer. Used by begin(), to handle allocation and\n+   * initialization.\n+   */\n+  inline void start() noexcept;\n+\n+  /**\n+   * Parse the next document found in the buffer previously given to document_stream.\n+   *\n+   * The content should be a valid JSON document encoded as UTF-8. If there is a\n+   * UTF-8 BOM, the caller is responsible for omitting it, UTF-8 BOM are\n+   * discouraged.\n+   *\n+   * You do NOT need to pre-allocate a parser.  This function takes care of\n+   * pre-allocating a capacity defined by the batch_size defined when creating the\n+   * document_stream object.\n+   *\n+   * The function returns simdjson::EMPTY if there is no more data to be parsed.\n+   *\n+   * The function returns simdjson::SUCCESS (as integer = 0) in case of success\n+   * and indicates that the buffer has successfully been parsed to the end.\n+   * Every document it contained has been parsed without error.\n+   *\n+   * The function returns an error code from simdjson/simdjson.h in case of failure\n+   * such as simdjson::CAPACITY, simdjson::MEMALLOC, simdjson::DEPTH_ERROR and so forth;\n+   * the simdjson::error_message function converts these error codes into a string).\n+   *\n+   * You can also check validity by calling parser.is_valid(). The same parser can\n+   * and should be reused for the other documents in the buffer.\n+   */\n+  inline void next() noexcept;\n+\n+  /** Move the json_iterator of the document to the location of the next document in the stream. */\n+  inline void next_document() noexcept;\n+\n+  /** Get the next document index. */\n+  inline size_t next_batch_start() const noexcept;\n+\n+  /** Pass the next batch through stage 1 with the given parser. */\n+  inline error_code run_stage1(ondemand::parser &p, size_t batch_start) noexcept;\n+\n+  // Fields\n+  ondemand::parser *parser;\n+  const uint8_t *buf;\n+  size_t len;\n+  size_t batch_size;\n+  /**\n+   * We are going to use just one document instance. The document owns\n+   * the json_iterator. It implies that we only ever pass a reference\n+   * to the document to the users.\n+   */\n+  document doc{};\n+  /** The error (or lack thereof) from the current document. */\n+  error_code error;\n+  size_t batch_start{0};\n+  size_t doc_index{};\n+\n+  #ifdef SIMDJSON_THREADS_ENABLED\n+  /** Indicates whether we use threads. Note that this needs to be a constant during the execution of the parsing. */\n+  bool use_thread;\n+\n+  inline void load_from_stage1_thread() noexcept;\n+\n+  /** Start a thread to run stage 1 on the next batch. */\n+  inline void start_stage1_thread() noexcept;\n+\n+  /** Wait for the stage 1 thread to finish and capture the results. */\n+  inline void finish_stage1_thread() noexcept;\n+\n+  /** The error returned from the stage 1 thread. */\n+  error_code stage1_thread_error{UNINITIALIZED};\n+  /** The thread used to run stage 1 against the next batch in the background. */\n+  std::unique_ptr<stage1_worker> worker{new(std::nothrow) stage1_worker()};\n+  /**\n+   * The parser used to run stage 1 in the background. Will be swapped\n+   * with the regular parser when finished.\n+   */\n+  ondemand::parser stage1_thread_parser{};\n+\n+  friend struct stage1_worker;\n+  #endif // SIMDJSON_THREADS_ENABLED\n+\n+  friend class parser;\n+  friend class document;\n+  friend class json_iterator;\n+  friend struct simdjson_result<ondemand::document_stream>;\n+  friend struct internal::simdjson_result_base<ondemand::document_stream>;\n+};  // document_stream\n+\n+} // namespace ondemand\n+} // namespace SIMDJSON_IMPLEMENTATION\n+} // namespace simdjson\n+\n+namespace simdjson {\n+template<>\n+struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_stream> : public SIMDJSON_IMPLEMENTATION::implementation_simdjson_result_base<SIMDJSON_IMPLEMENTATION::ondemand::document_stream> {\n+public:\n+  simdjson_really_inline simdjson_result(SIMDJSON_IMPLEMENTATION::ondemand::document_stream &&value) noexcept; ///< @private\n+  simdjson_really_inline simdjson_result(error_code error) noexcept; ///< @private\n+  simdjson_really_inline simdjson_result() noexcept = default;\n+};\n+\n+} // namespace simdjson\n\\ No newline at end of file"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/field-inl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -22,7 +22,7 @@ simdjson_really_inline simdjson_result<field> field::start(const value_iterator\n }\n \n simdjson_really_inline simdjson_warn_unused simdjson_result<std::string_view> field::unescaped_key() noexcept {\n-  SIMDJSON_ASSUME(first.buf != nullptr); // We would like to call .alive() by Visual Studio won't let us.\n+  SIMDJSON_ASSUME(first.buf != nullptr); // We would like to call .alive() but Visual Studio won't let us.\n   simdjson_result<std::string_view> answer = first.unescape(second.iter.string_buf_loc());\n   first.consume();\n   return answer;"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/json_iterator-inl.h",
        "status": "modified",
        "additions": 138,
        "deletions": 34,
        "changes": 172,
        "patch": "@@ -7,7 +7,9 @@ simdjson_really_inline json_iterator::json_iterator(json_iterator &&other) noexc\n     parser{other.parser},\n     _string_buf_loc{other._string_buf_loc},\n     error{other.error},\n-    _depth{other._depth}\n+    _depth{other._depth},\n+    _root{other._root},\n+    _streaming{other._streaming}\n {\n   other.parser = nullptr;\n }\n@@ -17,17 +19,32 @@ simdjson_really_inline json_iterator &json_iterator::operator=(json_iterator &&o\n   _string_buf_loc = other._string_buf_loc;\n   error = other.error;\n   _depth = other._depth;\n+  _root = other._root;\n+  _streaming = other._streaming;\n   other.parser = nullptr;\n   return *this;\n }\n \n simdjson_really_inline json_iterator::json_iterator(const uint8_t *buf, ondemand::parser *_parser) noexcept\n-  : token(buf, _parser->implementation->structural_indexes.get()),\n+  : token(buf, &_parser->implementation->structural_indexes[0]),\n     parser{_parser},\n     _string_buf_loc{parser->string_buf.get()},\n-    _depth{1}\n+    _depth{1},\n+    _root{parser->implementation->structural_indexes.get()},\n+    _streaming{false}\n+\n {\n   logger::log_headers();\n+#if SIMDJSON_CHECK_EOF\n+  assert_more_tokens();\n+#endif\n+}\n+\n+inline void json_iterator::rewind() noexcept {\n+  token.set_position( root_position() );\n+  logger::log_headers(); // We start again\n+  _string_buf_loc = parser->string_buf.get();\n+  _depth = 1;\n }\n \n // GCC 7 warns when the first line of this function is inlined away into oblivion due to the caller\n@@ -36,9 +53,19 @@ simdjson_really_inline json_iterator::json_iterator(const uint8_t *buf, ondemand\n SIMDJSON_PUSH_DISABLE_WARNINGS\n SIMDJSON_DISABLE_STRICT_OVERFLOW_WARNING\n simdjson_warn_unused simdjson_really_inline error_code json_iterator::skip_child(depth_t parent_depth) noexcept {\n+  /***\n+   * WARNING:\n+   * Inside an object, a string value is a depth of +1 compared to the object. Yet a key\n+   * is at the same depth as the object.\n+   * But json_iterator cannot easily tell whether we are pointing at a key or a string value.\n+   * Instead, it assumes that if you are pointing at a string, then it is a value, not a key.\n+   * To be clear...\n+   * the following code assumes that we are *not* pointing at a key. If we are then a bug\n+   * will follow. Unfortunately, it is not possible for the json_iterator its to make this\n+   * check.\n+   */\n   if (depth() <= parent_depth) { return SUCCESS; }\n-\n-  switch (*advance()) {\n+  switch (*return_current_and_advance()) {\n     // TODO consider whether matching braces is a requirement: if non-matching braces indicates\n     // *missing* braces, then future lookups are not in the object/arrays they think they are,\n     // violating the rule \"validate enough structure that the user can be confident they are\n@@ -59,7 +86,24 @@ simdjson_warn_unused simdjson_really_inline error_code json_iterator::skip_child\n       logger::log_end_value(*this, \"skip\");\n       _depth--;\n       if (depth() <= parent_depth) { return SUCCESS; }\n+#if SIMDJSON_CHECK_EOF\n+      // If there are no more tokens, the parent is incomplete.\n+      if (at_end()) { return report_error(INCOMPLETE_ARRAY_OR_OBJECT, \"Missing [ or { at start\"); }\n+#endif // SIMDJSON_CHECK_EOF\n       break;\n+    /*case '\"':\n+      if(*peek() == ':') {\n+        // we are at a key!!! This is\n+        // only possible if someone searched\n+        // for a key in an object and the key\n+        // was not found but our code then\n+        // decided the consume the separating\n+        // comma before returning.\n+        logger::log_value(*this, \"key\");\n+        advance(); // eat up the ':'\n+        break; // important!!!\n+      }\n+      simdjson_fallthrough;*/\n     // Anything else must be a scalar value\n     default:\n       // For the first scalar, we will have incremented depth already, so we decrement it here.\n@@ -70,9 +114,8 @@ simdjson_warn_unused simdjson_really_inline error_code json_iterator::skip_child\n   }\n \n   // Now that we've considered the first value, we only increment/decrement for arrays/objects\n-  auto end = &parser->implementation->structural_indexes[parser->implementation->n_structural_indexes];\n-  while (token.index <= end) {\n-    switch (*advance()) {\n+  while (position() < end_position()) {\n+    switch (*return_current_and_advance()) {\n       case '[': case '{':\n         logger::log_start_value(*this, \"skip\");\n         _depth++;\n@@ -99,23 +142,71 @@ simdjson_warn_unused simdjson_really_inline error_code json_iterator::skip_child\n SIMDJSON_POP_DISABLE_WARNINGS\n \n simdjson_really_inline bool json_iterator::at_root() const noexcept {\n-  return token.position() == root_checkpoint();\n+  return position() == root_position();\n+}\n+\n+simdjson_really_inline bool json_iterator::streaming() const noexcept {\n+  return _streaming;\n+}\n+\n+simdjson_really_inline token_position json_iterator::root_position() const noexcept {\n+  return _root;\n }\n \n-simdjson_really_inline token_position json_iterator::root_checkpoint() const noexcept {\n-  return parser->implementation->structural_indexes.get();\n+simdjson_really_inline void json_iterator::assert_at_document_depth() const noexcept {\n+  SIMDJSON_ASSUME( _depth == 1 );\n }\n \n simdjson_really_inline void json_iterator::assert_at_root() const noexcept {\n   SIMDJSON_ASSUME( _depth == 1 );\n-  // Visual Studio Clang treats unique_ptr.get() as \"side effecting.\"\n #ifndef SIMDJSON_CLANG_VISUAL_STUDIO\n-  SIMDJSON_ASSUME( token.index == parser->implementation->structural_indexes.get() );\n+  // Under Visual Studio, the next SIMDJSON_ASSUME fails with: the argument\n+  // has side effects that will be discarded.\n+  SIMDJSON_ASSUME( token.position() == _root );\n #endif\n }\n \n-simdjson_really_inline bool json_iterator::at_eof() const noexcept {\n-  return token.index == &parser->implementation->structural_indexes[parser->implementation->n_structural_indexes];\n+simdjson_really_inline void json_iterator::assert_more_tokens(uint32_t required_tokens) const noexcept {\n+  assert_valid_position(token._position + required_tokens - 1);\n+}\n+\n+simdjson_really_inline void json_iterator::assert_valid_position(token_position position) const noexcept {\n+#ifndef SIMDJSON_CLANG_VISUAL_STUDIO\n+  SIMDJSON_ASSUME( position >= &parser->implementation->structural_indexes[0] );\n+  SIMDJSON_ASSUME( position < &parser->implementation->structural_indexes[parser->implementation->n_structural_indexes] );\n+#endif\n+}\n+\n+simdjson_really_inline bool json_iterator::at_end() const noexcept {\n+  return position() == end_position();\n+}\n+simdjson_really_inline token_position json_iterator::end_position() const noexcept {\n+  uint32_t n_structural_indexes{parser->implementation->n_structural_indexes};\n+  return &parser->implementation->structural_indexes[n_structural_indexes];\n+}\n+\n+inline std::string json_iterator::to_string() const noexcept {\n+  if( !is_alive() ) { return \"dead json_iterator instance\"; }\n+  const char * current_structural = reinterpret_cast<const char *>(token.peek());\n+  return std::string(\"json_iterator [ depth : \") + std::to_string(_depth)\n+          + std::string(\", structural : '\") + std::string(current_structural,1)\n+          + std::string(\"', offset : \") + std::to_string(token.current_offset())\n+          + std::string(\"', error : \") + error_message(error)\n+          + std::string(\" ]\");\n+}\n+\n+inline simdjson_result<const char *> json_iterator::current_location() noexcept {\n+  if (!is_alive()) {    // Unrecoverable error\n+    if (!at_root()) {\n+      return reinterpret_cast<const char *>(token.peek(-1));\n+    } else {\n+      return reinterpret_cast<const char *>(token.peek());\n+    }\n+  }\n+  if (at_end()) {\n+    return OUT_OF_BOUNDS;\n+  }\n+  return reinterpret_cast<const char *>(token.peek());\n }\n \n simdjson_really_inline bool json_iterator::is_alive() const noexcept {\n@@ -127,27 +218,49 @@ simdjson_really_inline void json_iterator::abandon() noexcept {\n   _depth = 0;\n }\n \n-simdjson_really_inline const uint8_t *json_iterator::advance() noexcept {\n-  return token.advance();\n+simdjson_really_inline const uint8_t *json_iterator::return_current_and_advance() noexcept {\n+#if SIMDJSON_CHECK_EOF\n+  assert_more_tokens();\n+#endif // SIMDJSON_CHECK_EOF\n+  return token.return_current_and_advance();\n+}\n+\n+simdjson_really_inline const uint8_t *json_iterator::unsafe_pointer() const noexcept {\n+  // deliberately done without safety guard:\n+  return token.peek(0);\n }\n \n simdjson_really_inline const uint8_t *json_iterator::peek(int32_t delta) const noexcept {\n+#if SIMDJSON_CHECK_EOF\n+  assert_more_tokens(delta+1);\n+#endif // SIMDJSON_CHECK_EOF\n   return token.peek(delta);\n }\n \n simdjson_really_inline uint32_t json_iterator::peek_length(int32_t delta) const noexcept {\n+#if SIMDJSON_CHECK_EOF\n+  assert_more_tokens(delta+1);\n+#endif // #if SIMDJSON_CHECK_EOF\n   return token.peek_length(delta);\n }\n \n simdjson_really_inline const uint8_t *json_iterator::peek(token_position position) const noexcept {\n+  // todo: currently we require end-of-string buffering, but the following\n+  // assert_valid_position should be turned on if/when we lift that condition.\n+  // assert_valid_position(position);\n+  // This is almost surely related to SIMDJSON_CHECK_EOF but given that SIMDJSON_CHECK_EOF\n+  // is ON by default, we have no choice but to disable it for real with a comment.\n   return token.peek(position);\n }\n \n simdjson_really_inline uint32_t json_iterator::peek_length(token_position position) const noexcept {\n+#if SIMDJSON_CHECK_EOF\n+  assert_valid_position(position);\n+#endif // SIMDJSON_CHECK_EOF\n   return token.peek_length(position);\n }\n \n-simdjson_really_inline token_position json_iterator::last_document_position() const noexcept {\n+simdjson_really_inline token_position json_iterator::last_position() const noexcept {\n   // The following line fails under some compilers...\n   // SIMDJSON_ASSUME(parser->implementation->n_structural_indexes > 0);\n   // since it has side-effects.\n@@ -156,7 +269,7 @@ simdjson_really_inline token_position json_iterator::last_document_position() co\n   return &parser->implementation->structural_indexes[n_structural_indexes - 1];\n }\n simdjson_really_inline const uint8_t *json_iterator::peek_last() const noexcept {\n-  return token.peek(last_document_position());\n+  return token.peek(last_position());\n }\n \n simdjson_really_inline void json_iterator::ascend_to(depth_t parent_depth) noexcept {\n@@ -189,6 +302,7 @@ simdjson_really_inline error_code json_iterator::report_error(error_code _error,\n simdjson_really_inline token_position json_iterator::position() const noexcept {\n   return token.position();\n }\n+\n simdjson_really_inline void json_iterator::reenter_child(token_position position, depth_t child_depth) noexcept {\n   SIMDJSON_ASSUME(child_depth >= 1 && child_depth < INT32_MAX);\n   SIMDJSON_ASSUME(_depth == child_depth - 1);\n@@ -202,9 +316,11 @@ simdjson_really_inline void json_iterator::reenter_child(token_position position\n }\n \n #ifdef SIMDJSON_DEVELOPMENT_CHECKS\n+\n simdjson_really_inline token_position json_iterator::start_position(depth_t depth) const noexcept {\n   return parser->start_positions[depth];\n }\n+\n simdjson_really_inline void json_iterator::set_start_position(depth_t depth, token_position position) noexcept {\n   parser->start_positions[depth] = position;\n }\n@@ -220,9 +336,11 @@ simdjson_really_inline error_code json_iterator::optional_error(error_code _erro\n \n template<int N>\n simdjson_warn_unused simdjson_really_inline bool json_iterator::copy_to_buffer(const uint8_t *json, uint32_t max_len, uint8_t (&tmpbuf)[N]) noexcept {\n+  // Let us guard against silly cases:\n+  if((N < max_len) || (N == 0)) { return false; }\n   // Truncate whitespace to fit the buffer.\n   if (max_len > N-1) {\n-    if (jsoncharutils::is_not_structural_or_whitespace(json[N-1])) { return false; }\n+    // if (jsoncharutils::is_not_structural_or_whitespace(json[N-1])) { return false; }\n     max_len = N-1;\n   }\n \n@@ -232,20 +350,6 @@ simdjson_warn_unused simdjson_really_inline bool json_iterator::copy_to_buffer(c\n   return true;\n }\n \n-template<int N>\n-simdjson_warn_unused simdjson_really_inline bool json_iterator::peek_to_buffer(uint8_t (&tmpbuf)[N]) noexcept {\n-  auto max_len = token.peek_length();\n-  auto json = token.peek();\n-  return copy_to_buffer(json, max_len, tmpbuf);\n-}\n-\n-template<int N>\n-simdjson_warn_unused simdjson_really_inline bool json_iterator::advance_to_buffer(uint8_t (&tmpbuf)[N]) noexcept {\n-  auto max_len = peek_length();\n-  auto json = advance();\n-  return copy_to_buffer(json, max_len, tmpbuf);\n-}\n-\n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/json_iterator.h",
        "status": "modified",
        "additions": 79,
        "deletions": 17,
        "changes": 96,
        "patch": "@@ -3,6 +3,7 @@ namespace SIMDJSON_IMPLEMENTATION {\n namespace ondemand {\n \n class document;\n+class document_stream;\n class object;\n class array;\n class value;\n@@ -44,14 +45,27 @@ class json_iterator {\n    * - 3 = key or value inside root array/object.\n    */\n   depth_t _depth{};\n+  /**\n+   * Beginning of the document indexes.\n+   * Normally we have root == parser->implementation->structural_indexes.get()\n+   * but this may differ, especially in streaming mode (where we have several\n+   * documents);\n+   */\n+  token_position _root{};\n+  /**\n+   * Normally, a json_iterator operates over a single document, but in\n+   * some cases, we may have a stream of documents. This attribute is meant\n+   * as meta-data: the json_iterator works the same irrespective of the\n+   * value of this attribute.\n+   */\n+  bool _streaming{false};\n \n public:\n   simdjson_really_inline json_iterator() noexcept = default;\n   simdjson_really_inline json_iterator(json_iterator &&other) noexcept;\n   simdjson_really_inline json_iterator &operator=(json_iterator &&other) noexcept;\n-  simdjson_really_inline json_iterator(const json_iterator &other) noexcept = delete;\n-  simdjson_really_inline json_iterator &operator=(const json_iterator &other) noexcept = delete;\n-\n+  simdjson_really_inline explicit json_iterator(const json_iterator &other) noexcept = default;\n+  simdjson_really_inline json_iterator &operator=(const json_iterator &other) noexcept = default;\n   /**\n    * Skips a JSON value, whether it is a scalar, array or object.\n    */\n@@ -63,19 +77,30 @@ class json_iterator {\n   simdjson_really_inline bool at_root() const noexcept;\n \n   /**\n-   * Get the root value iterator\n+   * Tell whether we should be expected to run in streaming\n+   * mode (iterating over many documents). It is pure metadata\n+   * that does not affect how the iterator works. It is used by\n+   * start_root_array() and start_root_object().\n    */\n-  simdjson_really_inline token_position root_checkpoint() const noexcept;\n+  simdjson_really_inline bool streaming() const noexcept;\n \n   /**\n-   * Assert if the iterator is not at the start\n+   * Get the root value iterator\n+   */\n+  simdjson_really_inline token_position root_position() const noexcept;\n+  /**\n+   * Assert that we are at the document depth (== 1)\n+   */\n+  simdjson_really_inline void assert_at_document_depth() const noexcept;\n+  /**\n+   * Assert that we are at the root of the document\n    */\n   simdjson_really_inline void assert_at_root() const noexcept;\n \n   /**\n    * Tell whether the iterator is at the EOF mark\n    */\n-  simdjson_really_inline bool at_eof() const noexcept;\n+  simdjson_really_inline bool at_end() const noexcept;\n \n   /**\n    * Tell whether the iterator is live (has not been moved).\n@@ -88,10 +113,22 @@ class json_iterator {\n   simdjson_really_inline void abandon() noexcept;\n \n   /**\n-   * Advance the current token.\n+   * Advance the current token without modifying depth.\n    */\n-  simdjson_really_inline const uint8_t *advance() noexcept;\n+  simdjson_really_inline const uint8_t *return_current_and_advance() noexcept;\n \n+  /**\n+   * Assert that there are at least the given number of tokens left.\n+   *\n+   * Has no effect in release builds.\n+   */\n+  simdjson_really_inline void assert_more_tokens(uint32_t required_tokens=1) const noexcept;\n+  /**\n+   * Assert that the given position addresses an actual token (is within bounds).\n+   *\n+   * Has no effect in release builds.\n+   */\n+  simdjson_really_inline void assert_valid_position(token_position position) const noexcept;\n   /**\n    * Get the JSON text for a given token (relative).\n    *\n@@ -111,12 +148,21 @@ class json_iterator {\n    * @param delta The relative position of the token to retrieve. e.g. 0 = next token, -1 = prev token.\n    */\n   simdjson_really_inline uint32_t peek_length(int32_t delta=0) const noexcept;\n+  /**\n+   * Get a pointer to the current location in the input buffer.\n+   *\n+   * This is not null-terminated; it is a view into the JSON.\n+   *\n+   * You may be pointing outside of the input buffer: it is not generally\n+   * safe to derefence this pointer.\n+   */\n+  simdjson_really_inline const uint8_t *unsafe_pointer() const noexcept;\n   /**\n    * Get the JSON text for a given token.\n    *\n    * This is not null-terminated; it is a view into the JSON.\n    *\n-   * @param index The position of the token to retrieve.\n+   * @param position The position of the token to retrieve.\n    *\n    * TODO consider a string_view, assuming the length will get stripped out by the optimizer when\n    * it isn't used ...\n@@ -127,7 +173,7 @@ class json_iterator {\n    *\n    * The length will include any whitespace at the end of the token.\n    *\n-   * @param index The position of the token to retrieve.\n+   * @param position The position of the token to retrieve.\n    */\n   simdjson_really_inline uint32_t peek_length(token_position position) const noexcept;\n   /**\n@@ -156,8 +202,8 @@ class json_iterator {\n    *\n    * @param child_depth the expected child depth.\n    */\n-  simdjson_really_inline void descend_to(depth_t parent_depth) noexcept;\n-  simdjson_really_inline void descend_to(depth_t parent_depth, int32_t delta) noexcept;\n+  simdjson_really_inline void descend_to(depth_t child_depth) noexcept;\n+  simdjson_really_inline void descend_to(depth_t child_depth, int32_t delta) noexcept;\n \n   /**\n    * Get current depth.\n@@ -170,7 +216,7 @@ class json_iterator {\n   simdjson_really_inline uint8_t *&string_buf_loc() noexcept;\n \n   /**\n-   * Report an error, preventing further iteration.\n+   * Report an unrecoverable error, preventing further iteration.\n    *\n    * @param error The error to report. Must not be SUCCESS, UNINITIALIZED, INCORRECT_TYPE, or NO_SUCH_FIELD.\n    * @param message An error message to report with the error.\n@@ -185,21 +231,37 @@ class json_iterator {\n   simdjson_really_inline error_code optional_error(error_code error, const char *message) noexcept;\n \n   template<int N> simdjson_warn_unused simdjson_really_inline bool copy_to_buffer(const uint8_t *json, uint32_t max_len, uint8_t (&tmpbuf)[N]) noexcept;\n-  template<int N> simdjson_warn_unused simdjson_really_inline bool peek_to_buffer(uint8_t (&tmpbuf)[N]) noexcept;\n-  template<int N> simdjson_warn_unused simdjson_really_inline bool advance_to_buffer(uint8_t (&tmpbuf)[N]) noexcept;\n \n   simdjson_really_inline token_position position() const noexcept;\n   simdjson_really_inline void reenter_child(token_position position, depth_t child_depth) noexcept;\n #ifdef SIMDJSON_DEVELOPMENT_CHECKS\n   simdjson_really_inline token_position start_position(depth_t depth) const noexcept;\n   simdjson_really_inline void set_start_position(depth_t depth, token_position position) noexcept;\n #endif\n+  /* Useful for debugging and logging purposes. */\n+  inline std::string to_string() const noexcept;\n+\n+  /**\n+   * Returns the current location in the document if in bounds.\n+   */\n+  inline simdjson_result<const char *> current_location() noexcept;\n \n+  /**\n+   * Updates this json iterator so that it is back at the beginning of the document,\n+   * as if it had just been created.\n+   */\n+  inline void rewind() noexcept;\n protected:\n   simdjson_really_inline json_iterator(const uint8_t *buf, ondemand::parser *parser) noexcept;\n-  simdjson_really_inline token_position last_document_position() const noexcept;\n+  /// The last token before the end\n+  simdjson_really_inline token_position last_position() const noexcept;\n+  /// The token *at* the end. This points at gibberish and should only be used for comparison.\n+  simdjson_really_inline token_position end_position() const noexcept;\n+  /// The end of the buffer.\n+  simdjson_really_inline token_position end() const noexcept;\n \n   friend class document;\n+  friend class document_stream;\n   friend class object;\n   friend class array;\n   friend class value;"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/json_type-inl.h",
        "status": "modified",
        "additions": 81,
        "deletions": 0,
        "changes": 81,
        "patch": "@@ -15,12 +15,93 @@ inline std::ostream& operator<<(std::ostream& out, json_type type) noexcept {\n     return out;\n }\n \n+inline std::ostream& operator<<(std::ostream& out, number_type type) noexcept {\n+    switch (type) {\n+        case number_type::signed_integer: out << \"integer in [-9223372036854775808,9223372036854775808)\"; break;\n+        case number_type::unsigned_integer: out << \"unsigned integer in [9223372036854775808,18446744073709551616)\"; break;\n+        case number_type::floating_point_number: out << \"floating-point number (binary64)\"; break;\n+        default: SIMDJSON_UNREACHABLE();\n+    }\n+    return out;\n+}\n #if SIMDJSON_EXCEPTIONS\n inline std::ostream& operator<<(std::ostream& out, simdjson_result<json_type> &type) noexcept(false) {\n     return out << type.value();\n }\n #endif\n \n+\n+\n+simdjson_really_inline number_type number::get_number_type() const noexcept {\n+  return type;\n+}\n+\n+simdjson_really_inline bool number::is_uint64() const noexcept {\n+  return get_number_type() == number_type::unsigned_integer;\n+}\n+\n+simdjson_really_inline uint64_t number::get_uint64() const noexcept {\n+  return payload.unsigned_integer;\n+}\n+\n+simdjson_really_inline number::operator uint64_t() const noexcept {\n+  return get_uint64();\n+}\n+\n+\n+simdjson_really_inline bool number::is_int64() const noexcept {\n+  return get_number_type() == number_type::signed_integer;\n+}\n+\n+simdjson_really_inline int64_t number::get_int64() const noexcept {\n+  return payload.signed_integer;\n+}\n+\n+simdjson_really_inline number::operator int64_t() const noexcept {\n+  return get_int64();\n+}\n+\n+simdjson_really_inline bool number::is_double() const noexcept {\n+    return get_number_type() == number_type::floating_point_number;\n+}\n+\n+simdjson_really_inline double number::get_double() const noexcept {\n+  return payload.floating_point_number;\n+}\n+\n+simdjson_really_inline number::operator double() const noexcept {\n+  return get_double();\n+}\n+\n+simdjson_really_inline double number::as_double() const noexcept {\n+  if(is_double()) {\n+    return payload.floating_point_number;\n+  }\n+  if(is_int64()) {\n+    return double(payload.signed_integer);\n+  }\n+  return double(payload.unsigned_integer);\n+}\n+\n+simdjson_really_inline void number::append_s64(int64_t value) noexcept {\n+  payload.signed_integer = value;\n+  type = number_type::signed_integer;\n+}\n+\n+simdjson_really_inline void number::append_u64(uint64_t value) noexcept {\n+  payload.unsigned_integer = value;\n+  type = number_type::unsigned_integer;\n+}\n+\n+simdjson_really_inline void number::append_double(double value) noexcept {\n+  payload.floating_point_number = value;\n+  type = number_type::floating_point_number;\n+}\n+\n+simdjson_really_inline void number::skip_double() noexcept {\n+  type = number_type::floating_point_number;\n+}\n+\n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/json_type.h",
        "status": "modified",
        "additions": 101,
        "deletions": 1,
        "changes": 102,
        "patch": "@@ -1,7 +1,6 @@\n namespace simdjson {\n namespace SIMDJSON_IMPLEMENTATION {\n namespace ondemand {\n-\n /**\n  * The type of a JSON value.\n  */\n@@ -15,13 +14,114 @@ enum class json_type {\n     null     ///< A JSON null    (null)\n };\n \n+class value_iterator;\n+\n+/**\n+ * A type representing a JSON number.\n+ * The design of the struct is deliberately straight-forward. All\n+ * functions return standard values with no error check.\n+ */\n+struct number {\n+\n+  /**\n+   * return the automatically determined type of\n+   * the number: number_type::floating_point_number,\n+   * number_type::signed_integer or number_type::unsigned_integer.\n+   *\n+   *    enum class number_type {\n+   *        floating_point_number=1, /// a binary64 number\n+   *        signed_integer,          /// a signed integer that fits in a 64-bit word using two's complement\n+   *        unsigned_integer         /// a positive integer larger or equal to 1<<63\n+   *    };\n+   */\n+  simdjson_really_inline number_type get_number_type() const noexcept;\n+  /**\n+   * return true if the automatically determined type of\n+   * the number is number_type::unsigned_integer.\n+   */\n+  simdjson_really_inline bool is_uint64() const noexcept;\n+  /**\n+   * return the value as a uint64_t, only valid if is_uint64() is true.\n+   */\n+  simdjson_really_inline uint64_t get_uint64() const noexcept;\n+  simdjson_really_inline operator uint64_t() const noexcept;\n+\n+  /**\n+   * return true if the automatically determined type of\n+   * the number is number_type::signed_integer.\n+   */\n+  simdjson_really_inline bool is_int64() const noexcept;\n+  /**\n+   * return the value as a int64_t, only valid if is_int64() is true.\n+   */\n+  simdjson_really_inline int64_t get_int64() const noexcept;\n+  simdjson_really_inline operator int64_t() const noexcept;\n+\n+\n+  /**\n+   * return true if the automatically determined type of\n+   * the number is number_type::floating_point_number.\n+   */\n+  simdjson_really_inline bool is_double() const noexcept;\n+  /**\n+   * return the value as a double, only valid if is_double() is true.\n+   */\n+  simdjson_really_inline double get_double() const noexcept;\n+  simdjson_really_inline operator double() const noexcept;\n+\n+  /**\n+   * Convert the number to a double. Though it always succeed, the conversion\n+   * may be lossy if the number cannot be represented exactly.\n+   */\n+  simdjson_really_inline double as_double() const noexcept;\n+\n+\n+protected:\n+  /**\n+   * The next block of declaration is designed so that we can call the number parsing\n+   * functions on a number type. They are protected and should never be used outside\n+   * of the core simdjson library.\n+   */\n+  friend class value_iterator;\n+  template<typename W>\n+  friend error_code numberparsing::write_float(const uint8_t *const src, bool negative, uint64_t i, const uint8_t * start_digits, size_t digit_count, int64_t exponent, W &writer);\n+  template<typename W>\n+  friend error_code numberparsing::parse_number(const uint8_t *const src, W &writer);\n+  template<typename W>\n+  friend error_code numberparsing::slow_float_parsing(simdjson_unused const uint8_t * src, W writer);\n+  /** Store a signed 64-bit value to the number. */\n+  simdjson_really_inline void append_s64(int64_t value) noexcept;\n+  /** Store an unsigned 64-bit value to the number. */\n+  simdjson_really_inline void append_u64(uint64_t value) noexcept;\n+  /** Store a double value to the number. */\n+  simdjson_really_inline void append_double(double value) noexcept;\n+  /** Specifies that the value is a double, but leave it undefined. */\n+  simdjson_really_inline void skip_double() noexcept;\n+  /**\n+   * End of friend declarations.\n+   */\n+\n+  /**\n+   * Our attributes are a union type (size = 64 bits)\n+   * followed by a type indicator.\n+   */\n+  union {\n+    double floating_point_number;\n+    int64_t signed_integer;\n+    uint64_t unsigned_integer;\n+  } payload{0};\n+  number_type type{number_type::signed_integer};\n+  friend class value_iterator;\n+};\n+\n /**\n  * Write the JSON type to the output stream\n  *\n  * @param out The output stream.\n  * @param type The json_type.\n  */\n inline std::ostream& operator<<(std::ostream& out, json_type type) noexcept;\n+inline std::ostream& operator<<(std::ostream& out, number_type type) noexcept;\n \n #if SIMDJSON_EXCEPTIONS\n /**"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/logger-inl.h",
        "status": "modified",
        "additions": 46,
        "deletions": 18,
        "changes": 64,
        "patch": "@@ -10,70 +10,98 @@ static constexpr const int LOG_SMALL_BUFFER_LEN = 10;\n static int log_depth = 0; // Not threadsafe. Log only.\n \n // Helper to turn unprintable or newline characters into spaces\n-static simdjson_really_inline char printable_char(char c) {\n+static inline char printable_char(char c) {\n   if (c >= 0x20) {\n     return c;\n   } else {\n     return ' ';\n   }\n }\n \n-simdjson_really_inline void log_event(const json_iterator &iter, const char *type, std::string_view detail, int delta, int depth_delta) noexcept {\n+inline void log_event(const json_iterator &iter, const char *type, std::string_view detail, int delta, int depth_delta) noexcept {\n   log_line(iter, \"\", type, detail, delta, depth_delta);\n }\n \n-simdjson_really_inline void log_value(const json_iterator &iter, token_position index, depth_t depth, const char *type, std::string_view detail) noexcept {\n+inline void log_value(const json_iterator &iter, token_position index, depth_t depth, const char *type, std::string_view detail) noexcept {\n   log_line(iter, index, depth, \"\", type, detail);\n }\n-simdjson_really_inline void log_value(const json_iterator &iter, const char *type, std::string_view detail, int delta, int depth_delta) noexcept {\n+inline void log_value(const json_iterator &iter, const char *type, std::string_view detail, int delta, int depth_delta) noexcept {\n   log_line(iter, \"\", type, detail, delta, depth_delta);\n }\n \n-simdjson_really_inline void log_start_value(const json_iterator &iter, token_position index, depth_t depth, const char *type, std::string_view detail) noexcept {\n+inline void log_start_value(const json_iterator &iter, token_position index, depth_t depth, const char *type, std::string_view detail) noexcept {\n   log_line(iter, index, depth, \"+\", type, detail);\n   if (LOG_ENABLED) { log_depth++; }\n }\n-simdjson_really_inline void log_start_value(const json_iterator &iter, const char *type, int delta, int depth_delta) noexcept {\n+inline void log_start_value(const json_iterator &iter, const char *type, int delta, int depth_delta) noexcept {\n   log_line(iter, \"+\", type, \"\", delta, depth_delta);\n   if (LOG_ENABLED) { log_depth++; }\n }\n \n-simdjson_really_inline void log_end_value(const json_iterator &iter, const char *type, int delta, int depth_delta) noexcept {\n+inline void log_end_value(const json_iterator &iter, const char *type, int delta, int depth_delta) noexcept {\n   if (LOG_ENABLED) { log_depth--; }\n   log_line(iter, \"-\", type, \"\", delta, depth_delta);\n }\n \n-simdjson_really_inline void log_error(const json_iterator &iter, const char *error, const char *detail, int delta, int depth_delta) noexcept {\n+inline void log_error(const json_iterator &iter, const char *error, const char *detail, int delta, int depth_delta) noexcept {\n   log_line(iter, \"ERROR: \", error, detail, delta, depth_delta);\n }\n-simdjson_really_inline void log_error(const json_iterator &iter, token_position index, depth_t depth, const char *error, const char *detail) noexcept {\n+inline void log_error(const json_iterator &iter, token_position index, depth_t depth, const char *error, const char *detail) noexcept {\n   log_line(iter, index, depth, \"ERROR: \", error, detail);\n }\n \n-simdjson_really_inline void log_event(const value_iterator &iter, const char *type, std::string_view detail, int delta, int depth_delta) noexcept {\n+inline void log_event(const value_iterator &iter, const char *type, std::string_view detail, int delta, int depth_delta) noexcept {\n   log_event(iter.json_iter(), type, detail, delta, depth_delta);\n }\n \n-simdjson_really_inline void log_value(const value_iterator &iter, const char *type, std::string_view detail, int delta, int depth_delta) noexcept {\n+inline void log_value(const value_iterator &iter, const char *type, std::string_view detail, int delta, int depth_delta) noexcept {\n   log_value(iter.json_iter(), type, detail, delta, depth_delta);\n }\n \n-simdjson_really_inline void log_start_value(const value_iterator &iter, const char *type, int delta, int depth_delta) noexcept {\n+inline void log_start_value(const value_iterator &iter, const char *type, int delta, int depth_delta) noexcept {\n   log_start_value(iter.json_iter(), type, delta, depth_delta);\n }\n \n-simdjson_really_inline void log_end_value(const value_iterator &iter, const char *type, int delta, int depth_delta) noexcept {\n+inline void log_end_value(const value_iterator &iter, const char *type, int delta, int depth_delta) noexcept {\n   log_end_value(iter.json_iter(), type, delta, depth_delta);\n }\n \n-simdjson_really_inline void log_error(const value_iterator &iter, const char *error, const char *detail, int delta, int depth_delta) noexcept {\n+inline void log_error(const value_iterator &iter, const char *error, const char *detail, int delta, int depth_delta) noexcept {\n   log_error(iter.json_iter(), error, detail, delta, depth_delta);\n }\n \n-simdjson_really_inline void log_headers() noexcept {\n+inline void log_headers() noexcept {\n   if (LOG_ENABLED) {\n+    // Technically a static variable is not thread-safe, but if you are using threads\n+    // and logging... well...\n+    static bool displayed_hint{false};\n     log_depth = 0;\n     printf(\"\\n\");\n+    if(!displayed_hint) {\n+      // We only print this helpful header once.\n+      printf(\"# Logging provides the depth and position of the iterator user-visible steps:\\n\");\n+      printf(\"# +array says 'this is where we were when we discovered the start array'\\n\");\n+      printf(\"# -array says 'this is where we were when we ended the array'\\n\");\n+      printf(\"# skip says 'this is a structural or value I am skipping'\\n\");\n+      printf(\"# +/-skip says 'this is a start/end array or object I am skipping'\\n\");\n+      printf(\"#\\n\");\n+      printf(\"# The identation of the terms (array, string,...) indicates the depth,\\n\");\n+      printf(\"# in addition to the depth being displayed.\\n\");\n+      printf(\"#\\n\");\n+      printf(\"# Every token in the document has a single depth determined by the tokens before it,\\n\");\n+      printf(\"# and is not affected by what the token actually is.\\n\");\n+      printf(\"#\\n\");\n+      printf(\"# Not all structural elements are presented as tokens in the logs.\\n\");\n+      printf(\"#\\n\");\n+      printf(\"# We never give control to the user within an empty array or an empty object.\\n\");\n+      printf(\"#\\n\");\n+      printf(\"# Inside an array, having a depth greater than the array's depth means that\\n\");\n+      printf(\"# we are pointing inside a value.\\n\");\n+      printf(\"# Having a depth equal to the array means that we are pointing right before a value.\\n\");\n+      printf(\"# Having a depth smaller than the array means that we have moved beyond the array.\\n\");\n+      displayed_hint = true;\n+    }\n+    printf(\"\\n\");\n     printf(\"| %-*s \", LOG_EVENT_LEN,        \"Event\");\n     printf(\"| %-*s \", LOG_BUFFER_LEN,       \"Buffer\");\n     printf(\"| %-*s \", LOG_SMALL_BUFFER_LEN, \"Next\");\n@@ -93,10 +121,10 @@ simdjson_really_inline void log_headers() noexcept {\n   }\n }\n \n-simdjson_really_inline void log_line(const json_iterator &iter, const char *title_prefix, const char *title, std::string_view detail, int delta, int depth_delta) noexcept {\n-  log_line(iter, iter.token.index+delta, depth_t(iter.depth()+depth_delta), title_prefix, title, detail);\n+inline void log_line(const json_iterator &iter, const char *title_prefix, const char *title, std::string_view detail, int delta, int depth_delta) noexcept {\n+  log_line(iter, iter.position()+delta, depth_t(iter.depth()+depth_delta), title_prefix, title, detail);\n }\n-simdjson_really_inline void log_line(const json_iterator &iter, token_position index, depth_t depth, const char *title_prefix, const char *title, std::string_view detail) noexcept {\n+inline void log_line(const json_iterator &iter, token_position index, depth_t depth, const char *title_prefix, const char *title, std::string_view detail) noexcept {\n   if (LOG_ENABLED) {\n     const int indent = depth*2;\n     const auto buf = iter.token.buf;"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/logger.h",
        "status": "modified",
        "additions": 19,
        "deletions": 16,
        "changes": 35,
        "patch": "@@ -13,23 +13,26 @@ namespace logger {\n   static constexpr const bool LOG_ENABLED = false;\n #endif\n \n-static simdjson_really_inline void log_headers() noexcept;\n-static simdjson_really_inline void log_line(const json_iterator &iter, token_position index, depth_t depth, const char *title_prefix, const char *title, std::string_view detail) noexcept;\n-static simdjson_really_inline void log_line(const json_iterator &iter, const char *title_prefix, const char *title, std::string_view detail, int delta, int depth_delta) noexcept;\n-static simdjson_really_inline void log_event(const json_iterator &iter, const char *type, std::string_view detail=\"\", int delta=0, int depth_delta=0) noexcept;\n-static simdjson_really_inline void log_value(const json_iterator &iter, token_position index, depth_t depth, const char *type, std::string_view detail=\"\") noexcept;\n-static simdjson_really_inline void log_value(const json_iterator &iter, const char *type, std::string_view detail=\"\", int delta=-1, int depth_delta=0) noexcept;\n-static simdjson_really_inline void log_start_value(const json_iterator &iter, token_position index, depth_t depth, const char *type, std::string_view detail=\"\") noexcept;\n-static simdjson_really_inline void log_start_value(const json_iterator &iter, const char *type, int delta=-1, int depth_delta=0) noexcept;\n-static simdjson_really_inline void log_end_value(const json_iterator &iter, const char *type, int delta=-1, int depth_delta=0) noexcept;\n-static simdjson_really_inline void log_error(const json_iterator &iter, token_position index, depth_t depth, const char *error, const char *detail=\"\") noexcept;\n-static simdjson_really_inline void log_error(const json_iterator &iter, const char *error, const char *detail=\"\", int delta=-1, int depth_delta=0) noexcept;\n+// We do not want these functions to be 'really inlined' since real inlining is\n+// for performance purposes and if you are using the loggers, you do not care about\n+// performance (or should not).\n+static inline void log_headers() noexcept;\n+static inline void log_line(const json_iterator &iter, token_position index, depth_t depth, const char *title_prefix, const char *title, std::string_view detail) noexcept;\n+static inline void log_line(const json_iterator &iter, const char *title_prefix, const char *title, std::string_view detail, int delta, int depth_delta) noexcept;\n+static inline void log_event(const json_iterator &iter, const char *type, std::string_view detail=\"\", int delta=0, int depth_delta=0) noexcept;\n+static inline void log_value(const json_iterator &iter, token_position index, depth_t depth, const char *type, std::string_view detail=\"\") noexcept;\n+static inline void log_value(const json_iterator &iter, const char *type, std::string_view detail=\"\", int delta=-1, int depth_delta=0) noexcept;\n+static inline void log_start_value(const json_iterator &iter, token_position index, depth_t depth, const char *type, std::string_view detail=\"\") noexcept;\n+static inline void log_start_value(const json_iterator &iter, const char *type, int delta=-1, int depth_delta=0) noexcept;\n+static inline void log_end_value(const json_iterator &iter, const char *type, int delta=-1, int depth_delta=0) noexcept;\n+static inline void log_error(const json_iterator &iter, token_position index, depth_t depth, const char *error, const char *detail=\"\") noexcept;\n+static inline void log_error(const json_iterator &iter, const char *error, const char *detail=\"\", int delta=-1, int depth_delta=0) noexcept;\n \n-static simdjson_really_inline void log_event(const value_iterator &iter, const char *type, std::string_view detail=\"\", int delta=0, int depth_delta=0) noexcept;\n-static simdjson_really_inline void log_value(const value_iterator &iter, const char *type, std::string_view detail=\"\", int delta=-1, int depth_delta=0) noexcept;\n-static simdjson_really_inline void log_start_value(const value_iterator &iter, const char *type, int delta=-1, int depth_delta=0) noexcept;\n-static simdjson_really_inline void log_end_value(const value_iterator &iter, const char *type, int delta=-1, int depth_delta=0) noexcept;\n-static simdjson_really_inline void log_error(const value_iterator &iter, const char *error, const char *detail=\"\", int delta=-1, int depth_delta=0) noexcept;\n+static inline void log_event(const value_iterator &iter, const char *type, std::string_view detail=\"\", int delta=0, int depth_delta=0) noexcept;\n+static inline void log_value(const value_iterator &iter, const char *type, std::string_view detail=\"\", int delta=-1, int depth_delta=0) noexcept;\n+static inline void log_start_value(const value_iterator &iter, const char *type, int delta=-1, int depth_delta=0) noexcept;\n+static inline void log_end_value(const value_iterator &iter, const char *type, int delta=-1, int depth_delta=0) noexcept;\n+static inline void log_error(const value_iterator &iter, const char *error, const char *detail=\"\", int delta=-1, int depth_delta=0) noexcept;\n \n } // namespace logger\n } // namespace ondemand"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/object-inl.h",
        "status": "modified",
        "additions": 123,
        "deletions": 9,
        "changes": 132,
        "patch": "@@ -34,21 +34,52 @@ simdjson_really_inline simdjson_result<value> object::find_field(const std::stri\n }\n \n simdjson_really_inline simdjson_result<object> object::start(value_iterator &iter) noexcept {\n-  // We don't need to know if the object is empty to start iteration, but we do want to know if there\n-  // is an error--thus `simdjson_unused`.\n-  simdjson_unused bool has_value;\n-  SIMDJSON_TRY( iter.start_object().get(has_value) );\n+  SIMDJSON_TRY( iter.start_object().error() );\n   return object(iter);\n }\n simdjson_really_inline simdjson_result<object> object::start_root(value_iterator &iter) noexcept {\n-  simdjson_unused bool has_value;\n-  SIMDJSON_TRY( iter.start_root_object().get(has_value) );\n+  SIMDJSON_TRY( iter.start_root_object().error() );\n   return object(iter);\n }\n-simdjson_really_inline object object::started(value_iterator &iter) noexcept {\n-  simdjson_unused bool has_value = iter.started_object();\n-  return iter;\n+simdjson_really_inline error_code object::consume() noexcept {\n+  if(iter.is_at_key()) {\n+    /**\n+     * whenever you are pointing at a key, calling skip_child() is\n+     * unsafe because you will hit a string and you will assume that\n+     * it is string value, and this mistake will lead you to make bad\n+     * depth computation.\n+     */\n+    /**\n+     * We want to 'consume' the key. We could really\n+     * just do _json_iter->return_current_and_advance(); at this\n+     * point, but, for clarity, we will use the high-level API to\n+     * eat the key. We assume that the compiler optimizes away\n+     * most of the work.\n+     */\n+    simdjson_unused raw_json_string actual_key;\n+    auto error = iter.field_key().get(actual_key);\n+    if (error) { iter.abandon(); return error; };\n+    // Let us move to the value while we are at it.\n+    if ((error = iter.field_value())) { iter.abandon(); return error; }\n+  }\n+  auto error_skip = iter.json_iter().skip_child(iter.depth()-1);\n+  if(error_skip) { iter.abandon(); }\n+  return error_skip;\n+}\n+\n+simdjson_really_inline simdjson_result<std::string_view> object::raw_json() noexcept {\n+  const uint8_t * starting_point{iter.peek_start()};\n+  auto error = consume();\n+  if(error) { return error; }\n+  const uint8_t * final_point{iter._json_iter->peek(0)};\n+  return std::string_view(reinterpret_cast<const char*>(starting_point), size_t(final_point - starting_point));\n }\n+\n+simdjson_really_inline simdjson_result<object> object::started(value_iterator &iter) noexcept {\n+  SIMDJSON_TRY( iter.started_object().error() );\n+  return object(iter);\n+}\n+\n simdjson_really_inline object object::resume(const value_iterator &iter) noexcept {\n   return iter;\n }\n@@ -68,6 +99,69 @@ simdjson_really_inline simdjson_result<object_iterator> object::end() noexcept {\n   return object_iterator(iter);\n }\n \n+inline simdjson_result<value> object::at_pointer(std::string_view json_pointer) noexcept {\n+  if (json_pointer[0] != '/') { return INVALID_JSON_POINTER; }\n+  json_pointer = json_pointer.substr(1);\n+  size_t slash = json_pointer.find('/');\n+  std::string_view key = json_pointer.substr(0, slash);\n+  // Grab the child with the given key\n+  simdjson_result<value> child;\n+\n+  // If there is an escape character in the key, unescape it and then get the child.\n+  size_t escape = key.find('~');\n+  if (escape != std::string_view::npos) {\n+    // Unescape the key\n+    std::string unescaped(key);\n+    do {\n+      switch (unescaped[escape+1]) {\n+        case '0':\n+          unescaped.replace(escape, 2, \"~\");\n+          break;\n+        case '1':\n+          unescaped.replace(escape, 2, \"/\");\n+          break;\n+        default:\n+          return INVALID_JSON_POINTER; // \"Unexpected ~ escape character in JSON pointer\");\n+      }\n+      escape = unescaped.find('~', escape+1);\n+    } while (escape != std::string::npos);\n+    child = find_field(unescaped);  // Take note find_field does not unescape keys when matching\n+  } else {\n+    child = find_field(key);\n+  }\n+  if(child.error()) {\n+    return child; // we do not continue if there was an error\n+  }\n+  // If there is a /, we have to recurse and look up more of the path\n+  if (slash != std::string_view::npos) {\n+    child = child.at_pointer(json_pointer.substr(slash));\n+  }\n+  return child;\n+}\n+\n+simdjson_really_inline simdjson_result<size_t> object::count_fields() & noexcept {\n+  size_t count{0};\n+  // Important: we do not consume any of the values.\n+  for(simdjson_unused auto v : *this) { count++; }\n+  // The above loop will always succeed, but we want to report errors.\n+  if(iter.error()) { return iter.error(); }\n+  // We need to move back at the start because we expect users to iterate through\n+  // the object after counting the number of elements.\n+  iter.reset_object();\n+  return count;\n+}\n+\n+simdjson_really_inline simdjson_result<bool> object::is_empty() & noexcept {\n+  bool is_not_empty;\n+  auto error = iter.reset_object().get(is_not_empty);\n+  if(error) { return error; }\n+  return !is_not_empty;\n+}\n+\n+simdjson_really_inline simdjson_result<bool> object::reset() & noexcept {\n+  return iter.reset_object();\n+}\n+\n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n@@ -112,4 +206,24 @@ simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>\n   return std::forward<SIMDJSON_IMPLEMENTATION::ondemand::object>(first).find_field(key);\n }\n \n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object>::at_pointer(std::string_view json_pointer) noexcept {\n+  if (error()) { return error(); }\n+  return first.at_pointer(json_pointer);\n+}\n+\n+inline simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object>::reset() noexcept {\n+  if (error()) { return error(); }\n+  return first.reset();\n+}\n+\n+inline simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object>::is_empty() noexcept {\n+  if (error()) { return error(); }\n+  return first.is_empty();\n+}\n+\n+simdjson_really_inline  simdjson_result<size_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object>::count_fields() & noexcept {\n+  if (error()) { return error(); }\n+  return first.count_fields();\n+}\n+\n } // namespace simdjson"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/object.h",
        "status": "modified",
        "additions": 88,
        "deletions": 2,
        "changes": 90,
        "patch": "@@ -18,7 +18,6 @@ class object {\n \n   simdjson_really_inline simdjson_result<object_iterator> begin() noexcept;\n   simdjson_really_inline simdjson_result<object_iterator> end() noexcept;\n-\n   /**\n    * Look up a field by name on an object (order-sensitive).\n    *\n@@ -75,10 +74,92 @@ class object {\n   /** @overload simdjson_really_inline simdjson_result<value> find_field_unordered(std::string_view key) & noexcept; */\n   simdjson_really_inline simdjson_result<value> operator[](std::string_view key) && noexcept;\n \n+  /**\n+   * Get the value associated with the given JSON pointer. We use the RFC 6901\n+   * https://tools.ietf.org/html/rfc6901 standard, interpreting the current node\n+   * as the root of its own JSON document.\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"foo\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"/foo/a/1\") == 20\n+   *\n+   * It is allowed for a key to be the empty string:\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"//a/1\") == 20\n+   *\n+   * Note that at_pointer() called on the document automatically calls the document's rewind\n+   * method between each call. It invalidates all previously accessed arrays, objects and values\n+   * that have not been consumed. Yet it is not the case when calling at_pointer on an object\n+   * instance: there is no rewind and no invalidation.\n+   *\n+   * You may call at_pointer more than once on an object, but each time the pointer is advanced\n+   * to be within the value matched by the key indicated by the JSON pointer query. Thus any preceeding\n+   * key (as well as the current key) can no longer be used with following JSON pointer calls.\n+   *\n+   * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching.\n+   *\n+   * @return The value associated with the given JSON pointer, or:\n+   *         - NO_SUCH_FIELD if a field does not exist in an object\n+   *         - INDEX_OUT_OF_BOUNDS if an array index is larger than an array length\n+   *         - INCORRECT_TYPE if a non-integer is used to access an array\n+   *         - INVALID_JSON_POINTER if the JSON pointer is invalid and cannot be parsed\n+   */\n+  inline simdjson_result<value> at_pointer(std::string_view json_pointer) noexcept;\n+\n+  /**\n+   * Reset the iterator so that we are pointing back at the\n+   * beginning of the object. You should still consume values only once even if you\n+   * can iterate through the object more than once. If you unescape a string within\n+   * the object more than once, you have unsafe code. Note that rewinding an object\n+   * means that you may need to reparse it anew: it is not a free operation.\n+   *\n+   * @returns true if the object contains some elements (not empty)\n+   */\n+  inline simdjson_result<bool> reset() & noexcept;\n+  /**\n+   * This method scans the beginning of the object and checks whether the\n+   * object is empty.\n+   * The runtime complexity is constant time. After\n+   * calling this function, if successful, the object is 'rewinded' at its\n+   * beginning as if it had never been accessed. If the JSON is malformed (e.g.,\n+   * there is a missing comma), then an error is returned and it is no longer\n+   * safe to continue.\n+   */\n+  inline simdjson_result<bool> is_empty() & noexcept;\n+  /**\n+   * This method scans the object and counts the number of key-value pairs.\n+   * The count_fields method should always be called before you have begun\n+   * iterating through the object: it is expected that you are pointing at\n+   * the beginning of the object.\n+   * The runtime complexity is linear in the size of the object. After\n+   * calling this function, if successful, the object is 'rewinded' at its\n+   * beginning as if it had never been accessed. If the JSON is malformed (e.g.,\n+   * there is a missing comma), then an error is returned and it is no longer\n+   * safe to continue.\n+   *\n+   * To check that an object is empty, it is more performant to use\n+   * the is_empty() method.\n+   */\n+  simdjson_really_inline simdjson_result<size_t> count_fields() & noexcept;\n+  /**\n+   * Consumes the object and returns a string_view instance corresponding to the\n+   * object as represented in JSON. It points inside the original byte array containg\n+   * the JSON document.\n+   */\n+  simdjson_really_inline simdjson_result<std::string_view> raw_json() noexcept;\n+\n protected:\n+  /**\n+   * Go to the end of the object, no matter where you are right now.\n+   */\n+  simdjson_really_inline error_code consume() noexcept;\n   static simdjson_really_inline simdjson_result<object> start(value_iterator &iter) noexcept;\n   static simdjson_really_inline simdjson_result<object> start_root(value_iterator &iter) noexcept;\n-  static simdjson_really_inline object started(value_iterator &iter) noexcept;\n+  static simdjson_really_inline simdjson_result<object> started(value_iterator &iter) noexcept;\n   static simdjson_really_inline object resume(const value_iterator &iter) noexcept;\n   simdjson_really_inline object(const value_iterator &iter) noexcept;\n \n@@ -112,6 +193,11 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> : public SIMDJ\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(std::string_view key) && noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> operator[](std::string_view key) & noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> operator[](std::string_view key) && noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at_pointer(std::string_view json_pointer) noexcept;\n+  inline simdjson_result<bool> reset() noexcept;\n+  inline simdjson_result<bool> is_empty() noexcept;\n+  inline simdjson_result<size_t> count_fields() & noexcept;\n+\n };\n \n } // namespace simdjson"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/parser-inl.h",
        "status": "modified",
        "additions": 32,
        "deletions": 2,
        "changes": 34,
        "patch": "@@ -2,7 +2,12 @@ namespace simdjson {\n namespace SIMDJSON_IMPLEMENTATION {\n namespace ondemand {\n \n+simdjson_really_inline parser::parser(size_t max_capacity) noexcept\n+  : _max_capacity{max_capacity} {\n+}\n+\n simdjson_warn_unused simdjson_really_inline error_code parser::allocate(size_t new_capacity, size_t new_max_depth) noexcept {\n+  if (new_capacity > max_capacity()) { return CAPACITY; }\n   if (string_buf && new_capacity == capacity() && new_max_depth == max_depth()) { return SUCCESS; }\n \n   // string_capacity copied from document::allocate\n@@ -32,7 +37,7 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<document> parser::it\n   }\n \n   // Run stage 1.\n-  SIMDJSON_TRY( implementation->stage1(reinterpret_cast<const uint8_t *>(json.data()), json.length(), false) );\n+  SIMDJSON_TRY( implementation->stage1(reinterpret_cast<const uint8_t *>(json.data()), json.length(), stage1_mode::regular) );\n   return document::start({ reinterpret_cast<const uint8_t *>(json.data()), this });\n }\n \n@@ -75,17 +80,42 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<json_iterator> parse\n   }\n \n   // Run stage 1.\n-  SIMDJSON_TRY( implementation->stage1(reinterpret_cast<const uint8_t *>(json.data()), json.length(), false) );\n+  SIMDJSON_TRY( implementation->stage1(reinterpret_cast<const uint8_t *>(json.data()), json.length(), stage1_mode::regular) );\n   return json_iterator(reinterpret_cast<const uint8_t *>(json.data()), this);\n }\n \n+inline simdjson_result<document_stream> parser::iterate_many(const uint8_t *buf, size_t len, size_t batch_size) noexcept {\n+  if(batch_size < MINIMAL_BATCH_SIZE) { batch_size = MINIMAL_BATCH_SIZE; }\n+  return document_stream(*this, buf, len, batch_size);\n+}\n+inline simdjson_result<document_stream> parser::iterate_many(const char *buf, size_t len, size_t batch_size) noexcept {\n+  return iterate_many(reinterpret_cast<const uint8_t *>(buf), len, batch_size);\n+}\n+inline simdjson_result<document_stream> parser::iterate_many(const std::string &s, size_t batch_size) noexcept {\n+  return iterate_many(s.data(), s.length(), batch_size);\n+}\n+inline simdjson_result<document_stream> parser::iterate_many(const padded_string &s, size_t batch_size) noexcept {\n+  return iterate_many(s.data(), s.length(), batch_size);\n+}\n+\n simdjson_really_inline size_t parser::capacity() const noexcept {\n   return _capacity;\n }\n+simdjson_really_inline size_t parser::max_capacity() const noexcept {\n+  return _max_capacity;\n+}\n simdjson_really_inline size_t parser::max_depth() const noexcept {\n   return _max_depth;\n }\n \n+simdjson_really_inline void parser::set_max_capacity(size_t max_capacity) noexcept {\n+  size_t MINIMAL_DOCUMENT_CAPACITY = 32;\n+  if(max_capacity < MINIMAL_DOCUMENT_CAPACITY) {\n+    _max_capacity = max_capacity;\n+  } else {\n+    _max_capacity = MINIMAL_DOCUMENT_CAPACITY;\n+  }\n+}\n \n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/parser.h",
        "status": "modified",
        "additions": 125,
        "deletions": 13,
        "changes": 138,
        "patch": "@@ -8,6 +8,23 @@ class array;\n class object;\n class value;\n class raw_json_string;\n+class document_stream;\n+\n+/**\n+ * The default batch size for document_stream instances for this On Demand kernel.\n+ * Note that different On Demand kernel may use a different DEFAULT_BATCH_SIZE value\n+ * in the future.\n+ */\n+static constexpr size_t DEFAULT_BATCH_SIZE = 1000000;\n+/**\n+ * Some adversary might try to set the batch size to 0 or 1, which might cause problems.\n+ * We set a minimum of 32B since anything else is highly likely to be an error. In practice,\n+ * most users will want a much larger batch size.\n+ *\n+ * All non-negative MINIMAL_BATCH_SIZE values should be 'safe' except that, obviously, no JSON\n+ * document can ever span 0 or 1 byte and that very large values would create memory allocation issues.\n+ */\n+static constexpr size_t MINIMAL_BATCH_SIZE = 32;\n \n /**\n  * A JSON fragment iterator.\n@@ -21,11 +38,12 @@ class parser {\n    *\n    * The new parser will have zero capacity.\n    */\n-  inline parser() noexcept = default;\n+  inline explicit parser(size_t max_capacity = SIMDJSON_MAXSIZE_BYTES) noexcept;\n \n   inline parser(parser &&other) noexcept = default;\n   simdjson_really_inline parser(const parser &other) = delete;\n   simdjson_really_inline parser &operator=(const parser &other) = delete;\n+  simdjson_really_inline parser &operator=(parser &&other) noexcept = default;\n \n   /** Deallocate the JSON parser. */\n   inline ~parser() noexcept = default;\n@@ -36,6 +54,11 @@ class parser {\n    *   ondemand::parser parser;\n    *   document doc = parser.iterate(json);\n    *\n+   * ### IMPORTANT: Validate what you use\n+   *\n+   * Calling iterate on an invalid JSON document may not immediately trigger an error. The call to\n+   * iterate does not parse and validate the whole document.\n+   *\n    * ### IMPORTANT: Buffer Lifetime\n    *\n    * Because parsing is done while you iterate, you *must* keep the JSON buffer around at least as\n@@ -100,14 +123,15 @@ class parser {\n    * iteration to ensure intermediate buffers can be accessed. Any document must be destroyed before\n    * you call parse() again or destroy the parser.\n    *\n+   * The ondemand::document instance holds the iterator. The document must remain in scope\n+   * while you are accessing instances of ondemand::value, ondemand::object, ondemand::array.\n+   *\n    * ### REQUIRED: Buffer Padding\n    *\n    * The buffer must have at least SIMDJSON_PADDING extra allocated bytes. It does not matter what\n    * those bytes are initialized to, as long as they are allocated.\n    *\n    * @param json The JSON to parse.\n-   * @param len The length of the JSON.\n-   * @param allocated The number of bytes allocated in the JSON (must be at least len+SIMDJSON_PADDING).\n    *\n    * @return The iterator, or an error:\n    *         - INSUFFICIENT_PADDING if the input has less than SIMDJSON_PADDING extra bytes.\n@@ -120,21 +144,88 @@ class parser {\n    */\n   simdjson_warn_unused simdjson_result<json_iterator> iterate_raw(padded_string_view json) & noexcept;\n \n+\n+  /**\n+   * Parse a buffer containing many JSON documents.\n+   *\n+   *   auto json = R\"({ \"foo\": 1 } { \"foo\": 2 } { \"foo\": 3 } )\"_padded;\n+   *   ondemand::parser parser;\n+   *   ondemand::document_stream docs = parser.iterate_many(json);\n+   *   for (auto & doc : docs) {\n+   *     std::cout << doc[\"foo\"] << std::endl;\n+   *   }\n+   *   // Prints 1 2 3\n+   *\n+   * No copy of the input buffer is made.\n+   *\n+   * The function is lazy: it may be that no more than one JSON document at a time is parsed.\n+   *\n+   * The caller is responsabile to ensure that the input string data remains unchanged and is\n+   * not deleted during the loop.\n+   *\n+   * ### Format\n+   *\n+   * The buffer must contain a series of one or more JSON documents, concatenated into a single\n+   * buffer, separated by whitespace. It effectively parses until it has a fully valid document,\n+   * then starts parsing the next document at that point. (It does this with more parallelism and\n+   * lookahead than you might think, though.)\n+   *\n+   * documents that consist of an object or array may omit the whitespace between them, concatenating\n+   * with no separator. documents that consist of a single primitive (i.e. documents that are not\n+   * arrays or objects) MUST be separated with whitespace.\n+   *\n+   * The documents must not exceed batch_size bytes (by default 1MB) or they will fail to parse.\n+   * Setting batch_size to excessively large or excesively small values may impact negatively the\n+   * performance.\n+   *\n+   * ### REQUIRED: Buffer Padding\n+   *\n+   * The buffer must have at least SIMDJSON_PADDING extra allocated bytes. It does not matter what\n+   * those bytes are initialized to, as long as they are allocated.\n+   *\n+   * ### Threads\n+   *\n+   * When compiled with SIMDJSON_THREADS_ENABLED, this method will use a single thread under the\n+   * hood to do some lookahead.\n+   *\n+   * ### Parser Capacity\n+   *\n+   * If the parser's current capacity is less than batch_size, it will allocate enough capacity\n+   * to handle it (up to max_capacity).\n+   *\n+   * @param buf The concatenated JSON to parse.\n+   * @param len The length of the concatenated JSON.\n+   * @param batch_size The batch size to use. MUST be larger than the largest document. The sweet\n+   *                   spot is cache-related: small enough to fit in cache, yet big enough to\n+   *                   parse as many documents as possible in one tight loop.\n+   *                   Defaults to 10MB, which has been a reasonable sweet spot in our tests.\n+   * @return The stream, or an error. An empty input will yield 0 documents rather than an EMPTY error. Errors:\n+   *         - MEMALLOC if the parser does not have enough capacity and memory allocation fails\n+   *         - CAPACITY if the parser does not have enough capacity and batch_size > max_capacity.\n+   *         - other json errors if parsing fails. You should not rely on these errors to always the same for the\n+   *           same document: they may vary under runtime dispatch (so they may vary depending on your system and hardware).\n+   */\n+  inline simdjson_result<document_stream> iterate_many(const uint8_t *buf, size_t len, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept;\n+  /** @overload parse_many(const uint8_t *buf, size_t len, size_t batch_size) */\n+  inline simdjson_result<document_stream> iterate_many(const char *buf, size_t len, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept;\n+  /** @overload parse_many(const uint8_t *buf, size_t len, size_t batch_size) */\n+  inline simdjson_result<document_stream> iterate_many(const std::string &s, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept;\n+  inline simdjson_result<document_stream> iterate_many(const std::string &&s, size_t batch_size) = delete;// unsafe\n+  /** @overload parse_many(const uint8_t *buf, size_t len, size_t batch_size) */\n+  inline simdjson_result<document_stream> iterate_many(const padded_string &s, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept;\n+  inline simdjson_result<document_stream> iterate_many(const padded_string &&s, size_t batch_size) = delete;// unsafe\n+\n+  /** @private We do not want to allow implicit conversion from C string to std::string. */\n+  simdjson_result<document_stream> iterate_many(const char *buf, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept = delete;\n+\n   /** The capacity of this parser (the largest document it can process). */\n   simdjson_really_inline size_t capacity() const noexcept;\n+  /** The maximum capacity of this parser (the largest document it is allowed to process). */\n+  simdjson_really_inline size_t max_capacity() const noexcept;\n+  simdjson_really_inline void set_max_capacity(size_t max_capacity) noexcept;\n   /** The maximum depth of this parser (the most deeply nested objects and arrays it can process). */\n   simdjson_really_inline size_t max_depth() const noexcept;\n \n-private:\n-  /** @private [for benchmarking access] The implementation to use */\n-  std::unique_ptr<internal::dom_parser_implementation> implementation{};\n-  size_t _capacity{0};\n-  size_t _max_depth{DEFAULT_MAX_DEPTH};\n-  std::unique_ptr<uint8_t[]> string_buf{};\n-#ifdef SIMDJSON_DEVELOPMENT_CHECKS\n-  std::unique_ptr<token_position[]> start_positions{};\n-#endif\n-\n   /**\n    * Ensure this parser has enough memory to process JSON documents up to `capacity` bytes in length\n    * and `max_depth` depth.\n@@ -145,7 +236,28 @@ class parser {\n    */\n   simdjson_warn_unused error_code allocate(size_t capacity, size_t max_depth=DEFAULT_MAX_DEPTH) noexcept;\n \n+  #ifdef SIMDJSON_THREADS_ENABLED\n+  /**\n+   * The parser instance can use threads when they are available to speed up some\n+   * operations. It is enabled by default. Changing this attribute will change the\n+   * behavior of the parser for future operations.\n+   */\n+  bool threaded{true};\n+  #endif\n+\n+private:\n+  /** @private [for benchmarking access] The implementation to use */\n+  std::unique_ptr<internal::dom_parser_implementation> implementation{};\n+  size_t _capacity{0};\n+  size_t _max_capacity;\n+  size_t _max_depth{DEFAULT_MAX_DEPTH};\n+  std::unique_ptr<uint8_t[]> string_buf{};\n+#ifdef SIMDJSON_DEVELOPMENT_CHECKS\n+  std::unique_ptr<token_position[]> start_positions{};\n+#endif\n+\n   friend class json_iterator;\n+  friend class document_stream;\n };\n \n } // namespace ondemand"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/raw_json_string.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -75,7 +75,7 @@ class raw_json_string {\n    * long strings.\n    *\n    * If target is a compile-time constant, and your compiler likes you,\n-   * you should be able to do the following without performance penatly...\n+   * you should be able to do the following without performance penalty...\n    *\n    *   static_assert(raw_json_string::is_free_from_unescaped_quote(target), \"\");\n    *   s.unsafe_is_equal(target);\n@@ -89,7 +89,7 @@ class raw_json_string {\n    * the caller is responsible for this check. See is_free_from_unescaped_quote.\n    *\n    * If target is a compile-time constant, and your compiler likes you,\n-   * you should be able to do the following without performance penatly...\n+   * you should be able to do the following without performance penalty...\n    *\n    *   static_assert(raw_json_string::is_free_from_unescaped_quote(target), \"\");\n    *   s.unsafe_is_equal(target);"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/serialization-inl.h",
        "status": "added",
        "additions": 218,
        "deletions": 0,
        "changes": 218,
        "patch": "@@ -0,0 +1,218 @@\n+\n+\n+namespace simdjson {\n+\n+inline std::string_view trim(const std::string_view str) noexcept {\n+  // We can almost surely do better by rolling our own find_first_not_of function.\n+  size_t first = str.find_first_not_of(\" \\t\\n\\r\");\n+  // If we have the empty string (just white space), then no trimming is possible, and\n+  // we return the empty string_view.\n+  if (std::string_view::npos == first) { return std::string_view(); }\n+  size_t last = str.find_last_not_of(\" \\t\\n\\r\");\n+  return str.substr(first, (last - first + 1));\n+}\n+\n+\n+inline simdjson_result<std::string_view> to_json_string(SIMDJSON_IMPLEMENTATION::ondemand::document& x) noexcept {\n+  std::string_view v;\n+  auto error = x.raw_json().get(v);\n+  if(error) {return error; }\n+  return trim(v);\n+}\n+\n+inline simdjson_result<std::string_view> to_json_string(SIMDJSON_IMPLEMENTATION::ondemand::document_reference& x) noexcept {\n+  std::string_view v;\n+  auto error = x.raw_json().get(v);\n+  if(error) {return error; }\n+  return trim(v);\n+}\n+\n+inline simdjson_result<std::string_view> to_json_string(SIMDJSON_IMPLEMENTATION::ondemand::value& x) noexcept {\n+  /**\n+   * If we somehow receive a value that has already been consumed,\n+   * then the following code could be in trouble. E.g., we create\n+   * an array as needed, but if an array was already created, then\n+   * it could be bad.\n+   */\n+  using namespace SIMDJSON_IMPLEMENTATION::ondemand;\n+  SIMDJSON_IMPLEMENTATION::ondemand::json_type t;\n+  auto error = x.type().get(t);\n+  if(error != SUCCESS) { return error; }\n+  switch (t)\n+  {\n+    case json_type::array:\n+    {\n+      SIMDJSON_IMPLEMENTATION::ondemand::array array;\n+      error = x.get_array().get(array);\n+      if(error) { return error; }\n+      return to_json_string(array);\n+    }\n+    case json_type::object:\n+    {\n+      SIMDJSON_IMPLEMENTATION::ondemand::object object;\n+      error = x.get_object().get(object);\n+      if(error) { return error; }\n+      return to_json_string(object);\n+    }\n+    default:\n+      return trim(x.raw_json_token());\n+  }\n+}\n+\n+inline simdjson_result<std::string_view> to_json_string(SIMDJSON_IMPLEMENTATION::ondemand::object& x) noexcept {\n+  std::string_view v;\n+  auto error = x.raw_json().get(v);\n+  if(error) {return error; }\n+  return trim(v);\n+}\n+\n+inline simdjson_result<std::string_view> to_json_string(SIMDJSON_IMPLEMENTATION::ondemand::array& x) noexcept {\n+  std::string_view v;\n+  auto error = x.raw_json().get(v);\n+  if(error) {return error; }\n+  return trim(v);\n+}\n+\n+inline simdjson_result<std::string_view> to_json_string(simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document> x) {\n+  if (x.error()) { return x.error(); }\n+  return to_json_string(x.value_unsafe());\n+}\n+\n+inline simdjson_result<std::string_view> to_json_string(simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document_reference> x) {\n+  if (x.error()) { return x.error(); }\n+  return to_json_string(x.value_unsafe());\n+}\n+\n+inline simdjson_result<std::string_view> to_json_string(simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> x) {\n+  if (x.error()) { return x.error(); }\n+  return to_json_string(x.value_unsafe());\n+}\n+\n+inline simdjson_result<std::string_view> to_json_string(simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> x) {\n+  if (x.error()) { return x.error(); }\n+  return to_json_string(x.value_unsafe());\n+}\n+\n+inline simdjson_result<std::string_view> to_json_string(simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array> x) {\n+  if (x.error()) { return x.error(); }\n+  return to_json_string(x.value_unsafe());\n+}\n+} // namespace simdjson\n+\n+\n+#if SIMDJSON_EXCEPTIONS\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::value x) {\n+  std::string_view v;\n+  auto error = simdjson::to_json_string(x).get(v);\n+  if(error == simdjson::SUCCESS) {\n+    return (out << v);\n+  } else {\n+    throw simdjson::simdjson_error(error);\n+  }\n+}\n+inline std::ostream& operator<<(std::ostream& out, simdjson::simdjson_result<simdjson::SIMDJSON_IMPLEMENTATION::ondemand::value> x) {\n+  if (x.error()) { throw simdjson::simdjson_error(x.error()); }\n+  return (out << x.value());\n+}\n+#else\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::value x) {\n+  std::string_view v;\n+  auto error = simdjson::to_json_string(x).get(v);\n+  if(error == simdjson::SUCCESS) {\n+    return (out << v);\n+  } else {\n+    return (out << error);\n+  }\n+}\n+#endif\n+\n+#if SIMDJSON_EXCEPTIONS\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::array value) {\n+  std::string_view v;\n+  auto error = simdjson::to_json_string(value).get(v);\n+  if(error == simdjson::SUCCESS) {\n+    return (out << v);\n+  } else {\n+    throw simdjson::simdjson_error(error);\n+  }\n+}\n+inline std::ostream& operator<<(std::ostream& out, simdjson::simdjson_result<simdjson::SIMDJSON_IMPLEMENTATION::ondemand::array> x) {\n+  if (x.error()) { throw simdjson::simdjson_error(x.error()); }\n+  return (out << x.value());\n+}\n+#else\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::array value) {\n+  std::string_view v;\n+  auto error = simdjson::to_json_string(value).get(v);\n+  if(error == simdjson::SUCCESS) {\n+    return (out << v);\n+  } else {\n+    return (out << error);\n+  }\n+}\n+#endif\n+\n+#if SIMDJSON_EXCEPTIONS\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::document& value)  {\n+  std::string_view v;\n+  auto error = simdjson::to_json_string(value).get(v);\n+  if(error == simdjson::SUCCESS) {\n+    return (out << v);\n+  } else {\n+    throw simdjson::simdjson_error(error);\n+  }\n+}\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::document_reference& value)  {\n+  std::string_view v;\n+  auto error = simdjson::to_json_string(value).get(v);\n+  if(error == simdjson::SUCCESS) {\n+    return (out << v);\n+  } else {\n+    throw simdjson::simdjson_error(error);\n+  }\n+}\n+inline std::ostream& operator<<(std::ostream& out, simdjson::simdjson_result<simdjson::SIMDJSON_IMPLEMENTATION::ondemand::document>&& x) {\n+  if (x.error()) { throw simdjson::simdjson_error(x.error()); }\n+  return (out << x.value());\n+}\n+inline std::ostream& operator<<(std::ostream& out, simdjson::simdjson_result<simdjson::SIMDJSON_IMPLEMENTATION::ondemand::document_reference>&& x) {\n+  if (x.error()) { throw simdjson::simdjson_error(x.error()); }\n+  return (out << x.value());\n+}\n+#else\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::document& value)  {\n+  std::string_view v;\n+  auto error = simdjson::to_json_string(value).get(v);\n+  if(error == simdjson::SUCCESS) {\n+    return (out << v);\n+  } else {\n+    return (out << error);\n+  }\n+}\n+#endif\n+\n+#if SIMDJSON_EXCEPTIONS\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::object value) {\n+  std::string_view v;\n+  auto error = simdjson::to_json_string(value).get(v);\n+  if(error == simdjson::SUCCESS) {\n+    return (out << v);\n+  } else {\n+    throw simdjson::simdjson_error(error);\n+  }\n+}\n+inline std::ostream& operator<<(std::ostream& out,  simdjson::simdjson_result<simdjson::SIMDJSON_IMPLEMENTATION::ondemand::object> x) {\n+  if (x.error()) { throw  simdjson::simdjson_error(x.error()); }\n+  return (out << x.value());\n+}\n+#else\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::object value) {\n+  std::string_view v;\n+  auto error = simdjson::to_json_string(value).get(v);\n+  if(error == simdjson::SUCCESS) {\n+    return (out << v);\n+  } else {\n+    return (out << error);\n+  }\n+}\n+#endif"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/serialization.h",
        "status": "added",
        "additions": 80,
        "deletions": 0,
        "changes": 80,
        "patch": "@@ -0,0 +1,80 @@\n+#include \"simdjson/dom/serialization.h\"\n+#include \"simdjson/error.h\"\n+\n+namespace simdjson {\n+/**\n+ * Create a string-view instance out of a document instance. The string-view instance\n+ * contains JSON text that is suitable to be parsed as JSON again.\n+ */\n+inline simdjson_result<std::string_view> to_json_string(SIMDJSON_IMPLEMENTATION::ondemand::document& x) noexcept;\n+/**\n+ * Create a string-view instance out of a value instance. The string-view instance\n+ * contains JSON text that is suitable to be parsed as JSON again. The value must\n+ * not have been accessed previously.\n+ */\n+inline simdjson_result<std::string_view> to_json_string(SIMDJSON_IMPLEMENTATION::ondemand::value& x) noexcept;\n+/**\n+ * Create a string-view instance out of an object instance. The string-view instance\n+ * contains JSON text that is suitable to be parsed as JSON again.\n+ */\n+inline simdjson_result<std::string_view> to_json_string(SIMDJSON_IMPLEMENTATION::ondemand::object& x) noexcept;\n+/**\n+ * Create a string-view instance out of an array instance. The string-view instance\n+ * contains JSON text that is suitable to be parsed as JSON again.\n+ */\n+inline simdjson_result<std::string_view> to_json_string(SIMDJSON_IMPLEMENTATION::ondemand::array& x) noexcept;\n+inline simdjson_result<std::string_view> to_json_string(simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document> x);\n+inline simdjson_result<std::string_view> to_json_string(simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> x);\n+inline simdjson_result<std::string_view> to_json_string(simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> x);\n+inline simdjson_result<std::string_view> to_json_string(simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array> x);\n+} // namespace simdjson\n+\n+\n+/**\n+ * Print JSON to an output stream.\n+ *\n+ * @param out The output stream.\n+ * @param value The element.\n+ * @throw if there is an error with the underlying output stream. simdjson itself will not throw.\n+ */\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::value x);\n+#if SIMDJSON_EXCEPTIONS\n+inline std::ostream& operator<<(std::ostream& out, simdjson::simdjson_result<simdjson::SIMDJSON_IMPLEMENTATION::ondemand::value> x);\n+#endif\n+/**\n+ * Print JSON to an output stream.\n+ *\n+ * @param out The output stream.\n+ * @param value The array.\n+ * @throw if there is an error with the underlying output stream. simdjson itself will not throw.\n+ */\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::array value);\n+#if SIMDJSON_EXCEPTIONS\n+inline std::ostream& operator<<(std::ostream& out, simdjson::simdjson_result<simdjson::SIMDJSON_IMPLEMENTATION::ondemand::array> x);\n+#endif\n+/**\n+ * Print JSON to an output stream.\n+ *\n+ * @param out The output stream.\n+ * @param value The array.\n+ * @throw if there is an error with the underlying output stream. simdjson itself will not throw.\n+ */\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::document& value);\n+#if SIMDJSON_EXCEPTIONS\n+inline std::ostream& operator<<(std::ostream& out, simdjson::simdjson_result<simdjson::SIMDJSON_IMPLEMENTATION::ondemand::document>&& x);\n+#endif\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::document_reference& value);\n+#if SIMDJSON_EXCEPTIONS\n+inline std::ostream& operator<<(std::ostream& out, simdjson::simdjson_result<simdjson::SIMDJSON_IMPLEMENTATION::ondemand::document_reference>&& x);\n+#endif\n+/**\n+ * Print JSON to an output stream.\n+ *\n+ * @param out The output stream.\n+ * @param value The object.\n+ * @throw if there is an error with the underlying output stream. simdjson itself will not throw.\n+ */\n+inline std::ostream& operator<<(std::ostream& out, simdjson::SIMDJSON_IMPLEMENTATION::ondemand::object value);\n+#if SIMDJSON_EXCEPTIONS\n+inline std::ostream& operator<<(std::ostream& out, simdjson::simdjson_result<simdjson::SIMDJSON_IMPLEMENTATION::ondemand::object> x);\n+#endif"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/token_iterator-inl.h",
        "status": "modified",
        "additions": 23,
        "deletions": 16,
        "changes": 39,
        "patch": "@@ -2,13 +2,20 @@ namespace simdjson {\n namespace SIMDJSON_IMPLEMENTATION {\n namespace ondemand {\n \n-simdjson_really_inline token_iterator::token_iterator(const uint8_t *_buf, token_position _index) noexcept\n-  : buf{_buf}, index{_index}\n+simdjson_really_inline token_iterator::token_iterator(\n+  const uint8_t *_buf,\n+  token_position position\n+) noexcept : buf{_buf}, _position{position}\n {\n }\n \n-simdjson_really_inline const uint8_t *token_iterator::advance() noexcept {\n-  return &buf[*(index++)];\n+simdjson_really_inline uint32_t token_iterator::current_offset() const noexcept {\n+  return *(_position);\n+}\n+\n+\n+simdjson_really_inline const uint8_t *token_iterator::return_current_and_advance() noexcept {\n+  return &buf[*(_position++)];\n }\n \n simdjson_really_inline const uint8_t *token_iterator::peek(token_position position) const noexcept {\n@@ -22,39 +29,39 @@ simdjson_really_inline uint32_t token_iterator::peek_length(token_position posit\n }\n \n simdjson_really_inline const uint8_t *token_iterator::peek(int32_t delta) const noexcept {\n-  return &buf[*(index+delta)];\n+  return &buf[*(_position+delta)];\n }\n simdjson_really_inline uint32_t token_iterator::peek_index(int32_t delta) const noexcept {\n-  return *(index+delta);\n+  return *(_position+delta);\n }\n simdjson_really_inline uint32_t token_iterator::peek_length(int32_t delta) const noexcept {\n-  return *(index+delta+1) - *(index+delta);\n+  return *(_position+delta+1) - *(_position+delta);\n }\n \n simdjson_really_inline token_position token_iterator::position() const noexcept {\n-  return index;\n+  return _position;\n }\n-simdjson_really_inline void token_iterator::set_position(token_position target_checkpoint) noexcept {\n-  index = target_checkpoint;\n+simdjson_really_inline void token_iterator::set_position(token_position target_position) noexcept {\n+  _position = target_position;\n }\n \n simdjson_really_inline bool token_iterator::operator==(const token_iterator &other) const noexcept {\n-  return index == other.index;\n+  return _position == other._position;\n }\n simdjson_really_inline bool token_iterator::operator!=(const token_iterator &other) const noexcept {\n-  return index != other.index;\n+  return _position != other._position;\n }\n simdjson_really_inline bool token_iterator::operator>(const token_iterator &other) const noexcept {\n-  return index > other.index;\n+  return _position > other._position;\n }\n simdjson_really_inline bool token_iterator::operator>=(const token_iterator &other) const noexcept {\n-  return index >= other.index;\n+  return _position >= other._position;\n }\n simdjson_really_inline bool token_iterator::operator<(const token_iterator &other) const noexcept {\n-  return index < other.index;\n+  return _position < other._position;\n }\n simdjson_really_inline bool token_iterator::operator<=(const token_iterator &other) const noexcept {\n-  return index <= other.index;\n+  return _position <= other._position;\n }\n \n } // namespace ondemand"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/token_iterator.h",
        "status": "modified",
        "additions": 9,
        "deletions": 10,
        "changes": 19,
        "patch": "@@ -23,11 +23,12 @@ class token_iterator {\n \n   /**\n    * Advance to the next token (returning the current one).\n-   *\n-   * Does not check or update depth/expect_value. Caller is responsible for that.\n    */\n-  simdjson_really_inline const uint8_t *advance() noexcept;\n-\n+  simdjson_really_inline const uint8_t *return_current_and_advance() noexcept;\n+  /**\n+   * Reports the current offset in bytes from the start of the underlying buffer.\n+   */\n+  simdjson_really_inline uint32_t current_offset() const noexcept;\n   /**\n    * Get the JSON text for a given token (relative).\n    *\n@@ -57,8 +58,6 @@ class token_iterator {\n    *\n    * @param position The position of the token.\n    *\n-   * TODO consider a string_view, assuming the length will get stripped out by the optimizer when\n-   * it isn't used ...\n    */\n   simdjson_really_inline const uint8_t *peek(token_position position) const noexcept;\n   /**\n@@ -71,13 +70,13 @@ class token_iterator {\n   simdjson_really_inline uint32_t peek_length(token_position position) const noexcept;\n \n   /**\n-   * Save the current index to be restored later.\n+   * Return the current index.\n    */\n   simdjson_really_inline token_position position() const noexcept;\n   /**\n    * Reset to a previously saved index.\n    */\n-  simdjson_really_inline void set_position(token_position target_checkpoint) noexcept;\n+  simdjson_really_inline void set_position(token_position target_position) noexcept;\n \n   // NOTE: we don't support a full C++ iterator interface, because we expect people to make\n   // different calls to advance the iterator based on *their own* state.\n@@ -90,7 +89,7 @@ class token_iterator {\n   simdjson_really_inline bool operator<=(const token_iterator &other) const noexcept;\n \n protected:\n-  simdjson_really_inline token_iterator(const uint8_t *buf, token_position index) noexcept;\n+  simdjson_really_inline token_iterator(const uint8_t *buf, token_position position) noexcept;\n \n   /**\n    * Get the index of the JSON text for a given token (relative).\n@@ -112,7 +111,7 @@ class token_iterator {\n   simdjson_really_inline uint32_t peek_index(token_position position) const noexcept;\n \n   const uint8_t *buf{};\n-  token_position index{};\n+  token_position _position{};\n \n   friend class json_iterator;\n   friend class value_iterator;"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/value-inl.h",
        "status": "modified",
        "additions": 103,
        "deletions": 2,
        "changes": 105,
        "patch": "@@ -36,12 +36,21 @@ simdjson_really_inline simdjson_result<std::string_view> value::get_string() noe\n simdjson_really_inline simdjson_result<double> value::get_double() noexcept {\n   return iter.get_double();\n }\n+simdjson_really_inline simdjson_result<double> value::get_double_in_string() noexcept {\n+  return iter.get_double_in_string();\n+}\n simdjson_really_inline simdjson_result<uint64_t> value::get_uint64() noexcept {\n   return iter.get_uint64();\n }\n+simdjson_really_inline simdjson_result<uint64_t> value::get_uint64_in_string() noexcept {\n+  return iter.get_uint64_in_string();\n+}\n simdjson_really_inline simdjson_result<int64_t> value::get_int64() noexcept {\n   return iter.get_int64();\n }\n+simdjson_really_inline simdjson_result<int64_t> value::get_int64_in_string() noexcept {\n+  return iter.get_int64_in_string();\n+}\n simdjson_really_inline simdjson_result<bool> value::get_bool() noexcept {\n   return iter.get_bool();\n }\n@@ -95,6 +104,20 @@ simdjson_really_inline simdjson_result<array_iterator> value::begin() & noexcept\n simdjson_really_inline simdjson_result<array_iterator> value::end() & noexcept {\n   return {};\n }\n+simdjson_really_inline simdjson_result<size_t> value::count_elements() & noexcept {\n+  simdjson_result<size_t> answer;\n+  auto a = get_array();\n+  answer = a.count_elements();\n+  // count_elements leaves you pointing inside the array, at the first element.\n+  // We need to move back so that the user can create a new array (which requires that\n+  // we point at '[').\n+  iter.move_at_start();\n+  return answer;\n+}\n+simdjson_really_inline simdjson_result<value> value::at(size_t index) noexcept {\n+  auto a = get_array();\n+  return a.at(index);\n+}\n \n simdjson_really_inline simdjson_result<value> value::find_field(std::string_view key) noexcept {\n   return start_or_resume_object().find_field(key);\n@@ -121,10 +144,45 @@ simdjson_really_inline simdjson_result<json_type> value::type() noexcept {\n   return iter.type();\n }\n \n+simdjson_really_inline simdjson_result<bool> value::is_scalar() noexcept {\n+  json_type this_type;\n+  auto error = type().get(this_type);\n+  if(error) { return error; }\n+  return ! ((this_type == json_type::array) || (this_type == json_type::object));\n+}\n+\n+simdjson_really_inline bool value::is_negative() noexcept {\n+  return iter.is_negative();\n+}\n+\n+simdjson_really_inline simdjson_result<bool> value::is_integer() noexcept {\n+  return iter.is_integer();\n+}\n+simdjson_warn_unused simdjson_really_inline simdjson_result<number_type> value::get_number_type() noexcept {\n+  return iter.get_number_type();\n+}\n+simdjson_warn_unused simdjson_really_inline simdjson_result<number> value::get_number() noexcept {\n+  return iter.get_number();\n+}\n+\n simdjson_really_inline std::string_view value::raw_json_token() noexcept {\n   return std::string_view(reinterpret_cast<const char*>(iter.peek_start()), iter.peek_start_length());\n }\n \n+simdjson_really_inline simdjson_result<value> value::at_pointer(std::string_view json_pointer) noexcept {\n+  json_type t;\n+  SIMDJSON_TRY(type().get(t));\n+  switch (t)\n+  {\n+    case json_type::array:\n+      return (*this).get_array().at_pointer(json_pointer);\n+    case json_type::object:\n+      return (*this).get_object().at_pointer(json_pointer);\n+    default:\n+      return INVALID_JSON_POINTER;\n+  }\n+}\n+\n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n@@ -145,7 +203,14 @@ simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>\n     implementation_simdjson_result_base<SIMDJSON_IMPLEMENTATION::ondemand::value>(error)\n {\n }\n-\n+simdjson_really_inline simdjson_result<size_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::count_elements() & noexcept {\n+  if (error()) { return error(); }\n+  return first.count_elements();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::at(size_t index) noexcept {\n+  if (error()) { return error(); }\n+  return first.at(index);\n+}\n simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::begin() & noexcept {\n   if (error()) { return error(); }\n   return first.begin();\n@@ -194,14 +259,26 @@ simdjson_really_inline simdjson_result<uint64_t> simdjson_result<SIMDJSON_IMPLEM\n   if (error()) { return error(); }\n   return first.get_uint64();\n }\n+simdjson_really_inline simdjson_result<uint64_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_uint64_in_string() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_uint64_in_string();\n+}\n simdjson_really_inline simdjson_result<int64_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_int64() noexcept {\n   if (error()) { return error(); }\n   return first.get_int64();\n }\n+simdjson_really_inline simdjson_result<int64_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_int64_in_string() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_int64_in_string();\n+}\n simdjson_really_inline simdjson_result<double> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_double() noexcept {\n   if (error()) { return error(); }\n   return first.get_double();\n }\n+simdjson_really_inline simdjson_result<double> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_double_in_string() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_double_in_string();\n+}\n simdjson_really_inline simdjson_result<std::string_view> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_string() noexcept {\n   if (error()) { return error(); }\n   return first.get_string();\n@@ -242,7 +319,26 @@ simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::json_t\n   if (error()) { return error(); }\n   return first.type();\n }\n-\n+simdjson_really_inline simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::is_scalar() noexcept {\n+  if (error()) { return error(); }\n+  return first.is_scalar();\n+}\n+simdjson_really_inline simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::is_negative() noexcept {\n+  if (error()) { return error(); }\n+  return first.is_negative();\n+}\n+simdjson_really_inline simdjson_result<bool> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::is_integer() noexcept {\n+  if (error()) { return error(); }\n+  return first.is_integer();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number_type> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_number_type() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_number_type();\n+}\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_number() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_number();\n+}\n #if SIMDJSON_EXCEPTIONS\n simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::operator SIMDJSON_IMPLEMENTATION::ondemand::array() noexcept(false) {\n   if (error()) { throw simdjson_error(error()); }\n@@ -283,4 +379,9 @@ simdjson_really_inline simdjson_result<std::string_view> simdjson_result<SIMDJSO\n   return first.raw_json_token();\n }\n \n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::at_pointer(std::string_view json_pointer) noexcept {\n+  if (error()) { return error(); }\n+  return first.at_pointer(json_pointer);\n+}\n+\n } // namespace simdjson"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/value.h",
        "status": "modified",
        "additions": 180,
        "deletions": 4,
        "changes": 184,
        "patch": "@@ -69,11 +69,19 @@ class value {\n   /**\n    * Cast this JSON value to an unsigned integer.\n    *\n-   * @returns A signed 64-bit integer.\n+   * @returns A unsigned 64-bit integer.\n    * @returns INCORRECT_TYPE If the JSON value is not a 64-bit unsigned integer.\n    */\n   simdjson_really_inline simdjson_result<uint64_t> get_uint64() noexcept;\n \n+  /**\n+   * Cast this JSON value (inside string) to a unsigned integer.\n+   *\n+   * @returns A unsigned 64-bit integer.\n+   * @returns INCORRECT_TYPE If the JSON value is not a 64-bit unsigned integer.\n+   */\n+  simdjson_really_inline simdjson_result<uint64_t> get_uint64_in_string() noexcept;\n+\n   /**\n    * Cast this JSON value to a signed integer.\n    *\n@@ -82,6 +90,14 @@ class value {\n    */\n   simdjson_really_inline simdjson_result<int64_t> get_int64() noexcept;\n \n+  /**\n+   * Cast this JSON value (inside string) to a signed integer.\n+   *\n+   * @returns A signed 64-bit integer.\n+   * @returns INCORRECT_TYPE If the JSON value is not a 64-bit integer.\n+   */\n+  simdjson_really_inline simdjson_result<int64_t> get_int64_in_string() noexcept;\n+\n   /**\n    * Cast this JSON value to a double.\n    *\n@@ -90,6 +106,14 @@ class value {\n    */\n   simdjson_really_inline simdjson_result<double> get_double() noexcept;\n \n+  /**\n+   * Cast this JSON value (inside string) to a double\n+   *\n+   * @returns A double.\n+   * @returns INCORRECT_TYPE If the JSON value is not a valid floating-point number.\n+   */\n+  simdjson_really_inline simdjson_result<double> get_double_in_string() noexcept;\n+\n   /**\n    * Cast this JSON value to a string.\n    *\n@@ -208,7 +232,26 @@ class value {\n    * Part of the std::iterable interface.\n    */\n   simdjson_really_inline simdjson_result<array_iterator> end() & noexcept;\n-\n+  /**\n+   * This method scans the array and counts the number of elements.\n+   * The count_elements method should always be called before you have begun\n+   * iterating through the array: it is expected that you are pointing at\n+   * the beginning of the array.\n+   * The runtime complexity is linear in the size of the array. After\n+   * calling this function, if successful, the array is 'rewinded' at its\n+   * beginning as if it had never been accessed. If the JSON is malformed (e.g.,\n+   * there is a missing comma), then an error is returned and it is no longer\n+   * safe to continue.\n+   */\n+  simdjson_really_inline simdjson_result<size_t> count_elements() & noexcept;\n+  /**\n+   * Get the value at the given index in the array. This function has linear-time complexity.\n+   * This function should only be called once as the array iterator is not reset between each call.\n+   *\n+   * @return The value at the given index, or:\n+   *         - INDEX_OUT_OF_BOUNDS if the array index is larger than an array length\n+   */\n+  simdjson_really_inline simdjson_result<value> at(size_t index) noexcept;\n   /**\n    * Look up a field by name on an object (order-sensitive).\n    *\n@@ -278,6 +321,85 @@ class value {\n    */\n   simdjson_really_inline simdjson_result<json_type> type() noexcept;\n \n+  /**\n+   * Checks whether the value is a scalar (string, number, null, Boolean).\n+   * Returns false when there it is an array or object.\n+   *\n+   * @returns true if the type is string, number, null, Boolean\n+   * @error TAPE_ERROR when the JSON value is a bad token like \"}\" \",\" or \"alse\".\n+   */\n+  simdjson_really_inline simdjson_result<bool> is_scalar() noexcept;\n+\n+  /**\n+   * Checks whether the value is a negative number.\n+   *\n+   * @returns true if the number if negative.\n+   */\n+  simdjson_really_inline bool is_negative() noexcept;\n+  /**\n+   * Checks whether the value is an integer number. Note that\n+   * this requires to partially parse the number string. If\n+   * the value is determined to be an integer, it may still\n+   * not parse properly as an integer in subsequent steps\n+   * (e.g., it might overflow).\n+   *\n+   * Performance note: if you call this function systematically\n+   * before parsing a number, you may have fallen for a performance\n+   * anti-pattern.\n+   *\n+   * @returns true if the number if negative.\n+   */\n+  simdjson_really_inline simdjson_result<bool> is_integer() noexcept;\n+  /**\n+   * Determine the number type (integer or floating-point number).\n+   *\n+   * get_number_type() is number_type::unsigned_integer if we have\n+   * an integer greater or equal to 9223372036854775808\n+   * get_number_type() is number_type::signed_integer if we have an\n+   * integer that is less than 9223372036854775808\n+   * Otherwise, get_number_type() has value number_type::floating_point_number\n+   *\n+   * This function requires processing the number string, but it is expected\n+   * to be faster than get_number().get_number_type() because it is does not\n+   * parse the number value.\n+   *\n+   * @returns the type of the number\n+   */\n+  simdjson_really_inline simdjson_result<number_type> get_number_type() noexcept;\n+\n+  /**\n+   * Attempt to parse an ondemand::number. An ondemand::number may\n+   * contain an integer value or a floating-point value, the simdjson\n+   * library will autodetect the type. Thus it is a dynamically typed\n+   * number. Before accessing the value, you must determine the detected\n+   * type.\n+   *\n+   * number.get_number_type() is number_type::signed_integer if we have\n+   * a integer in [-9223372036854775808,9223372036854775808)\n+   * You can recover the value by calling number.get_int64() and you\n+   * have that number.is_int64() is true.\n+   *\n+   * number.get_number_type() is number_type::unsigned_integer if we have\n+   * an integer in [9223372036854775808,18446744073709551616)\n+   * You can recover the value by calling number.get_uint64() and you\n+   * have that number.is_uint64() is true.\n+   *\n+   * Otherwise, number.get_number_type() has value number_type::floating_point_number\n+   * and we have a binary64 number.\n+   * You can recover the value by calling number.get_double() and you\n+   * have that number.is_double() is true.\n+   *\n+   * You must check the type before accessing the value: it is an error\n+   * to call \"get_int64()\" when number.get_number_type() is not\n+   * number_type::signed_integer and when number.is_int64() is false.\n+   *\n+   * Performance note: this is designed with performance in mind. When\n+   * calling 'get_number()', you scan the number string only once, determining\n+   * efficiently the type and storing it in an efficient manner.\n+   */\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<number> get_number() noexcept;\n+\n+\n   /**\n    * Get the raw JSON for this token.\n    *\n@@ -303,6 +425,50 @@ class value {\n    */\n   simdjson_really_inline std::string_view raw_json_token() noexcept;\n \n+  /**\n+   * Get the value associated with the given JSON pointer.  We use the RFC 6901\n+   * https://tools.ietf.org/html/rfc6901 standard.\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"foo\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"/foo/a/1\") == 20\n+   *\n+   * It is allowed for a key to be the empty string:\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"//a/1\") == 20\n+   *\n+   * Note that at_pointer() called on the document automatically calls the document's rewind\n+   * method between each call. It invalidates all previously accessed arrays, objects and values\n+   * that have not been consumed.\n+   *\n+   * Calling at_pointer() on non-document instances (e.g., arrays and objects) is not\n+   * standardized (by RFC 6901). We provide some experimental support for JSON pointers\n+   * on non-document instances.  Yet it is not the case when calling at_pointer on an array\n+   * or an object instance: there is no rewind and no invalidation.\n+   *\n+   * You may only call at_pointer on an array after it has been created, but before it has\n+   * been first accessed. When calling at_pointer on an array, the pointer is advanced to\n+   * the location indicated by the JSON pointer (in case of success). It is no longer possible\n+   * to call at_pointer on the same array.\n+   *\n+   * You may call at_pointer more than once on an object, but each time the pointer is advanced\n+   * to be within the value matched by the key indicated by the JSON pointer query. Thus any preceeding\n+   * key (as well as the current key) can no longer be used with following JSON pointer calls.\n+   *\n+   * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching\n+   *\n+   * @return The value associated with the given JSON pointer, or:\n+   *         - NO_SUCH_FIELD if a field does not exist in an object\n+   *         - INDEX_OUT_OF_BOUNDS if an array index is larger than an array length\n+   *         - INCORRECT_TYPE if a non-integer is used to access an array\n+   *         - INVALID_JSON_POINTER if the JSON pointer is invalid and cannot be parsed\n+   */\n+  simdjson_really_inline simdjson_result<value> at_pointer(std::string_view json_pointer) noexcept;\n+\n protected:\n   /**\n    * Create a value.\n@@ -341,7 +507,6 @@ class value {\n   friend class field;\n   friend class object;\n   friend struct simdjson_result<value>;\n-  friend struct simdjson_result<document>;\n   friend struct simdjson_result<field>;\n };\n \n@@ -362,8 +527,11 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> : public SIMDJS\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> get_object() noexcept;\n \n   simdjson_really_inline simdjson_result<uint64_t> get_uint64() noexcept;\n+  simdjson_really_inline simdjson_result<uint64_t> get_uint64_in_string() noexcept;\n   simdjson_really_inline simdjson_result<int64_t> get_int64() noexcept;\n+  simdjson_really_inline simdjson_result<int64_t> get_int64_in_string() noexcept;\n   simdjson_really_inline simdjson_result<double> get_double() noexcept;\n+  simdjson_really_inline simdjson_result<double> get_double_in_string() noexcept;\n   simdjson_really_inline simdjson_result<std::string_view> get_string() noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::raw_json_string> get_raw_json_string() noexcept;\n   simdjson_really_inline simdjson_result<bool> get_bool() noexcept;\n@@ -383,7 +551,8 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> : public SIMDJS\n   simdjson_really_inline operator SIMDJSON_IMPLEMENTATION::ondemand::raw_json_string() noexcept(false);\n   simdjson_really_inline operator bool() noexcept(false);\n #endif\n-\n+  simdjson_really_inline simdjson_result<size_t> count_elements() & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at(size_t index) noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> begin() & noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> end() & noexcept;\n \n@@ -446,9 +615,16 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> : public SIMDJS\n    * let it throw an exception).\n    */\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::json_type> type() noexcept;\n+  simdjson_really_inline simdjson_result<bool> is_scalar() noexcept;\n+  simdjson_really_inline simdjson_result<bool> is_negative() noexcept;\n+  simdjson_really_inline simdjson_result<bool> is_integer() noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number_type> get_number_type() noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number> get_number() noexcept;\n \n   /** @copydoc simdjson_really_inline std::string_view value::raw_json_token() const noexcept */\n   simdjson_really_inline simdjson_result<std::string_view> raw_json_token() noexcept;\n+\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at_pointer(std::string_view json_pointer) noexcept;\n };\n \n } // namespace simdjson"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/value_iterator-inl.h",
        "status": "modified",
        "additions": 380,
        "deletions": 119,
        "changes": 499,
        "patch": "@@ -2,54 +2,73 @@ namespace simdjson {\n namespace SIMDJSON_IMPLEMENTATION {\n namespace ondemand {\n \n-simdjson_really_inline value_iterator::value_iterator(json_iterator *json_iter, depth_t depth, token_position start_index) noexcept\n-  : _json_iter{json_iter},\n-    _depth{depth},\n-    _start_position{start_index}\n+simdjson_really_inline value_iterator::value_iterator(\n+  json_iterator *json_iter,\n+  depth_t depth,\n+  token_position start_position\n+) noexcept : _json_iter{json_iter}, _depth{depth}, _start_position{start_position}\n {\n }\n \n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::start_object() noexcept {\n-  const uint8_t *json;\n-  SIMDJSON_TRY( advance_container_start(\"object\", json) );\n-  if (*json != '{') { return incorrect_type_error(\"Not an object\"); }\n+  SIMDJSON_TRY( start_container('{', \"Not an object\", \"object\") );\n   return started_object();\n }\n \n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::start_root_object() noexcept {\n-  bool result;\n-  SIMDJSON_TRY( start_object().get(result) );\n-  if (*_json_iter->peek_last() != '}') { return _json_iter->report_error(TAPE_ERROR, \"object invalid: { at beginning of document unmatched by } at end of document\"); }\n-  return result;\n+  SIMDJSON_TRY( start_container('{', \"Not an object\", \"object\") );\n+  return started_root_object();\n }\n \n-simdjson_warn_unused simdjson_really_inline bool value_iterator::started_object() noexcept {\n+simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::started_object() noexcept {\n   assert_at_container_start();\n #ifdef SIMDJSON_DEVELOPMENT_CHECKS\n-  _json_iter->set_start_position(_depth, _start_position);\n+  _json_iter->set_start_position(_depth, start_position());\n #endif\n   if (*_json_iter->peek() == '}') {\n     logger::log_value(*_json_iter, \"empty object\");\n-    _json_iter->advance();\n-    _json_iter->ascend_to(depth()-1);\n+    _json_iter->return_current_and_advance();\n+    end_container();\n     return false;\n   }\n-  logger::log_start_value(*_json_iter, \"object\");\n   return true;\n }\n \n+simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::started_root_object() noexcept {\n+  // When in streaming mode, we cannot expect peek_last() to be the last structural element of the\n+  // current document. It only works in the normal mode where we have indexed a single document.\n+  // Note that adding a check for 'streaming' is not expensive since we only have at most\n+  // one root element.\n+  if (! _json_iter->streaming() && (*_json_iter->peek_last() != '}')) {\n+    _json_iter->abandon();\n+    return report_error(INCOMPLETE_ARRAY_OR_OBJECT, \"missing } at end\");\n+  }\n+  return started_object();\n+}\n+\n+simdjson_warn_unused simdjson_really_inline error_code value_iterator::end_container() noexcept {\n+#if SIMDJSON_CHECK_EOF\n+    if (depth() > 1 && at_end()) { return report_error(INCOMPLETE_ARRAY_OR_OBJECT, \"missing parent ] or }\"); }\n+    // if (depth() <= 1 && !at_end()) { return report_error(INCOMPLETE_ARRAY_OR_OBJECT, \"missing [ or { at start\"); }\n+#endif // SIMDJSON_CHECK_EOF\n+    _json_iter->ascend_to(depth()-1);\n+    return SUCCESS;\n+}\n+\n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::has_next_field() noexcept {\n   assert_at_next();\n \n-  switch (*_json_iter->advance()) {\n+  // It's illegal to call this unless there are more tokens: anything that ends in } or ] is\n+  // obligated to verify there are more tokens if they are not the top level.\n+  switch (*_json_iter->return_current_and_advance()) {\n     case '}':\n       logger::log_end_value(*_json_iter, \"object\");\n-      _json_iter->ascend_to(depth()-1);\n+      SIMDJSON_TRY( end_container() );\n       return false;\n     case ',':\n       return true;\n     default:\n-      return _json_iter->report_error(TAPE_ERROR, \"Missing comma between object fields\");\n+      return report_error(TAPE_ERROR, \"Missing comma between object fields\");\n   }\n }\n \n@@ -65,7 +84,6 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator\n   //    { \"a\": [ 1, 2 ], \"b\": [ 3, 4 ] }\n   //      ^ (depth 2, index 1)\n   //    ```\n-  //\n   if (at_first_field()) {\n     has_value = true;\n \n@@ -86,7 +104,7 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator\n     // this object iterator will blithely scan that object for fields.\n     if (_json_iter->depth() < depth() - 1) { return OUT_OF_ORDER_ITERATION; }\n #endif\n-    has_value = false;\n+    return false;\n \n   // 3. When a previous search found a field or an iterator yielded a value:\n   //\n@@ -106,15 +124,19 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator\n     if ((error = skip_child() )) { abandon(); return error; }\n     if ((error = has_next_field().get(has_value) )) { abandon(); return error; }\n #ifdef SIMDJSON_DEVELOPMENT_CHECKS\n-    if (_json_iter->start_position(_depth) != _start_position) { return OUT_OF_ORDER_ITERATION; }\n+    if (_json_iter->start_position(_depth) != start_position()) { return OUT_OF_ORDER_ITERATION; }\n #endif\n   }\n   while (has_value) {\n     // Get the key and colon, stopping at the value.\n     raw_json_string actual_key;\n     // size_t max_key_length = _json_iter->peek_length() - 2; // -2 for the two quotes\n+    // Note: _json_iter->peek_length() - 2 might overflow if _json_iter->peek_length() < 2.\n+    // field_key() advances the pointer and checks that '\"' is found (corresponding to a key).\n+    // The depth is left unchanged by field_key().\n     if ((error = field_key().get(actual_key) )) { abandon(); return error; };\n-\n+    // field_value() will advance and check that we find a ':' separating the\n+    // key and the value. It will also increment the depth by one.\n     if ((error = field_value() )) { abandon(); return error; }\n     // If it matches, stop and return\n     // We could do it this way if we wanted to allow arbitrary\n@@ -126,20 +148,25 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator\n     // input).\n     if (actual_key.unsafe_is_equal(key)) {\n       logger::log_event(*this, \"match\", key, -2);\n+      // If we return here, then we return while pointing at the ':' that we just checked.\n       return true;\n     }\n \n     // No match: skip the value and see if , or } is next\n     logger::log_event(*this, \"no match\", key, -2);\n+    // The call to skip_child is meant to skip over the value corresponding to the key.\n+    // After skip_child(), we are right before the next comma (',') or the final brace ('}').\n     SIMDJSON_TRY( skip_child() ); // Skip the value entirely\n+    // The has_next_field() advances the pointer and check that either ',' or '}' is found.\n+    // It returns true if ',' is found, false otherwise. If anything other than ',' or '}' is found,\n+    // then we are in error and we abort.\n     if ((error = has_next_field().get(has_value) )) { abandon(); return error; }\n   }\n \n   // If the loop ended, we're out of fields to look at.\n   return false;\n }\n \n-\n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::find_field_unordered_raw(const std::string_view key) noexcept {\n   /**\n    * When find_field_unordered_raw is called, we can either be pointing at the\n@@ -187,9 +214,8 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator\n     // this object iterator will blithely scan that object for fields.\n     if (_json_iter->depth() < depth() - 1) { return OUT_OF_ORDER_ITERATION; }\n #endif\n-    _json_iter->reenter_child(_start_position + 1, _depth);\n+    SIMDJSON_TRY(reset_object().get(has_value));\n     at_first = true;\n-    has_value = started_object();\n   // 3. When a previous search found a field or an iterator yielded a value:\n   //\n   //    ```\n@@ -205,17 +231,14 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator\n   //    ```\n   //\n   } else {\n-    // If someone queried a key but they did access the value, then we are left pointing\n+    // If someone queried a key but they not did access the value, then we are left pointing\n     // at the ':' and we need to move forward through the value... If the value was\n     // processed then skip_child() does not move the iterator (but may adjust the depth).\n     if ((error = skip_child() )) { abandon(); return error; }\n     search_start = _json_iter->position();\n-    // The has_next_field() advances the pointer and check that either ',' or '}' is found.\n-    // It returns true if ',' is found, false otherwise. If anything other than ',' or '}' is found,\n-    // then we are in error and we abort.\n     if ((error = has_next_field().get(has_value) )) { abandon(); return error; }\n #ifdef SIMDJSON_DEVELOPMENT_CHECKS\n-    if (_json_iter->start_position(_depth) != _start_position) { return OUT_OF_ORDER_ITERATION; }\n+    if (_json_iter->start_position(_depth) != start_position()) { return OUT_OF_ORDER_ITERATION; }\n #endif\n   }\n \n@@ -232,14 +255,14 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator\n   //                                  ^ (depth 0)\n   // ```\n   //\n-\n   // Next, we find a match starting from the current position.\n   while (has_value) {\n     SIMDJSON_ASSUME( _json_iter->_depth == _depth ); // We must be at the start of a field\n \n     // Get the key and colon, stopping at the value.\n     raw_json_string actual_key;\n     // size_t max_key_length = _json_iter->peek_length() - 2; // -2 for the two quotes\n+    // Note: _json_iter->peek_length() - 2 might overflow if _json_iter->peek_length() < 2.\n     // field_key() advances the pointer and checks that '\"' is found (corresponding to a key).\n     // The depth is left unchanged by field_key().\n     if ((error = field_key().get(actual_key) )) { abandon(); return error; };\n@@ -281,15 +304,15 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator\n   // beginning of the object.\n   // (We have already run through the object before, so we've already validated its structure. We\n   // don't check errors in this bit.)\n-  _json_iter->reenter_child(_start_position + 1, _depth);\n-  has_value = started_object();\n+  SIMDJSON_TRY(reset_object().get(has_value));\n   while (true) {\n     SIMDJSON_ASSUME(has_value); // we should reach search_start before ever reaching the end of the object\n     SIMDJSON_ASSUME( _json_iter->_depth == _depth ); // We must be at the start of a field\n \n     // Get the key and colon, stopping at the value.\n     raw_json_string actual_key;\n     // size_t max_key_length = _json_iter->peek_length() - 2; // -2 for the two quotes\n+    // Note: _json_iter->peek_length() - 2 might overflow if _json_iter->peek_length() < 2.\n     // field_key() advances the pointer and checks that '\"' is found (corresponding to a key).\n     // The depth is left unchanged by field_key().\n     error = field_key().get(actual_key); SIMDJSON_ASSUME(!error);\n@@ -335,62 +358,77 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator\n simdjson_warn_unused simdjson_really_inline simdjson_result<raw_json_string> value_iterator::field_key() noexcept {\n   assert_at_next();\n \n-  const uint8_t *key = _json_iter->advance();\n-  if (*(key++) != '\"') { return _json_iter->report_error(TAPE_ERROR, \"Object key is not a string\"); }\n+  const uint8_t *key = _json_iter->return_current_and_advance();\n+  if (*(key++) != '\"') { return report_error(TAPE_ERROR, \"Object key is not a string\"); }\n   return raw_json_string(key);\n }\n \n simdjson_warn_unused simdjson_really_inline error_code value_iterator::field_value() noexcept {\n   assert_at_next();\n \n-  if (*_json_iter->advance() != ':') { return _json_iter->report_error(TAPE_ERROR, \"Missing colon in object field\"); }\n+  if (*_json_iter->return_current_and_advance() != ':') { return report_error(TAPE_ERROR, \"Missing colon in object field\"); }\n   _json_iter->descend_to(depth()+1);\n   return SUCCESS;\n }\n \n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::start_array() noexcept {\n-  const uint8_t *json;\n-  SIMDJSON_TRY( advance_container_start(\"array\", json) );\n-  if (*json != '[') { return incorrect_type_error(\"Not an array\"); }\n+  SIMDJSON_TRY( start_container('[', \"Not an array\", \"array\") );\n   return started_array();\n }\n \n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::start_root_array() noexcept {\n-  bool result;\n-  SIMDJSON_TRY( start_array().get(result) );\n-  if (*_json_iter->peek_last() != ']') { return _json_iter->report_error(TAPE_ERROR, \"array invalid: [ at beginning of document unmatched by ] at end of document\"); }\n-  return result;\n+  SIMDJSON_TRY( start_container('[', \"Not an array\", \"array\") );\n+  return started_root_array();\n }\n \n-simdjson_warn_unused simdjson_really_inline bool value_iterator::started_array() noexcept {\n+inline std::string value_iterator::to_string() const noexcept {\n+  auto answer = std::string(\"value_iterator [ depth : \") + std::to_string(_depth) + std::string(\", \");\n+  if(_json_iter != nullptr) { answer +=  _json_iter->to_string(); }\n+  answer += std::string(\" ]\");\n+  return answer;\n+}\n+\n+simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::started_array() noexcept {\n   assert_at_container_start();\n   if (*_json_iter->peek() == ']') {\n     logger::log_value(*_json_iter, \"empty array\");\n-    _json_iter->advance();\n-    _json_iter->ascend_to(depth()-1);\n+    _json_iter->return_current_and_advance();\n+    SIMDJSON_TRY( end_container() );\n     return false;\n   }\n-  logger::log_start_value(*_json_iter, \"array\");\n   _json_iter->descend_to(depth()+1);\n #ifdef SIMDJSON_DEVELOPMENT_CHECKS\n-  _json_iter->set_start_position(_depth, _start_position);\n+  _json_iter->set_start_position(_depth, start_position());\n #endif\n   return true;\n }\n \n+simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::started_root_array() noexcept {\n+  // When in streaming mode, we cannot expect peek_last() to be the last structural element of the\n+  // current document. It only works in the normal mode where we have indexed a single document.\n+  // Note that adding a check for 'streaming' is not expensive since we only have at most\n+  // one root element.\n+  if ( ! _json_iter->streaming() && (*_json_iter->peek_last() != ']')) {\n+    _json_iter->abandon();\n+    return report_error(INCOMPLETE_ARRAY_OR_OBJECT, \"missing ] at end\");\n+  }\n+  return started_array();\n+}\n+\n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::has_next_element() noexcept {\n   assert_at_next();\n \n-  switch (*_json_iter->advance()) {\n+  logger::log_event(*this, \"has_next_element\");\n+  switch (*_json_iter->return_current_and_advance()) {\n     case ']':\n       logger::log_end_value(*_json_iter, \"array\");\n-      _json_iter->ascend_to(depth()-1);\n+      SIMDJSON_TRY( end_container() );\n       return false;\n     case ',':\n       _json_iter->descend_to(depth()+1);\n       return true;\n     default:\n-      return _json_iter->report_error(TAPE_ERROR, \"Missing comma between array elements\");\n+      return report_error(TAPE_ERROR, \"Missing comma between array elements\");\n   }\n }\n \n@@ -409,27 +447,110 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<std::string_view> va\n   return get_raw_json_string().unescape(_json_iter->string_buf_loc());\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<raw_json_string> value_iterator::get_raw_json_string() noexcept {\n-  auto json = advance_start(\"string\");\n+  auto json = peek_scalar(\"string\");\n   if (*json != '\"') { return incorrect_type_error(\"Not a string\"); }\n+  advance_scalar(\"string\");\n   return raw_json_string(json+1);\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> value_iterator::get_uint64() noexcept {\n-  return numberparsing::parse_unsigned(advance_non_root_scalar(\"uint64\"));\n+  auto result = numberparsing::parse_unsigned(peek_non_root_scalar(\"uint64\"));\n+  if(result.error() == SUCCESS) { advance_non_root_scalar(\"uint64\"); }\n+  return result;\n+}\n+simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> value_iterator::get_uint64_in_string() noexcept {\n+  auto result = numberparsing::parse_unsigned_in_string(peek_non_root_scalar(\"uint64\"));\n+  if(result.error() == SUCCESS) { advance_non_root_scalar(\"uint64\"); }\n+  return result;\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> value_iterator::get_int64() noexcept {\n-  return numberparsing::parse_integer(advance_non_root_scalar(\"int64\"));\n+  auto result = numberparsing::parse_integer(peek_non_root_scalar(\"int64\"));\n+  if(result.error() == SUCCESS) { advance_non_root_scalar(\"int64\"); }\n+  return result;\n+}\n+simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> value_iterator::get_int64_in_string() noexcept {\n+  auto result = numberparsing::parse_integer_in_string(peek_non_root_scalar(\"int64\"));\n+  if(result.error() == SUCCESS) { advance_non_root_scalar(\"int64\"); }\n+  return result;\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<double> value_iterator::get_double() noexcept {\n-  return numberparsing::parse_double(advance_non_root_scalar(\"double\"));\n+  auto result = numberparsing::parse_double(peek_non_root_scalar(\"double\"));\n+  if(result.error() == SUCCESS) { advance_non_root_scalar(\"double\"); }\n+  return result;\n+}\n+simdjson_warn_unused simdjson_really_inline simdjson_result<double> value_iterator::get_double_in_string() noexcept {\n+  auto result = numberparsing::parse_double_in_string(peek_non_root_scalar(\"double\"));\n+  if(result.error() == SUCCESS) { advance_non_root_scalar(\"double\"); }\n+  return result;\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::get_bool() noexcept {\n-  return parse_bool(advance_non_root_scalar(\"bool\"));\n+  auto result = parse_bool(peek_non_root_scalar(\"bool\"));\n+  if(result.error() == SUCCESS) { advance_non_root_scalar(\"bool\"); }\n+  return result;\n }\n simdjson_really_inline bool value_iterator::is_null() noexcept {\n-  return parse_null(advance_non_root_scalar(\"null\"));\n+  auto result = parse_null(peek_non_root_scalar(\"null\"));\n+  if(result) { advance_non_root_scalar(\"null\"); }\n+  return result;\n+}\n+simdjson_really_inline bool value_iterator::is_negative() noexcept {\n+  return numberparsing::is_negative(peek_non_root_scalar(\"numbersign\"));\n+}\n+simdjson_really_inline bool value_iterator::is_root_negative() noexcept {\n+  return numberparsing::is_negative(peek_root_scalar(\"numbersign\"));\n+}\n+simdjson_really_inline simdjson_result<bool> value_iterator::is_integer() noexcept {\n+  return numberparsing::is_integer(peek_non_root_scalar(\"integer\"));\n+}\n+simdjson_really_inline simdjson_result<number_type> value_iterator::get_number_type() noexcept {\n+  return numberparsing::get_number_type(peek_non_root_scalar(\"integer\"));\n+}\n+simdjson_really_inline simdjson_result<number> value_iterator::get_number() noexcept {\n+  number num;\n+  error_code error =  numberparsing::parse_number(peek_non_root_scalar(\"number\"), num);\n+  if(error) { return error; }\n+  return num;\n }\n \n-constexpr const uint32_t MAX_INT_LENGTH = 1024;\n+simdjson_really_inline simdjson_result<bool> value_iterator::is_root_integer() noexcept {\n+  auto max_len = peek_start_length();\n+  auto json = peek_root_scalar(\"is_root_integer\");\n+  uint8_t tmpbuf[20+1]; // <20 digits> is the longest possible unsigned integer\n+  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) {\n+    return false; // if there are more than 20 characters, it cannot be represented as an integer.\n+  }\n+  return numberparsing::is_integer(tmpbuf);\n+}\n+\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::number_type> value_iterator::get_root_number_type() noexcept {\n+  auto max_len = peek_start_length();\n+  auto json = peek_root_scalar(\"number\");\n+  // Per https://www.exploringbinary.com/maximum-number-of-decimal-digits-in-binary-floating-point-numbers/,\n+  // 1074 is the maximum number of significant fractional digits. Add 8 more digits for the biggest\n+  // number: -0.<fraction>e-308.\n+  uint8_t tmpbuf[1074+8+1];\n+  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) {\n+    logger::log_error(*_json_iter, start_position(), depth(), \"Root number more than 1082 characters\");\n+    return NUMBER_ERROR;\n+  }\n+  return numberparsing::get_number_type(tmpbuf);\n+}\n+simdjson_really_inline simdjson_result<number> value_iterator::get_root_number() noexcept {\n+  auto max_len = peek_start_length();\n+  auto json = peek_root_scalar(\"number\");\n+  // Per https://www.exploringbinary.com/maximum-number-of-decimal-digits-in-binary-floating-point-numbers/,\n+  // 1074 is the maximum number of significant fractional digits. Add 8 more digits for the biggest\n+  // number: -0.<fraction>e-308.\n+  uint8_t tmpbuf[1074+8+1];\n+  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) {\n+    logger::log_error(*_json_iter, start_position(), depth(), \"Root number more than 1082 characters\");\n+    return NUMBER_ERROR;\n+  }\n+  number num;\n+  error_code error =  numberparsing::parse_number(tmpbuf, num);\n+  if(error) { return error; }\n+  advance_root_scalar(\"number\");\n+  return num;\n+}\n \n simdjson_warn_unused simdjson_really_inline simdjson_result<std::string_view> value_iterator::get_root_string() noexcept {\n   return get_string();\n@@ -439,42 +560,105 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<raw_json_string> val\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> value_iterator::get_root_uint64() noexcept {\n   auto max_len = peek_start_length();\n-  auto json = advance_root_scalar(\"uint64\");\n+  auto json = peek_root_scalar(\"uint64\");\n+  uint8_t tmpbuf[20+1]; // <20 digits> is the longest possible unsigned integer\n+  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) {\n+    logger::log_error(*_json_iter, start_position(), depth(), \"Root number more than 20 characters\");\n+    return NUMBER_ERROR;\n+  }\n+  auto result = numberparsing::parse_unsigned(tmpbuf);\n+  if(result.error() == SUCCESS) { advance_root_scalar(\"uint64\"); }\n+  return result;\n+}\n+simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> value_iterator::get_root_uint64_in_string() noexcept {\n+  auto max_len = peek_start_length();\n+  auto json = peek_root_scalar(\"uint64\");\n   uint8_t tmpbuf[20+1]; // <20 digits> is the longest possible unsigned integer\n-  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) { logger::log_error(*_json_iter, _start_position, depth(), \"Root number more than 20 characters\"); return NUMBER_ERROR; }\n-  return numberparsing::parse_unsigned(tmpbuf);\n+  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) {\n+    logger::log_error(*_json_iter, start_position(), depth(), \"Root number more than 20 characters\");\n+    return NUMBER_ERROR;\n+  }\n+  auto result = numberparsing::parse_unsigned_in_string(tmpbuf);\n+  if(result.error() == SUCCESS) { advance_root_scalar(\"uint64\"); }\n+  return result;\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> value_iterator::get_root_int64() noexcept {\n   auto max_len = peek_start_length();\n-  auto json = advance_root_scalar(\"int64\");\n+  auto json = peek_root_scalar(\"int64\");\n+  uint8_t tmpbuf[20+1]; // -<19 digits> is the longest possible integer\n+  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) {\n+    logger::log_error(*_json_iter, start_position(), depth(), \"Root number more than 20 characters\");\n+    return NUMBER_ERROR;\n+  }\n+\n+  auto result = numberparsing::parse_integer(tmpbuf);\n+  if(result.error() == SUCCESS) { advance_root_scalar(\"int64\"); }\n+  return result;\n+}\n+simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> value_iterator::get_root_int64_in_string() noexcept {\n+  auto max_len = peek_start_length();\n+  auto json = peek_root_scalar(\"int64\");\n   uint8_t tmpbuf[20+1]; // -<19 digits> is the longest possible integer\n-  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) { logger::log_error(*_json_iter, _start_position, depth(), \"Root number more than 20 characters\"); return NUMBER_ERROR; }\n-  return numberparsing::parse_integer(tmpbuf);\n+  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) {\n+    logger::log_error(*_json_iter, start_position(), depth(), \"Root number more than 20 characters\");\n+    return NUMBER_ERROR;\n+  }\n+\n+  auto result = numberparsing::parse_integer_in_string(tmpbuf);\n+  if(result.error() == SUCCESS) { advance_root_scalar(\"int64\"); }\n+  return result;\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<double> value_iterator::get_root_double() noexcept {\n   auto max_len = peek_start_length();\n-  auto json = advance_root_scalar(\"double\");\n-  // Per https://www.exploringbinary.com/maximum-number-of-decimal-digits-in-binary-floating-point-numbers/, 1074 is the maximum number of significant fractional digits. Add 8 more digits for the biggest number: -0.<fraction>e-308.\n+  auto json = peek_root_scalar(\"double\");\n+  // Per https://www.exploringbinary.com/maximum-number-of-decimal-digits-in-binary-floating-point-numbers/,\n+  // 1074 is the maximum number of significant fractional digits. Add 8 more digits for the biggest\n+  // number: -0.<fraction>e-308.\n+  uint8_t tmpbuf[1074+8+1];\n+  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) {\n+    logger::log_error(*_json_iter, start_position(), depth(), \"Root number more than 1082 characters\");\n+    return NUMBER_ERROR;\n+  }\n+  auto result = numberparsing::parse_double(tmpbuf);\n+  if(result.error() == SUCCESS) { advance_root_scalar(\"double\"); }\n+  return result;\n+}\n+\n+simdjson_warn_unused simdjson_really_inline simdjson_result<double> value_iterator::get_root_double_in_string() noexcept {\n+  auto max_len = peek_start_length();\n+  auto json = peek_root_scalar(\"double\");\n+  // Per https://www.exploringbinary.com/maximum-number-of-decimal-digits-in-binary-floating-point-numbers/,\n+  // 1074 is the maximum number of significant fractional digits. Add 8 more digits for the biggest\n+  // number: -0.<fraction>e-308.\n   uint8_t tmpbuf[1074+8+1];\n-  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) { logger::log_error(*_json_iter, _start_position, depth(), \"Root number more than 1082 characters\"); return NUMBER_ERROR; }\n-  return numberparsing::parse_double(tmpbuf);\n+  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) {\n+    logger::log_error(*_json_iter, start_position(), depth(), \"Root number more than 1082 characters\");\n+    return NUMBER_ERROR;\n+  }\n+  auto result = numberparsing::parse_double_in_string(tmpbuf);\n+  if(result.error() == SUCCESS) { advance_root_scalar(\"double\"); }\n+  return result;\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::get_root_bool() noexcept {\n   auto max_len = peek_start_length();\n-  auto json = advance_root_scalar(\"bool\");\n+  auto json = peek_root_scalar(\"bool\");\n   uint8_t tmpbuf[5+1];\n   if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) { return incorrect_type_error(\"Not a boolean\"); }\n-  return parse_bool(tmpbuf);\n+  auto result = parse_bool(tmpbuf);\n+  if(result.error() == SUCCESS) { advance_root_scalar(\"bool\"); }\n+  return result;\n }\n simdjson_really_inline bool value_iterator::is_root_null() noexcept {\n   auto max_len = peek_start_length();\n-  auto json = advance_root_scalar(\"null\");\n-  return max_len >= 4 && !atomparsing::str4ncmp(json, \"null\") &&\n-         (max_len == 4 || jsoncharutils::is_structural_or_whitespace(json[5]));\n+  auto json = peek_root_scalar(\"null\");\n+  bool result = (max_len >= 4 && !atomparsing::str4ncmp(json, \"null\") &&\n+         (max_len == 4 || jsoncharutils::is_structural_or_whitespace(json[5])));\n+  if(result) { advance_root_scalar(\"null\"); }\n+  return result;\n }\n \n simdjson_warn_unused simdjson_really_inline error_code value_iterator::skip_child() noexcept {\n-  SIMDJSON_ASSUME( _json_iter->token.index > _start_position );\n+  SIMDJSON_ASSUME( _json_iter->token._position > _start_position );\n   SIMDJSON_ASSUME( _json_iter->_depth >= _depth );\n \n   return _json_iter->skip_child(depth());\n@@ -495,17 +679,17 @@ simdjson_really_inline bool value_iterator::is_open() const noexcept {\n }\n SIMDJSON_POP_DISABLE_WARNINGS\n \n-simdjson_really_inline bool value_iterator::at_eof() const noexcept {\n-  return _json_iter->at_eof();\n+simdjson_really_inline bool value_iterator::at_end() const noexcept {\n+  return _json_iter->at_end();\n }\n \n simdjson_really_inline bool value_iterator::at_start() const noexcept {\n-  return _json_iter->token.index == _start_position;\n+  return _json_iter->token.position() == start_position();\n }\n \n simdjson_really_inline bool value_iterator::at_first_field() const noexcept {\n-  SIMDJSON_ASSUME( _json_iter->token.index > _start_position );\n-  return _json_iter->token.index == _start_position + 1;\n+  SIMDJSON_ASSUME( _json_iter->token._position > _start_position );\n+  return _json_iter->token.position() == start_position() + 1;\n }\n \n simdjson_really_inline void value_iterator::abandon() noexcept {\n@@ -529,120 +713,177 @@ simdjson_warn_unused simdjson_really_inline json_iterator &value_iterator::json_\n }\n \n simdjson_really_inline const uint8_t *value_iterator::peek_start() const noexcept {\n-  return _json_iter->peek(_start_position);\n+  return _json_iter->peek(start_position());\n }\n simdjson_really_inline uint32_t value_iterator::peek_start_length() const noexcept {\n-  return _json_iter->peek_length(_start_position);\n+  return _json_iter->peek_length(start_position());\n }\n \n-simdjson_really_inline const uint8_t *value_iterator::advance_start(const char *type) const noexcept {\n-  logger::log_value(*_json_iter, _start_position, depth(), type);\n+simdjson_really_inline const uint8_t *value_iterator::peek_scalar(const char *type) noexcept {\n+  logger::log_value(*_json_iter, start_position(), depth(), type);\n   // If we're not at the position anymore, we don't want to advance the cursor.\n   if (!is_at_start()) { return peek_start(); }\n \n   // Get the JSON and advance the cursor, decreasing depth to signify that we have retrieved the value.\n   assert_at_start();\n-  auto result = _json_iter->advance();\n+  return _json_iter->peek();\n+}\n+\n+simdjson_really_inline void value_iterator::advance_scalar(const char *type) noexcept {\n+  logger::log_value(*_json_iter, start_position(), depth(), type);\n+  // If we're not at the position anymore, we don't want to advance the cursor.\n+  if (!is_at_start()) { return; }\n+\n+  // Get the JSON and advance the cursor, decreasing depth to signify that we have retrieved the value.\n+  assert_at_start();\n+  _json_iter->return_current_and_advance();\n   _json_iter->ascend_to(depth()-1);\n-  return result;\n }\n-simdjson_really_inline error_code value_iterator::advance_container_start(const char *type, const uint8_t *&json) const noexcept {\n-  logger::log_start_value(*_json_iter, _start_position, depth(), type);\n \n+simdjson_really_inline error_code value_iterator::start_container(uint8_t start_char, const char *incorrect_type_message, const char *type) noexcept {\n+  logger::log_start_value(*_json_iter, start_position(), depth(), type);\n   // If we're not at the position anymore, we don't want to advance the cursor.\n+  const uint8_t *json;\n   if (!is_at_start()) {\n #ifdef SIMDJSON_DEVELOPMENT_CHECKS\n     if (!is_at_iterator_start()) { return OUT_OF_ORDER_ITERATION; }\n #endif\n     json = peek_start();\n-    return SUCCESS;\n+    if (*json != start_char) { return incorrect_type_error(incorrect_type_message); }\n+  } else {\n+    assert_at_start();\n+    /**\n+     * We should be prudent. Let us peek. If it is not the right type, we\n+     * return an error. Only once we have determined that we have the right\n+     * type are we allowed to advance!\n+     */\n+    json = _json_iter->peek();\n+    if (*json != start_char) { return incorrect_type_error(incorrect_type_message); }\n+    _json_iter->return_current_and_advance();\n   }\n \n-  // Get the JSON and advance the cursor, decreasing depth to signify that we have retrieved the value.\n-  assert_at_start();\n-  json = _json_iter->advance();\n+\n   return SUCCESS;\n }\n-simdjson_really_inline const uint8_t *value_iterator::advance_root_scalar(const char *type) const noexcept {\n-  logger::log_value(*_json_iter, _start_position, depth(), type);\n+\n+\n+simdjson_really_inline const uint8_t *value_iterator::peek_root_scalar(const char *type) noexcept {\n+  logger::log_value(*_json_iter, start_position(), depth(), type);\n   if (!is_at_start()) { return peek_start(); }\n \n   assert_at_root();\n-  auto result = _json_iter->advance();\n-  _json_iter->ascend_to(depth()-1);\n-  return result;\n+  return _json_iter->peek();\n }\n-simdjson_really_inline const uint8_t *value_iterator::advance_non_root_scalar(const char *type) const noexcept {\n-  logger::log_value(*_json_iter, _start_position, depth(), type);\n+simdjson_really_inline const uint8_t *value_iterator::peek_non_root_scalar(const char *type) noexcept {\n+  logger::log_value(*_json_iter, start_position(), depth(), type);\n   if (!is_at_start()) { return peek_start(); }\n \n   assert_at_non_root_start();\n-  auto result = _json_iter->advance();\n+  return _json_iter->peek();\n+}\n+\n+simdjson_really_inline void value_iterator::advance_root_scalar(const char *type) noexcept {\n+  logger::log_value(*_json_iter, start_position(), depth(), type);\n+  if (!is_at_start()) { return; }\n+\n+  assert_at_root();\n+  _json_iter->return_current_and_advance();\n+  _json_iter->ascend_to(depth()-1);\n+}\n+simdjson_really_inline void value_iterator::advance_non_root_scalar(const char *type) noexcept {\n+  logger::log_value(*_json_iter, start_position(), depth(), type);\n+  if (!is_at_start()) { return; }\n+\n+  assert_at_non_root_start();\n+  _json_iter->return_current_and_advance();\n   _json_iter->ascend_to(depth()-1);\n-  return result;\n }\n \n simdjson_really_inline error_code value_iterator::incorrect_type_error(const char *message) const noexcept {\n-  logger::log_error(*_json_iter, _start_position, depth(), message);\n+  logger::log_error(*_json_iter, start_position(), depth(), message);\n   return INCORRECT_TYPE;\n }\n \n simdjson_really_inline bool value_iterator::is_at_start() const noexcept {\n-  return _json_iter->token.index == _start_position;\n+  return position() == start_position();\n }\n-simdjson_really_inline bool value_iterator::is_at_container_start() const noexcept {\n-  return _json_iter->token.index == _start_position + 1;\n+\n+simdjson_really_inline bool value_iterator::is_at_key() const noexcept {\n+  // Keys are at the same depth as the object.\n+  // Note here that we could be safer and check that we are within an object,\n+  // but we do not.\n+  return _depth == _json_iter->_depth && *_json_iter->peek() == '\"';\n }\n+\n simdjson_really_inline bool value_iterator::is_at_iterator_start() const noexcept {\n   // We can legitimately be either at the first value ([1]), or after the array if it's empty ([]).\n-  auto delta = _json_iter->token.index - _start_position;\n+  auto delta = position() - start_position();\n   return delta == 1 || delta == 2;\n }\n \n-simdjson_really_inline void value_iterator::assert_at_start() const noexcept {\n-  SIMDJSON_ASSUME( _json_iter->token.index == _start_position );\n+inline void value_iterator::assert_at_start() const noexcept {\n+  SIMDJSON_ASSUME( _json_iter->token._position == _start_position );\n   SIMDJSON_ASSUME( _json_iter->_depth == _depth );\n   SIMDJSON_ASSUME( _depth > 0 );\n }\n \n-simdjson_really_inline void value_iterator::assert_at_container_start() const noexcept {\n-  SIMDJSON_ASSUME( _json_iter->token.index == _start_position + 1 );\n+inline void value_iterator::assert_at_container_start() const noexcept {\n+  SIMDJSON_ASSUME( _json_iter->token._position == _start_position + 1 );\n   SIMDJSON_ASSUME( _json_iter->_depth == _depth );\n   SIMDJSON_ASSUME( _depth > 0 );\n }\n \n-simdjson_really_inline void value_iterator::assert_at_next() const noexcept {\n-  SIMDJSON_ASSUME( _json_iter->token.index > _start_position );\n+inline void value_iterator::assert_at_next() const noexcept {\n+  SIMDJSON_ASSUME( _json_iter->token._position > _start_position );\n   SIMDJSON_ASSUME( _json_iter->_depth == _depth );\n   SIMDJSON_ASSUME( _depth > 0 );\n }\n \n-simdjson_really_inline void value_iterator::assert_at_child() const noexcept {\n-  SIMDJSON_ASSUME( _json_iter->token.index > _start_position );\n+simdjson_really_inline void value_iterator::move_at_start() noexcept {\n+  _json_iter->_depth = _depth;\n+  _json_iter->token.set_position(_start_position);\n+}\n+\n+simdjson_really_inline void value_iterator::move_at_container_start() noexcept {\n+  _json_iter->_depth = _depth;\n+  _json_iter->token.set_position(_start_position + 1);\n+}\n+\n+simdjson_really_inline simdjson_result<bool> value_iterator::reset_array() noexcept {\n+  move_at_container_start();\n+  return started_array();\n+}\n+\n+simdjson_really_inline simdjson_result<bool> value_iterator::reset_object() noexcept {\n+  move_at_container_start();\n+  return started_object();\n+}\n+\n+inline void value_iterator::assert_at_child() const noexcept {\n+  SIMDJSON_ASSUME( _json_iter->token._position > _start_position );\n   SIMDJSON_ASSUME( _json_iter->_depth == _depth + 1 );\n   SIMDJSON_ASSUME( _depth > 0 );\n }\n \n-simdjson_really_inline void value_iterator::assert_at_root() const noexcept {\n+inline void value_iterator::assert_at_root() const noexcept {\n   assert_at_start();\n   SIMDJSON_ASSUME( _depth == 1 );\n }\n \n-simdjson_really_inline void value_iterator::assert_at_non_root_start() const noexcept {\n+inline void value_iterator::assert_at_non_root_start() const noexcept {\n   assert_at_start();\n   SIMDJSON_ASSUME( _depth > 1 );\n }\n \n-simdjson_really_inline void value_iterator::assert_is_valid() const noexcept {\n+inline void value_iterator::assert_is_valid() const noexcept {\n   SIMDJSON_ASSUME( _json_iter != nullptr );\n }\n \n simdjson_really_inline bool value_iterator::is_valid() const noexcept {\n   return _json_iter != nullptr;\n }\n \n-\n-simdjson_really_inline simdjson_result<json_type> value_iterator::type() noexcept {\n+simdjson_really_inline simdjson_result<json_type> value_iterator::type() const noexcept {\n   switch (*peek_start()) {\n     case '{':\n       return json_type::object;\n@@ -663,6 +904,26 @@ simdjson_really_inline simdjson_result<json_type> value_iterator::type() noexcep\n   }\n }\n \n+simdjson_really_inline token_position value_iterator::start_position() const noexcept {\n+  return _start_position;\n+}\n+\n+simdjson_really_inline token_position value_iterator::position() const noexcept {\n+  return _json_iter->position();\n+}\n+\n+simdjson_really_inline token_position value_iterator::end_position() const noexcept {\n+  return _json_iter->end_position();\n+}\n+\n+simdjson_really_inline token_position value_iterator::last_position() const noexcept {\n+  return _json_iter->last_position();\n+}\n+\n+simdjson_really_inline error_code value_iterator::report_error(error_code error, const char *message) noexcept {\n+  return _json_iter->report_error(error, message);\n+}\n+\n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/generic/ondemand/value_iterator.h",
        "status": "modified",
        "additions": 158,
        "deletions": 22,
        "changes": 180,
        "patch": "@@ -25,8 +25,6 @@ class value_iterator {\n   depth_t _depth{};\n   /**\n    * The starting token index for this value\n-   *\n-   * PERF NOTE: this is a safety check; we expect this to be elided in release builds.\n    */\n   token_position _start_position{};\n \n@@ -48,7 +46,7 @@ class value_iterator {\n   /**\n    * Tell whether the iterator is at the EOF mark\n    */\n-  simdjson_really_inline bool at_eof() const noexcept;\n+  simdjson_really_inline bool at_end() const noexcept;\n \n   /**\n    * Tell whether the iterator is at the start of the value\n@@ -85,7 +83,7 @@ class value_iterator {\n    *\n    * @error TAPE_ERROR when the JSON value is a bad token like \"}\" \",\" or \"alse\".\n    */\n-  simdjson_really_inline simdjson_result<json_type> type() noexcept;\n+  simdjson_really_inline simdjson_result<json_type> type() const noexcept;\n \n   /**\n    * @addtogroup object Object iteration\n@@ -115,11 +113,23 @@ class value_iterator {\n   /**\n    * Start an object iteration after the user has already checked and moved past the {.\n    *\n-   * Does not move the iterator.\n+   * Does not move the iterator unless the object is empty ({}).\n+   *\n+   * @returns Whether the object had any fields (returns false for empty).\n+   * @error INCOMPLETE_ARRAY_OR_OBJECT If there are no more tokens (implying the *parent*\n+   *        array or object is incomplete).\n+   */\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<bool> started_object() noexcept;\n+  /**\n+   * Start an object iteration from the root, after the user has already checked and moved past the {.\n+   *\n+   * Does not move the iterator unless the object is empty ({}).\n    *\n    * @returns Whether the object had any fields (returns false for empty).\n+   * @error INCOMPLETE_ARRAY_OR_OBJECT If there are no more tokens (implying the *parent*\n+   *        array or object is incomplete).\n    */\n-  simdjson_warn_unused simdjson_really_inline bool started_object() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<bool> started_root_object() noexcept;\n \n   /**\n    * Moves to the next field in an object.\n@@ -129,6 +139,7 @@ class value_iterator {\n    *\n    * @return whether there is another field in the object.\n    * @error TAPE_ERROR If there is a comma missing between fields.\n+   * @error TAPE_ERROR If there is a comma, but not enough tokens remaining to have a key, :, and value.\n    */\n   simdjson_warn_unused simdjson_really_inline simdjson_result<bool> has_next_field() noexcept;\n \n@@ -225,13 +236,25 @@ class value_iterator {\n   simdjson_warn_unused simdjson_really_inline simdjson_result<bool> start_root_array() noexcept;\n \n   /**\n-   * Start an array iteration after the user has already checked and moved past the [.\n+   * Start an array iteration, after the user has already checked and moved past the [.\n    *\n-   * Does not move the iterator.\n+   * Does not move the iterator unless the array is empty ([]).\n    *\n    * @returns Whether the array had any elements (returns false for empty).\n+   * @error INCOMPLETE_ARRAY_OR_OBJECT If there are no more tokens (implying the *parent*\n+   *        array or object is incomplete).\n    */\n-  simdjson_warn_unused simdjson_really_inline bool started_array() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<bool> started_array() noexcept;\n+  /**\n+   * Start an array iteration from the root, after the user has already checked and moved past the [.\n+   *\n+   * Does not move the iterator unless the array is empty ([]).\n+   *\n+   * @returns Whether the array had any elements (returns false for empty).\n+   * @error INCOMPLETE_ARRAY_OR_OBJECT If there are no more tokens (implying the *parent*\n+   *        array or object is incomplete).\n+   */\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<bool> started_root_array() noexcept;\n \n   /**\n    * Moves to the next element in an array.\n@@ -260,17 +283,31 @@ class value_iterator {\n   simdjson_warn_unused simdjson_really_inline simdjson_result<std::string_view> get_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<raw_json_string> get_raw_json_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> get_uint64() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> get_uint64_in_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> get_int64() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> get_int64_in_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<double> get_double() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<double> get_double_in_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<bool> get_bool() noexcept;\n   simdjson_really_inline bool is_null() noexcept;\n+  simdjson_warn_unused simdjson_really_inline bool is_negative() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<bool> is_integer() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<number_type> get_number_type() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<number> get_number() noexcept;\n \n   simdjson_warn_unused simdjson_really_inline simdjson_result<std::string_view> get_root_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<raw_json_string> get_root_raw_json_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> get_root_uint64() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> get_root_uint64_in_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> get_root_int64() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> get_root_int64_in_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<double> get_root_double() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<double> get_root_double_in_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<bool> get_root_bool() noexcept;\n+  simdjson_warn_unused simdjson_really_inline bool is_root_negative() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<bool> is_root_integer() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<number_type> get_root_number_type() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<number> get_root_number() noexcept;\n   simdjson_really_inline bool is_root_null() noexcept;\n \n   simdjson_really_inline error_code error() const noexcept;\n@@ -282,31 +319,130 @@ class value_iterator {\n   simdjson_really_inline bool is_valid() const noexcept;\n \n   /** @} */\n-\n protected:\n+  /**\n+   * Restarts an array iteration.\n+   * @returns Whether the array has any elements (returns false for empty).\n+   */\n+  simdjson_really_inline simdjson_result<bool> reset_array() noexcept;\n+  /**\n+   * Restarts an object iteration.\n+   * @returns Whether the object has any fields (returns false for empty).\n+   */\n+  simdjson_really_inline simdjson_result<bool> reset_object() noexcept;\n+  /**\n+   * move_at_start(): moves us so that we are pointing at the beginning of\n+   * the container. It updates the index so that at_start() is true and it\n+   * syncs the depth. The user can then create a new container instance.\n+   *\n+   * Usage: used with value::count_elements().\n+   **/\n+  simdjson_really_inline void move_at_start() noexcept;\n+\n+  /**\n+   * move_at_container_start(): moves us so that we are pointing at the beginning of\n+   * the container so that assert_at_container_start() passes.\n+   *\n+   * Usage: used with reset_array() and reset_object().\n+   **/\n+   simdjson_really_inline void move_at_container_start() noexcept;\n+  /* Useful for debugging and logging purposes. */\n+  inline std::string to_string() const noexcept;\n   simdjson_really_inline value_iterator(json_iterator *json_iter, depth_t depth, token_position start_index) noexcept;\n \n   simdjson_really_inline bool parse_null(const uint8_t *json) const noexcept;\n   simdjson_really_inline simdjson_result<bool> parse_bool(const uint8_t *json) const noexcept;\n-\n   simdjson_really_inline const uint8_t *peek_start() const noexcept;\n   simdjson_really_inline uint32_t peek_start_length() const noexcept;\n-  simdjson_really_inline const uint8_t *advance_start(const char *type) const noexcept;\n-  simdjson_really_inline error_code advance_container_start(const char *type, const uint8_t *&json) const noexcept;\n-  simdjson_really_inline const uint8_t *advance_root_scalar(const char *type) const noexcept;\n-  simdjson_really_inline const uint8_t *advance_non_root_scalar(const char *type) const noexcept;\n+\n+  /**\n+   * The general idea of the advance_... methods and the peek_* methods\n+   * is that you first peek and check that you have desired type. If you do,\n+   * and only if you do, then you advance.\n+   *\n+   * We used to unconditionally advance. But this made reasoning about our\n+   * current state difficult.\n+   * Suppose you always advance. Look at the 'value' matching the key\n+   * \"shadowable\" in the following example...\n+   *\n+   * ({\"globals\":{\"a\":{\"shadowable\":[}}}})\n+   *\n+   * If the user thinks it is a Boolean and asks for it, then we check the '[',\n+   * decide it is not a Boolean, but still move into the next character ('}'). Now\n+   * we are left pointing at '}' right after a '['. And we have not yet reported\n+   * an error, only that we do not have a Boolean.\n+   *\n+   * If, instead, you just stand your ground until it is content that you know, then\n+   * you will only even move beyond the '[' if the user tells you that you have an\n+   * array. So you will be at the '}' character inside the array and, hopefully, you\n+   * will then catch the error because an array cannot start with '}', but the code\n+   * processing Boolean values does not know this.\n+   *\n+   * So the contract is: first call 'peek_...' and then call 'advance_...' only\n+   * if you have determined that it is a type you can handle.\n+   *\n+   * Unfortunately, it makes the code more verbose, longer and maybe more error prone.\n+   */\n+\n+  simdjson_really_inline void advance_scalar(const char *type) noexcept;\n+  simdjson_really_inline void advance_root_scalar(const char *type) noexcept;\n+  simdjson_really_inline void advance_non_root_scalar(const char *type) noexcept;\n+\n+  simdjson_really_inline const uint8_t *peek_scalar(const char *type) noexcept;\n+  simdjson_really_inline const uint8_t *peek_root_scalar(const char *type) noexcept;\n+  simdjson_really_inline const uint8_t *peek_non_root_scalar(const char *type) noexcept;\n+\n+\n+  simdjson_really_inline error_code start_container(uint8_t start_char, const char *incorrect_type_message, const char *type) noexcept;\n+  simdjson_really_inline error_code end_container() noexcept;\n+\n+  /**\n+   * Advance to a place expecting a value (increasing depth).\n+   *\n+   * @return The current token (the one left behind).\n+   * @error TAPE_ERROR If the document ended early.\n+   */\n+  simdjson_really_inline simdjson_result<const uint8_t *> advance_to_value() noexcept;\n \n   simdjson_really_inline error_code incorrect_type_error(const char *message) const noexcept;\n+  simdjson_really_inline error_code error_unless_more_tokens(uint32_t tokens=1) const noexcept;\n \n   simdjson_really_inline bool is_at_start() const noexcept;\n-  simdjson_really_inline bool is_at_container_start() const noexcept;\n+  /**\n+   * is_at_iterator_start() returns true on an array or object after it has just been\n+   * created, whether the instance is empty or not.\n+   *\n+   * Usage: used by array::begin() in debug mode (SIMDJSON_DEVELOPMENT_CHECKS)\n+   */\n   simdjson_really_inline bool is_at_iterator_start() const noexcept;\n-  simdjson_really_inline void assert_at_start() const noexcept;\n-  simdjson_really_inline void assert_at_container_start() const noexcept;\n-  simdjson_really_inline void assert_at_root() const noexcept;\n-  simdjson_really_inline void assert_at_child() const noexcept;\n-  simdjson_really_inline void assert_at_next() const noexcept;\n-  simdjson_really_inline void assert_at_non_root_start() const noexcept;\n+\n+  /**\n+   * Assuming that we are within an object, this returns true if we\n+   * are pointing at a key.\n+   *\n+   * Usage: the skip_child() method should never be used while we are pointing\n+   * at a key inside an object.\n+   */\n+  simdjson_really_inline bool is_at_key() const noexcept;\n+\n+  inline void assert_at_start() const noexcept;\n+  inline void assert_at_container_start() const noexcept;\n+  inline void assert_at_root() const noexcept;\n+  inline void assert_at_child() const noexcept;\n+  inline void assert_at_next() const noexcept;\n+  inline void assert_at_non_root_start() const noexcept;\n+\n+  /** Get the starting position of this value */\n+  simdjson_really_inline token_position start_position() const noexcept;\n+\n+  /** @copydoc error_code json_iterator::position() const noexcept; */\n+  simdjson_really_inline token_position position() const noexcept;\n+  /** @copydoc error_code json_iterator::end_position() const noexcept; */\n+  simdjson_really_inline token_position last_position() const noexcept;\n+  /** @copydoc error_code json_iterator::end_position() const noexcept; */\n+  simdjson_really_inline token_position end_position() const noexcept;\n+  /** @copydoc error_code json_iterator::report_error(error_code error, const char *message) noexcept; */\n+  simdjson_really_inline error_code report_error(error_code error, const char *message) noexcept;\n \n   friend class document;\n   friend class object;"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/haswell/numberparsing.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -27,7 +27,7 @@ static simdjson_really_inline uint32_t parse_eight_digits_unrolled(const uint8_t\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n \n-#define SWAR_NUMBER_PARSING\n+#define SIMDJSON_SWAR_NUMBER_PARSING 1\n \n #include \"simdjson/generic/numberparsing.h\"\n "
      },
      {
        "filename": "vendor/simdjson/include/simdjson/haswell/simd.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "patch": "@@ -303,11 +303,12 @@ namespace simd {\n     simdjson_really_inline simd8x64(const simd8<T> chunk0, const simd8<T> chunk1) : chunks{chunk0, chunk1} {}\n     simdjson_really_inline simd8x64(const T ptr[64]) : chunks{simd8<T>::load(ptr), simd8<T>::load(ptr+32)} {}\n \n-    simdjson_really_inline void compress(uint64_t mask, T * output) const {\n+    simdjson_really_inline uint64_t compress(uint64_t mask, T * output) const {\n       uint32_t mask1 = uint32_t(mask);\n       uint32_t mask2 = uint32_t(mask >> 32);\n       this->chunks[0].compress(mask1, output);\n       this->chunks[1].compress(mask2, output + 32 - count_ones(mask1));\n+      return 64 - count_ones(mask);\n     }\n \n     simdjson_really_inline void store(T ptr[64]) const {"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/internal/dom_parser_implementation.h",
        "status": "modified",
        "additions": 23,
        "deletions": 1,
        "changes": 24,
        "patch": "@@ -11,8 +11,30 @@ namespace dom {\n class document;\n } // namespace dom\n \n+/**\n+* This enum is used with the dom_parser_implementation::stage1 function.\n+* 1) The regular mode expects a fully formed JSON document.\n+* 2) The streaming_partial mode expects a possibly truncated\n+* input within a stream on JSON documents.\n+* 3) The stream_final mode allows us to truncate final\n+* unterminated strings. It is useful in conjunction with streaming_partial.\n+*/\n+enum class stage1_mode { regular, streaming_partial, streaming_final};\n+\n+/**\n+ * Returns true if mode == streaming_partial or mode == streaming_final\n+ */\n+inline bool is_streaming(stage1_mode mode) {\n+  // performance note: it is probably faster to check that mode is different\n+  // from regular than checking that it is either streaming_partial or streaming_final.\n+  return (mode != stage1_mode::regular);\n+  // return (mode == stage1_mode::streaming_partial || mode == stage1_mode::streaming_final);\n+}\n+\n+\n namespace internal {\n \n+\n /**\n  * An implementation of simdjson's DOM parser for a particular CPU architecture.\n  *\n@@ -51,7 +73,7 @@ class dom_parser_implementation {\n    * @param streaming Whether this is being called by parser::parse_many.\n    * @return The error code, or SUCCESS if there was no error.\n    */\n-  simdjson_warn_unused virtual error_code stage1(const uint8_t *buf, size_t len, bool streaming) noexcept = 0;\n+  simdjson_warn_unused virtual error_code stage1(const uint8_t *buf, size_t len, stage1_mode streaming) noexcept = 0;\n \n   /**\n    * @private For internal implementation use"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/nonstd/string_view.hpp",
        "status": "modified",
        "additions": 178,
        "deletions": 69,
        "changes": 247,
        "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2017-2019 by Martin Moene\n+// Copyright 2017-2020 by Martin Moene\n //\n // string-view lite, a C++17-like string_view for C++98 and later.\n // For more information see https://github.com/martinmoene/string-view-lite\n@@ -12,7 +12,7 @@\n #define NONSTD_SV_LITE_H_INCLUDED\n \n #define string_view_lite_MAJOR  1\n-#define string_view_lite_MINOR  4\n+#define string_view_lite_MINOR  6\n #define string_view_lite_PATCH  0\n \n #define string_view_lite_VERSION  nssv_STRINGIFY(string_view_lite_MAJOR) \".\" nssv_STRINGIFY(string_view_lite_MINOR) \".\" nssv_STRINGIFY(string_view_lite_PATCH)\n@@ -26,12 +26,22 @@\n #define nssv_STRING_VIEW_NONSTD   1\n #define nssv_STRING_VIEW_STD      2\n \n-#if !defined( nssv_CONFIG_SELECT_STRING_VIEW )\n-# define nssv_CONFIG_SELECT_STRING_VIEW  ( nssv_HAVE_STD_STRING_VIEW ? nssv_STRING_VIEW_STD : nssv_STRING_VIEW_NONSTD )\n+// tweak header support:\n+\n+#ifdef __has_include\n+# if __has_include(<nonstd/string_view.tweak.hpp>)\n+#  include <nonstd/string_view.tweak.hpp>\n+# endif\n+#define nssv_HAVE_TWEAK_HEADER  1\n+#else\n+#define nssv_HAVE_TWEAK_HEADER  0\n+//# pragma message(\"string_view.hpp: Note: Tweak header not supported.\")\n #endif\n \n-#if defined( nssv_CONFIG_SELECT_STD_STRING_VIEW ) || defined( nssv_CONFIG_SELECT_NONSTD_STRING_VIEW )\n-# error nssv_CONFIG_SELECT_STD_STRING_VIEW and nssv_CONFIG_SELECT_NONSTD_STRING_VIEW are deprecated and removed, please use nssv_CONFIG_SELECT_STRING_VIEW=nssv_STRING_VIEW_...\n+// string_view selection and configuration:\n+\n+#if !defined( nssv_CONFIG_SELECT_STRING_VIEW )\n+# define nssv_CONFIG_SELECT_STRING_VIEW  ( nssv_HAVE_STD_STRING_VIEW ? nssv_STRING_VIEW_STD : nssv_STRING_VIEW_NONSTD )\n #endif\n \n #ifndef  nssv_CONFIG_STD_SV_OPERATOR\n@@ -55,10 +65,17 @@\n # define nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS  1\n #endif\n \n+#ifndef  nssv_CONFIG_NO_STREAM_INSERTION\n+# define nssv_CONFIG_NO_STREAM_INSERTION  0\n+#endif\n+\n // Control presence of exception handling (try and auto discover):\n \n #ifndef nssv_CONFIG_NO_EXCEPTIONS\n-# if defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)\n+# if _MSC_VER\n+#  include <cstddef>    // for _HAS_EXCEPTIONS\n+# endif\n+# if defined(__cpp_exceptions) || defined(__EXCEPTIONS) || (_HAS_EXCEPTIONS)\n #  define nssv_CONFIG_NO_EXCEPTIONS  0\n # else\n #  define nssv_CONFIG_NO_EXCEPTIONS  1\n@@ -221,16 +238,21 @@ using std::operator<<;\n \n #define nssv_COMPILER_VERSION( major, minor, patch )  ( 10 * ( 10 * (major) + (minor) ) + (patch) )\n \n-#if defined(__clang__)\n-# define nssv_COMPILER_CLANG_VERSION  nssv_COMPILER_VERSION(__clang_major__, __clang_minor__, __clang_patchlevel__)\n+#if defined( __apple_build_version__ )\n+# define nssv_COMPILER_APPLECLANG_VERSION  nssv_COMPILER_VERSION(__clang_major__, __clang_minor__, __clang_patchlevel__)\n+# define nssv_COMPILER_CLANG_VERSION       0\n+#elif defined( __clang__ )\n+# define nssv_COMPILER_APPLECLANG_VERSION  0\n+# define nssv_COMPILER_CLANG_VERSION       nssv_COMPILER_VERSION(__clang_major__, __clang_minor__, __clang_patchlevel__)\n #else\n-# define nssv_COMPILER_CLANG_VERSION    0\n+# define nssv_COMPILER_APPLECLANG_VERSION  0\n+# define nssv_COMPILER_CLANG_VERSION       0\n #endif\n \n #if defined(__GNUC__) && !defined(__clang__)\n # define nssv_COMPILER_GNUC_VERSION  nssv_COMPILER_VERSION(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)\n #else\n-# define nssv_COMPILER_GNUC_VERSION    0\n+# define nssv_COMPILER_GNUC_VERSION  0\n #endif\n \n // half-open range [lo..hi):\n@@ -292,6 +314,45 @@ using std::operator<<;\n \n #define nssv_HAVE_STD_HASH              nssv_CPP11_120\n \n+// Presence of compiler intrinsics:\n+\n+// Providing char-type specializations for compare() and length() that\n+// use compiler intrinsics can improve compile- and run-time performance.\n+//\n+// The challenge is in using the right combinations of builtin availability\n+// and its constexpr-ness.\n+//\n+// | compiler | __builtin_memcmp (constexpr) | memcmp  (constexpr) |\n+// |----------|------------------------------|---------------------|\n+// | clang    | 4.0              (>= 4.0   ) | any     (?        ) |\n+// | clang-a  | 9.0              (>= 9.0   ) | any     (?        ) |\n+// | gcc      | any              (constexpr) | any     (?        ) |\n+// | msvc     | >= 14.2 C++17    (>= 14.2  ) | any     (?        ) |\n+\n+#define nssv_HAVE_BUILTIN_VER     ( (nssv_CPP17_000 && nssv_COMPILER_MSVC_VERSION >= 142) || nssv_COMPILER_GNUC_VERSION > 0 || nssv_COMPILER_CLANG_VERSION >= 400 || nssv_COMPILER_APPLECLANG_VERSION >= 900 )\n+#define nssv_HAVE_BUILTIN_CE      (  nssv_HAVE_BUILTIN_VER )\n+\n+#define nssv_HAVE_BUILTIN_MEMCMP  ( (nssv_HAVE_CONSTEXPR_14 && nssv_HAVE_BUILTIN_CE) || !nssv_HAVE_CONSTEXPR_14 )\n+#define nssv_HAVE_BUILTIN_STRLEN  ( (nssv_HAVE_CONSTEXPR_11 && nssv_HAVE_BUILTIN_CE) || !nssv_HAVE_CONSTEXPR_11 )\n+\n+#ifdef __has_builtin\n+# define nssv_HAVE_BUILTIN( x )  __has_builtin( x )\n+#else\n+# define nssv_HAVE_BUILTIN( x )  0\n+#endif\n+\n+#if nssv_HAVE_BUILTIN(__builtin_memcmp) || nssv_HAVE_BUILTIN_VER\n+# define nssv_BUILTIN_MEMCMP  __builtin_memcmp\n+#else\n+# define nssv_BUILTIN_MEMCMP  memcmp\n+#endif\n+\n+#if nssv_HAVE_BUILTIN(__builtin_strlen) || nssv_HAVE_BUILTIN_VER\n+# define nssv_BUILTIN_STRLEN  __builtin_strlen\n+#else\n+# define nssv_BUILTIN_STRLEN  strlen\n+#endif\n+\n // C++ feature usage:\n \n #if nssv_HAVE_CONSTEXPR_11\n@@ -350,9 +411,12 @@ using std::operator<<;\n #include <cassert>\n #include <iterator>\n #include <limits>\n-#include <ostream>\n #include <string>   // std::char_traits<>\n \n+#if ! nssv_CONFIG_NO_STREAM_INSERTION\n+# include <ostream>\n+#endif\n+\n #if ! nssv_CONFIG_NO_EXCEPTIONS\n # include <stdexcept>\n #endif\n@@ -405,39 +469,74 @@ nssv_DISABLE_MSVC_WARNINGS( 4455 26481 26472 )\n \n namespace nonstd { namespace sv_lite {\n \n-#if nssv_CPP11_OR_GREATER\n-\n namespace detail {\n \n-#if nssv_CPP14_OR_GREATER\n+// support constexpr comparison in C++14;\n+// for C++17 and later, use provided traits:\n \n template< typename CharT >\n-inline constexpr std::size_t length( CharT * s, std::size_t result = 0 )\n+inline nssv_constexpr14 int compare( CharT const * s1, CharT const * s2, std::size_t count )\n {\n-    CharT * v = s;\n-    std::size_t r = result;\n-    while ( *v != '\\0' ) {\n-       ++v;\n-       ++r;\n+    while ( count-- != 0 )\n+    {\n+        if ( *s1 < *s2 ) return -1;\n+        if ( *s1 > *s2 ) return +1;\n+        ++s1; ++s2;\n     }\n-    return r;\n+    return 0;\n+}\n+\n+#if nssv_HAVE_BUILTIN_MEMCMP\n+\n+// specialization of compare() for char, see also generic compare() above:\n+\n+inline nssv_constexpr14 int compare( char const * s1, char const * s2, std::size_t count )\n+{\n+    return nssv_BUILTIN_MEMCMP( s1, s2, count );\n+}\n+\n+#endif\n+\n+#if nssv_HAVE_BUILTIN_STRLEN\n+\n+// specialization of length() for char, see also generic length() further below:\n+\n+inline nssv_constexpr std::size_t length( char const * s )\n+{\n+    return nssv_BUILTIN_STRLEN( s );\n }\n \n-#else // nssv_CPP14_OR_GREATER\n+#endif\n+\n+#if defined(__OPTIMIZE__)\n \n+// gcc, clang provide __OPTIMIZE__\n // Expect tail call optimization to make length() non-recursive:\n \n template< typename CharT >\n-inline constexpr std::size_t length( CharT * s, std::size_t result = 0 )\n+inline nssv_constexpr std::size_t length( CharT * s, std::size_t result = 0 )\n {\n     return *s == '\\0' ? result : length( s + 1, result + 1 );\n }\n \n-#endif // nssv_CPP14_OR_GREATER\n+#else // OPTIMIZE\n \n-} // namespace detail\n+// non-recursive:\n \n-#endif // nssv_CPP11_OR_GREATER\n+template< typename CharT >\n+inline nssv_constexpr14 std::size_t length( CharT * s )\n+{\n+    std::size_t result = 0;\n+    while ( *s++ != '\\0' )\n+    {\n+       ++result;\n+    }\n+    return result;\n+}\n+\n+#endif // OPTIMIZE\n+\n+} // namespace detail\n \n template\n <\n@@ -589,9 +688,9 @@ class basic_string_view\n \n     nssv_constexpr14 void swap( basic_string_view & other ) nssv_noexcept\n     {\n-        using std::swap;\n-        swap( data_, other.data_ );\n-        swap( size_, other.size_ );\n+        const basic_string_view tmp(other);\n+        other = *this;\n+        *this = tmp;\n     }\n \n     // 24.4.2.6 String operations:\n@@ -630,7 +729,11 @@ class basic_string_view\n \n     nssv_constexpr14 int compare( basic_string_view other ) const nssv_noexcept // (1)\n     {\n+#if nssv_CPP17_OR_GREATER\n         if ( const int result = Traits::compare( data(), other.data(), (std::min)( size(), other.size() ) ) )\n+#else\n+        if ( const int result = detail::compare( data(), other.data(), (std::min)( size(), other.size() ) ) )\n+#endif\n         {\n             return result;\n         }\n@@ -874,7 +977,7 @@ class basic_string_view\n     {\n         const basic_string_view v;\n \n-        nssv_constexpr explicit not_in_view( basic_string_view v ) : v( v ) {}\n+        nssv_constexpr explicit not_in_view( basic_string_view v_ ) : v( v_ ) {}\n \n         nssv_constexpr bool operator()( CharT c ) const\n         {\n@@ -964,37 +1067,37 @@ template< class CharT, class Traits >\n nssv_constexpr bool operator== (\n     basic_string_view <CharT, Traits> lhs,\n     basic_string_view <CharT, Traits> rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) == 0 ; }\n+{ return lhs.size() == rhs.size() && lhs.compare( rhs ) == 0; }\n \n template< class CharT, class Traits >\n nssv_constexpr bool operator!= (\n     basic_string_view <CharT, Traits> lhs,\n     basic_string_view <CharT, Traits> rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) != 0 ; }\n+{ return !( lhs == rhs ); }\n \n template< class CharT, class Traits >\n nssv_constexpr bool operator< (\n     basic_string_view <CharT, Traits> lhs,\n     basic_string_view <CharT, Traits> rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) < 0 ; }\n+{ return lhs.compare( rhs ) < 0; }\n \n template< class CharT, class Traits >\n nssv_constexpr bool operator<= (\n     basic_string_view <CharT, Traits> lhs,\n     basic_string_view <CharT, Traits> rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) <= 0 ; }\n+{ return lhs.compare( rhs ) <= 0; }\n \n template< class CharT, class Traits >\n nssv_constexpr bool operator> (\n     basic_string_view <CharT, Traits> lhs,\n     basic_string_view <CharT, Traits> rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) > 0 ; }\n+{ return lhs.compare( rhs ) > 0; }\n \n template< class CharT, class Traits >\n nssv_constexpr bool operator>= (\n     basic_string_view <CharT, Traits> lhs,\n     basic_string_view <CharT, Traits> rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) >= 0 ; }\n+{ return lhs.compare( rhs ) >= 0; }\n \n // Let S be basic_string_view<CharT, Traits>, and sv be an instance of S.\n // Implementations shall provide sufficient additional overloads marked\n@@ -1003,21 +1106,21 @@ nssv_constexpr bool operator>= (\n \n #if ! nssv_CPP11_OR_GREATER || nssv_BETWEEN( nssv_COMPILER_MSVC_VERSION, 100, 141 )\n \n-// accomodate for older compilers:\n+// accommodate for older compilers:\n \n // ==\n \n template< class CharT, class Traits>\n nssv_constexpr bool operator==(\n     basic_string_view<CharT, Traits> lhs,\n-    char const * rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) == 0; }\n+    CharT const * rhs ) nssv_noexcept\n+{ return lhs.size() == detail::length( rhs ) && lhs.compare( rhs ) == 0; }\n \n template< class CharT, class Traits>\n nssv_constexpr bool operator==(\n-    char const * lhs,\n+    CharT const * lhs,\n     basic_string_view<CharT, Traits> rhs ) nssv_noexcept\n-{ return rhs.compare( lhs ) == 0; }\n+{ return detail::length( lhs ) == rhs.size() && rhs.compare( lhs ) == 0; }\n \n template< class CharT, class Traits>\n nssv_constexpr bool operator==(\n@@ -1036,38 +1139,38 @@ nssv_constexpr bool operator==(\n template< class CharT, class Traits>\n nssv_constexpr bool operator!=(\n     basic_string_view<CharT, Traits> lhs,\n-    char const * rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) != 0; }\n+    CharT const * rhs ) nssv_noexcept\n+{ return !( lhs == rhs ); }\n \n template< class CharT, class Traits>\n nssv_constexpr bool operator!=(\n-    char const * lhs,\n+    CharT const * lhs,\n     basic_string_view<CharT, Traits> rhs ) nssv_noexcept\n-{ return rhs.compare( lhs ) != 0; }\n+{ return !( lhs == rhs ); }\n \n template< class CharT, class Traits>\n nssv_constexpr bool operator!=(\n     basic_string_view<CharT, Traits> lhs,\n     std::basic_string<CharT, Traits> rhs ) nssv_noexcept\n-{ return lhs.size() != rhs.size() && lhs.compare( rhs ) != 0; }\n+{ return !( lhs == rhs ); }\n \n template< class CharT, class Traits>\n nssv_constexpr bool operator!=(\n     std::basic_string<CharT, Traits> rhs,\n     basic_string_view<CharT, Traits> lhs ) nssv_noexcept\n-{ return lhs.size() != rhs.size() || rhs.compare( lhs ) != 0; }\n+{ return !( lhs == rhs ); }\n \n // <\n \n template< class CharT, class Traits>\n nssv_constexpr bool operator<(\n     basic_string_view<CharT, Traits> lhs,\n-    char const * rhs ) nssv_noexcept\n+    CharT const * rhs ) nssv_noexcept\n { return lhs.compare( rhs ) < 0; }\n \n template< class CharT, class Traits>\n nssv_constexpr bool operator<(\n-    char const * lhs,\n+    CharT const * lhs,\n     basic_string_view<CharT, Traits> rhs ) nssv_noexcept\n { return rhs.compare( lhs ) > 0; }\n \n@@ -1088,12 +1191,12 @@ nssv_constexpr bool operator<(\n template< class CharT, class Traits>\n nssv_constexpr bool operator<=(\n     basic_string_view<CharT, Traits> lhs,\n-    char const * rhs ) nssv_noexcept\n+    CharT const * rhs ) nssv_noexcept\n { return lhs.compare( rhs ) <= 0; }\n \n template< class CharT, class Traits>\n nssv_constexpr bool operator<=(\n-    char const * lhs,\n+    CharT const * lhs,\n     basic_string_view<CharT, Traits> rhs ) nssv_noexcept\n { return rhs.compare( lhs ) >= 0; }\n \n@@ -1114,12 +1217,12 @@ nssv_constexpr bool operator<=(\n template< class CharT, class Traits>\n nssv_constexpr bool operator>(\n     basic_string_view<CharT, Traits> lhs,\n-    char const * rhs ) nssv_noexcept\n+    CharT const * rhs ) nssv_noexcept\n { return lhs.compare( rhs ) > 0; }\n \n template< class CharT, class Traits>\n nssv_constexpr bool operator>(\n-    char const * lhs,\n+    CharT const * lhs,\n     basic_string_view<CharT, Traits> rhs ) nssv_noexcept\n { return rhs.compare( lhs ) < 0; }\n \n@@ -1140,12 +1243,12 @@ nssv_constexpr bool operator>(\n template< class CharT, class Traits>\n nssv_constexpr bool operator>=(\n     basic_string_view<CharT, Traits> lhs,\n-    char const * rhs ) nssv_noexcept\n+    CharT const * rhs ) nssv_noexcept\n { return lhs.compare( rhs ) >= 0; }\n \n template< class CharT, class Traits>\n nssv_constexpr bool operator>=(\n-    char const * lhs,\n+    CharT const * lhs,\n     basic_string_view<CharT, Traits> rhs ) nssv_noexcept\n { return rhs.compare( lhs ) <= 0; }\n \n@@ -1165,7 +1268,7 @@ nssv_constexpr bool operator>=(\n \n #define nssv_BASIC_STRING_VIEW_I(T,U)  typename std::decay< basic_string_view<T,U> >::type\n \n-#if nssv_BETWEEN( nssv_COMPILER_MSVC_VERSION, 140, 150 )\n+#if defined(_MSC_VER)       // issue 40\n # define nssv_MSVC_ORDER(x)  , int=x\n #else\n # define nssv_MSVC_ORDER(x)  /*, int=x*/\n@@ -1177,7 +1280,7 @@ template< class CharT, class Traits  nssv_MSVC_ORDER(1) >\n nssv_constexpr bool operator==(\n          basic_string_view  <CharT, Traits> lhs,\n     nssv_BASIC_STRING_VIEW_I(CharT, Traits) rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) == 0; }\n+{ return lhs.size() == rhs.size() && lhs.compare( rhs ) == 0; }\n \n template< class CharT, class Traits  nssv_MSVC_ORDER(2) >\n nssv_constexpr bool operator==(\n@@ -1191,69 +1294,69 @@ template< class CharT, class Traits  nssv_MSVC_ORDER(1) >\n nssv_constexpr bool operator!= (\n          basic_string_view  < CharT, Traits > lhs,\n     nssv_BASIC_STRING_VIEW_I( CharT, Traits ) rhs ) nssv_noexcept\n-{ return lhs.size() != rhs.size() || lhs.compare( rhs ) != 0 ; }\n+{ return !( lhs == rhs ); }\n \n template< class CharT, class Traits  nssv_MSVC_ORDER(2) >\n nssv_constexpr bool operator!= (\n     nssv_BASIC_STRING_VIEW_I( CharT, Traits ) lhs,\n          basic_string_view  < CharT, Traits > rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) != 0 ; }\n+{ return !( lhs == rhs ); }\n \n // <\n \n template< class CharT, class Traits  nssv_MSVC_ORDER(1) >\n nssv_constexpr bool operator< (\n          basic_string_view  < CharT, Traits > lhs,\n     nssv_BASIC_STRING_VIEW_I( CharT, Traits ) rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) < 0 ; }\n+{ return lhs.compare( rhs ) < 0; }\n \n template< class CharT, class Traits  nssv_MSVC_ORDER(2) >\n nssv_constexpr bool operator< (\n     nssv_BASIC_STRING_VIEW_I( CharT, Traits ) lhs,\n          basic_string_view  < CharT, Traits > rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) < 0 ; }\n+{ return lhs.compare( rhs ) < 0; }\n \n // <=\n \n template< class CharT, class Traits  nssv_MSVC_ORDER(1) >\n nssv_constexpr bool operator<= (\n          basic_string_view  < CharT, Traits > lhs,\n     nssv_BASIC_STRING_VIEW_I( CharT, Traits ) rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) <= 0 ; }\n+{ return lhs.compare( rhs ) <= 0; }\n \n template< class CharT, class Traits  nssv_MSVC_ORDER(2) >\n nssv_constexpr bool operator<= (\n     nssv_BASIC_STRING_VIEW_I( CharT, Traits ) lhs,\n          basic_string_view  < CharT, Traits > rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) <= 0 ; }\n+{ return lhs.compare( rhs ) <= 0; }\n \n // >\n \n template< class CharT, class Traits  nssv_MSVC_ORDER(1) >\n nssv_constexpr bool operator> (\n          basic_string_view  < CharT, Traits > lhs,\n     nssv_BASIC_STRING_VIEW_I( CharT, Traits ) rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) > 0 ; }\n+{ return lhs.compare( rhs ) > 0; }\n \n template< class CharT, class Traits  nssv_MSVC_ORDER(2) >\n nssv_constexpr bool operator> (\n     nssv_BASIC_STRING_VIEW_I( CharT, Traits ) lhs,\n          basic_string_view  < CharT, Traits > rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) > 0 ; }\n+{ return lhs.compare( rhs ) > 0; }\n \n // >=\n \n template< class CharT, class Traits  nssv_MSVC_ORDER(1) >\n nssv_constexpr bool operator>= (\n          basic_string_view  < CharT, Traits > lhs,\n     nssv_BASIC_STRING_VIEW_I( CharT, Traits ) rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) >= 0 ; }\n+{ return lhs.compare( rhs ) >= 0; }\n \n template< class CharT, class Traits  nssv_MSVC_ORDER(2) >\n nssv_constexpr bool operator>= (\n     nssv_BASIC_STRING_VIEW_I( CharT, Traits ) lhs,\n          basic_string_view  < CharT, Traits > rhs ) nssv_noexcept\n-{ return lhs.compare( rhs ) >= 0 ; }\n+{ return lhs.compare( rhs ) >= 0; }\n \n #undef nssv_MSVC_ORDER\n #undef nssv_BASIC_STRING_VIEW_I\n@@ -1262,6 +1365,8 @@ nssv_constexpr bool operator>= (\n \n // 24.4.4 Inserters and extractors:\n \n+#if ! nssv_CONFIG_NO_STREAM_INSERTION\n+\n namespace detail {\n \n template< class Stream >\n@@ -1311,6 +1416,8 @@ operator<<(\n     return detail::write_to_stream( os, sv );\n }\n \n+#endif // nssv_CONFIG_NO_STREAM_INSERTION\n+\n // Several typedefs for common character types are provided:\n \n typedef basic_string_view<char>      string_view;\n@@ -1459,7 +1566,9 @@ using sv_lite::operator<=;\n using sv_lite::operator>;\n using sv_lite::operator>=;\n \n+#if ! nssv_CONFIG_NO_STREAM_INSERTION\n using sv_lite::operator<<;\n+#endif\n \n #if nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS\n using sv_lite::to_string;\n@@ -1526,4 +1635,4 @@ struct hash< nonstd::u32string_view >\n nssv_RESTORE_WARNINGS()\n \n #endif // nssv_HAVE_STD_STRING_VIEW\n-#endif // NONSTD_SV_LITE_H_INCLUDED\n\\ No newline at end of file\n+#endif // NONSTD_SV_LITE_H_INCLUDED"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/padded_string-inl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -115,11 +115,11 @@ inline padded_string::operator padded_string_view() const noexcept {\n   return padded_string_view(data(), length(), length() + SIMDJSON_PADDING);\n }\n \n-inline simdjson_result<padded_string> padded_string::load(const std::string &filename) noexcept {\n+inline simdjson_result<padded_string> padded_string::load(std::string_view filename) noexcept {\n   // Open the file\n   SIMDJSON_PUSH_DISABLE_WARNINGS\n   SIMDJSON_DISABLE_DEPRECATED_WARNING // Disable CRT_SECURE warning on MSVC: manually verified this is safe\n-  std::FILE *fp = std::fopen(filename.c_str(), \"rb\");\n+  std::FILE *fp = std::fopen(filename.data(), \"rb\");\n   SIMDJSON_POP_DISABLE_WARNINGS\n \n   if (fp == nullptr) {"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/padded_string.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -111,7 +111,7 @@ struct padded_string final {\n    *\n    * @param path the path to the file.\n    **/\n-  inline static simdjson_result<padded_string> load(const std::string &path) noexcept;\n+  inline static simdjson_result<padded_string> load(std::string_view path) noexcept;\n \n private:\n   padded_string &operator=(const padded_string &o) = delete;"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/ppc64/numberparsing.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -25,7 +25,7 @@ parse_eight_digits_unrolled(const uint8_t *chars) {\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n \n-#define SWAR_NUMBER_PARSING\n+#define SIMDJSON_SWAR_NUMBER_PARSING 1\n \n #include \"simdjson/generic/numberparsing.h\"\n "
      },
      {
        "filename": "vendor/simdjson/include/simdjson/ppc64/simd.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "patch": "@@ -422,14 +422,15 @@ template <typename T> struct simd8x64 {\n            (this->chunks[2] | this->chunks[3]);\n   }\n \n-  simdjson_really_inline void compress(uint64_t mask, T *output) const {\n+  simdjson_really_inline uint64_t compress(uint64_t mask, T *output) const {\n     this->chunks[0].compress(uint16_t(mask), output);\n     this->chunks[1].compress(uint16_t(mask >> 16),\n                              output + 16 - count_ones(mask & 0xFFFF));\n     this->chunks[2].compress(uint16_t(mask >> 32),\n                              output + 32 - count_ones(mask & 0xFFFFFFFF));\n     this->chunks[3].compress(uint16_t(mask >> 48),\n                              output + 48 - count_ones(mask & 0xFFFFFFFFFFFF));\n+    return 64 - count_ones(mask);\n   }\n \n   simdjson_really_inline uint64_t to_bitmask() const {"
      },
      {
        "filename": "vendor/simdjson/include/simdjson/simdjson_version.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "patch": "@@ -4,22 +4,22 @@\n #define SIMDJSON_SIMDJSON_VERSION_H\n \n /** The version of simdjson being used (major.minor.revision) */\n-#define SIMDJSON_VERSION 0.9.6\n+#define SIMDJSON_VERSION 1.0.0\n \n namespace simdjson {\n enum {\n   /**\n    * The major version (MAJOR.minor.revision) of simdjson being used.\n    */\n-  SIMDJSON_VERSION_MAJOR = 0,\n+  SIMDJSON_VERSION_MAJOR = 1,\n   /**\n    * The minor version (major.MINOR.revision) of simdjson being used.\n    */\n-  SIMDJSON_VERSION_MINOR = 9,\n+  SIMDJSON_VERSION_MINOR = 0,\n   /**\n    * The revision (major.minor.REVISION) of simdjson being used.\n    */\n-  SIMDJSON_VERSION_REVISION = 6\n+  SIMDJSON_VERSION_REVISION = 0\n };\n } // namespace simdjson\n "
      },
      {
        "filename": "vendor/simdjson/include/simdjson/westmere/numberparsing.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "patch": "@@ -27,7 +27,7 @@ static simdjson_really_inline uint32_t parse_eight_digits_unrolled(const uint8_t\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n \n-#define SWAR_NUMBER_PARSING\n+#define SIMDJSON_SWAR_NUMBER_PARSING 1\n \n #include \"simdjson/generic/numberparsing.h\"\n "
      },
      {
        "filename": "vendor/simdjson/include/simdjson/westmere/simd.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "patch": "@@ -284,11 +284,12 @@ namespace simd {\n       return (this->chunks[0] | this->chunks[1]) | (this->chunks[2] | this->chunks[3]);\n     }\n \n-    simdjson_really_inline void compress(uint64_t mask, T * output) const {\n+    simdjson_really_inline uint64_t compress(uint64_t mask, T * output) const {\n       this->chunks[0].compress(uint16_t(mask), output);\n       this->chunks[1].compress(uint16_t(mask >> 16), output + 16 - count_ones(mask & 0xFFFF));\n       this->chunks[2].compress(uint16_t(mask >> 32), output + 32 - count_ones(mask & 0xFFFFFFFF));\n       this->chunks[3].compress(uint16_t(mask >> 48), output + 48 - count_ones(mask & 0xFFFFFFFFFFFF));\n+      return 64 - count_ones(mask);\n     }\n \n     simdjson_really_inline uint64_t to_bitmask() const {"
      },
      {
        "filename": "vendor/simdjson/src/CMakeLists.txt",
        "status": "removed",
        "additions": 0,
        "deletions": 161,
        "changes": 161,
        "patch": "@@ -1,161 +0,0 @@\n-#\n-# For callers who intend to #include simdjson.cpp.\n-#\n-# target_link_libraries(my-program simdjson-include-source) gives you the header and source\n-# directories. It does not specify any compiler flags.\n-#\n-\n-add_library(simdjson-include-source INTERFACE)\n-target_link_libraries(simdjson-include-source INTERFACE simdjson-headers)\n-target_include_directories(simdjson-include-source INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>)\n-# If a CMake user installs simdjson and then does...\n-#   find_package(simdjson CONFIG REQUIRED)\n-#   find_package(Threads REQUIRED)\n-#   target_link_libraries(test PRIVATE simdjson-include-source)\n-# It is not clear what it should do? Does the user get access to the src files?\n-# install(TARGETS simdjson-include-source EXPORT simdjson-config)\n-\n-#\n-# For callers who intend to compile simdjson.cpp themselves.\n-#\n-# target_link_libraries(my-object simdjson-source) gives you the header and source directories, plus\n-# the .cpp sources. It does not specify any compiler flags.\n-#\n-add_library(simdjson-source INTERFACE)\n-target_sources(simdjson-source INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>/simdjson.cpp)\n-target_link_libraries(simdjson-source INTERFACE simdjson-include-source)\n-# Note that simdjson.cpp is *not* installed so installing simdjson-include-source is not great.\n-# If a CMake user installs simdjson and then does...\n-#   find_package(simdjson CONFIG REQUIRED)\n-#   find_package(Threads REQUIRED)\n-#   target_link_libraries(test PRIVATE simdjson-source)\n-# It might fail with  Cannot find source file: simdjson.cpp\n-# See issue https://github.com/simdjson/simdjson/issues/1383\n-# install(TARGETS simdjson-source EXPORT simdjson-config)\n-\n-#\n-# simdjson is the distributed library compiled with flags.\n-#\n-# target_link_libraries(my-object simdjson) gives you the .so or .a to link against, plus the header\n-# directory. It does not specify any compiler flags, even though simdjson.so/a was compiled with\n-# target_link_libraries(simdjson PRIVATE simdjson-flags).\n-#\n-\n-if(SIMDJSON_BUILD_STATIC)\n-  MESSAGE( STATUS \"Building a static library.\" )\n-  ###\n-  # In the case of a static library, if you do \"target_link_libraries(simdjson PRIVATE simdjson-source simdjson-internal-flags)\"\n-  # without also calling \"install(TARGETS simdjson-source EXPORT simdjson-config)\" you get an error\n-  # to the effect that you are trying to install 'simdjson' which depends on 'simdjson-source' while\n-  # not installing 'simdjson-source', so it fails. So we bypass entirely simdjson-source since we do\n-  # not want to install them.\n-  ####\n-  add_library(simdjson STATIC simdjson.cpp)\n-  target_include_directories(simdjson PRIVATE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>)\n-else()\n-  MESSAGE( STATUS \"Building a dynamic library.\" )\n-  add_library(simdjson SHARED \"\")\n-  if(MSVC)\n-    MESSAGE( STATUS \"Building a Windows DLL using Visual Studio, exporting all symbols automatically.\" )\n-    set_target_properties(simdjson PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS 1)\n-    # Setting the dllexport, users of the library should never need to set SIMDJSON_BUILDING_WINDOWS_DYNAMIC_LIBRARY\n-    # once the DLL is built. Note the private scope on the next line.\n-    target_compile_definitions(simdjson PRIVATE SIMDJSON_BUILDING_WINDOWS_DYNAMIC_LIBRARY=1)\n-    #\n-    # The simdjson-flags are exported as part of the CMake install. Therefore users of\n-    # the library should pick up the SIMDJSON_USING_WINDOWS_DYNAMIC_LIBRARY=1 value.\n-    # It should appear in simdjson-config.cmake (an installed file) as (for example)\n-    #      set_target_properties(simdjson::simdjson-flags PROPERTIES\n-    #        INTERFACE_COMPILE_DEFINITIONS \"SIMDJSON_THREADS_ENABLED=1\"\n-    #        INTERFACE_COMPILE_DEFINITIONS \"SIMDJSON_USING_WINDOWS_DYNAMIC_LIBRARY=1\"\n-    #        INTERFACE_LINK_LIBRARIES \"Threads::Threads\"\n-    #      )\n-    #\n-    target_compile_definitions(simdjson-flags INTERFACE SIMDJSON_USING_WINDOWS_DYNAMIC_LIBRARY=1)\n-  endif()\n-  ###\n-  # Somehow, for a dynamic library, the next line is entirely fine (but not for a static one).\n-  ###\n-  target_link_libraries(simdjson PRIVATE simdjson-source simdjson-internal-flags)\n-endif()\n-target_link_libraries(simdjson PUBLIC simdjson-headers simdjson-flags) # Only expose the headers, not sources\n-\n-\n-##\n-## In systems like R, libraries must not use stderr or abort to be acceptable.\n-## Thus we make it a hard rule that one is not allowed to call abort or stderr.\n-## The sanitized builds are allowed to abort.\n-##\n-if(NOT SIMDJSON_SANITIZE)\n-  find_program(GREP grep)\n-  find_program(NM nm)\n-  if((NOT GREP) OR (NOT NM))\n-    message(\"grep and nm are unavailable on this system.\")\n-  else()\n-    add_test(\n-      NAME \"avoid_abort\"\n-      # Under FreeBSD, the __cxa_guard_abort symbol may appear but it is fine.\n-      # So we want to look for <space><possibly _>abort as a test.\n-      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} ' _*abort' || exit 0  && exit 1\"\n-      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n-    )\n-    add_test(\n-      NAME \"avoid_cout\"\n-      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} ' _*cout' || exit 0  && exit 1\"\n-      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n-    )\n-    add_test(\n-      NAME \"avoid_cerr\"\n-      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} ' _*cerr' || exit 0  && exit 1\"\n-      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n-    )\n-    add_test(\n-      NAME \"avoid_printf\"\n-      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} ' _*printf' || exit 0  && exit 1\"\n-      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n-    )\n-    add_test(\n-      NAME \"avoid_stdout\"\n-      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} stdout || exit 0 && exit 1\"\n-      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n-    )\n-    add_test(\n-      NAME \"avoid_stderr\"\n-      COMMAND sh -c \"${NM}  $<TARGET_FILE_NAME:simdjson> |  ${GREP} stderr || exit 0 && exit 1\"\n-      WORKING_DIRECTORY ${PROJECT_BINARY_DIR}\n-    )\n-  endif()\n-endif()\n-\n-if(NOT MSVC)\n-  ## We output the library at the root of the current directory where cmake is invoked\n-  ## This is handy but Visual Studio will happily ignore us\n-  set_target_properties(simdjson PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})\n-  MESSAGE( STATUS \"Library output directory: \" ${PROJECT_BINARY_DIR})\n-\n-  ############\n-  # Please do not delete the following, our users want version numbers. See\n-  # https://github.com/simdjson/simdjson/issues/1014\n-  # https://github.com/simdjson/simdjson/issues/52\n-  ###########\n-  set_target_properties(simdjson PROPERTIES VERSION ${SIMDJSON_LIB_VERSION}\tSOVERSION ${SIMDJSON_LIB_SOVERSION})\n-  ##########\n-  # End of the do-not-delete message.\n-  #########\n-endif()\n-\n-#\n-# Installation\n-#\n-install(TARGETS simdjson\n-  EXPORT simdjson-config\n-  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n-  LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n-  RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n-)\n-\n-install(EXPORT simdjson-config\n-  FILE simdjson-targets.cmake\n-  NAMESPACE simdjson::\n-  DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/simdjson\n-)"
      },
      {
        "filename": "vendor/simdjson/src/arm64/dom_parser_implementation.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -133,7 +133,7 @@ simdjson_warn_unused error_code implementation::minify(const uint8_t *buf, size_\n   return arm64::stage1::json_minifier::minify<64>(buf, len, dst, dst_len);\n }\n \n-simdjson_warn_unused error_code dom_parser_implementation::stage1(const uint8_t *_buf, size_t _len, bool streaming) noexcept {\n+simdjson_warn_unused error_code dom_parser_implementation::stage1(const uint8_t *_buf, size_t _len, stage1_mode streaming) noexcept {\n   this->buf = _buf;\n   this->len = _len;\n   return arm64::stage1::json_structural_indexer::index<64>(buf, len, *this, streaming);\n@@ -152,7 +152,7 @@ simdjson_warn_unused error_code dom_parser_implementation::stage2_next(dom::docu\n }\n \n simdjson_warn_unused error_code dom_parser_implementation::parse(const uint8_t *_buf, size_t _len, dom::document &_doc) noexcept {\n-  auto error = stage1(_buf, _len, false);\n+  auto error = stage1(_buf, _len, stage1_mode::regular);\n   if (error) { return error; }\n   return stage2(_doc);\n }"
      },
      {
        "filename": "vendor/simdjson/src/arm64/implementation.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "patch": "@@ -10,12 +10,14 @@ simdjson_warn_unused error_code implementation::create_dom_parser_implementation\n ) const noexcept {\n   dst.reset( new (std::nothrow) dom_parser_implementation() );\n   if (!dst) { return MEMALLOC; }\n-  dst->set_capacity(capacity);\n-  dst->set_max_depth(max_depth);\n+  if (auto err = dst->set_capacity(capacity))\n+    return err;\n+  if (auto err = dst->set_max_depth(max_depth))\n+    return err;\n   return SUCCESS;\n }\n \n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n \n-#include \"simdjson/arm64/end.h\"\n\\ No newline at end of file\n+#include \"simdjson/arm64/end.h\""
      },
      {
        "filename": "vendor/simdjson/src/fallback/dom_parser_implementation.cpp",
        "status": "modified",
        "additions": 42,
        "deletions": 10,
        "changes": 52,
        "patch": "@@ -13,7 +13,7 @@ namespace stage1 {\n class structural_scanner {\n public:\n \n-simdjson_really_inline structural_scanner(dom_parser_implementation &_parser, bool _partial)\n+simdjson_really_inline structural_scanner(dom_parser_implementation &_parser, stage1_mode _partial)\n   : buf{_parser.buf},\n     next_structural_index{_parser.structural_indexes.get()},\n     parser{_parser},\n@@ -43,7 +43,7 @@ simdjson_really_inline void validate_utf8_character() {\n   if ((buf[idx] & 0b00100000) == 0) {\n     // missing continuation\n     if (simdjson_unlikely(idx+1 > len || !is_continuation(buf[idx+1]))) {\n-      if (idx+1 > len && partial) { idx = len; return; }\n+      if (idx+1 > len && is_streaming(partial)) { idx = len; return; }\n       error = UTF8_ERROR;\n       idx++;\n       return;\n@@ -58,7 +58,7 @@ simdjson_really_inline void validate_utf8_character() {\n   if ((buf[idx] & 0b00010000) == 0) {\n     // missing continuation\n     if (simdjson_unlikely(idx+2 > len || !is_continuation(buf[idx+1]) || !is_continuation(buf[idx+2]))) {\n-      if (idx+2 > len && partial) { idx = len; return; }\n+      if (idx+2 > len && is_streaming(partial)) { idx = len; return; }\n       error = UTF8_ERROR;\n       idx++;\n       return;\n@@ -74,7 +74,7 @@ simdjson_really_inline void validate_utf8_character() {\n   // 4-byte\n   // missing continuation\n   if (simdjson_unlikely(idx+3 > len || !is_continuation(buf[idx+1]) || !is_continuation(buf[idx+2]) || !is_continuation(buf[idx+3]))) {\n-    if (idx+2 > len && partial) { idx = len; return; }\n+    if (idx+2 > len && is_streaming(partial)) { idx = len; return; }\n     error = UTF8_ERROR;\n     idx++;\n     return;\n@@ -147,24 +147,56 @@ simdjson_really_inline error_code scan() {\n         break;\n     }\n   }\n-  *next_structural_index = len;\n   // We pad beyond.\n   // https://github.com/simdjson/simdjson/issues/906\n+  // See json_structural_indexer.h for an explanation.\n+  *next_structural_index = len; // assumed later in partial == stage1_mode::streaming_final\n   next_structural_index[1] = len;\n   next_structural_index[2] = 0;\n   parser.n_structural_indexes = uint32_t(next_structural_index - parser.structural_indexes.get());\n   if (simdjson_unlikely(parser.n_structural_indexes == 0)) { return EMPTY; }\n   parser.next_structural_index = 0;\n-  if (partial) {\n+  if (partial == stage1_mode::streaming_partial) {\n     if(unclosed_string) {\n       parser.n_structural_indexes--;\n       if (simdjson_unlikely(parser.n_structural_indexes == 0)) { return CAPACITY; }\n     }\n+    // We truncate the input to the end of the last complete document (or zero).\n     auto new_structural_indexes = find_next_document_index(parser);\n     if (new_structural_indexes == 0 && parser.n_structural_indexes > 0) {\n-      return CAPACITY; // If the buffer is partial but the document is incomplete, it's too big to parse.\n+      if(parser.structural_indexes[0] == 0) {\n+        // If the buffer is partial and we started at index 0 but the document is\n+        // incomplete, it's too big to parse.\n+        return CAPACITY;\n+      } else {\n+        // It is possible that the document could be parsed, we just had a lot\n+        // of white space.\n+        parser.n_structural_indexes = 0;\n+        return EMPTY;\n+      }\n     }\n     parser.n_structural_indexes = new_structural_indexes;\n+  } else if(partial == stage1_mode::streaming_final) {\n+    if(unclosed_string) { parser.n_structural_indexes--; }\n+    // We truncate the input to the end of the last complete document (or zero).\n+    // Because partial == stage1_mode::streaming_final, it means that we may\n+    // silently ignore trailing garbage. Though it sounds bad, we do it\n+    // deliberately because many people who have streams of JSON documents\n+    // will truncate them for processing. E.g., imagine that you are uncompressing\n+    // the data from a size file or receiving it in chunks from the network. You\n+    // may not know where exactly the last document will be. Meanwhile the\n+    // document_stream instances allow people to know the JSON documents they are\n+    // parsing (see the iterator.source() method).\n+    parser.n_structural_indexes = find_next_document_index(parser);\n+    // We store the initial n_structural_indexes so that the client can see\n+    // whether we used truncation. If initial_n_structural_indexes == parser.n_structural_indexes,\n+    // then this will query parser.structural_indexes[parser.n_structural_indexes] which is len,\n+    // otherwise, it will copy some prior index.\n+    parser.structural_indexes[parser.n_structural_indexes + 1] = parser.structural_indexes[parser.n_structural_indexes];\n+    // This next line is critical, do not change it unless you understand what you are\n+    // doing.\n+    parser.structural_indexes[parser.n_structural_indexes] = uint32_t(len);\n+    if (parser.n_structural_indexes == 0) { return EMPTY; }\n   } else if(unclosed_string) { error = UNCLOSED_STRING; }\n   return error;\n }\n@@ -176,13 +208,13 @@ simdjson_really_inline error_code scan() {\n   uint32_t len;\n   uint32_t idx{0};\n   error_code error{SUCCESS};\n-  bool partial;\n+  stage1_mode partial;\n }; // structural_scanner\n \n } // namespace stage1\n } // unnamed namespace\n \n-simdjson_warn_unused error_code dom_parser_implementation::stage1(const uint8_t *_buf, size_t _len, bool partial) noexcept {\n+simdjson_warn_unused error_code dom_parser_implementation::stage1(const uint8_t *_buf, size_t _len, stage1_mode partial) noexcept {\n   this->buf = _buf;\n   this->len = _len;\n   stage1::structural_scanner scanner(*this, partial);\n@@ -328,7 +360,7 @@ simdjson_warn_unused error_code dom_parser_implementation::stage2_next(dom::docu\n }\n \n simdjson_warn_unused error_code dom_parser_implementation::parse(const uint8_t *_buf, size_t _len, dom::document &_doc) noexcept {\n-  auto error = stage1(_buf, _len, false);\n+  auto error = stage1(_buf, _len, stage1_mode::regular);\n   if (error) { return error; }\n   return stage2(_doc);\n }"
      },
      {
        "filename": "vendor/simdjson/src/fallback/implementation.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "patch": "@@ -10,12 +10,14 @@ simdjson_warn_unused error_code implementation::create_dom_parser_implementation\n ) const noexcept {\n   dst.reset( new (std::nothrow) dom_parser_implementation() );\n   if (!dst) { return MEMALLOC; }\n-  dst->set_capacity(capacity);\n-  dst->set_max_depth(max_depth);\n+  if (auto err = dst->set_capacity(capacity))\n+    return err;\n+  if (auto err = dst->set_max_depth(max_depth))\n+    return err;\n   return SUCCESS;\n }\n \n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n \n-#include \"simdjson/fallback/end.h\"\n\\ No newline at end of file\n+#include \"simdjson/fallback/end.h\""
      },
      {
        "filename": "vendor/simdjson/src/from_chars.cpp",
        "status": "modified",
        "additions": 103,
        "deletions": 0,
        "changes": 103,
        "patch": "@@ -134,6 +134,86 @@ decimal parse_decimal(const char *&p) noexcept {\n   return answer;\n }\n \n+// This should always succeed since it follows a call to parse_number.\n+// Will not read at or beyond the \"end\" pointer.\n+decimal parse_decimal(const char *&p, const char * end) noexcept {\n+  decimal answer;\n+  answer.num_digits = 0;\n+  answer.decimal_point = 0;\n+  answer.truncated = false;\n+  if(p == end) { return answer; } // should never happen\n+  answer.negative = (*p == '-');\n+  if ((*p == '-') || (*p == '+')) {\n+    ++p;\n+  }\n+\n+  while ((p != end) && (*p == '0')) {\n+    ++p;\n+  }\n+  while ((p != end) && is_integer(*p)) {\n+    if (answer.num_digits < max_digits) {\n+      answer.digits[answer.num_digits] = uint8_t(*p - '0');\n+    }\n+    answer.num_digits++;\n+    ++p;\n+  }\n+  if ((p != end) && (*p == '.')) {\n+    ++p;\n+    if(p == end) { return answer; } // should never happen\n+    const char *first_after_period = p;\n+    // if we have not yet encountered a zero, we have to skip it as well\n+    if (answer.num_digits == 0) {\n+      // skip zeros\n+      while (*p == '0') {\n+        ++p;\n+      }\n+    }\n+    while ((p != end) && is_integer(*p)) {\n+      if (answer.num_digits < max_digits) {\n+        answer.digits[answer.num_digits] = uint8_t(*p - '0');\n+      }\n+      answer.num_digits++;\n+      ++p;\n+    }\n+    answer.decimal_point = int32_t(first_after_period - p);\n+  }\n+  if(answer.num_digits > 0) {\n+    const char *preverse = p - 1;\n+    int32_t trailing_zeros = 0;\n+    while ((*preverse == '0') || (*preverse == '.')) {\n+      if(*preverse == '0') { trailing_zeros++; };\n+      --preverse;\n+    }\n+    answer.decimal_point += int32_t(answer.num_digits);\n+    answer.num_digits -= uint32_t(trailing_zeros);\n+  }\n+  if(answer.num_digits > max_digits ) {\n+    answer.num_digits = max_digits;\n+    answer.truncated = true;\n+  }\n+  if ((p != end) && (('e' == *p) || ('E' == *p))) {\n+    ++p;\n+    if(p == end) { return answer; } // should never happen\n+    bool neg_exp = false;\n+    if ('-' == *p) {\n+      neg_exp = true;\n+      ++p;\n+    } else if ('+' == *p) {\n+      ++p;\n+    }\n+    int32_t exp_number = 0; // exponential part\n+    while ((p != end) && is_integer(*p)) {\n+      uint8_t digit = uint8_t(*p - '0');\n+      if (exp_number < 0x10000) {\n+        exp_number = 10 * exp_number + digit;\n+      }\n+      ++p;\n+    }\n+    answer.decimal_point += (neg_exp ? -exp_number : exp_number);\n+  }\n+  return answer;\n+}\n+\n namespace {\n \n // remove all final zeroes\n@@ -473,6 +553,12 @@ adjusted_mantissa parse_long_mantissa(const char *first) {\n   return compute_float<binary>(d);\n }\n \n+template <typename binary>\n+adjusted_mantissa parse_long_mantissa(const char *first, const char *end) {\n+  decimal d = parse_decimal(first, end);\n+  return compute_float<binary>(d);\n+}\n+\n double from_chars(const char *first) noexcept {\n   bool negative = first[0] == '-';\n   if (negative) {\n@@ -489,5 +575,22 @@ double from_chars(const char *first) noexcept {\n   return value;\n }\n \n+\n+double from_chars(const char *first, const char *end) noexcept {\n+  bool negative = first[0] == '-';\n+  if (negative) {\n+    first++;\n+  }\n+  adjusted_mantissa am = parse_long_mantissa<binary_format<double>>(first, end);\n+  uint64_t word = am.mantissa;\n+  word |= uint64_t(am.power2)\n+          << binary_format<double>::mantissa_explicit_bits();\n+  word = negative ? word | (uint64_t(1) << binary_format<double>::sign_index())\n+                  : word;\n+  double value;\n+  std::memcpy(&value, &word, sizeof(double));\n+  return value;\n+}\n+\n } // internal\n } // simdjson\n\\ No newline at end of file"
      },
      {
        "filename": "vendor/simdjson/src/generic/stage1/find_next_document_index.h",
        "status": "modified",
        "additions": 23,
        "deletions": 3,
        "changes": 26,
        "patch": "@@ -13,8 +13,8 @@ namespace {\n   *\n   * Simply put, we iterate over the structural characters, starting from\n   * the end. We consider that we found the end of a JSON document when the\n-  * first element of the pair is NOT one of these characters: '{' '[' ';' ','\n-  * and when the second element is NOT one of these characters: '}' '}' ';' ','.\n+  * first element of the pair is NOT one of these characters: '{' '[' ':' ','\n+  * and when the second element is NOT one of these characters: '}' ']' ':' ','.\n   *\n   * This simple comparison works most of the time, but it does not cover cases\n   * where the batch's structural indexes contain a perfect amount of documents.\n@@ -28,7 +28,8 @@ namespace {\n   * batch.\n   */\n simdjson_really_inline uint32_t find_next_document_index(dom_parser_implementation &parser) {\n-  // TODO don't count separately, just figure out depth\n+  // Variant: do not count separately, just figure out depth\n+  if(parser.n_structural_indexes == 0) { return 0; }\n   auto arr_cnt = 0;\n   auto obj_cnt = 0;\n   for (auto i = parser.n_structural_indexes - 1; i > 0; i--) {\n@@ -65,6 +66,25 @@ simdjson_really_inline uint32_t find_next_document_index(dom_parser_implementati\n     // Last document is incomplete; mark the document at i + 1 as the next one\n     return i;\n   }\n+  // If we made it to the end, we want to finish counting to see if we have a full document.\n+  switch (parser.buf[parser.structural_indexes[0]]) {\n+    case '}':\n+      obj_cnt--;\n+      break;\n+    case ']':\n+      arr_cnt--;\n+      break;\n+    case '{':\n+      obj_cnt++;\n+      break;\n+    case '[':\n+      arr_cnt++;\n+      break;\n+  }\n+  if (!arr_cnt && !obj_cnt) {\n+    // We have a complete document.\n+    return parser.n_structural_indexes;\n+  }\n   return 0;\n }\n "
      },
      {
        "filename": "vendor/simdjson/src/generic/stage1/json_minifier.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "patch": "@@ -27,8 +27,7 @@ class json_minifier {\n \n simdjson_really_inline void json_minifier::next(const simd::simd8x64<uint8_t>& in, const json_block& block) {\n   uint64_t mask = block.whitespace();\n-  in.compress(mask, dst);\n-  dst += 64 - count_ones(mask);\n+  dst += in.compress(mask, dst);\n }\n \n simdjson_really_inline error_code json_minifier::finish(uint8_t *dst_start, size_t &dst_len) {"
      },
      {
        "filename": "vendor/simdjson/src/generic/stage1/json_structural_indexer.h",
        "status": "modified",
        "additions": 117,
        "deletions": 16,
        "changes": 133,
        "patch": "@@ -31,8 +31,62 @@ class bit_indexer {\n     // it helps tremendously.\n     if (bits == 0)\n         return;\n+#if defined(SIMDJSON_PREFER_REVERSE_BITS)\n+    /**\n+     * ARM lacks a fast trailing zero instruction, but it has a fast\n+     * bit reversal instruction and a fast leading zero instruction.\n+     * Thus it may be profitable to reverse the bits (once) and then\n+     * to rely on a sequence of instructions that call the leading\n+     * zero instruction.\n+     *\n+     * Performance notes:\n+     * The chosen routine is not optimal in terms of data dependency\n+     * since zero_leading_bit might require two instructions. However,\n+     * it tends to minimize the total number of instructions which is\n+     * beneficial.\n+     */\n+\n+    uint64_t rev_bits = reverse_bits(bits);\n     int cnt = static_cast<int>(count_ones(bits));\n+    int i = 0;\n+    // Do the first 8 all together\n+    for (; i<8; i++) {\n+      int lz = leading_zeroes(rev_bits);\n+      this->tail[i] = static_cast<uint32_t>(idx) + lz;\n+      rev_bits = zero_leading_bit(rev_bits, lz);\n+    }\n+    // Do the next 8 all together (we hope in most cases it won't happen at all\n+    // and the branch is easily predicted).\n+    if (simdjson_unlikely(cnt > 8)) {\n+      i = 8;\n+      for (; i<16; i++) {\n+        int lz = leading_zeroes(rev_bits);\n+        this->tail[i] = static_cast<uint32_t>(idx) + lz;\n+        rev_bits = zero_leading_bit(rev_bits, lz);\n+      }\n+\n+\n+      // Most files don't have 16+ structurals per block, so we take several basically guaranteed\n+      // branch mispredictions here. 16+ structurals per block means either punctuation ({} [] , :)\n+      // or the start of a value (\"abc\" true 123) every four characters.\n+      if (simdjson_unlikely(cnt > 16)) {\n+        i = 16;\n+        while (rev_bits != 0) {\n+          int lz = leading_zeroes(rev_bits);\n+          this->tail[i++] = static_cast<uint32_t>(idx) + lz;\n+          rev_bits = zero_leading_bit(rev_bits, lz);\n+        }\n+      }\n+    }\n+    this->tail += cnt;\n+#else // SIMDJSON_PREFER_REVERSE_BITS\n+    /**\n+     * Under recent x64 systems, we often have both a fast trailing zero\n+     * instruction and a fast 'clear-lower-bit' instruction so the following\n+     * algorithm can be competitive.\n+     */\n \n+    int cnt = static_cast<int>(count_ones(bits));\n     // Do the first 8 all together\n     for (int i=0; i<8; i++) {\n       this->tail[i] = idx + trailing_zeroes(bits);\n@@ -61,6 +115,7 @@ class bit_indexer {\n     }\n \n     this->tail += cnt;\n+#endif\n   }\n };\n \n@@ -74,14 +129,14 @@ class json_structural_indexer {\n    *   you are processing substrings, you may want to call on a function like trimmed_length_safe_utf8.\n    */\n   template<size_t STEP_SIZE>\n-  static error_code index(const uint8_t *buf, size_t len, dom_parser_implementation &parser, bool partial) noexcept;\n+  static error_code index(const uint8_t *buf, size_t len, dom_parser_implementation &parser, stage1_mode partial) noexcept;\n \n private:\n   simdjson_really_inline json_structural_indexer(uint32_t *structural_indexes);\n   template<size_t STEP_SIZE>\n   simdjson_really_inline void step(const uint8_t *block, buf_block_reader<STEP_SIZE> &reader) noexcept;\n   simdjson_really_inline void next(const simd::simd8x64<uint8_t>& in, const json_block& block, size_t idx);\n-  simdjson_really_inline error_code finish(dom_parser_implementation &parser, size_t idx, size_t len, bool partial);\n+  simdjson_really_inline error_code finish(dom_parser_implementation &parser, size_t idx, size_t len, stage1_mode partial);\n \n   json_scanner scanner{};\n   utf8_checker checker{};\n@@ -131,23 +186,29 @@ simdjson_really_inline size_t trim_partial_utf8(const uint8_t *buf, size_t len)\n // workout.\n //\n template<size_t STEP_SIZE>\n-error_code json_structural_indexer::index(const uint8_t *buf, size_t len, dom_parser_implementation &parser, bool partial) noexcept {\n+error_code json_structural_indexer::index(const uint8_t *buf, size_t len, dom_parser_implementation &parser, stage1_mode partial) noexcept {\n   if (simdjson_unlikely(len > parser.capacity())) { return CAPACITY; }\n-  if (partial) { len = trim_partial_utf8(buf, len); }\n-\n+  // We guard the rest of the code so that we can assume that len > 0 throughout.\n+  if (len == 0) { return EMPTY; }\n+  if (is_streaming(partial)) {\n+    len = trim_partial_utf8(buf, len);\n+    // If you end up with an empty window after trimming\n+    // the partial UTF-8 bytes, then chances are good that you\n+    // have an UTF-8 formatting error.\n+    if(len == 0) { return UTF8_ERROR; }\n+  }\n   buf_block_reader<STEP_SIZE> reader(buf, len);\n   json_structural_indexer indexer(parser.structural_indexes.get());\n \n   // Read all but the last block\n   while (reader.has_full_block()) {\n     indexer.step<STEP_SIZE>(reader.full_block(), reader);\n   }\n-\n-  // Take care of the last block (will always be there unless file is empty)\n+  // Take care of the last block (will always be there unless file is empty which is\n+  // not supposed to happen.)\n   uint8_t block[STEP_SIZE];\n-  if (simdjson_unlikely(reader.get_remainder(block) == 0)) { return EMPTY; }\n+  if (simdjson_unlikely(reader.get_remainder(block) == 0)) { return UNEXPECTED_ERROR; }\n   indexer.step<STEP_SIZE>(block, reader);\n-\n   return indexer.finish(parser, reader.block_index(), len, partial);\n }\n \n@@ -178,14 +239,13 @@ simdjson_really_inline void json_structural_indexer::next(const simd::simd8x64<u\n   unescaped_chars_error |= block.non_quote_inside_string(unescaped);\n }\n \n-simdjson_really_inline error_code json_structural_indexer::finish(dom_parser_implementation &parser, size_t idx, size_t len, bool partial) {\n+simdjson_really_inline error_code json_structural_indexer::finish(dom_parser_implementation &parser, size_t idx, size_t len, stage1_mode partial) {\n   // Write out the final iteration's structurals\n   indexer.write(uint32_t(idx-64), prev_structurals);\n-\n   error_code error = scanner.finish();\n   // We deliberately break down the next expression so that it is\n   // human readable.\n-  const bool should_we_exit =  partial ?\n+  const bool should_we_exit = is_streaming(partial) ?\n     ((error != SUCCESS) && (error != UNCLOSED_STRING)) // when partial we tolerate UNCLOSED_STRING\n     : (error != SUCCESS); // if partial is false, we must have SUCCESS\n   const bool have_unclosed_string = (error == UNCLOSED_STRING);\n@@ -194,9 +254,10 @@ simdjson_really_inline error_code json_structural_indexer::finish(dom_parser_imp\n   if (unescaped_chars_error) {\n     return UNESCAPED_CHARS;\n   }\n-\n   parser.n_structural_indexes = uint32_t(indexer.tail - parser.structural_indexes.get());\n   /***\n+   * The On Demand API requires special padding.\n+   *\n    * This is related to https://github.com/simdjson/simdjson/issues/906\n    * Basically, we want to make sure that if the parsing continues beyond the last (valid)\n    * structural character, it quickly stops.\n@@ -209,8 +270,11 @@ simdjson_really_inline error_code json_structural_indexer::finish(dom_parser_imp\n    * if the repeated character is [. But if so, the document must start with [. But if the document\n    * starts with [, it should end with ]. If we enforce that rule, then we would get\n    * ][[ which is invalid.\n+   *\n+   * This is illustrated with the test array_iterate_unclosed_error() on the following input:\n+   * R\"({ \"a\": [,,)\"\n    **/\n-  parser.structural_indexes[parser.n_structural_indexes] = uint32_t(len);\n+  parser.structural_indexes[parser.n_structural_indexes] = uint32_t(len); // used later in partial == stage1_mode::streaming_final\n   parser.structural_indexes[parser.n_structural_indexes + 1] = uint32_t(len);\n   parser.structural_indexes[parser.n_structural_indexes + 2] = 0;\n   parser.next_structural_index = 0;\n@@ -221,19 +285,56 @@ simdjson_really_inline error_code json_structural_indexer::finish(dom_parser_imp\n   if (simdjson_unlikely(parser.structural_indexes[parser.n_structural_indexes - 1] > len)) {\n     return UNEXPECTED_ERROR;\n   }\n-  if (partial) {\n+  if (partial == stage1_mode::streaming_partial) {\n     // If we have an unclosed string, then the last structural\n     // will be the quote and we want to make sure to omit it.\n     if(have_unclosed_string) {\n       parser.n_structural_indexes--;\n       // a valid JSON file cannot have zero structural indexes - we should have found something\n       if (simdjson_unlikely(parser.n_structural_indexes == 0u)) { return CAPACITY; }\n     }\n+    // We truncate the input to the end of the last complete document (or zero).\n     auto new_structural_indexes = find_next_document_index(parser);\n     if (new_structural_indexes == 0 && parser.n_structural_indexes > 0) {\n-      return CAPACITY; // If the buffer is partial but the document is incomplete, it's too big to parse.\n+      if(parser.structural_indexes[0] == 0) {\n+        // If the buffer is partial and we started at index 0 but the document is\n+        // incomplete, it's too big to parse.\n+        return CAPACITY;\n+      } else {\n+        // It is possible that the document could be parsed, we just had a lot\n+        // of white space.\n+        parser.n_structural_indexes = 0;\n+        return EMPTY;\n+      }\n     }\n+\n     parser.n_structural_indexes = new_structural_indexes;\n+  } else if (partial == stage1_mode::streaming_final) {\n+    if(have_unclosed_string) { parser.n_structural_indexes--; }\n+    // We truncate the input to the end of the last complete document (or zero).\n+    // Because partial == stage1_mode::streaming_final, it means that we may\n+    // silently ignore trailing garbage. Though it sounds bad, we do it\n+    // deliberately because many people who have streams of JSON documents\n+    // will truncate them for processing. E.g., imagine that you are uncompressing\n+    // the data from a size file or receiving it in chunks from the network. You\n+    // may not know where exactly the last document will be. Meanwhile the\n+    // document_stream instances allow people to know the JSON documents they are\n+    // parsing (see the iterator.source() method).\n+    parser.n_structural_indexes = find_next_document_index(parser);\n+    // We store the initial n_structural_indexes so that the client can see\n+    // whether we used truncation. If initial_n_structural_indexes == parser.n_structural_indexes,\n+    // then this will query parser.structural_indexes[parser.n_structural_indexes] which is len,\n+    // otherwise, it will copy some prior index.\n+    parser.structural_indexes[parser.n_structural_indexes + 1] = parser.structural_indexes[parser.n_structural_indexes];\n+    // This next line is critical, do not change it unless you understand what you are\n+    // doing.\n+    parser.structural_indexes[parser.n_structural_indexes] = uint32_t(len);\n+    if (simdjson_unlikely(parser.n_structural_indexes == 0u)) {\n+        // We tolerate an unclosed string at the very end of the stream. Indeed, users\n+        // often load their data in bulk without being careful and they want us to ignore\n+        // the trailing garbage.\n+        return EMPTY;\n+    }\n   }\n   checker.check_eof();\n   return checker.errors();"
      },
      {
        "filename": "vendor/simdjson/src/generic/stage1/utf8_lookup4_algorithm.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "patch": "@@ -167,7 +167,6 @@ using namespace simd;\n         }\n         this->prev_incomplete = is_incomplete(input.chunks[simd8x64<uint8_t>::NUM_CHUNKS-1]);\n         this->prev_input_block = input.chunks[simd8x64<uint8_t>::NUM_CHUNKS-1];\n-\n       }\n     }\n     // do not forget to call check_eof!"
      },
      {
        "filename": "vendor/simdjson/src/generic/stage2/json_iterator.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "patch": "@@ -125,12 +125,12 @@ simdjson_warn_unused simdjson_really_inline error_code json_iterator::walk_docum\n   {\n     auto value = advance();\n \n-    // Make sure the outer hash or array is closed before continuing; otherwise, there are ways we\n+    // Make sure the outer object or array is closed before continuing; otherwise, there are ways we\n     // could get into memory corruption. See https://github.com/simdjson/simdjson/issues/906\n     if (!STREAMING) {\n       switch (*value) {\n-        case '{': if (last_structural() != '}') { return TAPE_ERROR; }; break;\n-        case '[': if (last_structural() != ']') { return TAPE_ERROR; }; break;\n+        case '{': if (last_structural() != '}') { log_value(\"starting brace unmatched\"); return TAPE_ERROR; }; break;\n+        case '[': if (last_structural() != ']') { log_value(\"starting bracket unmatched\"); return TAPE_ERROR; }; break;\n       }\n     }\n "
      },
      {
        "filename": "vendor/simdjson/src/haswell/dom_parser_implementation.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -134,7 +134,7 @@ simdjson_warn_unused error_code implementation::minify(const uint8_t *buf, size_\n   return haswell::stage1::json_minifier::minify<128>(buf, len, dst, dst_len);\n }\n \n-simdjson_warn_unused error_code dom_parser_implementation::stage1(const uint8_t *_buf, size_t _len, bool streaming) noexcept {\n+simdjson_warn_unused error_code dom_parser_implementation::stage1(const uint8_t *_buf, size_t _len, stage1_mode streaming) noexcept {\n   this->buf = _buf;\n   this->len = _len;\n   return haswell::stage1::json_structural_indexer::index<128>(_buf, _len, *this, streaming);\n@@ -153,7 +153,7 @@ simdjson_warn_unused error_code dom_parser_implementation::stage2_next(dom::docu\n }\n \n simdjson_warn_unused error_code dom_parser_implementation::parse(const uint8_t *_buf, size_t _len, dom::document &_doc) noexcept {\n-  auto error = stage1(_buf, _len, false);\n+  auto error = stage1(_buf, _len, stage1_mode::regular);\n   if (error) { return error; }\n   return stage2(_doc);\n }"
      },
      {
        "filename": "vendor/simdjson/src/haswell/implementation.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "patch": "@@ -10,8 +10,10 @@ simdjson_warn_unused error_code implementation::create_dom_parser_implementation\n ) const noexcept {\n   dst.reset( new (std::nothrow) dom_parser_implementation() );\n   if (!dst) { return MEMALLOC; }\n-  dst->set_capacity(capacity);\n-  dst->set_max_depth(max_depth);\n+  if (auto err = dst->set_capacity(capacity))\n+    return err;\n+  if (auto err = dst->set_max_depth(max_depth))\n+    return err;\n   return SUCCESS;\n }\n "
      },
      {
        "filename": "vendor/simdjson/src/internal/error_tables.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "patch": "@@ -30,7 +30,10 @@ namespace internal {\n     { UNEXPECTED_ERROR, \"Unexpected error, consider reporting this problem as you may have found a bug in simdjson\" },\n     { PARSER_IN_USE, \"Cannot parse a new document while a document is still in use.\" },\n     { OUT_OF_ORDER_ITERATION, \"Objects and arrays can only be iterated when they are first encountered.\" },\n-    { INSUFFICIENT_PADDING, \"simdjson requires the input JSON string to have at least SIMDJSON_PADDING extra bytes allocated, beyond the string's length.\" }\n+    { INSUFFICIENT_PADDING, \"simdjson requires the input JSON string to have at least SIMDJSON_PADDING extra bytes allocated, beyond the string's length. Consider using the simdjson::padded_string class if needed.\" },\n+    { INCOMPLETE_ARRAY_OR_OBJECT, \"JSON document ended early in the middle of an object or array.\" },\n+    { SCALAR_DOCUMENT_AS_VALUE, \"A JSON document made of a scalar (number, Boolean, null or string) is treated as a value. Use get_bool(), get_double(), etc. on the document instead. \"},\n+    { OUT_OF_BOUNDS, \"Attempted to access location outside of document.\"}\n   }; // error_messages[]\n \n } // namespace internal"
      },
      {
        "filename": "vendor/simdjson/src/ppc64/dom_parser_implementation.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -104,7 +104,7 @@ simdjson_warn_unused error_code implementation::minify(const uint8_t *buf, size_\n   return ppc64::stage1::json_minifier::minify<64>(buf, len, dst, dst_len);\n }\n \n-simdjson_warn_unused error_code dom_parser_implementation::stage1(const uint8_t *_buf, size_t _len, bool streaming) noexcept {\n+simdjson_warn_unused error_code dom_parser_implementation::stage1(const uint8_t *_buf, size_t _len, stage1_mode streaming) noexcept {\n   this->buf = _buf;\n   this->len = _len;\n   return ppc64::stage1::json_structural_indexer::index<64>(buf, len, *this, streaming);\n@@ -123,7 +123,7 @@ simdjson_warn_unused error_code dom_parser_implementation::stage2_next(dom::docu\n }\n \n simdjson_warn_unused error_code dom_parser_implementation::parse(const uint8_t *_buf, size_t _len, dom::document &_doc) noexcept {\n-  auto error = stage1(_buf, _len, false);\n+  auto error = stage1(_buf, _len, stage1_mode::regular);\n   if (error) { return error; }\n   return stage2(_doc);\n }"
      },
      {
        "filename": "vendor/simdjson/src/ppc64/implementation.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "patch": "@@ -10,12 +10,14 @@ simdjson_warn_unused error_code implementation::create_dom_parser_implementation\n ) const noexcept {\n   dst.reset( new (std::nothrow) dom_parser_implementation() );\n   if (!dst) { return MEMALLOC; }\n-  dst->set_capacity(capacity);\n-  dst->set_max_depth(max_depth);\n+  if (auto err = dst->set_capacity(capacity))\n+    return err;\n+  if (auto err = dst->set_max_depth(max_depth))\n+    return err;\n   return SUCCESS;\n }\n \n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n \n-#include \"simdjson/ppc64/end.h\"\n\\ No newline at end of file\n+#include \"simdjson/ppc64/end.h\""
      },
      {
        "filename": "vendor/simdjson/src/to_chars.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 6,
        "changes": 17,
        "patch": "@@ -1,6 +1,8 @@\n #include <cstring>\n #include <cstdint>\n #include <array>\n+#include <cmath>\n+\n namespace simdjson {\n namespace internal {\n /*!\n@@ -858,9 +860,9 @@ inline char *format_buffer(char *buf, int len, int decimal_exponent,\n \n     std::memset(buf + k, '0', static_cast<size_t>(n) - static_cast<size_t>(k));\n     // Make it look like a floating-point number (#362, #378)\n-    buf[n + 0] = '.';\n-    buf[n + 1] = '0';\n-    return buf + (static_cast<size_t>(n) + 2);\n+    // buf[n + 0] = '.';\n+    // buf[n + 1] = '0';\n+    return buf + (static_cast<size_t>(n));\n   }\n \n   if (0 < n && n <= max_exp) {\n@@ -913,7 +915,8 @@ format. Returns an iterator pointing past-the-end of the decimal representation.\n */\n char *to_chars(char *first, const char *last, double value) {\n   static_cast<void>(last); // maybe unused - fix warning\n-  if (value <= -0) {\n+  bool negative = std::signbit(value);\n+  if (negative) {\n     value = -value;\n     *first++ = '-';\n   }\n@@ -922,8 +925,10 @@ char *to_chars(char *first, const char *last, double value) {\n   {\n     *first++ = '0';\n     // Make it look like a floating-point number (#362, #378)\n-    *first++ = '.';\n-    *first++ = '0';\n+    if(negative) {\n+      *first++ = '.';\n+      *first++ = '0';\n+    }\n     return first;\n   }\n   // Compute v = buffer * 10^decimal_exponent."
      },
      {
        "filename": "vendor/simdjson/src/westmere/dom_parser_implementation.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "patch": "@@ -133,7 +133,7 @@ simdjson_warn_unused error_code implementation::minify(const uint8_t *buf, size_\n   return westmere::stage1::json_minifier::minify<64>(buf, len, dst, dst_len);\n }\n \n-simdjson_warn_unused error_code dom_parser_implementation::stage1(const uint8_t *_buf, size_t _len, bool streaming) noexcept {\n+simdjson_warn_unused error_code dom_parser_implementation::stage1(const uint8_t *_buf, size_t _len, stage1_mode streaming) noexcept {\n   this->buf = _buf;\n   this->len = _len;\n   return westmere::stage1::json_structural_indexer::index<64>(_buf, _len, *this, streaming);\n@@ -152,7 +152,7 @@ simdjson_warn_unused error_code dom_parser_implementation::stage2_next(dom::docu\n }\n \n simdjson_warn_unused error_code dom_parser_implementation::parse(const uint8_t *_buf, size_t _len, dom::document &_doc) noexcept {\n-  auto error = stage1(_buf, _len, false);\n+  auto error = stage1(_buf, _len, stage1_mode::regular);\n   if (error) { return error; }\n   return stage2(_doc);\n }"
      },
      {
        "filename": "vendor/simdjson/src/westmere/implementation.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "patch": "@@ -10,12 +10,14 @@ simdjson_warn_unused error_code implementation::create_dom_parser_implementation\n ) const noexcept {\n   dst.reset( new (std::nothrow) dom_parser_implementation() );\n   if (!dst) { return MEMALLOC; }\n-  dst->set_capacity(capacity);\n-  dst->set_max_depth(max_depth);\n+  if (auto err = dst->set_capacity(capacity))\n+    return err;\n+  if (auto err = dst->set_max_depth(max_depth))\n+    return err;\n   return SUCCESS;\n }\n \n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n \n-#include \"simdjson/westmere/end.h\"\n\\ No newline at end of file\n+#include \"simdjson/westmere/end.h\""
      },
      {
        "filename": "vendor/simdjson/tools/CMakeLists.txt",
        "status": "modified",
        "additions": 10,
        "deletions": 7,
        "changes": 17,
        "patch": "@@ -1,10 +1,13 @@\n if(TARGET cxxopts) # we only build the tools if cxxopts is available\n-  message(STATUS \"We have cxxopts as a dependency and we are buiding the tools (e.g., json2json).\")\n-  link_libraries(simdjson simdjson-internal-flags simdjson-windows-headers cxxopts)\n-  add_executable(json2json json2json.cpp)\n-  add_executable(jsonstats jsonstats.cpp)\n-  add_executable(jsonpointer jsonpointer.cpp)\n-  add_executable(minify minify.cpp)\n+  message(STATUS \"We have cxxopts as a dependency and we are building the tools (e.g., json2json).\")\n+  foreach(tool IN ITEMS json2json jsonstats jsonpointer minify)\n+    add_executable(\"${tool}\" \"${tool}.cpp\")\n+    simdjson_apply_props(\"${tool}\")\n+    target_link_libraries(\n+        \"${tool}\" PRIVATE\n+        simdjson simdjson-internal-flags simdjson-windows-headers cxxopts\n+    )\n+  endforeach()\n else()\n   message(STATUS \"We are missing cxxopts as a dependency so the tools (e.g., json2json) are omitted.\")\n-endif()\n\\ No newline at end of file\n+endif()"
      },
      {
        "filename": "vendor/simdjson/tools/json2json.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 2,
        "changes": 15,
        "patch": "@@ -31,6 +31,7 @@ int main(int argc, const char *argv[]) {\n   cxxopts::Options options(progName, progUsage);\n \n   options.add_options()\n+    (\"z,ondemand\", \"Use On Demand front-end.\", cxxopts::value<bool>()->default_value(\"false\"))\n   \t(\"d,rawdump\", \"Dumps the raw content of the tape.\", cxxopts::value<bool>()->default_value(\"false\"))\n   \t(\"f,file\", \"File name.\", cxxopts::value<std::string>())\n   \t(\"h,help\", \"Print usage.\")\n@@ -44,7 +45,7 @@ int main(int argc, const char *argv[]) {\n   \tstd::cerr << options.help() << std::endl;\n   \treturn EXIT_SUCCESS;\n   }\n-\n+  bool ondemand = result[\"ondemand\"].as<bool>();\n   bool rawdump = result[\"rawdump\"].as<bool>();\n \n   if(!result.count(\"file\")) {\n@@ -54,7 +55,17 @@ int main(int argc, const char *argv[]) {\n   }\n \n   const char *filename = result[\"file\"].as<std::string>().c_str();\n-\n+  if(ondemand) {\n+    simdjson::ondemand::parser parser;\n+    simdjson::padded_string docdata;\n+    auto error = simdjson::padded_string::load(filename).get(docdata);\n+    if(error != simdjson::SUCCESS) { std::cout << error << std::endl; return EXIT_FAILURE; }\n+    simdjson::ondemand::document doc;\n+    error = parser.iterate(docdata).get(doc);\n+    if(error != simdjson::SUCCESS) { std::cout << error << std::endl; return EXIT_FAILURE; }\n+    std::cout << doc;\n+    return EXIT_SUCCESS;\n+  }\n   simdjson::dom::parser parser;\n   simdjson::dom::element doc;\n   auto error = parser.load(filename).get(doc); // do the parsing, return false on error"
      },
      {
        "filename": "vendor/simdjson/tools/release.py",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "patch": "@@ -145,11 +145,8 @@ def topaddedversionstring(major, minor, rev):\n     sonumber += 1\n \n for line in fileinput.input(cmakefile, inplace=1, backup='.bak'):\n-    line = re.sub('SIMDJSON_SEMANTIC_VERSION \"\\d+\\.\\d+\\.\\d+','SIMDJSON_SEMANTIC_VERSION \"'+newversionstring, line.rstrip())\n+    line = re.sub('    VERSION \\d+\\.\\d+\\.\\d+','    VERSION '+newmajorversionstring+'.'+mewminorversionstring+'.'+newrevversionstring, line.rstrip())\n     line = re.sub('SIMDJSON_LIB_VERSION \"\\d+','SIMDJSON_LIB_VERSION \"'+str(sonumber), line)\n-    line = re.sub('set\\(PROJECT_VERSION_MAJOR \\d+','set(PROJECT_VERSION_MAJOR '+newmajorversionstring, line)\n-    line = re.sub('set\\(PROJECT_VERSION_MINOR \\d+','set(PROJECT_VERSION_MINOR '+mewminorversionstring, line)\n-    line = re.sub('set\\(PROJECT_VERSION_PATCH \\d+','set(PROJECT_VERSION_PATCH '+newrevversionstring, line)\n     line = re.sub('set\\(SIMDJSON_LIB_SOVERSION \\\"\\d+\\\"','set(SIMDJSON_LIB_SOVERSION \\\"'+str(sonumber)+'\\\"', line)\n     print(line)\n "
      },
      {
        "filename": "vendor/simdjson/windows/getopt.h",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "patch": "@@ -112,13 +112,8 @@ char    *optarg;\t\t/* argument associated with option */\n extern char __declspec(dllimport) *__progname;\n #endif\n \n-// D. Lemire (April 2020): adding __clang__\n-// D. Lemire (June 2020): adding __MINGW32__ and __MINGW64__\n-#if defined(__CYGWIN__) || defined(__clang__) || defined(__MINGW32__) || defined(__MINGW64__)\n+// next line modified D. Lemire (last modified on June 1st 2021)\n static char EMSG[] = \"\";\n-#else\n-#define\tEMSG\t\t\"\"\n-#endif\n \n static int getopt_internal(int, char * const *, const char *,\n \t\t\t   const struct option *, int *, int);"
      }
    ],
    "lines_added": 6134,
    "lines_removed": 1848
  },
  "issues": [],
  "pull_requests": [],
  "build_info": {
    "old_build_script": "#!/bin/bash\n#!/bin/bash\ncmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBENCHMARK_ENABLE_GTEST_TESTS=ON -DBUILD_TESTING=ON -DBENCHMARK_ENABLE_TESTING=ON -DBENCHMARK_ENABLE_ASSEMBLY_TESTS=ON",
    "new_build_script": "#!/bin/bash\n#!/bin/bash\ncmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBENCHMARK_ENABLE_GTEST_TESTS=ON -DBUILD_TESTING=ON -DBENCHMARK_ENABLE_TESTING=ON -DBENCHMARK_ENABLE_ASSEMBLY_TESTS=ON",
    "old_test_script": "#!/bin/bash\ncmake --build /test_workspace/workspace/old/build -- -j 1",
    "new_test_script": "#!/bin/bash\ncmake --build /test_workspace/workspace/old/build -- -j 1",
    "build_system": "cmake"
  },
  "performance_analysis": {
    "is_significant": false,
    "p_value": 1.0,
    "is_pair_significant": false,
    "pair_p_value": 1.0,
    "is_binom_significant": false,
    "binom_p_value": 1.0,
    "is_wilcoxon_significant": false,
    "wilcoxon_p_value": 0.9999993688219968,
    "is_mannwhitney_significant": false,
    "mannwhitney_p_value": 0.9995083175453278,
    "relative_improvement": -0.005015324602953461,
    "absolute_improvement_ms": -5.999999999999561,
    "old_mean_ms": 1196.3333333333337,
    "new_mean_ms": 1202.3333333333333,
    "old_std_ms": 8.899179866642246,
    "new_std_ms": 7.279320417946068,
    "effect_size_cohens_d": -0.7380349938680636,
    "old_ci95_ms": [
      1193.0103249590154,
      1199.656341707652
    ],
    "new_ci95_ms": [
      1199.6151904178437,
      1205.0514762488228
    ],
    "old_ci99_ms": [
      1191.8548663426059,
      1200.8118003240616
    ],
    "new_ci99_ms": [
      1198.6700523686566,
      1205.99661429801
    ],
    "new_times_s": [
      1.21,
      1.2,
      1.2,
      1.2,
      1.19,
      1.22,
      1.19,
      1.21,
      1.2,
      1.2,
      1.2,
      1.2,
      1.21,
      1.21,
      1.2,
      1.2,
      1.21,
      1.2,
      1.2,
      1.21,
      1.2,
      1.22,
      1.2,
      1.21,
      1.2,
      1.2,
      1.2,
      1.19,
      1.2,
      1.2,
      1.2
    ],
    "old_times_s": [
      1.2,
      1.19,
      1.19,
      1.19,
      1.19,
      1.19,
      1.2,
      1.2,
      1.19,
      1.19,
      1.19,
      1.2,
      1.2,
      1.19,
      1.2,
      1.2,
      1.18,
      1.19,
      1.19,
      1.2,
      1.23,
      1.19,
      1.2,
      1.2,
      1.21,
      1.19,
      1.2,
      1.2,
      1.2,
      1.2,
      1.2
    ]
  },
  "tests": {
    "total_tests": 2,
    "significant_improvements": 0,
    "significant_improvements_tests": [],
    "significant_regressions": 0,
    "significant_regressions_tests": [],
    "significant_pair_improvements": 0,
    "significant_pair_improvements_tests": [],
    "significant_pair_regressions": 0,
    "significant_pair_regressions_tests": [],
    "significant_binom_improvements": 0,
    "significant_binom_improvements_tests": [],
    "significant_binom_regressions": 0,
    "significant_binom_regressions_tests": [],
    "significant_wilcoxon_improvements": 0,
    "significant_wilcoxon_improvements_tests": [],
    "significant_wilcoxon_regressions": 0,
    "significant_wilcoxon_regressions_tests": [],
    "significant_mannwhitney_improvements": 0,
    "significant_mannwhitney_improvements_tests": [],
    "significant_mannwhitney_regressions": 1,
    "significant_mannwhitney_regressions_tests": [
      "quick-lint-js-test"
    ],
    "tests": [
      {
        "test_name": "quick-lint-js-test",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999993246351578,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.993740387604918,
        "relative_improvement": -0.007057163020465748,
        "absolute_improvement_ms": -3.448275862069028,
        "old_mean_ms": 488.62068965517244,
        "new_mean_ms": 492.06896551724145,
        "old_std_ms": 4.411136823860462,
        "new_std_ms": 5.592923044110294,
        "effect_size_cohens_d": -0.6846149939856508,
        "old_ci95_ms": [
          486.9427829434854,
          490.29859636685944
        ],
        "new_ci95_ms": [
          489.94153136854305,
          494.1963996659398
        ],
        "old_ci99_ms": [
          486.3572252659068,
          490.88415404443805
        ],
        "new_ci99_ms": [
          489.1990971255447,
          494.9388339089382
        ],
        "new_times": [
          0.49,
          0.49,
          0.49,
          0.5,
          0.48,
          0.49,
          0.49,
          0.49,
          0.49,
          0.49,
          0.5,
          0.5,
          0.49,
          0.49,
          0.49,
          0.5,
          0.49,
          0.49,
          0.49,
          0.5,
          0.49,
          0.51,
          0.49,
          0.49,
          0.49,
          0.49,
          0.49,
          0.49,
          0.49
        ],
        "old_times": [
          0.49,
          0.49,
          0.48,
          0.49,
          0.49,
          0.5,
          0.49,
          0.48,
          0.49,
          0.48,
          0.49,
          0.49,
          0.49,
          0.49,
          0.48,
          0.48,
          0.49,
          0.49,
          0.49,
          0.49,
          0.49,
          0.49,
          0.49,
          0.49,
          0.49,
          0.49,
          0.49,
          0.49,
          0.49
        ]
      },
      {
        "test_name": "quick-lint-js-test-cli",
        "is_significant": false,
        "p_value": 0.9999999999999835,
        "is_pair_significant": false,
        "pair_p_value": 0.9999999999999835,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999431363717,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.8495447335324144,
        "relative_improvement": -0.0038314176245211615,
        "absolute_improvement_ms": -0.3448275862068806,
        "old_mean_ms": 89.99999999999999,
        "new_mean_ms": 90.34482758620686,
        "old_std_ms": 1.4123431441001795e-14,
        "new_std_ms": 1.8569533817705206,
        "effect_size_cohens_d": -0.2626128657194327,
        "old_ci95_ms": [
          89.99999999999999,
          89.99999999999999
        ],
        "new_ci95_ms": [
          89.63848029593265,
          91.05117487648108
        ],
        "old_ci99_ms": [
          89.99999999999997,
          90.0
        ],
        "new_ci99_ms": [
          89.39197846363409,
          91.29767670877965
        ],
        "new_times": [
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.1,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09
        ],
        "old_times": [
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09,
          0.09
        ]
      }
    ]
  },
  "logs": {
    "full_log_path": "/logs/full.log",
    "config_log_path": "/logs/config.log",
    "build_log_path": "/logs/build.log",
    "test_log_path": "/logs/test.log",
    "build_success": true,
    "test_success": true
  },
  "raw_timing_data": {
    "warmup_runs": 1,
    "measurement_runs": 30,
    "min_exec_time_improvement": 0.05,
    "min_p_value": 0.05
  }
}