{
  "metadata": {
    "collection_date": "2026-01-11T17:46:22.204425",
    "repository": "https://github.com/google/highway",
    "repository_name": "google/highway"
  },
  "commit_info": {
    "old_sha": "ad9dd756fbeb5367f7725a9927e38f93f2afbbb5",
    "new_sha": "ad9dd756fbeb5367f7725a9927e38f93f2afbbb5",
    "commit_message": [
      "further sort speedup: about 1.1x for low-entropy arrays\n\nPiperOrigin-RevId: 468707301"
    ],
    "commit_date": "2022-08-19T15:27:22+00:00",
    "patch": [
      "--- hwy/contrib/sort/traits-inl.h\n@@ -220,6 +220,11 @@ struct OrderAscending : public KeyLane<T> {\n   HWY_INLINE Vec<D> LastValue(D d) const {\n     return Set(d, hwy::HighestValue<T>());\n   }\n+\n+  template <class D>\n+  HWY_INLINE Vec<D> PrevValue(D d, Vec<D> v) const {\n+    return Sub(v, Set(d, 1));\n+  }\n };\n \n template <typename T>\n@@ -264,6 +269,11 @@ struct OrderDescending : public KeyLane<T> {\n   HWY_INLINE Vec<D> LastValue(D d) const {\n     return Set(d, hwy::LowestValue<T>());\n   }\n+\n+  template <class D>\n+  HWY_INLINE Vec<D> PrevValue(D d, Vec<D> v) const {\n+    return Add(v, Set(d, 1));\n+  }\n };\n \n // Shared code that depends on Order.\n--- hwy/contrib/sort/traits128-inl.h\n@@ -184,6 +184,12 @@ struct OrderAscending128 : public Key128 {\n   HWY_INLINE Vec<D> LastValue(D d) const {\n     return Set(d, hwy::HighestValue<TFromD<D> >());\n   }\n+\n+  template <class D>\n+  HWY_INLINE Vec<D> PrevValue(D d, Vec<D> v) const {\n+    const Vec<D> k1 = OddEven(Zero(d), Set(d, 1));\n+    return Sub(v, k1);\n+  }\n };\n \n struct OrderDescending128 : public Key128 {\n@@ -224,6 +230,12 @@ struct OrderDescending128 : public Key128 {\n   HWY_INLINE Vec<D> LastValue(D d) const {\n     return Set(d, hwy::LowestValue<TFromD<D> >());\n   }\n+\n+  template <class D>\n+  HWY_INLINE Vec<D> PrevValue(D d, Vec<D> v) const {\n+    const Vec<D> k1 = OddEven(Zero(d), Set(d, 1));\n+    return Add(v, k1);\n+  }\n };\n \n // Base class shared between OrderAscendingKV128, OrderDescendingKV128.\n@@ -281,6 +293,12 @@ struct OrderAscendingKV128 : public KeyValue128 {\n   HWY_INLINE Vec<D> LastValue(D d) const {\n     return Set(d, hwy::HighestValue<TFromD<D> >());\n   }\n+\n+  template <class D>\n+  HWY_INLINE Vec<D> PrevValue(D d, Vec<D> v) const {\n+    const Vec<D> k1 = OddEven(Zero(d), Set(d, 1));\n+    return Sub(v, k1);\n+  }\n };\n \n struct OrderDescendingKV128 : public KeyValue128 {\n@@ -321,6 +339,12 @@ struct OrderDescendingKV128 : public KeyValue128 {\n   HWY_INLINE Vec<D> LastValue(D d) const {\n     return Set(d, hwy::LowestValue<TFromD<D> >());\n   }\n+\n+  template <class D>\n+  HWY_INLINE Vec<D> PrevValue(D d, Vec<D> v) const {\n+    const Vec<D> k1 = OddEven(Zero(d), Set(d, 1));\n+    return Add(v, k1);\n+  }\n };\n \n // Shared code that depends on Order.\n--- hwy/contrib/sort/vqsort-inl.h\n@@ -580,12 +580,13 @@ V OrXor(const V o, const V x1, const V x2) {\n   return Or(o, Xor(x1, x2));\n }\n \n-// Returns a lower bound on the index of the first difference, or `num` if all\n+// Returns a lower bound on the index of the first mismatch, or `num` if all\n // are equal. `num` is const to ensure we don't change it, which would lead to\n // bugs because the caller will check whether we return the original value.\n template <class D, class Traits, typename T>\n-HWY_NOINLINE size_t ScanEqual(D d, Traits st, const T* HWY_RESTRICT keys,\n-                              const size_t num) {\n+HWY_NOINLINE size_t LowerBoundOfMismatch(D d, Traits st,\n+                                         const T* HWY_RESTRICT keys,\n+                                         const size_t num) {\n   using V = Vec<decltype(d)>;\n   const size_t N = Lanes(d);\n   HWY_DASSERT(num >= N);  // See HandleSpecialCases\n@@ -654,55 +655,79 @@ HWY_NOINLINE size_t ScanEqual(D d, Traits st, const T* HWY_RESTRICT keys,\n   return num;  // all equal\n }\n \n-// Returns false if `reference` is already the first key in sort order.\n-// Otherwise, sets `prev_out` to the key prior to `reference` in sort order.\n-// Starts scanning before index `start`, which is less than `num`.\n+enum class PivotResult {\n+  kAllEqual,  // stop without partitioning\n+  kNormal,    // partition and recurse left and right\n+  kIsFirst,   // partition but skip left recursion\n+  kWasLast,   // partition but skip right recursion\n+};\n+\n+// Classifies (and possibly modifies) `pivot` by scanning for the first/last\n+// key from index `idx_diff`, which is less than `num`.\n template <class D, class Traits, typename T>\n-HWY_NOINLINE bool ScanForPrev(D d, Traits st, const T* HWY_RESTRICT keys,\n-                              size_t num, size_t start, Vec<D> reference,\n-                              Vec<D>* HWY_RESTRICT prev_out,\n-                              T* HWY_RESTRICT buf) {\n+HWY_NOINLINE PivotResult CheckFirstLast(D d, Traits st,\n+                                        const T* HWY_RESTRICT keys, size_t num,\n+                                        size_t idx_diff,\n+                                        Vec<D>* HWY_RESTRICT pivot,\n+                                        T* HWY_RESTRICT buf) {\n   const size_t N = Lanes(d);\n   HWY_DASSERT(num >= N);  // See HandleSpecialCases\n-  HWY_DASSERT(start < num);\n+  HWY_DASSERT(idx_diff < num);\n \n-  const Vec<D> first = st.FirstValue(d);\n-  Vec<D> prev = first;\n+  Vec<D> first = st.LastValue(d);\n+  Vec<D> last = st.FirstValue(d);\n+  // Early out for mostly-0 arrays, where pivot is often FirstValue.\n+  if (AllTrue(d, st.EqualKeys(d, *pivot, last))) {\n+    return PivotResult::kIsFirst;\n+  }\n \n-  // The value before the first difference might be the desired prev (if it is\n-  // equal to the reference in ScanEqual), so start one vector before.\n+  // We know keys[0, idx_diff) are equal, but they might be the first/last, so\n+  // start scanning one vector before.\n   size_t i = static_cast<size_t>(\n-      HWY_MAX(static_cast<intptr_t>(start) - static_cast<intptr_t>(N), 0));\n+      HWY_MAX(static_cast<intptr_t>(idx_diff) - static_cast<intptr_t>(N), 0));\n+\n+  constexpr size_t kLoops = 4;\n+  const size_t lanes_per_group = kLoops * N;\n+\n+  // Whole group, unrolled\n+  for (; i + lanes_per_group <= num; i += lanes_per_group) {\n+    HWY_DEFAULT_UNROLL\n+    for (size_t loop = 0; loop < kLoops; ++loop) {\n+      const Vec<D> curr = LoadU(d, keys + i + loop * N);\n+      first = st.First(d, first, curr);\n+      last = st.Last(d, last, curr);\n+    }\n+  }\n   // Whole vectors, no unrolling\n   for (; i + N <= num; i += N) {\n     const Vec<D> curr = LoadU(d, keys + i);\n-    const Mask<D> is_before = st.Compare(d, curr, reference);\n-    prev = IfThenElse(is_before, st.Last(d, prev, curr), prev);\n+    first = st.First(d, first, curr);\n+    last = st.Last(d, last, curr);\n   }\n   // If there are remainders, re-check the last whole vector.\n   if (HWY_LIKELY(i != num)) {\n     const Vec<D> curr = LoadU(d, keys + num - N);\n-    const Mask<D> is_before = st.Compare(d, curr, reference);\n-    prev = IfThenElse(is_before, st.Last(d, prev, curr), prev);\n+    first = st.First(d, first, curr);\n+    last = st.Last(d, last, curr);\n   }\n \n-  prev = st.LastOfLanes(d, prev, buf);\n-  // If prev has not changed, then no `curr` came before `reference`, hence\n-  // `reference` is the first (perhaps even the first possible, i.e. `first`).\n-  if (AllTrue(d, st.EqualKeys(d, prev, first))) {\n-    *prev_out = reference;\n-    return false;\n+  first = st.FirstOfLanes(d, first, buf);\n+  last = st.LastOfLanes(d, last, buf);\n+\n+  if (AllTrue(d, st.EqualKeys(d, first, *pivot))) {\n+    return PivotResult::kIsFirst;\n   }\n-  *prev_out = prev;\n-  return true;\n+  // Fixup required because keys equal to the pivot go to the left partition,\n+  // and the pivot is the last, so Partition would not change anything.\n+  // Instead use the previous value in sort order, which is not necessarily an\n+  // actual key.\n+  if (AllTrue(d, st.EqualKeys(d, last, *pivot))) {\n+    *pivot = st.PrevValue(d, *pivot);\n+    return PivotResult::kWasLast;\n+  }\n+  return PivotResult::kNormal;\n }\n \n-enum class PivotResult {\n-  kNormal,    // use partition\n-  kAllEqual,  // already done\n-  kIsFirst,   // can skip left recursion\n-};\n-\n // Writes samples from `keys[0, num)` into `buf`.\n template <class D, class Traits, typename T>\n HWY_INLINE void DrawSamples(D d, Traits st, T* HWY_RESTRICT keys, size_t num,\n@@ -795,7 +820,7 @@ HWY_NOINLINE Vec<D> ChoosePivot(D d, Traits st, T* HWY_RESTRICT keys,\n \n   // All samples are equal.\n   if (st.Equal1(buf, buf + kSampleLanes - N1)) {\n-    const size_t idx_diff = ScanEqual(d, st, keys, num);\n+    const size_t idx_diff = LowerBoundOfMismatch(d, st, keys, num);\n     const bool all_eq = idx_diff == num;\n #if VQSORT_PRINT\n     fprintf(stderr, \"Pivot num=%zu samplesEq, idxDiff %zu keysEq: %d\\n\", num,\n@@ -806,21 +831,11 @@ HWY_NOINLINE Vec<D> ChoosePivot(D d, Traits st, T* HWY_RESTRICT keys,\n       return Zero(d);\n     }\n \n-    // If the sample is indeed the most common key and it is the largest, then\n-    // the right partition will be empty. Prevent this by replacing the pivot\n-    // with the previous key in sort order. By contrast, selecting the first key\n-    // in sort order would guarantee (minimal) progress. We instead do a full\n-    // scan to maximize load balance in case there are numerous keys that\n-    // precede the most common key. This also tells us whether the pivot is the\n-    // first in sort order; if so, we can skip the left recursion.\n-    const V reference = st.SetKey(d, buf);\n-    V pivot;\n-    result = ScanForPrev(d, st, keys, num, idx_diff, reference, &pivot, buf)\n-                 ? PivotResult::kNormal\n-                 : PivotResult::kIsFirst;\n+    V pivot = st.SetKey(d, buf);  // the single unique sample\n+    result = CheckFirstLast(d, st, keys, num, idx_diff, &pivot, buf);\n #if VQSORT_PRINT\n-    Print(d, \"Using PREV as pivot\", pivot, 0, st.LanesPerKey());\n-    fprintf(stderr, \"IsMin %d\\n\", result == PivotResult::kIsFirst);\n+    fprintf(stderr, \"PivotResult %d\\n\", static_cast<int>(result));\n+    Print(d, \"Adjusted pivot\", pivot, 0, st.LanesPerKey());\n #endif\n     return pivot;\n   }\n@@ -874,14 +889,17 @@ HWY_NOINLINE void Recurse(D d, Traits st, T* HWY_RESTRICT keys,\n   }\n \n   const size_t bound = Partition(d, st, keys, begin, end, pivot, buf);\n-  // ChoosePivot ensures pivot != largest key, so the right partition is never\n-  // empty; nor is the left, because the pivot is one of the keys.\n+  // ChoosePivot ensures pivot != last key, so the right partition is never\n+  // empty. Nor is the left, because the pivot is either one of the keys, or\n+  // the value prior to the last (which is not the only value).\n   HWY_ASSERT(begin != bound && bound != end);\n   if (HWY_LIKELY(result != PivotResult::kIsFirst)) {\n     Recurse(d, st, keys, keys_end, begin, bound, buf, rng,\n             remaining_levels - 1);\n   }\n-  Recurse(d, st, keys, keys_end, bound, end, buf, rng, remaining_levels - 1);\n+  if (HWY_LIKELY(result != PivotResult::kWasLast)) {\n+    Recurse(d, st, keys, keys_end, bound, end, buf, rng, remaining_levels - 1);\n+  }\n }\n \n // Returns true if sorting is finished."
    ],
    "files_changed": [
      {
        "filename": "hwy/contrib/sort/traits-inl.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "patch": "@@ -220,6 +220,11 @@ struct OrderAscending : public KeyLane<T> {\n   HWY_INLINE Vec<D> LastValue(D d) const {\n     return Set(d, hwy::HighestValue<T>());\n   }\n+\n+  template <class D>\n+  HWY_INLINE Vec<D> PrevValue(D d, Vec<D> v) const {\n+    return Sub(v, Set(d, 1));\n+  }\n };\n \n template <typename T>\n@@ -264,6 +269,11 @@ struct OrderDescending : public KeyLane<T> {\n   HWY_INLINE Vec<D> LastValue(D d) const {\n     return Set(d, hwy::LowestValue<T>());\n   }\n+\n+  template <class D>\n+  HWY_INLINE Vec<D> PrevValue(D d, Vec<D> v) const {\n+    return Add(v, Set(d, 1));\n+  }\n };\n \n // Shared code that depends on Order."
      },
      {
        "filename": "hwy/contrib/sort/traits128-inl.h",
        "status": "modified",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "patch": "@@ -184,6 +184,12 @@ struct OrderAscending128 : public Key128 {\n   HWY_INLINE Vec<D> LastValue(D d) const {\n     return Set(d, hwy::HighestValue<TFromD<D> >());\n   }\n+\n+  template <class D>\n+  HWY_INLINE Vec<D> PrevValue(D d, Vec<D> v) const {\n+    const Vec<D> k1 = OddEven(Zero(d), Set(d, 1));\n+    return Sub(v, k1);\n+  }\n };\n \n struct OrderDescending128 : public Key128 {\n@@ -224,6 +230,12 @@ struct OrderDescending128 : public Key128 {\n   HWY_INLINE Vec<D> LastValue(D d) const {\n     return Set(d, hwy::LowestValue<TFromD<D> >());\n   }\n+\n+  template <class D>\n+  HWY_INLINE Vec<D> PrevValue(D d, Vec<D> v) const {\n+    const Vec<D> k1 = OddEven(Zero(d), Set(d, 1));\n+    return Add(v, k1);\n+  }\n };\n \n // Base class shared between OrderAscendingKV128, OrderDescendingKV128.\n@@ -281,6 +293,12 @@ struct OrderAscendingKV128 : public KeyValue128 {\n   HWY_INLINE Vec<D> LastValue(D d) const {\n     return Set(d, hwy::HighestValue<TFromD<D> >());\n   }\n+\n+  template <class D>\n+  HWY_INLINE Vec<D> PrevValue(D d, Vec<D> v) const {\n+    const Vec<D> k1 = OddEven(Zero(d), Set(d, 1));\n+    return Sub(v, k1);\n+  }\n };\n \n struct OrderDescendingKV128 : public KeyValue128 {\n@@ -321,6 +339,12 @@ struct OrderDescendingKV128 : public KeyValue128 {\n   HWY_INLINE Vec<D> LastValue(D d) const {\n     return Set(d, hwy::LowestValue<TFromD<D> >());\n   }\n+\n+  template <class D>\n+  HWY_INLINE Vec<D> PrevValue(D d, Vec<D> v) const {\n+    const Vec<D> k1 = OddEven(Zero(d), Set(d, 1));\n+    return Add(v, k1);\n+  }\n };\n \n // Shared code that depends on Order."
      },
      {
        "filename": "hwy/contrib/sort/vqsort-inl.h",
        "status": "modified",
        "additions": 70,
        "deletions": 52,
        "changes": 122,
        "patch": "@@ -580,12 +580,13 @@ V OrXor(const V o, const V x1, const V x2) {\n   return Or(o, Xor(x1, x2));\n }\n \n-// Returns a lower bound on the index of the first difference, or `num` if all\n+// Returns a lower bound on the index of the first mismatch, or `num` if all\n // are equal. `num` is const to ensure we don't change it, which would lead to\n // bugs because the caller will check whether we return the original value.\n template <class D, class Traits, typename T>\n-HWY_NOINLINE size_t ScanEqual(D d, Traits st, const T* HWY_RESTRICT keys,\n-                              const size_t num) {\n+HWY_NOINLINE size_t LowerBoundOfMismatch(D d, Traits st,\n+                                         const T* HWY_RESTRICT keys,\n+                                         const size_t num) {\n   using V = Vec<decltype(d)>;\n   const size_t N = Lanes(d);\n   HWY_DASSERT(num >= N);  // See HandleSpecialCases\n@@ -654,55 +655,79 @@ HWY_NOINLINE size_t ScanEqual(D d, Traits st, const T* HWY_RESTRICT keys,\n   return num;  // all equal\n }\n \n-// Returns false if `reference` is already the first key in sort order.\n-// Otherwise, sets `prev_out` to the key prior to `reference` in sort order.\n-// Starts scanning before index `start`, which is less than `num`.\n+enum class PivotResult {\n+  kAllEqual,  // stop without partitioning\n+  kNormal,    // partition and recurse left and right\n+  kIsFirst,   // partition but skip left recursion\n+  kWasLast,   // partition but skip right recursion\n+};\n+\n+// Classifies (and possibly modifies) `pivot` by scanning for the first/last\n+// key from index `idx_diff`, which is less than `num`.\n template <class D, class Traits, typename T>\n-HWY_NOINLINE bool ScanForPrev(D d, Traits st, const T* HWY_RESTRICT keys,\n-                              size_t num, size_t start, Vec<D> reference,\n-                              Vec<D>* HWY_RESTRICT prev_out,\n-                              T* HWY_RESTRICT buf) {\n+HWY_NOINLINE PivotResult CheckFirstLast(D d, Traits st,\n+                                        const T* HWY_RESTRICT keys, size_t num,\n+                                        size_t idx_diff,\n+                                        Vec<D>* HWY_RESTRICT pivot,\n+                                        T* HWY_RESTRICT buf) {\n   const size_t N = Lanes(d);\n   HWY_DASSERT(num >= N);  // See HandleSpecialCases\n-  HWY_DASSERT(start < num);\n+  HWY_DASSERT(idx_diff < num);\n \n-  const Vec<D> first = st.FirstValue(d);\n-  Vec<D> prev = first;\n+  Vec<D> first = st.LastValue(d);\n+  Vec<D> last = st.FirstValue(d);\n+  // Early out for mostly-0 arrays, where pivot is often FirstValue.\n+  if (AllTrue(d, st.EqualKeys(d, *pivot, last))) {\n+    return PivotResult::kIsFirst;\n+  }\n \n-  // The value before the first difference might be the desired prev (if it is\n-  // equal to the reference in ScanEqual), so start one vector before.\n+  // We know keys[0, idx_diff) are equal, but they might be the first/last, so\n+  // start scanning one vector before.\n   size_t i = static_cast<size_t>(\n-      HWY_MAX(static_cast<intptr_t>(start) - static_cast<intptr_t>(N), 0));\n+      HWY_MAX(static_cast<intptr_t>(idx_diff) - static_cast<intptr_t>(N), 0));\n+\n+  constexpr size_t kLoops = 4;\n+  const size_t lanes_per_group = kLoops * N;\n+\n+  // Whole group, unrolled\n+  for (; i + lanes_per_group <= num; i += lanes_per_group) {\n+    HWY_DEFAULT_UNROLL\n+    for (size_t loop = 0; loop < kLoops; ++loop) {\n+      const Vec<D> curr = LoadU(d, keys + i + loop * N);\n+      first = st.First(d, first, curr);\n+      last = st.Last(d, last, curr);\n+    }\n+  }\n   // Whole vectors, no unrolling\n   for (; i + N <= num; i += N) {\n     const Vec<D> curr = LoadU(d, keys + i);\n-    const Mask<D> is_before = st.Compare(d, curr, reference);\n-    prev = IfThenElse(is_before, st.Last(d, prev, curr), prev);\n+    first = st.First(d, first, curr);\n+    last = st.Last(d, last, curr);\n   }\n   // If there are remainders, re-check the last whole vector.\n   if (HWY_LIKELY(i != num)) {\n     const Vec<D> curr = LoadU(d, keys + num - N);\n-    const Mask<D> is_before = st.Compare(d, curr, reference);\n-    prev = IfThenElse(is_before, st.Last(d, prev, curr), prev);\n+    first = st.First(d, first, curr);\n+    last = st.Last(d, last, curr);\n   }\n \n-  prev = st.LastOfLanes(d, prev, buf);\n-  // If prev has not changed, then no `curr` came before `reference`, hence\n-  // `reference` is the first (perhaps even the first possible, i.e. `first`).\n-  if (AllTrue(d, st.EqualKeys(d, prev, first))) {\n-    *prev_out = reference;\n-    return false;\n+  first = st.FirstOfLanes(d, first, buf);\n+  last = st.LastOfLanes(d, last, buf);\n+\n+  if (AllTrue(d, st.EqualKeys(d, first, *pivot))) {\n+    return PivotResult::kIsFirst;\n   }\n-  *prev_out = prev;\n-  return true;\n+  // Fixup required because keys equal to the pivot go to the left partition,\n+  // and the pivot is the last, so Partition would not change anything.\n+  // Instead use the previous value in sort order, which is not necessarily an\n+  // actual key.\n+  if (AllTrue(d, st.EqualKeys(d, last, *pivot))) {\n+    *pivot = st.PrevValue(d, *pivot);\n+    return PivotResult::kWasLast;\n+  }\n+  return PivotResult::kNormal;\n }\n \n-enum class PivotResult {\n-  kNormal,    // use partition\n-  kAllEqual,  // already done\n-  kIsFirst,   // can skip left recursion\n-};\n-\n // Writes samples from `keys[0, num)` into `buf`.\n template <class D, class Traits, typename T>\n HWY_INLINE void DrawSamples(D d, Traits st, T* HWY_RESTRICT keys, size_t num,\n@@ -795,7 +820,7 @@ HWY_NOINLINE Vec<D> ChoosePivot(D d, Traits st, T* HWY_RESTRICT keys,\n \n   // All samples are equal.\n   if (st.Equal1(buf, buf + kSampleLanes - N1)) {\n-    const size_t idx_diff = ScanEqual(d, st, keys, num);\n+    const size_t idx_diff = LowerBoundOfMismatch(d, st, keys, num);\n     const bool all_eq = idx_diff == num;\n #if VQSORT_PRINT\n     fprintf(stderr, \"Pivot num=%zu samplesEq, idxDiff %zu keysEq: %d\\n\", num,\n@@ -806,21 +831,11 @@ HWY_NOINLINE Vec<D> ChoosePivot(D d, Traits st, T* HWY_RESTRICT keys,\n       return Zero(d);\n     }\n \n-    // If the sample is indeed the most common key and it is the largest, then\n-    // the right partition will be empty. Prevent this by replacing the pivot\n-    // with the previous key in sort order. By contrast, selecting the first key\n-    // in sort order would guarantee (minimal) progress. We instead do a full\n-    // scan to maximize load balance in case there are numerous keys that\n-    // precede the most common key. This also tells us whether the pivot is the\n-    // first in sort order; if so, we can skip the left recursion.\n-    const V reference = st.SetKey(d, buf);\n-    V pivot;\n-    result = ScanForPrev(d, st, keys, num, idx_diff, reference, &pivot, buf)\n-                 ? PivotResult::kNormal\n-                 : PivotResult::kIsFirst;\n+    V pivot = st.SetKey(d, buf);  // the single unique sample\n+    result = CheckFirstLast(d, st, keys, num, idx_diff, &pivot, buf);\n #if VQSORT_PRINT\n-    Print(d, \"Using PREV as pivot\", pivot, 0, st.LanesPerKey());\n-    fprintf(stderr, \"IsMin %d\\n\", result == PivotResult::kIsFirst);\n+    fprintf(stderr, \"PivotResult %d\\n\", static_cast<int>(result));\n+    Print(d, \"Adjusted pivot\", pivot, 0, st.LanesPerKey());\n #endif\n     return pivot;\n   }\n@@ -874,14 +889,17 @@ HWY_NOINLINE void Recurse(D d, Traits st, T* HWY_RESTRICT keys,\n   }\n \n   const size_t bound = Partition(d, st, keys, begin, end, pivot, buf);\n-  // ChoosePivot ensures pivot != largest key, so the right partition is never\n-  // empty; nor is the left, because the pivot is one of the keys.\n+  // ChoosePivot ensures pivot != last key, so the right partition is never\n+  // empty. Nor is the left, because the pivot is either one of the keys, or\n+  // the value prior to the last (which is not the only value).\n   HWY_ASSERT(begin != bound && bound != end);\n   if (HWY_LIKELY(result != PivotResult::kIsFirst)) {\n     Recurse(d, st, keys, keys_end, begin, bound, buf, rng,\n             remaining_levels - 1);\n   }\n-  Recurse(d, st, keys, keys_end, bound, end, buf, rng, remaining_levels - 1);\n+  if (HWY_LIKELY(result != PivotResult::kWasLast)) {\n+    Recurse(d, st, keys, keys_end, bound, end, buf, rng, remaining_levels - 1);\n+  }\n }\n \n // Returns true if sorting is finished."
      }
    ],
    "lines_added": 104,
    "lines_removed": 52
  },
  "issues": [],
  "pull_requests": [],
  "build_info": {
    "old_build_script": "#!/bin/bash\n#!/bin/bash\ncmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON",
    "new_build_script": "#!/bin/bash\n#!/bin/bash\ncmake -S /test_workspace/workspace/new -B /test_workspace/workspace/new/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON",
    "old_test_script": "#!/bin/bash\ncmake --build /test_workspace/workspace/old/build -- -j 1",
    "new_test_script": "#!/bin/bash\ncmake --build /test_workspace/workspace/new/build -- -j 1",
    "build_system": "cmake"
  },
  "performance_analysis": {
    "is_significant": false,
    "p_value": 1.0,
    "is_pair_significant": false,
    "pair_p_value": 0.9999999999999971,
    "is_binom_significant": false,
    "binom_p_value": 1.0,
    "is_wilcoxon_significant": false,
    "wilcoxon_p_value": 0.9999991333466779,
    "is_mannwhitney_significant": false,
    "mannwhitney_p_value": 0.3557865418119106,
    "relative_improvement": 0.00013729259012276542,
    "absolute_improvement_ms": 2.333333333336185,
    "old_mean_ms": 16995.333333333336,
    "new_mean_ms": 16993.0,
    "old_std_ms": 217.02905150095074,
    "new_std_ms": 221.48635826287742,
    "effect_size_cohens_d": 0.010641417625205096,
    "old_ci95_ms": [
      16914.293353648092,
      17076.37331301858
    ],
    "new_ci95_ms": [
      16910.295634616436,
      17075.70436538356
    ],
    "old_ci99_ms": [
      16886.114567363755,
      17104.552099302913
    ],
    "new_ci99_ms": [
      16881.538117080323,
      17104.461882919677
    ],
    "new_times_s": [
      17.07,
      16.88,
      16.94,
      16.92,
      17.05,
      16.91,
      16.6,
      16.78,
      16.82,
      17.12,
      16.76,
      16.74,
      16.78,
      17.38,
      17.07,
      17.05,
      17.46,
      17.12,
      17.32,
      17.32,
      17.33,
      17.26,
      16.72,
      16.94,
      17.0,
      16.9,
      16.83,
      17.15,
      16.87,
      16.8,
      16.97
    ],
    "old_times_s": [
      17.15,
      17.09,
      16.91,
      16.61,
      16.99,
      16.64,
      17.09,
      16.92,
      16.82,
      16.89,
      17.0,
      17.23,
      17.09,
      16.73,
      17.02,
      17.04,
      16.89,
      16.52,
      17.3,
      16.73,
      17.19,
      17.44,
      17.01,
      17.06,
      17.15,
      17.0,
      17.12,
      17.05,
      17.07,
      16.85,
      17.41
    ]
  },
  "tests": {
    "total_tests": 1,
    "significant_improvements": 0,
    "significant_improvements_tests": [],
    "significant_regressions": 0,
    "significant_regressions_tests": [],
    "significant_pair_improvements": 0,
    "significant_pair_improvements_tests": [],
    "significant_pair_regressions": 0,
    "significant_pair_regressions_tests": [],
    "significant_binom_improvements": 0,
    "significant_binom_improvements_tests": [],
    "significant_binom_regressions": 0,
    "significant_binom_regressions_tests": [],
    "significant_wilcoxon_improvements": 0,
    "significant_wilcoxon_improvements_tests": [],
    "significant_wilcoxon_regressions": 0,
    "significant_wilcoxon_regressions_tests": [],
    "significant_mannwhitney_improvements": 0,
    "significant_mannwhitney_improvements_tests": [],
    "significant_mannwhitney_regressions": 0,
    "significant_mannwhitney_regressions_tests": [],
    "tests": [
      {
        "test_name": "NanobenchmarkTest.RunAll",
        "is_significant": false,
        "p_value": 0.41171404821648244,
        "is_pair_significant": false,
        "pair_p_value": 0.3945507105301836,
        "is_binom_significant": false,
        "binom_p_value": 0.644464448094368,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.40178957973145385,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.10495917887631484,
        "relative_improvement": 0.05941358024691368,
        "absolute_improvement_ms": 26.551724137931053,
        "old_mean_ms": 446.89655172413796,
        "new_mean_ms": 420.3448275862069,
        "old_std_ms": 84.68865028848158,
        "new_std_ms": 61.09025867054008,
        "effect_size_cohens_d": 0.35959287325421396,
        "old_ci95_ms": [
          414.6827119823912,
          479.1103914658847
        ],
        "new_ci95_ms": [
          397.10733595195546,
          443.5823192204583
        ],
        "old_ci99_ms": [
          403.44069175940723,
          490.3524116888687
        ],
        "new_ci99_ms": [
          388.9978912853785,
          451.6917638870353
        ],
        "new_times": [
          0.42,
          0.47,
          0.39,
          0.38,
          0.34,
          0.34,
          0.39,
          0.34,
          0.49,
          0.44,
          0.46,
          0.45,
          0.49,
          0.37,
          0.5,
          0.41,
          0.4,
          0.46,
          0.24,
          0.46,
          0.38,
          0.51,
          0.49,
          0.41,
          0.44,
          0.49,
          0.42,
          0.38,
          0.43
        ],
        "old_times": [
          0.44,
          0.32,
          0.53,
          0.35,
          0.56,
          0.44,
          0.47,
          0.47,
          0.57,
          0.46,
          0.39,
          0.5,
          0.42,
          0.44,
          0.45,
          0.39,
          0.37,
          0.56,
          0.25,
          0.62,
          0.41,
          0.47,
          0.56,
          0.41,
          0.31,
          0.5,
          0.4,
          0.42,
          0.48
        ]
      }
    ]
  },
  "logs": {
    "full_log_path": "/logs/full.log",
    "config_log_path": "/logs/config.log",
    "build_log_path": "/logs/build.log",
    "test_log_path": "/logs/test.log",
    "build_success": true,
    "test_success": true
  },
  "raw_timing_data": {
    "warmup_runs": 1,
    "measurement_runs": 30,
    "min_exec_time_improvement": 0.05,
    "min_p_value": 0.05
  }
}