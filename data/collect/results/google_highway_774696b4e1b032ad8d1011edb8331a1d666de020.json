{
    "metadata": {
        "collection_date": "2026-01-14T18:41:02.411960",
        "repository": "https://github.com/google/highway",
        "repository_name": "google/highway"
    },
    "commit_info": {
        "old_sha": "b5423d1779e6098e8dd2522a5290f17a8a6b3c5a",
        "new_sha": "774696b4e1b032ad8d1011edb8331a1d666de020",
        "commit_message": [
            "Improvements to f64 to i64 conversion routines on SSE2/SSSE3/SSE4/AVX2"
        ],
        "commit_date": "2023-04-08T10:25:12+00:00",
        "patch": [
            "--- hwy/ops/x86_128-inl.h\n@@ -6485,12 +6485,24 @@ HWY_API VFromD<D> ConvertTo(D /* tag */, VFromD<Rebind<int32_t, D>> v) {\n   return VFromD<D>{_mm_cvtepi32_ps(v.raw)};\n }\n \n-template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_F32_D(D)>\n-HWY_API VFromD<D> ConvertTo(D df, VFromD<Rebind<uint32_t, D>> v) {\n #if HWY_TARGET <= HWY_AVX3\n-  (void)df;\n+template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_F32_D(D)>\n+HWY_API VFromD<D> ConvertTo(D /*df*/, VFromD<Rebind<uint32_t, D>> v) {\n   return VFromD<D>{_mm_cvtepu32_ps(v.raw)};\n-#else\n+}\n+\n+template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_F64_D(D)>\n+HWY_API VFromD<D> ConvertTo(D /*dd*/, VFromD<Rebind<int64_t, D>> v) {\n+  return VFromD<D>{_mm_cvtepi64_pd(v.raw)};\n+}\n+\n+template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_F64_D(D)>\n+HWY_API VFromD<D> ConvertTo(D /*dd*/, VFromD<Rebind<uint64_t, D>> v) {\n+  return VFromD<D>{_mm_cvtepu64_pd(v.raw)};\n+}\n+#else  // AVX2 or below\n+template <class D, HWY_IF_F32_D(D)>\n+HWY_API VFromD<D> ConvertTo(D df, VFromD<Rebind<uint32_t, D>> v) {\n   // Based on wim's approach (https://stackoverflow.com/questions/34066228/)\n   const RebindToUnsigned<decltype(df)> du32;\n   const RebindToSigned<decltype(df)> d32;\n@@ -6502,15 +6514,10 @@ HWY_API VFromD<D> ConvertTo(D df, VFromD<Rebind<uint32_t, D>> v) {\n   const auto v_lo = BitCast(d32, And(v, msk_lo));\n   const auto v_hi = BitCast(d32, ShiftRight<16>(v));\n   return MulAdd(cnst2_16_flt, ConvertTo(df, v_hi), ConvertTo(df, v_lo));\n-#endif\n }\n \n-template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_F64_D(D)>\n+template <class D, HWY_IF_F64_D(D)>\n HWY_API VFromD<D> ConvertTo(D dd, VFromD<Rebind<int64_t, D>> v) {\n-#if HWY_TARGET <= HWY_AVX3\n-  (void)dd;\n-  return VFromD<D>{_mm_cvtepi64_pd(v.raw)};\n-#else\n   // Based on wim's approach (https://stackoverflow.com/questions/41144668/)\n   const Repartition<uint32_t, decltype(dd)> d32;\n   const Repartition<uint64_t, decltype(dd)> d64;\n@@ -6525,15 +6532,20 @@ HWY_API VFromD<D> ConvertTo(D dd, VFromD<Rebind<int64_t, D>> v) {\n \n   const auto k84_63_52 = BitCast(dd, Set(d64, 0x4530000080100000ULL));\n   return (v_upper - k84_63_52) + v_lower;  // order matters!\n-#endif\n }\n \n-template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_F64_D(D)>\n+namespace detail {\n+template <class VW>\n+HWY_INLINE VFromD<Rebind<double, DFromV<VW>>> U64ToF64VecFast(VW w) {\n+  const DFromV<decltype(w)> d64;\n+  const RebindToFloat<decltype(d64)> dd;\n+  const auto cnst2_52_dbl = Set(dd, 0x0010000000000000);  // 2^52\n+  return BitCast(dd, Or(w, BitCast(d64, cnst2_52_dbl))) - cnst2_52_dbl;\n+}\n+}  // namespace detail\n+\n+template <class D, HWY_IF_F64_D(D)>\n HWY_API VFromD<D> ConvertTo(D dd, VFromD<Rebind<uint64_t, D>> v) {\n-#if HWY_TARGET <= HWY_AVX3\n-  (void)dd;\n-  return VFromD<D>{_mm_cvtepu64_pd(v.raw)};\n-#else\n   // Based on wim's approach (https://stackoverflow.com/questions/41144668/)\n   const RebindToUnsigned<decltype(dd)> d64;\n   using VU = VFromD<decltype(d64)>;\n@@ -6545,79 +6557,82 @@ HWY_API VFromD<D> ConvertTo(D dd, VFromD<Rebind<uint64_t, D>> v) {\n   const VU v_lo = And(v, msk_lo);\n   const VU v_hi = ShiftRight<32>(v);\n \n-  auto uint64_to_double128_fast = [&dd](VU w) HWY_ATTR {\n-    w = Or(w, VU{detail::BitCastToInteger(Set(dd, 0x0010000000000000).raw)});\n-    return BitCast(dd, w) - Set(dd, 0x0010000000000000);\n-  };\n-\n-  const auto v_lo_dbl = uint64_to_double128_fast(v_lo);\n-  return MulAdd(cnst2_32_dbl, uint64_to_double128_fast(v_hi), v_lo_dbl);\n-#endif\n+  const auto v_lo_dbl = detail::U64ToF64VecFast(v_lo);\n+  return MulAdd(cnst2_32_dbl, detail::U64ToF64VecFast(v_hi), v_lo_dbl);\n }\n+#endif  // HWY_TARGET <= HWY_AVX3\n \n // Truncates (rounds toward zero).\n template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> ConvertTo(D di, VFromD<Rebind<float, D>> v) {\n   return detail::FixConversionOverflow(di, v, _mm_cvttps_epi32(v.raw));\n }\n \n-// Full (partial handled below)\n-template <class DI>\n-HWY_API Vec128<int64_t> ConvertTo(DI di, const Vec128<double> v) {\n-#if HWY_TARGET <= HWY_AVX3 && HWY_ARCH_X86_64\n+#if HWY_TARGET <= HWY_AVX3\n+template <class DI, HWY_IF_V_SIZE_LE_D(DI, 16), HWY_IF_I64_D(DI)>\n+HWY_API VFromD<DI> ConvertTo(DI di, VFromD<Rebind<double, DI>> v) {\n   return detail::FixConversionOverflow(di, v, _mm_cvttpd_epi64(v.raw));\n-#elif HWY_ARCH_X86_64\n+}\n+\n+#else  // AVX2 or below\n+\n+#if HWY_ARCH_X86_64\n+template <class DI, HWY_IF_V_SIZE_D(DI, 8), HWY_IF_I64_D(DI)>\n+HWY_API VFromD<DI> ConvertTo(DI di, Vec64<double> v) {\n+  const Vec64<int64_t> i0{_mm_cvtsi64_si128(_mm_cvttsd_si64(v.raw))};\n+  return detail::FixConversionOverflow(di, v, i0.raw);\n+}\n+template <class DI, HWY_IF_V_SIZE_D(DI, 16), HWY_IF_I64_D(DI)>\n+HWY_API VFromD<DI> ConvertTo(DI di, Vec128<double> v) {\n   const __m128i i0 = _mm_cvtsi64_si128(_mm_cvttsd_si64(v.raw));\n   const Full64<double> dd2;\n   const __m128i i1 = _mm_cvtsi64_si128(_mm_cvttsd_si64(UpperHalf(dd2, v).raw));\n   return detail::FixConversionOverflow(di, v, _mm_unpacklo_epi64(i0, i1));\n-#else\n+}\n+#endif  // HWY_ARCH_X86_64\n+\n+#if !HWY_ARCH_X86_64 || HWY_TARGET <= HWY_AVX2\n+template <class DI, HWY_IF_V_SIZE_GT_D(DI, (HWY_ARCH_X86_64 ? 16 : 0)),\n+          HWY_IF_I64_D(DI)>\n+HWY_API VFromD<DI> ConvertTo(DI di, VFromD<Rebind<double, DI>> v) {\n   using VI = VFromD<decltype(di)>;\n-  const VI k0 = Zero(di);\n-  const VI k1 = Set(di, 1);\n-  const VI k51 = Set(di, 51);\n+  const RebindToUnsigned<decltype(di)> du;\n+  using VU = VFromD<decltype(du)>;\n+  const Repartition<int32_t, decltype(di)> di32;\n+  const Repartition<uint16_t, decltype(di)> du16;\n+  const VI k1075 = Set(di, 1075);\n \n   // Exponent indicates whether the number can be represented as int64_t.\n-  const VI biased_exp = ShiftRight<52>(BitCast(di, v)) & Set(di, 0x7FF);\n-  const VI exp = biased_exp - Set(di, 0x3FF);\n-  const auto in_range = exp < Set(di, 63);\n+  const VU biased_exp = ShiftRight<52>(BitCast(du, v)) & Set(du, 0x7FF);\n+  const auto in_range = MaskFromVec(BitCast(di,\n+    VecFromMask(di32, DupEven(BitCast(di32, biased_exp)) < Set(di32, 1086))));\n \n   // If we were to cap the exponent at 51 and add 2^52, the number would be in\n   // [2^52, 2^53) and mantissa bits could be read out directly. We need to\n   // round-to-0 (truncate), but changing rounding mode in MXCSR hits a\n   // compiler reordering bug: https://gcc.godbolt.org/z/4hKj6c6qc . We instead\n   // manually shift the mantissa into place (we already have many of the\n   // inputs anyway).\n-  const VI shift_mnt = Max(k51 - exp, k0);\n-  const VI shift_int = Max(exp - k51, k0);\n-  const VI mantissa = BitCast(di, v) & Set(di, (1ULL << 52) - 1);\n-  // Include implicit 1-bit; shift by one more to ensure it's in the mantissa.\n-  const VI int52 = (mantissa | Set(di, 1ULL << 52)) >> (shift_mnt + k1);\n-  // For inputs larger than 2^52, insert zeros at the bottom.\n-  const VI shifted = int52 << shift_int;\n-  // Restore the one bit lost when shifting in the implicit 1-bit.\n-  const VI restored = shifted | ((mantissa & k1) << (shift_int - k1));\n+  const VU shift_mnt =\n+    BitCast(du, SaturatedSub(BitCast(du16, k1075), BitCast(du16, biased_exp)));\n+  const VU shift_int =\n+    BitCast(du, SaturatedSub(BitCast(du16, biased_exp), BitCast(du16, k1075)));\n+  const VU mantissa = BitCast(du, v) & Set(du, (1ULL << 52) - 1);\n+  // Include implicit 1-bit\n+  const VU int53 = (mantissa | Set(du, 1ULL << 52)) >> shift_mnt;\n+  // For inputs larger than 2^53 - 1, insert zeros at the bottom.\n+  const VU shifted = int53 << shift_int;\n \n   // Saturate to LimitsMin (unchanged when negating below) or LimitsMax.\n   const VI sign_mask = BroadcastSignBit(BitCast(di, v));\n   const VI limit = Set(di, LimitsMax<int64_t>()) - sign_mask;\n-  const VI magnitude = IfThenElse(in_range, restored, limit);\n+  const VI magnitude = IfThenElse(in_range, BitCast(di, shifted), limit);\n \n   // If the input was negative, negate the integer (two's complement).\n   return (magnitude ^ sign_mask) - sign_mask;\n-#endif\n-}\n-template <class D>\n-HWY_API Vec64<int64_t> ConvertTo(D di, const Vec64<double> v) {\n-  // Only need to specialize for non-AVX3, 64-bit (single scalar op)\n-#if HWY_TARGET > HWY_AVX3 && HWY_ARCH_X86_64\n-  const Vec64<int64_t> i0{_mm_cvtsi64_si128(_mm_cvttsd_si64(v.raw))};\n-  return detail::FixConversionOverflow(di, v, i0.raw);\n-#else\n-  const Twice<decltype(di)> dit;\n-  return LowerHalf(ConvertTo(dit, Vec128<double>{v.raw}));\n-#endif\n }\n+#endif  // !HWY_ARCH_X86_64 || HWY_TARGET <= HWY_AVX2\n+#endif  // HWY_TARGET <= HWY_AVX3\n \n template <size_t N>\n HWY_API Vec128<int32_t, N> NearestInt(const Vec128<float, N> v) {\n--- hwy/ops/x86_256-inl.h\n@@ -4526,124 +4526,35 @@ HWY_API Vec256<float> ConvertTo(D /* tag */, Vec256<int32_t> v) {\n   return Vec256<float>{_mm256_cvtepi32_ps(v.raw)};\n }\n \n-template <class D, HWY_IF_F64_D(D)>\n-HWY_API Vec256<double> ConvertTo(D dd, const Vec256<int64_t> v) {\n #if HWY_TARGET <= HWY_AVX3\n-  (void)dd;\n-  return Vec256<double>{_mm256_cvtepi64_pd(v.raw)};\n-#else\n-  // Based on wim's approach (https://stackoverflow.com/questions/41144668/)\n-  const Repartition<uint32_t, decltype(dd)> d32;\n-  const Repartition<uint64_t, decltype(dd)> d64;\n-\n-  // Toggle MSB of lower 32-bits and insert exponent for 2^84 + 2^63\n-  const auto k84_63 = Set(d64, 0x4530000080000000ULL);\n-  const auto v_upper = BitCast(dd, ShiftRight<32>(BitCast(d64, v)) ^ k84_63);\n-\n-  // Exponent is 2^52, lower 32 bits from v (=> 32-bit OddEven)\n-  const auto k52 = Set(d32, 0x43300000);\n-  const auto v_lower = BitCast(dd, OddEven(k52, BitCast(d32, v)));\n-\n-  const auto k84_63_52 = BitCast(dd, Set(d64, 0x4530000080100000ULL));\n-  return (v_upper - k84_63_52) + v_lower;  // order matters!\n-#endif\n-}\n-\n template <class D, HWY_IF_F32_D(D)>\n-HWY_API Vec256<float> ConvertTo(D df, Vec256<uint32_t> v) {\n-#if HWY_TARGET <= HWY_AVX3\n-  (void)df;\n+HWY_API Vec256<float> ConvertTo(D /*df*/, Vec256<uint32_t> v) {\n   return Vec256<float>{_mm256_cvtepu32_ps(v.raw)};\n-#else\n-  // Based on wim's approach (https://stackoverflow.com/questions/34066228/)\n-  const RebindToUnsigned<decltype(df)> du32;\n-  const RebindToSigned<decltype(df)> d32;\n-\n-  const auto msk_lo = Set(du32, 0xFFFF);\n-  const auto cnst2_16_flt = Set(df, 65536.0f);  // 2^16\n-\n-  // Extract the 16 lowest/highest significant bits of v and cast to signed int\n-  const auto v_lo = BitCast(d32, And(v, msk_lo));\n-  const auto v_hi = BitCast(d32, ShiftRight<16>(v));\n+}\n \n-  return MulAdd(cnst2_16_flt, ConvertTo(df, v_hi), ConvertTo(df, v_lo));\n-#endif\n+template <class D, HWY_IF_F64_D(D)>\n+HWY_API Vec256<double> ConvertTo(D /*dd*/, Vec256<int64_t> v) {\n+  return Vec256<double>{_mm256_cvtepi64_pd(v.raw)};\n }\n \n template <class D, HWY_IF_F64_D(D)>\n-HWY_API Vec256<double> ConvertTo(D dd, Vec256<uint64_t> v) {\n-#if HWY_TARGET <= HWY_AVX3\n-  (void)dd;\n+HWY_API Vec256<double> ConvertTo(D /*dd*/, Vec256<uint64_t> v) {\n   return Vec256<double>{_mm256_cvtepu64_pd(v.raw)};\n-#else\n-  // Based on wim's approach (https://stackoverflow.com/questions/41144668/)\n-  const RebindToUnsigned<decltype(dd)> d64;\n-  using VU = VFromD<decltype(d64)>;\n-\n-  const VU msk_lo = Set(d64, 0xFFFFFFFFULL);\n-  const auto cnst2_32_dbl = Set(dd, 4294967296.0);  // 2^32\n-\n-  // Extract the 32 lowest significant bits of v\n-  const VU v_lo = And(v, msk_lo);\n-  const VU v_hi = ShiftRight<32>(v);\n-\n-  auto uint64_to_double256_fast = [&dd](Vec256<uint64_t> w) HWY_ATTR {\n-    w = Or(w, Vec256<uint64_t>{\n-                  detail::BitCastToInteger(Set(dd, 0x0010000000000000).raw)});\n-    return BitCast(dd, w) - Set(dd, 0x0010000000000000);\n-  };\n-\n-  const auto v_lo_dbl = uint64_to_double256_fast(v_lo);\n-  return MulAdd(cnst2_32_dbl, uint64_to_double256_fast(v_hi), v_lo_dbl);\n-#endif\n }\n+#endif  // HWY_TARGET <= HWY_AVX3\n \n // Truncates (rounds toward zero).\n template <class D, HWY_IF_I32_D(D)>\n HWY_API Vec256<int32_t> ConvertTo(D d, Vec256<float> v) {\n   return detail::FixConversionOverflow(d, v, _mm256_cvttps_epi32(v.raw));\n }\n \n+#if HWY_TARGET <= HWY_AVX3\n template <class D, HWY_IF_I64_D(D)>\n HWY_API Vec256<int64_t> ConvertTo(D di, Vec256<double> v) {\n-#if HWY_TARGET <= HWY_AVX3\n   return detail::FixConversionOverflow(di, v, _mm256_cvttpd_epi64(v.raw));\n-#else\n-  using VI = decltype(Zero(di));\n-  const VI k0 = Zero(di);\n-  const VI k1 = Set(di, 1);\n-  const VI k51 = Set(di, 51);\n-\n-  // Exponent indicates whether the number can be represented as int64_t.\n-  const VI biased_exp = ShiftRight<52>(BitCast(di, v)) & Set(di, 0x7FF);\n-  const VI exp = biased_exp - Set(di, 0x3FF);\n-  const auto in_range = exp < Set(di, 63);\n-\n-  // If we were to cap the exponent at 51 and add 2^52, the number would be in\n-  // [2^52, 2^53) and mantissa bits could be read out directly. We need to\n-  // round-to-0 (truncate), but changing rounding mode in MXCSR hits a\n-  // compiler reordering bug: https://gcc.godbolt.org/z/4hKj6c6qc . We instead\n-  // manually shift the mantissa into place (we already have many of the\n-  // inputs anyway).\n-  const VI shift_mnt = Max(k51 - exp, k0);\n-  const VI shift_int = Max(exp - k51, k0);\n-  const VI mantissa = BitCast(di, v) & Set(di, (1ULL << 52) - 1);\n-  // Include implicit 1-bit; shift by one more to ensure it's in the mantissa.\n-  const VI int52 = (mantissa | Set(di, 1ULL << 52)) >> (shift_mnt + k1);\n-  // For inputs larger than 2^52, insert zeros at the bottom.\n-  const VI shifted = int52 << shift_int;\n-  // Restore the one bit lost when shifting in the implicit 1-bit.\n-  const VI restored = shifted | ((mantissa & k1) << (shift_int - k1));\n-\n-  // Saturate to LimitsMin (unchanged when negating below) or LimitsMax.\n-  const VI sign_mask = BroadcastSignBit(BitCast(di, v));\n-  const VI limit = Set(di, LimitsMax<int64_t>()) - sign_mask;\n-  const VI magnitude = IfThenElse(in_range, restored, limit);\n-\n-  // If the input was negative, negate the integer (two's complement).\n-  return (magnitude ^ sign_mask) - sign_mask;\n-#endif\n }\n+#endif\n \n HWY_API Vec256<int32_t> NearestInt(const Vec256<float> v) {\n   const Full256<int32_t> di;"
        ],
        "files_changed": [
            {
                "filename": "hwy/ops/x86_128-inl.h",
                "status": "modified",
                "additions": 73,
                "deletions": 58,
                "changes": 131,
                "patch": "@@ -6485,12 +6485,24 @@ HWY_API VFromD<D> ConvertTo(D /* tag */, VFromD<Rebind<int32_t, D>> v) {\n   return VFromD<D>{_mm_cvtepi32_ps(v.raw)};\n }\n \n-template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_F32_D(D)>\n-HWY_API VFromD<D> ConvertTo(D df, VFromD<Rebind<uint32_t, D>> v) {\n #if HWY_TARGET <= HWY_AVX3\n-  (void)df;\n+template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_F32_D(D)>\n+HWY_API VFromD<D> ConvertTo(D /*df*/, VFromD<Rebind<uint32_t, D>> v) {\n   return VFromD<D>{_mm_cvtepu32_ps(v.raw)};\n-#else\n+}\n+\n+template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_F64_D(D)>\n+HWY_API VFromD<D> ConvertTo(D /*dd*/, VFromD<Rebind<int64_t, D>> v) {\n+  return VFromD<D>{_mm_cvtepi64_pd(v.raw)};\n+}\n+\n+template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_F64_D(D)>\n+HWY_API VFromD<D> ConvertTo(D /*dd*/, VFromD<Rebind<uint64_t, D>> v) {\n+  return VFromD<D>{_mm_cvtepu64_pd(v.raw)};\n+}\n+#else  // AVX2 or below\n+template <class D, HWY_IF_F32_D(D)>\n+HWY_API VFromD<D> ConvertTo(D df, VFromD<Rebind<uint32_t, D>> v) {\n   // Based on wim's approach (https://stackoverflow.com/questions/34066228/)\n   const RebindToUnsigned<decltype(df)> du32;\n   const RebindToSigned<decltype(df)> d32;\n@@ -6502,15 +6514,10 @@ HWY_API VFromD<D> ConvertTo(D df, VFromD<Rebind<uint32_t, D>> v) {\n   const auto v_lo = BitCast(d32, And(v, msk_lo));\n   const auto v_hi = BitCast(d32, ShiftRight<16>(v));\n   return MulAdd(cnst2_16_flt, ConvertTo(df, v_hi), ConvertTo(df, v_lo));\n-#endif\n }\n \n-template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_F64_D(D)>\n+template <class D, HWY_IF_F64_D(D)>\n HWY_API VFromD<D> ConvertTo(D dd, VFromD<Rebind<int64_t, D>> v) {\n-#if HWY_TARGET <= HWY_AVX3\n-  (void)dd;\n-  return VFromD<D>{_mm_cvtepi64_pd(v.raw)};\n-#else\n   // Based on wim's approach (https://stackoverflow.com/questions/41144668/)\n   const Repartition<uint32_t, decltype(dd)> d32;\n   const Repartition<uint64_t, decltype(dd)> d64;\n@@ -6525,15 +6532,20 @@ HWY_API VFromD<D> ConvertTo(D dd, VFromD<Rebind<int64_t, D>> v) {\n \n   const auto k84_63_52 = BitCast(dd, Set(d64, 0x4530000080100000ULL));\n   return (v_upper - k84_63_52) + v_lower;  // order matters!\n-#endif\n }\n \n-template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_F64_D(D)>\n+namespace detail {\n+template <class VW>\n+HWY_INLINE VFromD<Rebind<double, DFromV<VW>>> U64ToF64VecFast(VW w) {\n+  const DFromV<decltype(w)> d64;\n+  const RebindToFloat<decltype(d64)> dd;\n+  const auto cnst2_52_dbl = Set(dd, 0x0010000000000000);  // 2^52\n+  return BitCast(dd, Or(w, BitCast(d64, cnst2_52_dbl))) - cnst2_52_dbl;\n+}\n+}  // namespace detail\n+\n+template <class D, HWY_IF_F64_D(D)>\n HWY_API VFromD<D> ConvertTo(D dd, VFromD<Rebind<uint64_t, D>> v) {\n-#if HWY_TARGET <= HWY_AVX3\n-  (void)dd;\n-  return VFromD<D>{_mm_cvtepu64_pd(v.raw)};\n-#else\n   // Based on wim's approach (https://stackoverflow.com/questions/41144668/)\n   const RebindToUnsigned<decltype(dd)> d64;\n   using VU = VFromD<decltype(d64)>;\n@@ -6545,79 +6557,82 @@ HWY_API VFromD<D> ConvertTo(D dd, VFromD<Rebind<uint64_t, D>> v) {\n   const VU v_lo = And(v, msk_lo);\n   const VU v_hi = ShiftRight<32>(v);\n \n-  auto uint64_to_double128_fast = [&dd](VU w) HWY_ATTR {\n-    w = Or(w, VU{detail::BitCastToInteger(Set(dd, 0x0010000000000000).raw)});\n-    return BitCast(dd, w) - Set(dd, 0x0010000000000000);\n-  };\n-\n-  const auto v_lo_dbl = uint64_to_double128_fast(v_lo);\n-  return MulAdd(cnst2_32_dbl, uint64_to_double128_fast(v_hi), v_lo_dbl);\n-#endif\n+  const auto v_lo_dbl = detail::U64ToF64VecFast(v_lo);\n+  return MulAdd(cnst2_32_dbl, detail::U64ToF64VecFast(v_hi), v_lo_dbl);\n }\n+#endif  // HWY_TARGET <= HWY_AVX3\n \n // Truncates (rounds toward zero).\n template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> ConvertTo(D di, VFromD<Rebind<float, D>> v) {\n   return detail::FixConversionOverflow(di, v, _mm_cvttps_epi32(v.raw));\n }\n \n-// Full (partial handled below)\n-template <class DI>\n-HWY_API Vec128<int64_t> ConvertTo(DI di, const Vec128<double> v) {\n-#if HWY_TARGET <= HWY_AVX3 && HWY_ARCH_X86_64\n+#if HWY_TARGET <= HWY_AVX3\n+template <class DI, HWY_IF_V_SIZE_LE_D(DI, 16), HWY_IF_I64_D(DI)>\n+HWY_API VFromD<DI> ConvertTo(DI di, VFromD<Rebind<double, DI>> v) {\n   return detail::FixConversionOverflow(di, v, _mm_cvttpd_epi64(v.raw));\n-#elif HWY_ARCH_X86_64\n+}\n+\n+#else  // AVX2 or below\n+\n+#if HWY_ARCH_X86_64\n+template <class DI, HWY_IF_V_SIZE_D(DI, 8), HWY_IF_I64_D(DI)>\n+HWY_API VFromD<DI> ConvertTo(DI di, Vec64<double> v) {\n+  const Vec64<int64_t> i0{_mm_cvtsi64_si128(_mm_cvttsd_si64(v.raw))};\n+  return detail::FixConversionOverflow(di, v, i0.raw);\n+}\n+template <class DI, HWY_IF_V_SIZE_D(DI, 16), HWY_IF_I64_D(DI)>\n+HWY_API VFromD<DI> ConvertTo(DI di, Vec128<double> v) {\n   const __m128i i0 = _mm_cvtsi64_si128(_mm_cvttsd_si64(v.raw));\n   const Full64<double> dd2;\n   const __m128i i1 = _mm_cvtsi64_si128(_mm_cvttsd_si64(UpperHalf(dd2, v).raw));\n   return detail::FixConversionOverflow(di, v, _mm_unpacklo_epi64(i0, i1));\n-#else\n+}\n+#endif  // HWY_ARCH_X86_64\n+\n+#if !HWY_ARCH_X86_64 || HWY_TARGET <= HWY_AVX2\n+template <class DI, HWY_IF_V_SIZE_GT_D(DI, (HWY_ARCH_X86_64 ? 16 : 0)),\n+          HWY_IF_I64_D(DI)>\n+HWY_API VFromD<DI> ConvertTo(DI di, VFromD<Rebind<double, DI>> v) {\n   using VI = VFromD<decltype(di)>;\n-  const VI k0 = Zero(di);\n-  const VI k1 = Set(di, 1);\n-  const VI k51 = Set(di, 51);\n+  const RebindToUnsigned<decltype(di)> du;\n+  using VU = VFromD<decltype(du)>;\n+  const Repartition<int32_t, decltype(di)> di32;\n+  const Repartition<uint16_t, decltype(di)> du16;\n+  const VI k1075 = Set(di, 1075);\n \n   // Exponent indicates whether the number can be represented as int64_t.\n-  const VI biased_exp = ShiftRight<52>(BitCast(di, v)) & Set(di, 0x7FF);\n-  const VI exp = biased_exp - Set(di, 0x3FF);\n-  const auto in_range = exp < Set(di, 63);\n+  const VU biased_exp = ShiftRight<52>(BitCast(du, v)) & Set(du, 0x7FF);\n+  const auto in_range = MaskFromVec(BitCast(di,\n+    VecFromMask(di32, DupEven(BitCast(di32, biased_exp)) < Set(di32, 1086))));\n \n   // If we were to cap the exponent at 51 and add 2^52, the number would be in\n   // [2^52, 2^53) and mantissa bits could be read out directly. We need to\n   // round-to-0 (truncate), but changing rounding mode in MXCSR hits a\n   // compiler reordering bug: https://gcc.godbolt.org/z/4hKj6c6qc . We instead\n   // manually shift the mantissa into place (we already have many of the\n   // inputs anyway).\n-  const VI shift_mnt = Max(k51 - exp, k0);\n-  const VI shift_int = Max(exp - k51, k0);\n-  const VI mantissa = BitCast(di, v) & Set(di, (1ULL << 52) - 1);\n-  // Include implicit 1-bit; shift by one more to ensure it's in the mantissa.\n-  const VI int52 = (mantissa | Set(di, 1ULL << 52)) >> (shift_mnt + k1);\n-  // For inputs larger than 2^52, insert zeros at the bottom.\n-  const VI shifted = int52 << shift_int;\n-  // Restore the one bit lost when shifting in the implicit 1-bit.\n-  const VI restored = shifted | ((mantissa & k1) << (shift_int - k1));\n+  const VU shift_mnt =\n+    BitCast(du, SaturatedSub(BitCast(du16, k1075), BitCast(du16, biased_exp)));\n+  const VU shift_int =\n+    BitCast(du, SaturatedSub(BitCast(du16, biased_exp), BitCast(du16, k1075)));\n+  const VU mantissa = BitCast(du, v) & Set(du, (1ULL << 52) - 1);\n+  // Include implicit 1-bit\n+  const VU int53 = (mantissa | Set(du, 1ULL << 52)) >> shift_mnt;\n+  // For inputs larger than 2^53 - 1, insert zeros at the bottom.\n+  const VU shifted = int53 << shift_int;\n \n   // Saturate to LimitsMin (unchanged when negating below) or LimitsMax.\n   const VI sign_mask = BroadcastSignBit(BitCast(di, v));\n   const VI limit = Set(di, LimitsMax<int64_t>()) - sign_mask;\n-  const VI magnitude = IfThenElse(in_range, restored, limit);\n+  const VI magnitude = IfThenElse(in_range, BitCast(di, shifted), limit);\n \n   // If the input was negative, negate the integer (two's complement).\n   return (magnitude ^ sign_mask) - sign_mask;\n-#endif\n-}\n-template <class D>\n-HWY_API Vec64<int64_t> ConvertTo(D di, const Vec64<double> v) {\n-  // Only need to specialize for non-AVX3, 64-bit (single scalar op)\n-#if HWY_TARGET > HWY_AVX3 && HWY_ARCH_X86_64\n-  const Vec64<int64_t> i0{_mm_cvtsi64_si128(_mm_cvttsd_si64(v.raw))};\n-  return detail::FixConversionOverflow(di, v, i0.raw);\n-#else\n-  const Twice<decltype(di)> dit;\n-  return LowerHalf(ConvertTo(dit, Vec128<double>{v.raw}));\n-#endif\n }\n+#endif  // !HWY_ARCH_X86_64 || HWY_TARGET <= HWY_AVX2\n+#endif  // HWY_TARGET <= HWY_AVX3\n \n template <size_t N>\n HWY_API Vec128<int32_t, N> NearestInt(const Vec128<float, N> v) {"
            },
            {
                "filename": "hwy/ops/x86_256-inl.h",
                "status": "modified",
                "additions": 9,
                "deletions": 98,
                "changes": 107,
                "patch": "@@ -4526,124 +4526,35 @@ HWY_API Vec256<float> ConvertTo(D /* tag */, Vec256<int32_t> v) {\n   return Vec256<float>{_mm256_cvtepi32_ps(v.raw)};\n }\n \n-template <class D, HWY_IF_F64_D(D)>\n-HWY_API Vec256<double> ConvertTo(D dd, const Vec256<int64_t> v) {\n #if HWY_TARGET <= HWY_AVX3\n-  (void)dd;\n-  return Vec256<double>{_mm256_cvtepi64_pd(v.raw)};\n-#else\n-  // Based on wim's approach (https://stackoverflow.com/questions/41144668/)\n-  const Repartition<uint32_t, decltype(dd)> d32;\n-  const Repartition<uint64_t, decltype(dd)> d64;\n-\n-  // Toggle MSB of lower 32-bits and insert exponent for 2^84 + 2^63\n-  const auto k84_63 = Set(d64, 0x4530000080000000ULL);\n-  const auto v_upper = BitCast(dd, ShiftRight<32>(BitCast(d64, v)) ^ k84_63);\n-\n-  // Exponent is 2^52, lower 32 bits from v (=> 32-bit OddEven)\n-  const auto k52 = Set(d32, 0x43300000);\n-  const auto v_lower = BitCast(dd, OddEven(k52, BitCast(d32, v)));\n-\n-  const auto k84_63_52 = BitCast(dd, Set(d64, 0x4530000080100000ULL));\n-  return (v_upper - k84_63_52) + v_lower;  // order matters!\n-#endif\n-}\n-\n template <class D, HWY_IF_F32_D(D)>\n-HWY_API Vec256<float> ConvertTo(D df, Vec256<uint32_t> v) {\n-#if HWY_TARGET <= HWY_AVX3\n-  (void)df;\n+HWY_API Vec256<float> ConvertTo(D /*df*/, Vec256<uint32_t> v) {\n   return Vec256<float>{_mm256_cvtepu32_ps(v.raw)};\n-#else\n-  // Based on wim's approach (https://stackoverflow.com/questions/34066228/)\n-  const RebindToUnsigned<decltype(df)> du32;\n-  const RebindToSigned<decltype(df)> d32;\n-\n-  const auto msk_lo = Set(du32, 0xFFFF);\n-  const auto cnst2_16_flt = Set(df, 65536.0f);  // 2^16\n-\n-  // Extract the 16 lowest/highest significant bits of v and cast to signed int\n-  const auto v_lo = BitCast(d32, And(v, msk_lo));\n-  const auto v_hi = BitCast(d32, ShiftRight<16>(v));\n+}\n \n-  return MulAdd(cnst2_16_flt, ConvertTo(df, v_hi), ConvertTo(df, v_lo));\n-#endif\n+template <class D, HWY_IF_F64_D(D)>\n+HWY_API Vec256<double> ConvertTo(D /*dd*/, Vec256<int64_t> v) {\n+  return Vec256<double>{_mm256_cvtepi64_pd(v.raw)};\n }\n \n template <class D, HWY_IF_F64_D(D)>\n-HWY_API Vec256<double> ConvertTo(D dd, Vec256<uint64_t> v) {\n-#if HWY_TARGET <= HWY_AVX3\n-  (void)dd;\n+HWY_API Vec256<double> ConvertTo(D /*dd*/, Vec256<uint64_t> v) {\n   return Vec256<double>{_mm256_cvtepu64_pd(v.raw)};\n-#else\n-  // Based on wim's approach (https://stackoverflow.com/questions/41144668/)\n-  const RebindToUnsigned<decltype(dd)> d64;\n-  using VU = VFromD<decltype(d64)>;\n-\n-  const VU msk_lo = Set(d64, 0xFFFFFFFFULL);\n-  const auto cnst2_32_dbl = Set(dd, 4294967296.0);  // 2^32\n-\n-  // Extract the 32 lowest significant bits of v\n-  const VU v_lo = And(v, msk_lo);\n-  const VU v_hi = ShiftRight<32>(v);\n-\n-  auto uint64_to_double256_fast = [&dd](Vec256<uint64_t> w) HWY_ATTR {\n-    w = Or(w, Vec256<uint64_t>{\n-                  detail::BitCastToInteger(Set(dd, 0x0010000000000000).raw)});\n-    return BitCast(dd, w) - Set(dd, 0x0010000000000000);\n-  };\n-\n-  const auto v_lo_dbl = uint64_to_double256_fast(v_lo);\n-  return MulAdd(cnst2_32_dbl, uint64_to_double256_fast(v_hi), v_lo_dbl);\n-#endif\n }\n+#endif  // HWY_TARGET <= HWY_AVX3\n \n // Truncates (rounds toward zero).\n template <class D, HWY_IF_I32_D(D)>\n HWY_API Vec256<int32_t> ConvertTo(D d, Vec256<float> v) {\n   return detail::FixConversionOverflow(d, v, _mm256_cvttps_epi32(v.raw));\n }\n \n+#if HWY_TARGET <= HWY_AVX3\n template <class D, HWY_IF_I64_D(D)>\n HWY_API Vec256<int64_t> ConvertTo(D di, Vec256<double> v) {\n-#if HWY_TARGET <= HWY_AVX3\n   return detail::FixConversionOverflow(di, v, _mm256_cvttpd_epi64(v.raw));\n-#else\n-  using VI = decltype(Zero(di));\n-  const VI k0 = Zero(di);\n-  const VI k1 = Set(di, 1);\n-  const VI k51 = Set(di, 51);\n-\n-  // Exponent indicates whether the number can be represented as int64_t.\n-  const VI biased_exp = ShiftRight<52>(BitCast(di, v)) & Set(di, 0x7FF);\n-  const VI exp = biased_exp - Set(di, 0x3FF);\n-  const auto in_range = exp < Set(di, 63);\n-\n-  // If we were to cap the exponent at 51 and add 2^52, the number would be in\n-  // [2^52, 2^53) and mantissa bits could be read out directly. We need to\n-  // round-to-0 (truncate), but changing rounding mode in MXCSR hits a\n-  // compiler reordering bug: https://gcc.godbolt.org/z/4hKj6c6qc . We instead\n-  // manually shift the mantissa into place (we already have many of the\n-  // inputs anyway).\n-  const VI shift_mnt = Max(k51 - exp, k0);\n-  const VI shift_int = Max(exp - k51, k0);\n-  const VI mantissa = BitCast(di, v) & Set(di, (1ULL << 52) - 1);\n-  // Include implicit 1-bit; shift by one more to ensure it's in the mantissa.\n-  const VI int52 = (mantissa | Set(di, 1ULL << 52)) >> (shift_mnt + k1);\n-  // For inputs larger than 2^52, insert zeros at the bottom.\n-  const VI shifted = int52 << shift_int;\n-  // Restore the one bit lost when shifting in the implicit 1-bit.\n-  const VI restored = shifted | ((mantissa & k1) << (shift_int - k1));\n-\n-  // Saturate to LimitsMin (unchanged when negating below) or LimitsMax.\n-  const VI sign_mask = BroadcastSignBit(BitCast(di, v));\n-  const VI limit = Set(di, LimitsMax<int64_t>()) - sign_mask;\n-  const VI magnitude = IfThenElse(in_range, restored, limit);\n-\n-  // If the input was negative, negate the integer (two's complement).\n-  return (magnitude ^ sign_mask) - sign_mask;\n-#endif\n }\n+#endif\n \n HWY_API Vec256<int32_t> NearestInt(const Vec256<float> v) {\n   const Full256<int32_t> di;"
            }
        ],
        "lines_added": 82,
        "lines_removed": 156
    },
    "issues": [],
    "pull_requests": [],
    "build_info": {
        "old_build_script": [
            "apt-get update",
            "cmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON -DHWY_ENABLE_TESTS=ON",
            "cmake --build /test_workspace/workspace/old/build -- -j 1"
        ],
        "new_build_script": [
            "apt-get update",
            "cmake -S /test_workspace/workspace/new -B /test_workspace/workspace/new/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON -DHWY_ENABLE_TESTS=ON",
            "cmake --build /test_workspace/workspace/new/build -- -j 1"
        ],
        "old_test_script": [
            "cd /test_workspace/workspace/old/build",
            "ctest --output-on-failure"
        ],
        "new_test_script": [
            "cd /test_workspace/workspace/new/build",
            "ctest --output-on-failure"
        ],
        "build_system": "cmake"
    },
    "performance_analysis": {
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999991333466779,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.42667777486564173,
        "relative_improvement": 0.00010350270400817882,
        "absolute_improvement_ms": 12.000000000028876,
        "old_mean_ms": 115939.00000000001,
        "new_mean_ms": 115926.99999999999,
        "old_std_ms": 430.3835498715074,
        "new_std_ms": 405.8974730405328,
        "effect_size_cohens_d": 0.028686193189278588,
        "old_ci95_ms": [
            115778.29214131826,
            116099.70785868178
        ],
        "new_ci95_ms": [
            115775.43539267205,
            116078.56460732793
        ],
        "old_ci99_ms": [
            115722.41166822838,
            116155.58833177167
        ],
        "new_ci99_ms": [
            115722.73416181353,
            116131.26583818646
        ],
        "new_times_s": [
            116.26,
            115.78,
            116.41,
            115.95,
            115.92,
            116.14,
            115.96,
            115.44,
            115.73,
            116.02,
            115.58,
            115.98,
            116.17,
            116.35,
            116.25,
            116.44,
            116.48,
            115.94,
            115.58,
            115.27,
            115.46,
            115.26,
            115.14,
            115.3,
            115.84,
            116.34,
            115.98,
            116.7,
            116.25,
            116.11,
            116.04
        ],
        "old_times_s": [
            115.96,
            115.96,
            116.26,
            116.27,
            116.23,
            116.42,
            116.47,
            115.82,
            116.35,
            116.2,
            115.79,
            116.24,
            116.26,
            115.91,
            116.37,
            116.29,
            115.29,
            115.51,
            115.16,
            115.35,
            115.29,
            115.41,
            115.54,
            115.46,
            116.76,
            115.83,
            115.61,
            115.64,
            115.96,
            116.11,
            116.41
        ]
    },
    "tests": {
        "total_tests": 1,
        "significant_improvements": 0,
        "significant_improvements_tests": [],
        "significant_regressions": 0,
        "significant_regressions_tests": [],
        "significant_pair_improvements": 0,
        "significant_pair_improvements_tests": [],
        "significant_pair_regressions": 0,
        "significant_pair_regressions_tests": [],
        "significant_binom_improvements": 0,
        "significant_binom_improvements_tests": [],
        "significant_binom_regressions": 0,
        "significant_binom_regressions_tests": [],
        "significant_wilcoxon_improvements": 0,
        "significant_wilcoxon_improvements_tests": [],
        "significant_wilcoxon_regressions": 0,
        "significant_wilcoxon_regressions_tests": [],
        "significant_mannwhitney_improvements": 0,
        "significant_mannwhitney_improvements_tests": [],
        "significant_mannwhitney_regressions": 0,
        "significant_mannwhitney_regressions_tests": [],
        "tests": [
            {
                "test_name": "NanobenchmarkTest.RunAll",
                "is_significant": false,
                "p_value": 0.555666939122468,
                "is_pair_significant": false,
                "pair_p_value": 0.5494886255523248,
                "is_binom_significant": false,
                "binom_p_value": 0.77087084017694,
                "is_wilcoxon_significant": false,
                "wilcoxon_p_value": 0.639388414822935,
                "is_mannwhitney_significant": false,
                "mannwhitney_p_value": 0.2664521507814045,
                "relative_improvement": 0.04368174726989083,
                "absolute_improvement_ms": 19.310344827586366,
                "old_mean_ms": 442.06896551724145,
                "new_mean_ms": 422.75862068965506,
                "old_std_ms": 86.53567845299533,
                "new_std_ms": 68.39468190082668,
                "effect_size_cohens_d": 0.24758626533100758,
                "old_ci95_ms": [
                    409.1525538359555,
                    474.98537719852743
                ],
                "new_ci95_ms": [
                    396.7426750530691,
                    448.7745663262411
                ],
                "old_ci99_ms": [
                    397.66534930660754,
                    486.47258172787537
                ],
                "new_ci99_ms": [
                    387.6636025391667,
                    457.8536388401435
                ],
                "new_times": [
                    0.48,
                    0.49,
                    0.38,
                    0.48,
                    0.2,
                    0.38,
                    0.48,
                    0.45,
                    0.52,
                    0.43,
                    0.41,
                    0.35,
                    0.28,
                    0.43,
                    0.41,
                    0.46,
                    0.44,
                    0.52,
                    0.44,
                    0.35,
                    0.41,
                    0.41,
                    0.41,
                    0.47,
                    0.37,
                    0.43,
                    0.47,
                    0.44,
                    0.47
                ],
                "old_times": [
                    0.31,
                    0.42,
                    0.58,
                    0.4,
                    0.38,
                    0.49,
                    0.39,
                    0.5,
                    0.38,
                    0.43,
                    0.52,
                    0.49,
                    0.53,
                    0.47,
                    0.43,
                    0.53,
                    0.38,
                    0.49,
                    0.39,
                    0.44,
                    0.41,
                    0.68,
                    0.5,
                    0.44,
                    0.4,
                    0.21,
                    0.38,
                    0.43,
                    0.42
                ]
            }
        ]
    },
    "logs": {
        "full_log_path": "/logs/full.log",
        "config_log_path": "/logs/config.log",
        "build_log_path": "/logs/build.log",
        "test_log_path": "/logs/test.log",
        "build_success": true,
        "test_success": true
    },
    "raw_timing_data": {
        "warmup_runs": 1,
        "measurement_runs": 30,
        "min_exec_time_improvement": 0.05,
        "min_p_value": 0.05
    }
}