{
  "metadata": {
    "collection_date": "2026-01-11T17:46:20.464484",
    "repository": "https://github.com/google/highway",
    "repository_name": "google/highway"
  },
  "commit_info": {
    "old_sha": "4464e1b0319a0e827cdbdf6c6a6f32daa6b85d9d",
    "new_sha": "ab066c4da4cb744f1c1743dfcf05ef9d68ebb01b",
    "commit_message": [
      "Merge pull request #2592 from johnplatts:hwy_avx10_2_conv_enh_061225\n\nPiperOrigin-RevId: 771061284"
    ],
    "commit_date": "2025-06-13T12:59:23+00:00",
    "patch": [
      "--- hwy/ops/x86_128-inl.h\n@@ -70,6 +70,14 @@ namespace detail {\n #define HWY_X86_GCC_INLINE_ASM_VEC_CONSTRAINT \"x\"\n #endif\n \n+#undef HWY_X86_HAVE_AVX10_2_OPS\n+#if HWY_TARGET_IS_AVX10_2 && \\\n+    (HWY_COMPILER_GCC_ACTUAL >= 1501 || HWY_COMPILER3_CLANG >= 200103)\n+#define HWY_X86_HAVE_AVX10_2_OPS 1\n+#else\n+#define HWY_X86_HAVE_AVX10_2_OPS 0\n+#endif\n+\n template <typename T>\n struct Raw128 {\n   using type = __m128i;\n@@ -10443,6 +10451,7 @@ X86ConvertScalarFromFloat(TF from_val) {\n   return X86ConvertScalarFromFloat<TTo>(hwy::TypeTag<RemoveCvRef<TTo>>(),\n                                         from_val);\n }\n+\n #endif  // HWY_COMPILER_GCC_ACTUAL >= 700 && !HWY_IS_DEBUG_BUILD\n \n }  // namespace detail\n@@ -10455,7 +10464,9 @@ X86ConvertScalarFromFloat(TF from_val) {\n \n template <class D, HWY_IF_V_SIZE_LE_D(D, 8), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, VFromD<Rebind<double, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm_cvtts_pd_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttpd_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n@@ -10492,7 +10503,9 @@ HWY_API VFromD<D> DemoteTo(D di32, VFromD<Rebind<double, D>> v) {\n #if HWY_TARGET <= HWY_AVX3\n template <class D, HWY_IF_V_SIZE_LE_D(D, 8), HWY_IF_U32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, VFromD<Rebind<double, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm_cvtts_pd_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttpd_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -10520,8 +10533,12 @@ HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, VFromD<Rebind<double, D>> v) {\n \n // F64->U32 DemoteTo is generic for all vector lengths\n template <class D, HWY_IF_U32_D(D)>\n-HWY_API VFromD<D> DemoteTo(D /* tag */, VFromD<Rebind<double, D>> v) {\n-  return DemoteInRangeTo(D(), ZeroIfNegative(v));\n+HWY_API VFromD<D> DemoteTo(D du32, VFromD<Rebind<double, D>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return DemoteInRangeTo(du32, v);\n+#else\n+  return DemoteInRangeTo(du32, ZeroIfNegative(v));\n+#endif\n }\n #else   // HWY_TARGET > HWY_AVX3\n \n@@ -10649,7 +10666,9 @@ HWY_API Vec128<uint8_t, N> U8FromU32(const Vec128<uint32_t, N> v) {\n #if HWY_TARGET <= HWY_AVX3\n template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_I64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm_cvtts_ps_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an int64_t\n \n@@ -10677,6 +10696,9 @@ HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n // Generic for all vector lengths.\n template <class D, HWY_IF_I64_D(D)>\n HWY_API VFromD<D> PromoteTo(D di64, VFromD<Rebind<float, D>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return PromoteInRangeTo(di64, v);\n+#else\n   const Rebind<float, decltype(di64)> df32;\n   const RebindToFloat<decltype(di64)> df64;\n   // We now avoid GCC UB in PromoteInRangeTo via assembly, see #2189 and\n@@ -10689,14 +10711,21 @@ HWY_API VFromD<D> PromoteTo(D di64, VFromD<Rebind<float, D>> v) {\n       di64, PromoteMaskTo(df64, df32, Ge(v, Set(df32, 9.223372e18f))));\n   return IfThenElse(overflow, Set(di64, LimitsMax<int64_t>()),\n                     PromoteInRangeTo(di64, v));\n+#endif\n }\n template <class D, HWY_IF_U64_D(D)>\n-HWY_API VFromD<D> PromoteTo(D /* tag */, VFromD<Rebind<float, D>> v) {\n-  return PromoteInRangeTo(D(), ZeroIfNegative(v));\n+HWY_API VFromD<D> PromoteTo(D du64, VFromD<Rebind<float, D>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return PromoteInRangeTo(du64, v);\n+#else\n+  return PromoteInRangeTo(du64, ZeroIfNegative(v));\n+#endif\n }\n template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_U64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /* tag */, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm_cvtts_ps_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an uint64_t\n \n@@ -11375,7 +11404,9 @@ HWY_API VFromD<D> ConvertTo(D /* tag */, VFromD<RebindToFloat<D>> v) {\n \n template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, VFromD<RebindToFloat<D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm_cvtts_ps_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttps_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n@@ -11405,17 +11436,23 @@ HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, VFromD<RebindToFloat<D>> v) {\n // F32 to I32 ConvertTo is generic for all vector lengths\n template <class D, HWY_IF_I32_D(D)>\n HWY_API VFromD<D> ConvertTo(D di, VFromD<RebindToFloat<D>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return ConvertInRangeTo(di, v);\n+#else\n   const RebindToFloat<decltype(di)> df;\n   // See comment at the first occurrence of \"IfThenElse(overflow,\".\n   const MFromD<D> overflow = RebindMask(di, Ge(v, Set(df, 2147483648.0f)));\n   return IfThenElse(overflow, Set(di, LimitsMax<int32_t>()),\n                     ConvertInRangeTo(di, v));\n+#endif\n }\n \n #if HWY_TARGET <= HWY_AVX3\n template <class DI, HWY_IF_V_SIZE_LE_D(DI, 16), HWY_IF_I64_D(DI)>\n HWY_API VFromD<DI> ConvertInRangeTo(DI /*di*/, VFromD<RebindToFloat<DI>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DI>{_mm_cvtts_pd_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttpd_epi64 with GCC if any\n   // values of v[i] are not within the range of an int64_t\n \n@@ -11443,17 +11480,23 @@ HWY_API VFromD<DI> ConvertInRangeTo(DI /*di*/, VFromD<RebindToFloat<DI>> v) {\n // F64 to I64 ConvertTo is generic for all vector lengths on AVX3\n template <class DI, HWY_IF_I64_D(DI)>\n HWY_API VFromD<DI> ConvertTo(DI di, VFromD<RebindToFloat<DI>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return ConvertInRangeTo(di, v);\n+#else\n   const RebindToFloat<decltype(di)> df;\n   // See comment at the first occurrence of \"IfThenElse(overflow,\".\n   const MFromD<DI> overflow =\n       RebindMask(di, Ge(v, Set(df, 9.223372036854776e18)));\n   return IfThenElse(overflow, Set(di, LimitsMax<int64_t>()),\n                     ConvertInRangeTo(di, v));\n+#endif\n }\n \n template <class DU, HWY_IF_V_SIZE_LE_D(DU, 16), HWY_IF_U32_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm_cvtts_ps_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttps_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -11482,13 +11525,19 @@ HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n \n // F32->U32 ConvertTo is generic for all vector lengths\n template <class DU, HWY_IF_U32_D(DU)>\n-HWY_API VFromD<DU> ConvertTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-  return ConvertInRangeTo(DU(), ZeroIfNegative(v));\n+HWY_API VFromD<DU> ConvertTo(DU du32, VFromD<RebindToFloat<DU>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return ConvertInRangeTo(du32, v);\n+#else\n+  return ConvertInRangeTo(du32, ZeroIfNegative(v));\n+#endif\n }\n \n template <class DU, HWY_IF_V_SIZE_LE_D(DU, 16), HWY_IF_U64_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm_cvtts_pd_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttpd_epu64 with GCC if any\n   // values of v[i] are not within the range of an uint64_t\n \n@@ -11515,8 +11564,12 @@ HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n \n // F64->U64 ConvertTo is generic for all vector lengths\n template <class DU, HWY_IF_U64_D(DU)>\n-HWY_API VFromD<DU> ConvertTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-  return ConvertInRangeTo(DU(), ZeroIfNegative(v));\n+HWY_API VFromD<DU> ConvertTo(DU du64, VFromD<RebindToFloat<DU>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return ConvertInRangeTo(du64, v);\n+#else\n+  return ConvertInRangeTo(du64, ZeroIfNegative(v));\n+#endif\n }\n \n #else  // AVX2 or below\n--- hwy/ops/x86_256-inl.h\n@@ -6446,7 +6446,9 @@ HWY_API VFromD<D> PromoteTo(D /* tag */, Vec32<int8_t> v) {\n #if HWY_TARGET <= HWY_AVX3\n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_I64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_ps_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an int64_t\n \n@@ -6474,7 +6476,9 @@ HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n }\n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_U64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /* tag */, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_ps_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an uint64_t\n #if HWY_COMPILER_GCC_ACTUAL >= 700 && !HWY_IS_DEBUG_BUILD\n@@ -6853,7 +6857,9 @@ HWY_API VFromD<D> DemoteTo(D /* tag */, Vec256<double> v) {\n \n template <class D, HWY_IF_V_SIZE_D(D, 16), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec256<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_pd_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttpd_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n@@ -6883,7 +6889,9 @@ HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec256<double> v) {\n #if HWY_TARGET <= HWY_AVX3\n template <class D, HWY_IF_V_SIZE_D(D, 16), HWY_IF_U32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec256<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_pd_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttpd_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -7178,7 +7186,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /* tag */, VFromD<RebindToFloat<D>> v) {\n \n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> ConvertInRangeTo(D /*d*/, Vec256<float> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_ps_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttps_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n@@ -7212,7 +7222,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /*d*/, Vec256<float> v) {\n #if HWY_TARGET <= HWY_AVX3\n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_I64_D(D)>\n HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, Vec256<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_pd_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttpd_epi64 with GCC if any\n   // values of v[i] are not within the range of an int64_t\n \n@@ -7240,7 +7252,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, Vec256<double> v) {\n }\n template <class DU, HWY_IF_V_SIZE_D(DU, 32), HWY_IF_U32_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm256_cvtts_ps_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttps_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -7280,7 +7294,9 @@ HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n }\n template <class DU, HWY_IF_V_SIZE_D(DU, 32), HWY_IF_U64_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm256_cvtts_pd_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttpd_epu64 with GCC if any\n   // values of v[i] are not within the range of an uint64_t\n \n--- hwy/ops/x86_512-inl.h\n@@ -5511,7 +5511,9 @@ HWY_API VFromD<D> PromoteTo(D /* tag */, Vec256<uint32_t> v) {\n \n template <class D, HWY_IF_V_SIZE_D(D, 64), HWY_IF_I64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_ps_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an int64_t\n \n@@ -5543,7 +5545,9 @@ HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n }\n template <class D, HWY_IF_V_SIZE_D(D, 64), HWY_IF_U64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /* tag */, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_ps_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an uint64_t\n \n@@ -5831,23 +5835,27 @@ HWY_API VFromD<D> DemoteTo(D /* tag */, Vec512<double> v) {\n \n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec512<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_pd_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttpd_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n #if HWY_COMPILER_GCC_ACTUAL >= 700 && !HWY_IS_DEBUG_BUILD\n   if (detail::IsConstantX86VecForF2IConv<int32_t>(v)) {\n     typedef double GccF64RawVectType __attribute__((__vector_size__(64)));\n     const auto raw_v = reinterpret_cast<GccF64RawVectType>(v.raw);\n-    return VFromD<D>{_mm256_setr_epi32(\n+    return VFromD<D>{\n+        _mm256_setr_epi32(\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[0]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[1]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[2]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[3]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[4]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[5]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[6]),\n-        detail::X86ConvertScalarFromFloat<int32_t>(raw_v[7]))};\n+        detail::X86ConvertScalarFromFloat<int32_t>(raw_v[7]))\n+        };\n   }\n #endif\n \n@@ -5864,7 +5872,9 @@ HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec512<double> v) {\n \n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_U32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec512<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_pd_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttpd_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -6210,7 +6220,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /* tag */, VFromD<RebindToFloat<D>> v) {\n #endif  // HWY_HAVE_FLOAT16\n template <class D, HWY_IF_V_SIZE_D(D, 64), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> ConvertInRangeTo(D /*d*/, Vec512<float> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_ps_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttps_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n@@ -6250,7 +6262,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /*d*/, Vec512<float> v) {\n }\n template <class D, HWY_IF_V_SIZE_D(D, 64), HWY_IF_I64_D(D)>\n HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, Vec512<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_pd_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttpd_epi64 with GCC if any\n   // values of v[i] are not within the range of an int64_t\n \n@@ -6282,7 +6296,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, Vec512<double> v) {\n }\n template <class DU, HWY_IF_V_SIZE_D(DU, 64), HWY_IF_U32_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm512_cvtts_ps_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttps_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -6338,7 +6354,9 @@ HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n }\n template <class DU, HWY_IF_V_SIZE_D(DU, 64), HWY_IF_U64_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm512_cvtts_pd_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttpd_epu64 with GCC if any\n   // values of v[i] are not within the range of an uint64_t\n "
    ],
    "files_changed": [
      {
        "filename": "hwy/ops/x86_128-inl.h",
        "status": "modified",
        "additions": 69,
        "deletions": 16,
        "changes": 85,
        "patch": "@@ -70,6 +70,14 @@ namespace detail {\n #define HWY_X86_GCC_INLINE_ASM_VEC_CONSTRAINT \"x\"\n #endif\n \n+#undef HWY_X86_HAVE_AVX10_2_OPS\n+#if HWY_TARGET_IS_AVX10_2 && \\\n+    (HWY_COMPILER_GCC_ACTUAL >= 1501 || HWY_COMPILER3_CLANG >= 200103)\n+#define HWY_X86_HAVE_AVX10_2_OPS 1\n+#else\n+#define HWY_X86_HAVE_AVX10_2_OPS 0\n+#endif\n+\n template <typename T>\n struct Raw128 {\n   using type = __m128i;\n@@ -10443,6 +10451,7 @@ X86ConvertScalarFromFloat(TF from_val) {\n   return X86ConvertScalarFromFloat<TTo>(hwy::TypeTag<RemoveCvRef<TTo>>(),\n                                         from_val);\n }\n+\n #endif  // HWY_COMPILER_GCC_ACTUAL >= 700 && !HWY_IS_DEBUG_BUILD\n \n }  // namespace detail\n@@ -10455,7 +10464,9 @@ X86ConvertScalarFromFloat(TF from_val) {\n \n template <class D, HWY_IF_V_SIZE_LE_D(D, 8), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, VFromD<Rebind<double, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm_cvtts_pd_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttpd_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n@@ -10492,7 +10503,9 @@ HWY_API VFromD<D> DemoteTo(D di32, VFromD<Rebind<double, D>> v) {\n #if HWY_TARGET <= HWY_AVX3\n template <class D, HWY_IF_V_SIZE_LE_D(D, 8), HWY_IF_U32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, VFromD<Rebind<double, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm_cvtts_pd_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttpd_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -10520,8 +10533,12 @@ HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, VFromD<Rebind<double, D>> v) {\n \n // F64->U32 DemoteTo is generic for all vector lengths\n template <class D, HWY_IF_U32_D(D)>\n-HWY_API VFromD<D> DemoteTo(D /* tag */, VFromD<Rebind<double, D>> v) {\n-  return DemoteInRangeTo(D(), ZeroIfNegative(v));\n+HWY_API VFromD<D> DemoteTo(D du32, VFromD<Rebind<double, D>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return DemoteInRangeTo(du32, v);\n+#else\n+  return DemoteInRangeTo(du32, ZeroIfNegative(v));\n+#endif\n }\n #else   // HWY_TARGET > HWY_AVX3\n \n@@ -10649,7 +10666,9 @@ HWY_API Vec128<uint8_t, N> U8FromU32(const Vec128<uint32_t, N> v) {\n #if HWY_TARGET <= HWY_AVX3\n template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_I64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm_cvtts_ps_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an int64_t\n \n@@ -10677,6 +10696,9 @@ HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n // Generic for all vector lengths.\n template <class D, HWY_IF_I64_D(D)>\n HWY_API VFromD<D> PromoteTo(D di64, VFromD<Rebind<float, D>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return PromoteInRangeTo(di64, v);\n+#else\n   const Rebind<float, decltype(di64)> df32;\n   const RebindToFloat<decltype(di64)> df64;\n   // We now avoid GCC UB in PromoteInRangeTo via assembly, see #2189 and\n@@ -10689,14 +10711,21 @@ HWY_API VFromD<D> PromoteTo(D di64, VFromD<Rebind<float, D>> v) {\n       di64, PromoteMaskTo(df64, df32, Ge(v, Set(df32, 9.223372e18f))));\n   return IfThenElse(overflow, Set(di64, LimitsMax<int64_t>()),\n                     PromoteInRangeTo(di64, v));\n+#endif\n }\n template <class D, HWY_IF_U64_D(D)>\n-HWY_API VFromD<D> PromoteTo(D /* tag */, VFromD<Rebind<float, D>> v) {\n-  return PromoteInRangeTo(D(), ZeroIfNegative(v));\n+HWY_API VFromD<D> PromoteTo(D du64, VFromD<Rebind<float, D>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return PromoteInRangeTo(du64, v);\n+#else\n+  return PromoteInRangeTo(du64, ZeroIfNegative(v));\n+#endif\n }\n template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_U64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /* tag */, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm_cvtts_ps_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an uint64_t\n \n@@ -11375,7 +11404,9 @@ HWY_API VFromD<D> ConvertTo(D /* tag */, VFromD<RebindToFloat<D>> v) {\n \n template <class D, HWY_IF_V_SIZE_LE_D(D, 16), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, VFromD<RebindToFloat<D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm_cvtts_ps_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttps_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n@@ -11405,17 +11436,23 @@ HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, VFromD<RebindToFloat<D>> v) {\n // F32 to I32 ConvertTo is generic for all vector lengths\n template <class D, HWY_IF_I32_D(D)>\n HWY_API VFromD<D> ConvertTo(D di, VFromD<RebindToFloat<D>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return ConvertInRangeTo(di, v);\n+#else\n   const RebindToFloat<decltype(di)> df;\n   // See comment at the first occurrence of \"IfThenElse(overflow,\".\n   const MFromD<D> overflow = RebindMask(di, Ge(v, Set(df, 2147483648.0f)));\n   return IfThenElse(overflow, Set(di, LimitsMax<int32_t>()),\n                     ConvertInRangeTo(di, v));\n+#endif\n }\n \n #if HWY_TARGET <= HWY_AVX3\n template <class DI, HWY_IF_V_SIZE_LE_D(DI, 16), HWY_IF_I64_D(DI)>\n HWY_API VFromD<DI> ConvertInRangeTo(DI /*di*/, VFromD<RebindToFloat<DI>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DI>{_mm_cvtts_pd_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttpd_epi64 with GCC if any\n   // values of v[i] are not within the range of an int64_t\n \n@@ -11443,17 +11480,23 @@ HWY_API VFromD<DI> ConvertInRangeTo(DI /*di*/, VFromD<RebindToFloat<DI>> v) {\n // F64 to I64 ConvertTo is generic for all vector lengths on AVX3\n template <class DI, HWY_IF_I64_D(DI)>\n HWY_API VFromD<DI> ConvertTo(DI di, VFromD<RebindToFloat<DI>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return ConvertInRangeTo(di, v);\n+#else\n   const RebindToFloat<decltype(di)> df;\n   // See comment at the first occurrence of \"IfThenElse(overflow,\".\n   const MFromD<DI> overflow =\n       RebindMask(di, Ge(v, Set(df, 9.223372036854776e18)));\n   return IfThenElse(overflow, Set(di, LimitsMax<int64_t>()),\n                     ConvertInRangeTo(di, v));\n+#endif\n }\n \n template <class DU, HWY_IF_V_SIZE_LE_D(DU, 16), HWY_IF_U32_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm_cvtts_ps_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttps_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -11482,13 +11525,19 @@ HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n \n // F32->U32 ConvertTo is generic for all vector lengths\n template <class DU, HWY_IF_U32_D(DU)>\n-HWY_API VFromD<DU> ConvertTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-  return ConvertInRangeTo(DU(), ZeroIfNegative(v));\n+HWY_API VFromD<DU> ConvertTo(DU du32, VFromD<RebindToFloat<DU>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return ConvertInRangeTo(du32, v);\n+#else\n+  return ConvertInRangeTo(du32, ZeroIfNegative(v));\n+#endif\n }\n \n template <class DU, HWY_IF_V_SIZE_LE_D(DU, 16), HWY_IF_U64_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm_cvtts_pd_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm_cvttpd_epu64 with GCC if any\n   // values of v[i] are not within the range of an uint64_t\n \n@@ -11515,8 +11564,12 @@ HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n \n // F64->U64 ConvertTo is generic for all vector lengths\n template <class DU, HWY_IF_U64_D(DU)>\n-HWY_API VFromD<DU> ConvertTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-  return ConvertInRangeTo(DU(), ZeroIfNegative(v));\n+HWY_API VFromD<DU> ConvertTo(DU du64, VFromD<RebindToFloat<DU>> v) {\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return ConvertInRangeTo(du64, v);\n+#else\n+  return ConvertInRangeTo(du64, ZeroIfNegative(v));\n+#endif\n }\n \n #else  // AVX2 or below"
      },
      {
        "filename": "hwy/ops/x86_256-inl.h",
        "status": "modified",
        "additions": 24,
        "deletions": 8,
        "changes": 32,
        "patch": "@@ -6446,7 +6446,9 @@ HWY_API VFromD<D> PromoteTo(D /* tag */, Vec32<int8_t> v) {\n #if HWY_TARGET <= HWY_AVX3\n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_I64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_ps_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an int64_t\n \n@@ -6474,7 +6476,9 @@ HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n }\n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_U64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /* tag */, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_ps_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an uint64_t\n #if HWY_COMPILER_GCC_ACTUAL >= 700 && !HWY_IS_DEBUG_BUILD\n@@ -6853,7 +6857,9 @@ HWY_API VFromD<D> DemoteTo(D /* tag */, Vec256<double> v) {\n \n template <class D, HWY_IF_V_SIZE_D(D, 16), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec256<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_pd_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttpd_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n@@ -6883,7 +6889,9 @@ HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec256<double> v) {\n #if HWY_TARGET <= HWY_AVX3\n template <class D, HWY_IF_V_SIZE_D(D, 16), HWY_IF_U32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec256<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_pd_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttpd_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -7178,7 +7186,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /* tag */, VFromD<RebindToFloat<D>> v) {\n \n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> ConvertInRangeTo(D /*d*/, Vec256<float> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_ps_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttps_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n@@ -7212,7 +7222,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /*d*/, Vec256<float> v) {\n #if HWY_TARGET <= HWY_AVX3\n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_I64_D(D)>\n HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, Vec256<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm256_cvtts_pd_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttpd_epi64 with GCC if any\n   // values of v[i] are not within the range of an int64_t\n \n@@ -7240,7 +7252,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, Vec256<double> v) {\n }\n template <class DU, HWY_IF_V_SIZE_D(DU, 32), HWY_IF_U32_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm256_cvtts_ps_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttps_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -7280,7 +7294,9 @@ HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n }\n template <class DU, HWY_IF_V_SIZE_D(DU, 32), HWY_IF_U64_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm256_cvtts_pd_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm256_cvttpd_epu64 with GCC if any\n   // values of v[i] are not within the range of an uint64_t\n "
      },
      {
        "filename": "hwy/ops/x86_512-inl.h",
        "status": "modified",
        "additions": 28,
        "deletions": 10,
        "changes": 38,
        "patch": "@@ -5511,7 +5511,9 @@ HWY_API VFromD<D> PromoteTo(D /* tag */, Vec256<uint32_t> v) {\n \n template <class D, HWY_IF_V_SIZE_D(D, 64), HWY_IF_I64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_ps_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an int64_t\n \n@@ -5543,7 +5545,9 @@ HWY_API VFromD<D> PromoteInRangeTo(D /*di64*/, VFromD<Rebind<float, D>> v) {\n }\n template <class D, HWY_IF_V_SIZE_D(D, 64), HWY_IF_U64_D(D)>\n HWY_API VFromD<D> PromoteInRangeTo(D /* tag */, VFromD<Rebind<float, D>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_ps_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior with GCC if any values of v[i] are not\n   // within the range of an uint64_t\n \n@@ -5831,23 +5835,27 @@ HWY_API VFromD<D> DemoteTo(D /* tag */, Vec512<double> v) {\n \n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec512<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_pd_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttpd_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n #if HWY_COMPILER_GCC_ACTUAL >= 700 && !HWY_IS_DEBUG_BUILD\n   if (detail::IsConstantX86VecForF2IConv<int32_t>(v)) {\n     typedef double GccF64RawVectType __attribute__((__vector_size__(64)));\n     const auto raw_v = reinterpret_cast<GccF64RawVectType>(v.raw);\n-    return VFromD<D>{_mm256_setr_epi32(\n+    return VFromD<D>{\n+        _mm256_setr_epi32(\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[0]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[1]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[2]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[3]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[4]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[5]),\n         detail::X86ConvertScalarFromFloat<int32_t>(raw_v[6]),\n-        detail::X86ConvertScalarFromFloat<int32_t>(raw_v[7]))};\n+        detail::X86ConvertScalarFromFloat<int32_t>(raw_v[7]))\n+        };\n   }\n #endif\n \n@@ -5864,7 +5872,9 @@ HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec512<double> v) {\n \n template <class D, HWY_IF_V_SIZE_D(D, 32), HWY_IF_U32_D(D)>\n HWY_API VFromD<D> DemoteInRangeTo(D /* tag */, Vec512<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_pd_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttpd_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -6210,7 +6220,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /* tag */, VFromD<RebindToFloat<D>> v) {\n #endif  // HWY_HAVE_FLOAT16\n template <class D, HWY_IF_V_SIZE_D(D, 64), HWY_IF_I32_D(D)>\n HWY_API VFromD<D> ConvertInRangeTo(D /*d*/, Vec512<float> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_ps_epi32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttps_epi32 with GCC if any\n   // values of v[i] are not within the range of an int32_t\n \n@@ -6250,7 +6262,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /*d*/, Vec512<float> v) {\n }\n template <class D, HWY_IF_V_SIZE_D(D, 64), HWY_IF_I64_D(D)>\n HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, Vec512<double> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<D>{_mm512_cvtts_pd_epi64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttpd_epi64 with GCC if any\n   // values of v[i] are not within the range of an int64_t\n \n@@ -6282,7 +6296,9 @@ HWY_API VFromD<D> ConvertInRangeTo(D /*di*/, Vec512<double> v) {\n }\n template <class DU, HWY_IF_V_SIZE_D(DU, 64), HWY_IF_U32_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm512_cvtts_ps_epu32(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttps_epu32 with GCC if any\n   // values of v[i] are not within the range of an uint32_t\n \n@@ -6338,7 +6354,9 @@ HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n }\n template <class DU, HWY_IF_V_SIZE_D(DU, 64), HWY_IF_U64_D(DU)>\n HWY_API VFromD<DU> ConvertInRangeTo(DU /*du*/, VFromD<RebindToFloat<DU>> v) {\n-#if HWY_COMPILER_GCC_ACTUAL\n+#if HWY_X86_HAVE_AVX10_2_OPS\n+  return VFromD<DU>{_mm512_cvtts_pd_epu64(v.raw)};\n+#elif HWY_COMPILER_GCC_ACTUAL\n   // Workaround for undefined behavior in _mm512_cvttpd_epu64 with GCC if any\n   // values of v[i] are not within the range of an uint64_t\n "
      }
    ],
    "lines_added": 121,
    "lines_removed": 34
  },
  "issues": [],
  "pull_requests": [],
  "build_info": {
    "old_build_script": "#!/bin/bash\n#!/bin/bash\ncmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON -DHWY_ENABLE_TESTS=ON",
    "new_build_script": "#!/bin/bash\n#!/bin/bash\ncmake -S /test_workspace/workspace/new -B /test_workspace/workspace/new/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON -DHWY_ENABLE_TESTS=ON",
    "old_test_script": "#!/bin/bash\ncmake --build /test_workspace/workspace/old/build -- -j 1",
    "new_test_script": "#!/bin/bash\ncmake --build /test_workspace/workspace/new/build -- -j 1",
    "build_system": "cmake"
  },
  "performance_analysis": {
    "is_significant": false,
    "p_value": 1.0,
    "is_pair_significant": false,
    "pair_p_value": 1.0,
    "is_binom_significant": false,
    "binom_p_value": 1.0,
    "is_wilcoxon_significant": false,
    "wilcoxon_p_value": 0.9999991333466779,
    "is_mannwhitney_significant": false,
    "mannwhitney_p_value": 0.27957977904801207,
    "relative_improvement": 0.0009200778801406721,
    "absolute_improvement_ms": 51.666666666669414,
    "old_mean_ms": 56154.666666666664,
    "new_mean_ms": 56102.99999999999,
    "old_std_ms": 556.7623979904645,
    "new_std_ms": 564.533069188065,
    "effect_size_cohens_d": 0.09215309889411784,
    "old_ci95_ms": [
      55946.76817054087,
      56362.56516279246
    ],
    "new_ci95_ms": [
      55892.19988756228,
      56313.800112437704
    ],
    "old_ci99_ms": [
      55874.47882256821,
      56434.854510765115
    ],
    "new_ci99_ms": [
      55818.9016051569,
      56387.098394843095
    ],
    "new_times_s": [
      54.69,
      56.0,
      55.89,
      55.59,
      56.7,
      55.59,
      55.48,
      55.59,
      55.42,
      55.42,
      56.37,
      55.74,
      55.32,
      56.12,
      57.17,
      57.06,
      55.6,
      55.61,
      56.07,
      56.06,
      55.98,
      56.06,
      56.2,
      56.41,
      57.06,
      56.52,
      55.77,
      56.41,
      56.77,
      55.82,
      57.29
    ],
    "old_times_s": [
      55.53,
      55.12,
      56.0,
      56.78,
      57.15,
      55.54,
      55.68,
      55.74,
      56.58,
      56.02,
      55.26,
      55.46,
      56.28,
      55.64,
      56.66,
      55.76,
      56.52,
      55.47,
      55.64,
      56.56,
      56.57,
      56.42,
      56.5,
      57.08,
      57.17,
      56.23,
      56.48,
      56.24,
      55.87,
      56.31,
      55.91
    ]
  },
  "tests": {
    "total_tests": 9,
    "significant_improvements": 0,
    "significant_improvements_tests": [],
    "significant_regressions": 0,
    "significant_regressions_tests": [],
    "significant_pair_improvements": 0,
    "significant_pair_improvements_tests": [],
    "significant_pair_regressions": 0,
    "significant_pair_regressions_tests": [],
    "significant_binom_improvements": 0,
    "significant_binom_improvements_tests": [],
    "significant_binom_regressions": 0,
    "significant_binom_regressions_tests": [],
    "significant_wilcoxon_improvements": 0,
    "significant_wilcoxon_improvements_tests": [],
    "significant_wilcoxon_regressions": 0,
    "significant_wilcoxon_regressions_tests": [],
    "significant_mannwhitney_improvements": 0,
    "significant_mannwhitney_improvements_tests": [],
    "significant_mannwhitney_regressions": 0,
    "significant_mannwhitney_regressions_tests": [],
    "tests": [
      {
        "test_name": "AbortDeathTest.AbortDefault",
        "is_significant": false,
        "p_value": 0.9624400229906332,
        "is_pair_significant": false,
        "pair_p_value": 0.991147381058296,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.99999991548966,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.8520153586000264,
        "relative_improvement": -0.06666666666666674,
        "absolute_improvement_ms": -0.6896551724137941,
        "old_mean_ms": 10.344827586206899,
        "new_mean_ms": 11.034482758620692,
        "old_std_ms": 1.8569533817705186,
        "new_std_ms": 3.099340466946034,
        "effect_size_cohens_d": -0.26994300465927334,
        "old_ci95_ms": [
          9.638480295932675,
          11.05117487648112
        ],
        "new_ci95_ms": [
          9.855556695125623,
          12.213408822115762
        ],
        "old_ci99_ms": [
          9.391978463634116,
          11.29767670877968
        ],
        "new_ci99_ms": [
          9.444133817459822,
          12.624831699781565
        ],
        "new_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.02,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.02,
          0.02,
          0.01
        ],
        "old_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.02,
          0.01,
          0.01
        ]
      },
      {
        "test_name": "NanobenchmarkTest.RunTest",
        "is_significant": false,
        "p_value": 0.9482241936160791,
        "is_pair_significant": false,
        "pair_p_value": 0.940865568386224,
        "is_binom_significant": false,
        "binom_p_value": 0.987940227612853,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9834377205656416,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.6282997420159515,
        "relative_improvement": -0.012776831345826266,
        "absolute_improvement_ms": -5.172413793103459,
        "old_mean_ms": 404.82758620689657,
        "new_mean_ms": 410.00000000000006,
        "old_std_ms": 51.866634585745324,
        "new_std_ms": 66.27863262664026,
        "effect_size_cohens_d": -0.0869159511316972,
        "old_ci95_ms": [
          385.09857353757803,
          424.5565988762151
        ],
        "new_ci95_ms": [
          384.7889564603548,
          435.21104353964523
        ],
        "old_ci99_ms": [
          378.2135216100192,
          431.44165080377394
        ],
        "new_ci99_ms": [
          375.9907795405161,
          444.00922045948397
        ],
        "new_times": [
          0.46,
          0.42,
          0.63,
          0.34,
          0.35,
          0.37,
          0.43,
          0.43,
          0.5,
          0.39,
          0.4,
          0.31,
          0.43,
          0.5,
          0.4,
          0.42,
          0.4,
          0.36,
          0.38,
          0.3,
          0.37,
          0.42,
          0.44,
          0.47,
          0.47,
          0.34,
          0.38,
          0.42,
          0.36
        ],
        "old_times": [
          0.41,
          0.36,
          0.36,
          0.34,
          0.43,
          0.38,
          0.37,
          0.34,
          0.44,
          0.36,
          0.45,
          0.37,
          0.38,
          0.46,
          0.41,
          0.39,
          0.56,
          0.34,
          0.44,
          0.51,
          0.36,
          0.46,
          0.4,
          0.45,
          0.38,
          0.39,
          0.42,
          0.41,
          0.37
        ]
      },
      {
        "test_name": "AutoTuneTest.TestCostDistribution",
        "is_significant": false,
        "p_value": 0.9999172928312177,
        "is_pair_significant": false,
        "pair_p_value": 0.9989406933796833,
        "is_binom_significant": false,
        "binom_p_value": 0.9988421499729156,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9995961510170515,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.6540545321243556,
        "relative_improvement": -0.0057306590257879715,
        "absolute_improvement_ms": -0.6896551724138028,
        "old_mean_ms": 120.34482758620689,
        "new_mean_ms": 121.0344827586207,
        "old_std_ms": 6.804808499819215,
        "new_std_ms": 6.178781425287502,
        "effect_size_cohens_d": -0.10611162181545969,
        "old_ci95_ms": [
          117.75641686363966,
          122.93323830877412
        ],
        "new_ci95_ms": [
          118.68419999988645,
          123.38476551735495
        ],
        "old_ci99_ms": [
          116.85311052320426,
          123.83654464920951
        ],
        "new_ci99_ms": [
          117.86399581077885,
          124.20496970646253
        ],
        "new_times": [
          0.13,
          0.13,
          0.12,
          0.13,
          0.13,
          0.12,
          0.13,
          0.12,
          0.12,
          0.12,
          0.12,
          0.12,
          0.11,
          0.11,
          0.12,
          0.11,
          0.12,
          0.13,
          0.12,
          0.12,
          0.12,
          0.12,
          0.11,
          0.12,
          0.12,
          0.13,
          0.12,
          0.12,
          0.12
        ],
        "old_times": [
          0.12,
          0.11,
          0.12,
          0.12,
          0.13,
          0.12,
          0.12,
          0.12,
          0.11,
          0.11,
          0.12,
          0.12,
          0.13,
          0.13,
          0.13,
          0.12,
          0.12,
          0.11,
          0.12,
          0.13,
          0.12,
          0.12,
          0.13,
          0.12,
          0.11,
          0.12,
          0.11,
          0.13,
          0.12
        ]
      },
      {
        "test_name": "SpinTest.TestPingPong",
        "is_significant": false,
        "p_value": 0.9999999999238092,
        "is_pair_significant": false,
        "pair_p_value": 0.9999999999238092,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.99999991548966,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.926663564827266,
        "relative_improvement": -0.008620689655172422,
        "absolute_improvement_ms": -0.6896551724137889,
        "old_mean_ms": 80.00000000000001,
        "new_mean_ms": 80.68965517241381,
        "old_std_ms": 1.4123431441001795e-14,
        "new_std_ms": 2.578807147775636,
        "effect_size_cohens_d": -0.37820575262078154,
        "old_ci95_ms": [
          80.00000000000001,
          80.00000000000001
        ],
        "new_ci95_ms": [
          79.70872939428018,
          81.67058095054743
        ],
        "old_ci99_ms": [
          80.0,
          80.00000000000003
        ],
        "new_ci99_ms": [
          79.36640486782102,
          82.01290547700658
        ],
        "new_times": [
          0.08,
          0.08,
          0.09,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.09,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08
        ],
        "old_times": [
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08,
          0.08
        ]
      },
      {
        "test_name": "ThreadPoolTest.TestPool",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999638108507,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 1.0,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 10.000000000000002,
        "new_mean_ms": 10.000000000000002,
        "old_std_ms": 1.7654289301252243e-15,
        "new_std_ms": 1.7654289301252243e-15,
        "effect_size_cohens_d": 0.0,
        "old_ci95_ms": [
          10.000000000000002,
          10.000000000000002
        ],
        "new_ci95_ms": [
          10.000000000000002,
          10.000000000000002
        ],
        "old_ci99_ms": [
          10.0,
          10.000000000000004
        ],
        "new_ci99_ms": [
          10.0,
          10.000000000000004
        ],
        "new_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ],
        "old_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ]
      },
      {
        "test_name": "ThreadPoolTest.TestWaitMode",
        "is_significant": false,
        "p_value": 0.9982029831608538,
        "is_pair_significant": false,
        "pair_p_value": 0.9965324457084739,
        "is_binom_significant": false,
        "binom_p_value": 0.9997269436717033,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9977691879102321,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.12804129318947788,
        "relative_improvement": 0.007490353332828787,
        "absolute_improvement_ms": 34.13793103448359,
        "old_mean_ms": 4557.586206896552,
        "new_mean_ms": 4523.448275862069,
        "old_std_ms": 232.26609082217055,
        "new_std_ms": 262.3012970676083,
        "effect_size_cohens_d": 0.13779781003942304,
        "old_ci95_ms": [
          4469.236910955475,
          4645.935502837629
        ],
        "new_ci95_ms": [
          4423.674198473832,
          4623.222353250305
        ],
        "old_ci99_ms": [
          4438.404679230896,
          4676.767734562208
        ],
        "new_ci99_ms": [
          4388.854934309104,
          4658.041617415033
        ],
        "new_times": [
          4.26,
          4.64,
          4.67,
          4.77,
          4.38,
          4.39,
          4.33,
          4.37,
          4.29,
          4.83,
          4.34,
          4.37,
          4.84,
          4.72,
          4.33,
          4.35,
          4.37,
          4.19,
          4.89,
          4.49,
          4.47,
          4.45,
          4.77,
          4.68,
          4.41,
          4.33,
          4.48,
          4.35,
          5.42
        ],
        "old_times": [
          4.48,
          4.46,
          4.97,
          4.63,
          4.39,
          4.79,
          5.14,
          4.42,
          4.23,
          4.74,
          4.78,
          4.38,
          5.09,
          4.39,
          4.62,
          4.41,
          4.4,
          4.82,
          4.44,
          4.71,
          4.47,
          4.52,
          4.38,
          4.44,
          4.45,
          4.52,
          4.32,
          4.46,
          4.32
        ]
      },
      {
        "test_name": "ThreadPoolTest.TestCounter",
        "is_significant": false,
        "p_value": 0.9940548031230759,
        "is_pair_significant": false,
        "pair_p_value": 0.9962058191342144,
        "is_binom_significant": false,
        "binom_p_value": 0.9988421499729156,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9964972633944473,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.8490207181889338,
        "relative_improvement": -0.05206073752711482,
        "absolute_improvement_ms": -8.275862068965523,
        "old_mean_ms": 158.96551724137933,
        "new_mean_ms": 167.24137931034485,
        "old_std_ms": 20.061481854219842,
        "new_std_ms": 27.502798782791167,
        "effect_size_cohens_d": -0.3438044111424953,
        "old_ci95_ms": [
          151.33453765636526,
          166.5964968263934
        ],
        "new_ci95_ms": [
          156.77987414500816,
          177.70288447568154
        ],
        "old_ci99_ms": [
          148.6714702448536,
          169.2595642379051
        ],
        "new_ci99_ms": [
          153.12900689123109,
          181.35375172945865
        ],
        "new_times": [
          0.14,
          0.18,
          0.16,
          0.19,
          0.17,
          0.19,
          0.15,
          0.14,
          0.16,
          0.23,
          0.18,
          0.24,
          0.14,
          0.19,
          0.15,
          0.17,
          0.16,
          0.17,
          0.14,
          0.15,
          0.13,
          0.15,
          0.2,
          0.15,
          0.16,
          0.16,
          0.15,
          0.21,
          0.14
        ],
        "old_times": [
          0.14,
          0.17,
          0.15,
          0.15,
          0.16,
          0.19,
          0.14,
          0.17,
          0.17,
          0.14,
          0.14,
          0.16,
          0.2,
          0.17,
          0.13,
          0.14,
          0.15,
          0.17,
          0.15,
          0.15,
          0.15,
          0.13,
          0.18,
          0.18,
          0.15,
          0.19,
          0.15,
          0.2,
          0.14
        ]
      },
      {
        "test_name": "TopologyTest.TestTopology",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999638108507,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 1.0,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 10.000000000000002,
        "new_mean_ms": 10.000000000000002,
        "old_std_ms": 1.7654289301252243e-15,
        "new_std_ms": 1.7654289301252243e-15,
        "effect_size_cohens_d": 0.0,
        "old_ci95_ms": [
          10.000000000000002,
          10.000000000000002
        ],
        "new_ci95_ms": [
          10.000000000000002,
          10.000000000000002
        ],
        "old_ci99_ms": [
          10.0,
          10.000000000000004
        ],
        "new_ci99_ms": [
          10.0,
          10.000000000000004
        ],
        "new_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ],
        "old_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ]
      },
      {
        "test_name": "TopologyTest.TestCaches",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 1.0,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999999638108507,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 1.0,
        "relative_improvement": 0.0,
        "absolute_improvement_ms": 0.0,
        "old_mean_ms": 10.000000000000002,
        "new_mean_ms": 10.000000000000002,
        "old_std_ms": 1.7654289301252243e-15,
        "new_std_ms": 1.7654289301252243e-15,
        "effect_size_cohens_d": 0.0,
        "old_ci95_ms": [
          10.000000000000002,
          10.000000000000002
        ],
        "new_ci95_ms": [
          10.000000000000002,
          10.000000000000002
        ],
        "old_ci99_ms": [
          10.0,
          10.000000000000004
        ],
        "new_ci99_ms": [
          10.0,
          10.000000000000004
        ],
        "new_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ],
        "old_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ]
      }
    ]
  },
  "logs": {
    "full_log_path": "/logs/full.log",
    "config_log_path": "/logs/config.log",
    "build_log_path": "/logs/build.log",
    "test_log_path": "/logs/test.log",
    "build_success": true,
    "test_success": true
  },
  "raw_timing_data": {
    "warmup_runs": 1,
    "measurement_runs": 30,
    "min_exec_time_improvement": 0.05,
    "min_p_value": 0.05
  }
}