{
  "metadata": {
    "collection_date": "2026-01-14T18:43:57.635015",
    "repository": "https://github.com/taocpp/PEGTL",
    "repository_name": "taocpp/PEGTL"
  },
  "commit_info": {
    "old_sha": "1bfa6e450599da90be20016d8d2113ea0a3c5521",
    "new_sha": "c49626c56179d2d38e6d72b2a58de7875ade6e00",
    "commit_message": [
      "Avoid more instantiations, eliminate duseltronik ;-("
    ],
    "commit_date": "2020-05-23T11:58:44+00:00",
    "patch": [
      "--- include/tao/pegtl/internal/dusel_mode.hpp\n@@ -1,23 +0,0 @@\n-// Copyright (c) 2017-2020 Dr. Colin Hirsch and Daniel Frey\n-// Please see LICENSE for license or visit https://github.com/taocpp/PEGTL/\n-\n-#ifndef TAO_PEGTL_INTERNAL_DUSEL_MODE_HPP\n-#define TAO_PEGTL_INTERNAL_DUSEL_MODE_HPP\n-\n-#include \"../config.hpp\"\n-\n-namespace TAO_PEGTL_NAMESPACE::internal\n-{\n-   enum class dusel_mode : char\n-   {\n-      nothing = 0,\n-      control = 1,\n-      control_and_apply_void = 2,\n-      control_and_apply_bool = 3,\n-      control_and_apply0_void = 4,\n-      control_and_apply0_bool = 5\n-   };\n-\n-}  // namespace TAO_PEGTL_NAMESPACE::internal\n-\n-#endif\n--- include/tao/pegtl/internal/duseltronik.hpp\n@@ -1,224 +0,0 @@\n-// Copyright (c) 2014-2020 Dr. Colin Hirsch and Daniel Frey\n-// Please see LICENSE for license or visit https://github.com/taocpp/PEGTL/\n-\n-#ifndef TAO_PEGTL_INTERNAL_DUSELTRONIK_HPP\n-#define TAO_PEGTL_INTERNAL_DUSELTRONIK_HPP\n-\n-#include \"../apply_mode.hpp\"\n-#include \"../config.hpp\"\n-#include \"../rewind_mode.hpp\"\n-\n-#include \"dusel_mode.hpp\"\n-#include \"has_unwind.hpp\"\n-\n-#if defined( _MSC_VER )\n-#pragma warning( push )\n-#pragma warning( disable : 4702 )\n-#endif\n-\n-namespace TAO_PEGTL_NAMESPACE::internal\n-{\n-   template< typename Rule,\n-             apply_mode A,\n-             rewind_mode M,\n-             template< typename... >\n-             class Action,\n-             template< typename... >\n-             class Control,\n-             dusel_mode >\n-   struct duseltronik;\n-\n-   template< typename Rule,\n-             apply_mode A,\n-             rewind_mode M,\n-             template< typename... >\n-             class Action,\n-             template< typename... >\n-             class Control,\n-             typename ParseInput,\n-             typename... States >\n-   [[nodiscard]] auto match( ParseInput& in, States&&... st )\n-   {\n-      if constexpr( has_unwind< Control< Rule >, void, const ParseInput&, States... > ) {\n-         try {\n-            return duseltronik< Rule, A, M, Action, Control, dusel_mode::nothing >::match( in, st... );\n-         }\n-         catch( ... ) {\n-            Control< Rule >::unwind( static_cast< const ParseInput& >( in ), st... );\n-            throw;\n-         }\n-      }\n-      else {\n-         return duseltronik< Rule, A, M, Action, Control, dusel_mode::nothing >::match( in, st... );\n-      }\n-   }\n-\n-   template< typename Rule,\n-             apply_mode A,\n-             rewind_mode M,\n-             template< typename... >\n-             class Action,\n-             template< typename... >\n-             class Control >\n-   struct duseltronik< Rule, A, M, Action, Control, dusel_mode::nothing >\n-   {\n-      template< typename ParseInput, typename... States >\n-      [[nodiscard]] static auto match( ParseInput& in, States&&... st )\n-         -> decltype( Rule::template match< A, M, Action, Control >( in, st... ) )\n-      {\n-         return Rule::template match< A, M, Action, Control >( in, st... );\n-      }\n-\n-      template< typename ParseInput, typename... States, int = 1 >\n-      [[nodiscard]] static auto match( ParseInput& in, States&&... /*unused*/ )\n-         -> decltype( Rule::match( in ) )\n-      {\n-         return Rule::match( in );\n-      }\n-   };\n-\n-   template< typename Rule,\n-             apply_mode A,\n-             rewind_mode M,\n-             template< typename... >\n-             class Action,\n-             template< typename... >\n-             class Control >\n-   struct duseltronik< Rule, A, M, Action, Control, dusel_mode::control >\n-   {\n-      template< typename ParseInput, typename... States >\n-      [[nodiscard]] static auto match( ParseInput& in, States&&... st )\n-      {\n-         Control< Rule >::start( static_cast< const ParseInput& >( in ), st... );\n-         const auto result = internal::match< Rule, A, M, Action, Control >( in, st... );\n-         if( result ) {\n-            Control< Rule >::success( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         else {\n-            Control< Rule >::failure( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         return result;\n-      }\n-   };\n-\n-   template< typename Rule,\n-             apply_mode A,\n-             rewind_mode M,\n-             template< typename... >\n-             class Action,\n-             template< typename... >\n-             class Control >\n-   struct duseltronik< Rule, A, M, Action, Control, dusel_mode::control_and_apply_void >\n-   {\n-      template< typename ParseInput, typename... States >\n-      [[nodiscard]] static bool match( ParseInput& in, States&&... st )\n-      {\n-         auto m = in.template mark< rewind_mode::required >();\n-         Control< Rule >::start( static_cast< const ParseInput& >( in ), st... );\n-         const auto result = internal::match< Rule, A, rewind_mode::active, Action, Control >( in, st... );\n-         if( result ) {\n-            Control< Rule >::template apply< Action >( m.iterator(), static_cast< const ParseInput& >( in ), st... );\n-         }\n-         if( result ) {\n-            Control< Rule >::success( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         else {\n-            Control< Rule >::failure( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         (void)m( result );\n-         return result;\n-      }\n-   };\n-\n-   template< typename Rule,\n-             apply_mode A,\n-             rewind_mode M,\n-             template< typename... >\n-             class Action,\n-             template< typename... >\n-             class Control >\n-   struct duseltronik< Rule, A, M, Action, Control, dusel_mode::control_and_apply_bool >\n-   {\n-      template< typename ParseInput, typename... States >\n-      [[nodiscard]] static auto match( ParseInput& in, States&&... st )\n-      {\n-         auto m = in.template mark< rewind_mode::required >();\n-         Control< Rule >::start( static_cast< const ParseInput& >( in ), st... );\n-         auto result = internal::match< Rule, A, rewind_mode::active, Action, Control >( in, st... );\n-         if( result ) {\n-            result = Control< Rule >::template apply< Action >( m.iterator(), static_cast< const ParseInput& >( in ), st... );\n-         }\n-         if( result ) {\n-            Control< Rule >::success( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         else {\n-            Control< Rule >::failure( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         (void)m( result );\n-         return result;\n-      }\n-   };\n-\n-   template< typename Rule,\n-             apply_mode A,\n-             rewind_mode M,\n-             template< typename... >\n-             class Action,\n-             template< typename... >\n-             class Control >\n-   struct duseltronik< Rule, A, M, Action, Control, dusel_mode::control_and_apply0_void >\n-   {\n-      template< typename ParseInput, typename... States >\n-      [[nodiscard]] static auto match( ParseInput& in, States&&... st )\n-      {\n-         Control< Rule >::start( static_cast< const ParseInput& >( in ), st... );\n-         const auto result = internal::match< Rule, A, M, Action, Control >( in, st... );\n-         if( result ) {\n-            Control< Rule >::template apply0< Action >( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         if( result ) {\n-            Control< Rule >::success( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         else {\n-            Control< Rule >::failure( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         return result;\n-      }\n-   };\n-\n-   template< typename Rule,\n-             apply_mode A,\n-             rewind_mode M,\n-             template< typename... >\n-             class Action,\n-             template< typename... >\n-             class Control >\n-   struct duseltronik< Rule, A, M, Action, Control, dusel_mode::control_and_apply0_bool >\n-   {\n-      template< typename ParseInput, typename... States >\n-      [[nodiscard]] static auto match( ParseInput& in, States&&... st )\n-      {\n-         auto m = in.template mark< rewind_mode::required >();\n-         Control< Rule >::start( static_cast< const ParseInput& >( in ), st... );\n-         auto result = internal::match< Rule, A, rewind_mode::active, Action, Control >( in, st... );\n-         if( result ) {\n-            result = Control< Rule >::template apply0< Action >( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         if( result ) {\n-            Control< Rule >::success( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         else {\n-            Control< Rule >::failure( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         (void)m( result );\n-         return result;\n-      }\n-   };\n-\n-}  // namespace TAO_PEGTL_NAMESPACE::internal\n-\n-#if defined( _MSC_VER )\n-#pragma warning( pop )\n-#endif\n-\n-#endif\n--- include/tao/pegtl/match.hpp\n@@ -13,15 +13,74 @@\n #include \"require_apply0.hpp\"\n #include \"rewind_mode.hpp\"\n \n-#include \"internal/dusel_mode.hpp\"\n-#include \"internal/duseltronik.hpp\"\n #include \"internal/has_apply.hpp\"\n #include \"internal/has_apply0.hpp\"\n+#include \"internal/has_unwind.hpp\"\n+#include \"internal/marker.hpp\"\n #include \"internal/missing_apply.hpp\"\n #include \"internal/missing_apply0.hpp\"\n \n namespace TAO_PEGTL_NAMESPACE\n {\n+   namespace internal\n+   {\n+      template< typename Rule,\n+                apply_mode A,\n+                rewind_mode M,\n+                template< typename... >\n+                class Action,\n+                template< typename... >\n+                class Control,\n+                typename ParseInput,\n+                typename... States >\n+      [[nodiscard]] static auto match_no_control( ParseInput& in, States&&... st )\n+         -> decltype( Rule::template match< A, M, Action, Control >( in, st... ) )\n+      {\n+         return Rule::template match< A, M, Action, Control >( in, st... );\n+      }\n+\n+      template< typename Rule,\n+                apply_mode A,\n+                rewind_mode M,\n+                template< typename... >\n+                class Action,\n+                template< typename... >\n+                class Control,\n+                typename ParseInput,\n+                typename... States >\n+      [[nodiscard]] static auto match_no_control( ParseInput& in, States&&... /*unused*/ )\n+         -> decltype( Rule::match( in ) )\n+      {\n+         return Rule::match( in );\n+      }\n+\n+      template< typename Rule,\n+                apply_mode A,\n+                rewind_mode M,\n+                template< typename... >\n+                class Action,\n+                template< typename... >\n+                class Control,\n+                typename ParseInput,\n+                typename... States >\n+      [[nodiscard]] auto match_control_unwind( ParseInput& in, States&&... st )\n+      {\n+         if constexpr( has_unwind< Control< Rule >, void, const ParseInput&, States... > ) {\n+            try {\n+               return match_no_control< Rule, A, M, Action, Control >( in, st... );\n+            }\n+            catch( ... ) {\n+               Control< Rule >::unwind( static_cast< const ParseInput& >( in ), st... );\n+               throw;\n+            }\n+         }\n+         else {\n+            return match_no_control< Rule, A, M, Action, Control >( in, st... );\n+         }\n+      }\n+\n+   }  // namespace internal\n+\n    template< typename Rule,\n              apply_mode A,\n              rewind_mode M,\n@@ -33,38 +92,67 @@ namespace TAO_PEGTL_NAMESPACE\n              typename... States >\n    [[nodiscard]] auto match( ParseInput& in, States&&... st )\n    {\n-      constexpr bool enable_control = Control< Rule >::enable;\n-      constexpr bool enable_action = enable_control && ( A == apply_mode::action );\n+      if constexpr( !Control< Rule >::enable ) {\n+         return internal::match_no_control< Rule, A, M, Action, Control >( in, st... );\n+      }\n+      else {\n+         constexpr bool enable_action = ( A == apply_mode::action );\n \n-      using iterator_t = typename ParseInput::iterator_t;\n-      constexpr bool has_apply_void = enable_action && internal::has_apply< Control< Rule >, void, Action, const iterator_t&, const ParseInput&, States... >;\n-      constexpr bool has_apply_bool = enable_action && internal::has_apply< Control< Rule >, bool, Action, const iterator_t&, const ParseInput&, States... >;\n-      constexpr bool has_apply = has_apply_void || has_apply_bool;\n+         using iterator_t = typename ParseInput::iterator_t;\n+         constexpr bool has_apply_void = enable_action && internal::has_apply< Control< Rule >, void, Action, const iterator_t&, const ParseInput&, States... >;\n+         constexpr bool has_apply_bool = enable_action && internal::has_apply< Control< Rule >, bool, Action, const iterator_t&, const ParseInput&, States... >;\n+         constexpr bool has_apply = has_apply_void || has_apply_bool;\n \n-      constexpr bool has_apply0_void = enable_action && internal::has_apply0< Control< Rule >, void, Action, const ParseInput&, States... >;\n-      constexpr bool has_apply0_bool = enable_action && internal::has_apply0< Control< Rule >, bool, Action, const ParseInput&, States... >;\n-      constexpr bool has_apply0 = has_apply0_void || has_apply0_bool;\n+         constexpr bool has_apply0_void = enable_action && internal::has_apply0< Control< Rule >, void, Action, const ParseInput&, States... >;\n+         constexpr bool has_apply0_bool = enable_action && internal::has_apply0< Control< Rule >, bool, Action, const ParseInput&, States... >;\n+         constexpr bool has_apply0 = has_apply0_void || has_apply0_bool;\n \n-      static_assert( !( has_apply && has_apply0 ), \"both apply() and apply0() defined\" );\n+         static_assert( !( has_apply && has_apply0 ), \"both apply() and apply0() defined\" );\n \n-      constexpr bool is_nothing = std::is_base_of_v< nothing< Rule >, Action< Rule > >;\n-      static_assert( !( has_apply && is_nothing ), \"unexpected apply() defined\" );\n-      static_assert( !( has_apply0 && is_nothing ), \"unexpected apply0() defined\" );\n+         constexpr bool is_nothing = std::is_base_of_v< nothing< Rule >, Action< Rule > >;\n+         static_assert( !( has_apply && is_nothing ), \"unexpected apply() defined\" );\n+         static_assert( !( has_apply0 && is_nothing ), \"unexpected apply0() defined\" );\n \n-      if constexpr( !has_apply && std::is_base_of_v< require_apply, Action< Rule > > ) {\n-         internal::missing_apply< Control< Rule >, Action >( in, st... );\n-      }\n+         if constexpr( !has_apply && std::is_base_of_v< require_apply, Action< Rule > > ) {\n+            internal::missing_apply< Control< Rule >, Action >( in, st... );\n+         }\n \n-      if constexpr( !has_apply0 && std::is_base_of_v< require_apply0, Action< Rule > > ) {\n-         internal::missing_apply0< Control< Rule >, Action >( in, st... );\n-      }\n+         if constexpr( !has_apply0 && std::is_base_of_v< require_apply0, Action< Rule > > ) {\n+            internal::missing_apply0< Control< Rule >, Action >( in, st... );\n+         }\n+\n+         constexpr bool validate_nothing = std::is_base_of_v< maybe_nothing, Action< void > >;\n+         constexpr bool is_maybe_nothing = std::is_base_of_v< maybe_nothing, Action< Rule > >;\n+         static_assert( !enable_action || !validate_nothing || is_nothing || is_maybe_nothing || has_apply || has_apply0, \"either apply() or apply0() must be defined\" );\n \n-      constexpr bool validate_nothing = std::is_base_of_v< maybe_nothing, Action< void > >;\n-      constexpr bool is_maybe_nothing = std::is_base_of_v< maybe_nothing, Action< Rule > >;\n-      static_assert( !enable_action || !validate_nothing || is_nothing || is_maybe_nothing || has_apply || has_apply0, \"either apply() or apply0() must be defined\" );\n+         constexpr bool use_marker = has_apply || has_apply0_bool;\n \n-      constexpr auto mode = static_cast< internal::dusel_mode >( enable_control + has_apply_void + 2 * has_apply_bool + 3 * has_apply0_void + 4 * has_apply0_bool );\n-      return internal::duseltronik< Rule, A, M, Action, Control, mode >::match( in, st... );\n+         auto m = in.template mark< ( use_marker ? rewind_mode::required : rewind_mode::dontcare ) >();\n+         Control< Rule >::start( static_cast< const ParseInput& >( in ), st... );\n+         auto result = internal::match_control_unwind< Rule, A, ( use_marker ? rewind_mode::active : M ), Action, Control >( in, st... );\n+         if( result ) {\n+            if constexpr( has_apply_void ) {\n+               Control< Rule >::template apply< Action >( m.iterator(), static_cast< const ParseInput& >( in ), st... );\n+            }\n+            else if constexpr( has_apply_bool ) {\n+               result = Control< Rule >::template apply< Action >( m.iterator(), static_cast< const ParseInput& >( in ), st... );\n+            }\n+            else if constexpr( has_apply0_void ) {\n+               Control< Rule >::template apply0< Action >( static_cast< const ParseInput& >( in ), st... );\n+            }\n+            else if constexpr( has_apply0_bool ) {\n+               result = Control< Rule >::template apply0< Action >( static_cast< const ParseInput& >( in ), st... );\n+            }\n+         }\n+         if( result ) {\n+            Control< Rule >::success( static_cast< const ParseInput& >( in ), st... );\n+         }\n+         else {\n+            Control< Rule >::failure( static_cast< const ParseInput& >( in ), st... );\n+         }\n+         (void)m( result );\n+         return result;\n+      }\n    }\n \n }  // namespace TAO_PEGTL_NAMESPACE"
    ],
    "files_changed": [
      {
        "filename": "include/tao/pegtl/internal/dusel_mode.hpp",
        "status": "removed",
        "additions": 0,
        "deletions": 23,
        "changes": 23,
        "patch": "@@ -1,23 +0,0 @@\n-// Copyright (c) 2017-2020 Dr. Colin Hirsch and Daniel Frey\n-// Please see LICENSE for license or visit https://github.com/taocpp/PEGTL/\n-\n-#ifndef TAO_PEGTL_INTERNAL_DUSEL_MODE_HPP\n-#define TAO_PEGTL_INTERNAL_DUSEL_MODE_HPP\n-\n-#include \"../config.hpp\"\n-\n-namespace TAO_PEGTL_NAMESPACE::internal\n-{\n-   enum class dusel_mode : char\n-   {\n-      nothing = 0,\n-      control = 1,\n-      control_and_apply_void = 2,\n-      control_and_apply_bool = 3,\n-      control_and_apply0_void = 4,\n-      control_and_apply0_bool = 5\n-   };\n-\n-}  // namespace TAO_PEGTL_NAMESPACE::internal\n-\n-#endif"
      },
      {
        "filename": "include/tao/pegtl/internal/duseltronik.hpp",
        "status": "removed",
        "additions": 0,
        "deletions": 224,
        "changes": 224,
        "patch": "@@ -1,224 +0,0 @@\n-// Copyright (c) 2014-2020 Dr. Colin Hirsch and Daniel Frey\n-// Please see LICENSE for license or visit https://github.com/taocpp/PEGTL/\n-\n-#ifndef TAO_PEGTL_INTERNAL_DUSELTRONIK_HPP\n-#define TAO_PEGTL_INTERNAL_DUSELTRONIK_HPP\n-\n-#include \"../apply_mode.hpp\"\n-#include \"../config.hpp\"\n-#include \"../rewind_mode.hpp\"\n-\n-#include \"dusel_mode.hpp\"\n-#include \"has_unwind.hpp\"\n-\n-#if defined( _MSC_VER )\n-#pragma warning( push )\n-#pragma warning( disable : 4702 )\n-#endif\n-\n-namespace TAO_PEGTL_NAMESPACE::internal\n-{\n-   template< typename Rule,\n-             apply_mode A,\n-             rewind_mode M,\n-             template< typename... >\n-             class Action,\n-             template< typename... >\n-             class Control,\n-             dusel_mode >\n-   struct duseltronik;\n-\n-   template< typename Rule,\n-             apply_mode A,\n-             rewind_mode M,\n-             template< typename... >\n-             class Action,\n-             template< typename... >\n-             class Control,\n-             typename ParseInput,\n-             typename... States >\n-   [[nodiscard]] auto match( ParseInput& in, States&&... st )\n-   {\n-      if constexpr( has_unwind< Control< Rule >, void, const ParseInput&, States... > ) {\n-         try {\n-            return duseltronik< Rule, A, M, Action, Control, dusel_mode::nothing >::match( in, st... );\n-         }\n-         catch( ... ) {\n-            Control< Rule >::unwind( static_cast< const ParseInput& >( in ), st... );\n-            throw;\n-         }\n-      }\n-      else {\n-         return duseltronik< Rule, A, M, Action, Control, dusel_mode::nothing >::match( in, st... );\n-      }\n-   }\n-\n-   template< typename Rule,\n-             apply_mode A,\n-             rewind_mode M,\n-             template< typename... >\n-             class Action,\n-             template< typename... >\n-             class Control >\n-   struct duseltronik< Rule, A, M, Action, Control, dusel_mode::nothing >\n-   {\n-      template< typename ParseInput, typename... States >\n-      [[nodiscard]] static auto match( ParseInput& in, States&&... st )\n-         -> decltype( Rule::template match< A, M, Action, Control >( in, st... ) )\n-      {\n-         return Rule::template match< A, M, Action, Control >( in, st... );\n-      }\n-\n-      template< typename ParseInput, typename... States, int = 1 >\n-      [[nodiscard]] static auto match( ParseInput& in, States&&... /*unused*/ )\n-         -> decltype( Rule::match( in ) )\n-      {\n-         return Rule::match( in );\n-      }\n-   };\n-\n-   template< typename Rule,\n-             apply_mode A,\n-             rewind_mode M,\n-             template< typename... >\n-             class Action,\n-             template< typename... >\n-             class Control >\n-   struct duseltronik< Rule, A, M, Action, Control, dusel_mode::control >\n-   {\n-      template< typename ParseInput, typename... States >\n-      [[nodiscard]] static auto match( ParseInput& in, States&&... st )\n-      {\n-         Control< Rule >::start( static_cast< const ParseInput& >( in ), st... );\n-         const auto result = internal::match< Rule, A, M, Action, Control >( in, st... );\n-         if( result ) {\n-            Control< Rule >::success( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         else {\n-            Control< Rule >::failure( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         return result;\n-      }\n-   };\n-\n-   template< typename Rule,\n-             apply_mode A,\n-             rewind_mode M,\n-             template< typename... >\n-             class Action,\n-             template< typename... >\n-             class Control >\n-   struct duseltronik< Rule, A, M, Action, Control, dusel_mode::control_and_apply_void >\n-   {\n-      template< typename ParseInput, typename... States >\n-      [[nodiscard]] static bool match( ParseInput& in, States&&... st )\n-      {\n-         auto m = in.template mark< rewind_mode::required >();\n-         Control< Rule >::start( static_cast< const ParseInput& >( in ), st... );\n-         const auto result = internal::match< Rule, A, rewind_mode::active, Action, Control >( in, st... );\n-         if( result ) {\n-            Control< Rule >::template apply< Action >( m.iterator(), static_cast< const ParseInput& >( in ), st... );\n-         }\n-         if( result ) {\n-            Control< Rule >::success( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         else {\n-            Control< Rule >::failure( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         (void)m( result );\n-         return result;\n-      }\n-   };\n-\n-   template< typename Rule,\n-             apply_mode A,\n-             rewind_mode M,\n-             template< typename... >\n-             class Action,\n-             template< typename... >\n-             class Control >\n-   struct duseltronik< Rule, A, M, Action, Control, dusel_mode::control_and_apply_bool >\n-   {\n-      template< typename ParseInput, typename... States >\n-      [[nodiscard]] static auto match( ParseInput& in, States&&... st )\n-      {\n-         auto m = in.template mark< rewind_mode::required >();\n-         Control< Rule >::start( static_cast< const ParseInput& >( in ), st... );\n-         auto result = internal::match< Rule, A, rewind_mode::active, Action, Control >( in, st... );\n-         if( result ) {\n-            result = Control< Rule >::template apply< Action >( m.iterator(), static_cast< const ParseInput& >( in ), st... );\n-         }\n-         if( result ) {\n-            Control< Rule >::success( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         else {\n-            Control< Rule >::failure( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         (void)m( result );\n-         return result;\n-      }\n-   };\n-\n-   template< typename Rule,\n-             apply_mode A,\n-             rewind_mode M,\n-             template< typename... >\n-             class Action,\n-             template< typename... >\n-             class Control >\n-   struct duseltronik< Rule, A, M, Action, Control, dusel_mode::control_and_apply0_void >\n-   {\n-      template< typename ParseInput, typename... States >\n-      [[nodiscard]] static auto match( ParseInput& in, States&&... st )\n-      {\n-         Control< Rule >::start( static_cast< const ParseInput& >( in ), st... );\n-         const auto result = internal::match< Rule, A, M, Action, Control >( in, st... );\n-         if( result ) {\n-            Control< Rule >::template apply0< Action >( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         if( result ) {\n-            Control< Rule >::success( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         else {\n-            Control< Rule >::failure( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         return result;\n-      }\n-   };\n-\n-   template< typename Rule,\n-             apply_mode A,\n-             rewind_mode M,\n-             template< typename... >\n-             class Action,\n-             template< typename... >\n-             class Control >\n-   struct duseltronik< Rule, A, M, Action, Control, dusel_mode::control_and_apply0_bool >\n-   {\n-      template< typename ParseInput, typename... States >\n-      [[nodiscard]] static auto match( ParseInput& in, States&&... st )\n-      {\n-         auto m = in.template mark< rewind_mode::required >();\n-         Control< Rule >::start( static_cast< const ParseInput& >( in ), st... );\n-         auto result = internal::match< Rule, A, rewind_mode::active, Action, Control >( in, st... );\n-         if( result ) {\n-            result = Control< Rule >::template apply0< Action >( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         if( result ) {\n-            Control< Rule >::success( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         else {\n-            Control< Rule >::failure( static_cast< const ParseInput& >( in ), st... );\n-         }\n-         (void)m( result );\n-         return result;\n-      }\n-   };\n-\n-}  // namespace TAO_PEGTL_NAMESPACE::internal\n-\n-#if defined( _MSC_VER )\n-#pragma warning( pop )\n-#endif\n-\n-#endif"
      },
      {
        "filename": "include/tao/pegtl/match.hpp",
        "status": "modified",
        "additions": 114,
        "deletions": 26,
        "changes": 140,
        "patch": "@@ -13,15 +13,74 @@\n #include \"require_apply0.hpp\"\n #include \"rewind_mode.hpp\"\n \n-#include \"internal/dusel_mode.hpp\"\n-#include \"internal/duseltronik.hpp\"\n #include \"internal/has_apply.hpp\"\n #include \"internal/has_apply0.hpp\"\n+#include \"internal/has_unwind.hpp\"\n+#include \"internal/marker.hpp\"\n #include \"internal/missing_apply.hpp\"\n #include \"internal/missing_apply0.hpp\"\n \n namespace TAO_PEGTL_NAMESPACE\n {\n+   namespace internal\n+   {\n+      template< typename Rule,\n+                apply_mode A,\n+                rewind_mode M,\n+                template< typename... >\n+                class Action,\n+                template< typename... >\n+                class Control,\n+                typename ParseInput,\n+                typename... States >\n+      [[nodiscard]] static auto match_no_control( ParseInput& in, States&&... st )\n+         -> decltype( Rule::template match< A, M, Action, Control >( in, st... ) )\n+      {\n+         return Rule::template match< A, M, Action, Control >( in, st... );\n+      }\n+\n+      template< typename Rule,\n+                apply_mode A,\n+                rewind_mode M,\n+                template< typename... >\n+                class Action,\n+                template< typename... >\n+                class Control,\n+                typename ParseInput,\n+                typename... States >\n+      [[nodiscard]] static auto match_no_control( ParseInput& in, States&&... /*unused*/ )\n+         -> decltype( Rule::match( in ) )\n+      {\n+         return Rule::match( in );\n+      }\n+\n+      template< typename Rule,\n+                apply_mode A,\n+                rewind_mode M,\n+                template< typename... >\n+                class Action,\n+                template< typename... >\n+                class Control,\n+                typename ParseInput,\n+                typename... States >\n+      [[nodiscard]] auto match_control_unwind( ParseInput& in, States&&... st )\n+      {\n+         if constexpr( has_unwind< Control< Rule >, void, const ParseInput&, States... > ) {\n+            try {\n+               return match_no_control< Rule, A, M, Action, Control >( in, st... );\n+            }\n+            catch( ... ) {\n+               Control< Rule >::unwind( static_cast< const ParseInput& >( in ), st... );\n+               throw;\n+            }\n+         }\n+         else {\n+            return match_no_control< Rule, A, M, Action, Control >( in, st... );\n+         }\n+      }\n+\n+   }  // namespace internal\n+\n    template< typename Rule,\n              apply_mode A,\n              rewind_mode M,\n@@ -33,38 +92,67 @@ namespace TAO_PEGTL_NAMESPACE\n              typename... States >\n    [[nodiscard]] auto match( ParseInput& in, States&&... st )\n    {\n-      constexpr bool enable_control = Control< Rule >::enable;\n-      constexpr bool enable_action = enable_control && ( A == apply_mode::action );\n+      if constexpr( !Control< Rule >::enable ) {\n+         return internal::match_no_control< Rule, A, M, Action, Control >( in, st... );\n+      }\n+      else {\n+         constexpr bool enable_action = ( A == apply_mode::action );\n \n-      using iterator_t = typename ParseInput::iterator_t;\n-      constexpr bool has_apply_void = enable_action && internal::has_apply< Control< Rule >, void, Action, const iterator_t&, const ParseInput&, States... >;\n-      constexpr bool has_apply_bool = enable_action && internal::has_apply< Control< Rule >, bool, Action, const iterator_t&, const ParseInput&, States... >;\n-      constexpr bool has_apply = has_apply_void || has_apply_bool;\n+         using iterator_t = typename ParseInput::iterator_t;\n+         constexpr bool has_apply_void = enable_action && internal::has_apply< Control< Rule >, void, Action, const iterator_t&, const ParseInput&, States... >;\n+         constexpr bool has_apply_bool = enable_action && internal::has_apply< Control< Rule >, bool, Action, const iterator_t&, const ParseInput&, States... >;\n+         constexpr bool has_apply = has_apply_void || has_apply_bool;\n \n-      constexpr bool has_apply0_void = enable_action && internal::has_apply0< Control< Rule >, void, Action, const ParseInput&, States... >;\n-      constexpr bool has_apply0_bool = enable_action && internal::has_apply0< Control< Rule >, bool, Action, const ParseInput&, States... >;\n-      constexpr bool has_apply0 = has_apply0_void || has_apply0_bool;\n+         constexpr bool has_apply0_void = enable_action && internal::has_apply0< Control< Rule >, void, Action, const ParseInput&, States... >;\n+         constexpr bool has_apply0_bool = enable_action && internal::has_apply0< Control< Rule >, bool, Action, const ParseInput&, States... >;\n+         constexpr bool has_apply0 = has_apply0_void || has_apply0_bool;\n \n-      static_assert( !( has_apply && has_apply0 ), \"both apply() and apply0() defined\" );\n+         static_assert( !( has_apply && has_apply0 ), \"both apply() and apply0() defined\" );\n \n-      constexpr bool is_nothing = std::is_base_of_v< nothing< Rule >, Action< Rule > >;\n-      static_assert( !( has_apply && is_nothing ), \"unexpected apply() defined\" );\n-      static_assert( !( has_apply0 && is_nothing ), \"unexpected apply0() defined\" );\n+         constexpr bool is_nothing = std::is_base_of_v< nothing< Rule >, Action< Rule > >;\n+         static_assert( !( has_apply && is_nothing ), \"unexpected apply() defined\" );\n+         static_assert( !( has_apply0 && is_nothing ), \"unexpected apply0() defined\" );\n \n-      if constexpr( !has_apply && std::is_base_of_v< require_apply, Action< Rule > > ) {\n-         internal::missing_apply< Control< Rule >, Action >( in, st... );\n-      }\n+         if constexpr( !has_apply && std::is_base_of_v< require_apply, Action< Rule > > ) {\n+            internal::missing_apply< Control< Rule >, Action >( in, st... );\n+         }\n \n-      if constexpr( !has_apply0 && std::is_base_of_v< require_apply0, Action< Rule > > ) {\n-         internal::missing_apply0< Control< Rule >, Action >( in, st... );\n-      }\n+         if constexpr( !has_apply0 && std::is_base_of_v< require_apply0, Action< Rule > > ) {\n+            internal::missing_apply0< Control< Rule >, Action >( in, st... );\n+         }\n+\n+         constexpr bool validate_nothing = std::is_base_of_v< maybe_nothing, Action< void > >;\n+         constexpr bool is_maybe_nothing = std::is_base_of_v< maybe_nothing, Action< Rule > >;\n+         static_assert( !enable_action || !validate_nothing || is_nothing || is_maybe_nothing || has_apply || has_apply0, \"either apply() or apply0() must be defined\" );\n \n-      constexpr bool validate_nothing = std::is_base_of_v< maybe_nothing, Action< void > >;\n-      constexpr bool is_maybe_nothing = std::is_base_of_v< maybe_nothing, Action< Rule > >;\n-      static_assert( !enable_action || !validate_nothing || is_nothing || is_maybe_nothing || has_apply || has_apply0, \"either apply() or apply0() must be defined\" );\n+         constexpr bool use_marker = has_apply || has_apply0_bool;\n \n-      constexpr auto mode = static_cast< internal::dusel_mode >( enable_control + has_apply_void + 2 * has_apply_bool + 3 * has_apply0_void + 4 * has_apply0_bool );\n-      return internal::duseltronik< Rule, A, M, Action, Control, mode >::match( in, st... );\n+         auto m = in.template mark< ( use_marker ? rewind_mode::required : rewind_mode::dontcare ) >();\n+         Control< Rule >::start( static_cast< const ParseInput& >( in ), st... );\n+         auto result = internal::match_control_unwind< Rule, A, ( use_marker ? rewind_mode::active : M ), Action, Control >( in, st... );\n+         if( result ) {\n+            if constexpr( has_apply_void ) {\n+               Control< Rule >::template apply< Action >( m.iterator(), static_cast< const ParseInput& >( in ), st... );\n+            }\n+            else if constexpr( has_apply_bool ) {\n+               result = Control< Rule >::template apply< Action >( m.iterator(), static_cast< const ParseInput& >( in ), st... );\n+            }\n+            else if constexpr( has_apply0_void ) {\n+               Control< Rule >::template apply0< Action >( static_cast< const ParseInput& >( in ), st... );\n+            }\n+            else if constexpr( has_apply0_bool ) {\n+               result = Control< Rule >::template apply0< Action >( static_cast< const ParseInput& >( in ), st... );\n+            }\n+         }\n+         if( result ) {\n+            Control< Rule >::success( static_cast< const ParseInput& >( in ), st... );\n+         }\n+         else {\n+            Control< Rule >::failure( static_cast< const ParseInput& >( in ), st... );\n+         }\n+         (void)m( result );\n+         return result;\n+      }\n    }\n \n }  // namespace TAO_PEGTL_NAMESPACE"
      }
    ],
    "lines_added": 114,
    "lines_removed": 273
  },
  "issues": [],
  "pull_requests": [],
  "build_info": {
    "old_build_script": "#!/bin/bash\n#!/bin/bash\ncmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DPEGTL_BUILD_TESTS=ON",
    "new_build_script": "#!/bin/bash\n#!/bin/bash\ncmake -S /test_workspace/workspace/new -B /test_workspace/workspace/new/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DPEGTL_BUILD_TESTS=ON",
    "old_test_script": "#!/bin/bash\ncmake --build /test_workspace/workspace/old/build -- -j 1",
    "new_test_script": "#!/bin/bash\ncmake --build /test_workspace/workspace/new/build -- -j 1",
    "build_system": "cmake"
  },
  "performance_analysis": {
    "is_significant": false,
    "p_value": 0.7549197838296712,
    "is_pair_significant": false,
    "pair_p_value": 0.7395044919078053,
    "is_binom_significant": false,
    "binom_p_value": 0.9998375428840518,
    "is_wilcoxon_significant": false,
    "wilcoxon_p_value": 0.9854535990582314,
    "is_mannwhitney_significant": false,
    "mannwhitney_p_value": 0.13978243466256857,
    "relative_improvement": 0.033502538071066,
    "absolute_improvement_ms": 11.000000000000066,
    "old_mean_ms": 328.33333333333337,
    "new_mean_ms": 317.3333333333333,
    "old_std_ms": 39.920898798994244,
    "new_std_ms": 19.464084224865136,
    "effect_size_cohens_d": 0.350264411848485,
    "old_ci95_ms": [
      313.4266247368899,
      343.24004192977685
    ],
    "new_ci95_ms": [
      310.06532483739215,
      324.6013418292745
    ],
    "old_ci99_ms": [
      308.2433441218958,
      348.42332254477094
    ],
    "new_ci99_ms": [
      307.5381319763462,
      327.1285346903204
    ],
    "new_times_s": [
      0.32,
      0.31,
      0.4,
      0.31,
      0.32,
      0.3,
      0.32,
      0.32,
      0.31,
      0.31,
      0.31,
      0.31,
      0.32,
      0.31,
      0.32,
      0.31,
      0.31,
      0.31,
      0.31,
      0.32,
      0.32,
      0.31,
      0.31,
      0.31,
      0.31,
      0.31,
      0.31,
      0.37,
      0.31,
      0.32,
      0.31
    ],
    "old_times_s": [
      0.32,
      0.3,
      0.32,
      0.3,
      0.43,
      0.31,
      0.31,
      0.31,
      0.32,
      0.32,
      0.31,
      0.3,
      0.31,
      0.48,
      0.31,
      0.31,
      0.33,
      0.31,
      0.32,
      0.32,
      0.32,
      0.38,
      0.31,
      0.31,
      0.38,
      0.32,
      0.35,
      0.31,
      0.31,
      0.32,
      0.32
    ]
  },
  "tests": {
    "total_tests": 2,
    "significant_improvements": 0,
    "significant_improvements_tests": [],
    "significant_regressions": 0,
    "significant_regressions_tests": [],
    "significant_pair_improvements": 0,
    "significant_pair_improvements_tests": [],
    "significant_pair_regressions": 0,
    "significant_pair_regressions_tests": [],
    "significant_binom_improvements": 0,
    "significant_binom_improvements_tests": [],
    "significant_binom_regressions": 0,
    "significant_binom_regressions_tests": [],
    "significant_wilcoxon_improvements": 0,
    "significant_wilcoxon_improvements_tests": [],
    "significant_wilcoxon_regressions": 0,
    "significant_wilcoxon_regressions_tests": [],
    "significant_mannwhitney_improvements": 0,
    "significant_mannwhitney_improvements_tests": [],
    "significant_mannwhitney_regressions": 0,
    "significant_mannwhitney_regressions_tests": [],
    "tests": [
      {
        "test_name": "pegtl-test-ascii_classes",
        "is_significant": false,
        "p_value": 0.3566841104876235,
        "is_pair_significant": false,
        "pair_p_value": 0.3327696037748072,
        "is_binom_significant": false,
        "binom_p_value": 0.9999481420964003,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9827383562773414,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.177306668878067,
        "relative_improvement": 0.081081081081081,
        "absolute_improvement_ms": 1.0344827586206904,
        "old_mean_ms": 12.758620689655174,
        "new_mean_ms": 11.724137931034484,
        "old_std_ms": 4.54858826147342,
        "new_std_ms": 3.8442587221924476,
        "effect_size_cohens_d": 0.24565184222025888,
        "old_ci95_ms": [
          11.028430247285776,
          14.488811132024574
        ],
        "new_ci95_ms": [
          10.261860117175374,
          13.186415744893596
        ],
        "old_ci99_ms": [
          10.424626537493195,
          15.092614841817156
        ],
        "new_ci99_ms": [
          9.751552842823312,
          13.696723019245658
        ],
        "new_times": [
          0.02,
          0.01,
          0.02,
          0.01,
          0.01,
          0.02,
          0.01,
          0.01,
          0.01,
          0.01,
          0.02,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.02,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ],
        "old_times": [
          0.02,
          0.01,
          0.02,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.02,
          0.01,
          0.01,
          0.01,
          0.01,
          0.02,
          0.01,
          0.02,
          0.02,
          0.01,
          0.01,
          0.02,
          0.01,
          0.02,
          0.01,
          0.01,
          0.01,
          0.01
        ]
      },
      {
        "test_name": "pegtl-test-contrib_json",
        "is_significant": false,
        "p_value": 0.36779048152120597,
        "is_pair_significant": false,
        "pair_p_value": 0.3741590898282561,
        "is_binom_significant": false,
        "binom_p_value": 0.9999999441206455,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999432539594574,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.08043002539521898,
        "relative_improvement": 0.06451612903225812,
        "absolute_improvement_ms": 0.6896551724137924,
        "old_mean_ms": 10.689655172413794,
        "new_mean_ms": 10.000000000000002,
        "old_std_ms": 2.578807147775638,
        "new_std_ms": 1.7654289301252243e-15,
        "effect_size_cohens_d": 0.3782057526207832,
        "old_ci95_ms": [
          9.708729394280168,
          11.670580950547421
        ],
        "new_ci95_ms": [
          10.000000000000002,
          10.000000000000002
        ],
        "old_ci99_ms": [
          9.366404867821013,
          12.012905477006576
        ],
        "new_ci99_ms": [
          10.0,
          10.000000000000004
        ],
        "new_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ],
        "old_times": [
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.02,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.02,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01,
          0.01
        ]
      }
    ]
  },
  "logs": {
    "full_log_path": "/logs/full.log",
    "config_log_path": "/logs/config.log",
    "build_log_path": "/logs/build.log",
    "test_log_path": "/logs/test.log",
    "build_success": true,
    "test_success": true
  },
  "raw_timing_data": {
    "warmup_runs": 1,
    "measurement_runs": 30,
    "min_exec_time_improvement": 0.05,
    "min_p_value": 0.05
  }
}