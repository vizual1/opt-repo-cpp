{
  "metadata": {
    "collection_date": "2026-01-11T17:46:46.460085",
    "repository": "https://github.com/Haivision/srt",
    "repository_name": "Haivision/srt"
  },
  "commit_info": {
    "old_sha": "f6492242ee72e3b7a7a786e5c4fae4afe9b2435a",
    "new_sha": "37acb298d8c6be294ea602ecfc50a3c7fee980ba",
    "commit_message": [
      "[core] Shared moving average calc for RCV and SND\nbuffers.\nFixes #1272"
    ],
    "commit_date": "2020-06-15T08:00:43+00:00",
    "patch": [
      "--- srtcore/buffer.cpp\n@@ -63,6 +63,46 @@ using namespace std;\n using namespace srt_logging;\n using namespace srt::sync;\n \n+bool AvgBufSize::isTimeToUpdate(const time_point& now) const\n+{\n+    const int      usMAvgBasePeriod = 1000000; // us\n+    const int      us2ms            = 1000;\n+    const int      msMAvgPeriod     = (usMAvgBasePeriod / SRT_MAVG_SAMPLING_RATE) / us2ms;\n+    const uint64_t elapsed_ms       = count_milliseconds(now - m_tsLastSamplingTime); // ms since last sampling\n+    return (elapsed_ms >= msMAvgPeriod);\n+}\n+\n+void AvgBufSize::update(const steady_clock::time_point& now, int pkts, int bytes, int timespan_ms)\n+{\n+    const uint64_t elapsed_ms = count_milliseconds(now - m_tsLastSamplingTime); // ms since last sampling\n+    m_tsLastSamplingTime      = now;\n+\n+    HLOGC(dlog.Debug,\n+          log << \"AvgBufSize::update: elapsed \" << elapsed_ms << \" ms, \" << pkts << \" pkts \" << bytes\n+              << \" bytes, timespan \" << timespan_ms << \" ms\");\n+\n+    const uint64_t one_second_in_ms = 1000;\n+    if (elapsed_ms > one_second_in_ms)\n+    {\n+        // No sampling in last 1 sec, initialize average\n+        m_iCountMAvg      = pkts;\n+        m_iBytesCountMAvg = bytes;\n+        m_iTimespanMAvg   = timespan_ms;\n+        return;\n+    }\n+\n+    //\n+    // weight last average value between -1 sec and last sampling time (LST)\n+    // and new value between last sampling time and now\n+    //                                      |elapsed_ms|\n+    //   +----------------------------------+-------+\n+    //  -1                                 LST      0(now)\n+    //\n+    m_iCountMAvg      = avg_iir_w<1000>(m_iCountMAvg, pkts, elapsed_ms);\n+    m_iBytesCountMAvg = avg_iir_w<1000>(m_iBytesCountMAvg, bytes, elapsed_ms);\n+    m_iTimespanMAvg   = avg_iir_w<1000>(m_iTimespanMAvg, timespan_ms, elapsed_ms);\n+}\n+\n CSndBuffer::CSndBuffer(int size, int mss)\n     : m_BufLock()\n     , m_pBlock(NULL)\n@@ -75,11 +115,6 @@ CSndBuffer::CSndBuffer(int size, int mss)\n     , m_iMSS(mss)\n     , m_iCount(0)\n     , m_iBytesCount(0)\n-#ifdef SRT_ENABLE_SNDBUFSZ_MAVG\n-    , m_iCountMAvg(0)\n-    , m_iBytesCountMAvg(0)\n-    , m_TimespanMAvg(0)\n-#endif\n     , m_iInRatePktsCount(0)\n     , m_iInRateBytesCount(0)\n     , m_InRatePeriod(INPUTRATE_FAST_START_US) // 0.5 sec (fast start)\n@@ -582,45 +617,20 @@ int CSndBuffer::getAvgBufSize(int& w_bytes, int& w_tsp)\n     /* update stats in case there was no add/ack activity lately */\n     updAvgBufSize(steady_clock::now());\n \n-    w_bytes = m_iBytesCountMAvg;\n-    w_tsp   = m_TimespanMAvg;\n-    return (m_iCountMAvg);\n+    w_bytes = m_mavg.bytes();\n+    w_tsp   = m_mavg.timespan_ms();\n+    return m_mavg.pkts();\n }\n \n void CSndBuffer::updAvgBufSize(const steady_clock::time_point& now)\n {\n-    const uint64_t elapsed_ms = count_milliseconds(now - m_tsLastSamplingTime); // ms since last sampling\n-\n-    if ((1000000 / SRT_MAVG_SAMPLING_RATE) / 1000 > elapsed_ms)\n+    if (!m_mavg.isTimeToUpdate(now))\n         return;\n \n-    if (1000 < elapsed_ms)\n-    {\n-        /* No sampling in last 1 sec, initialize average */\n-        m_iCountMAvg         = getCurrBufSize((m_iBytesCountMAvg), (m_TimespanMAvg));\n-        m_tsLastSamplingTime = now;\n-    }\n-    else //((1000000 / SRT_MAVG_SAMPLING_RATE) / 1000 <= elapsed_ms)\n-    {\n-        /*\n-         * weight last average value between -1 sec and last sampling time (LST)\n-         * and new value between last sampling time and now\n-         *                                      |elapsed_ms|\n-         *   +----------------------------------+-------+\n-         *  -1                                 LST      0(now)\n-         */\n-        int instspan;\n-        int bytescount;\n-        int count = getCurrBufSize((bytescount), (instspan));\n-\n-        HLOGC(dlog.Debug,\n-              log << \"updAvgBufSize: \" << elapsed_ms << \": \" << count << \" \" << bytescount << \" \" << instspan << \"ms\");\n-\n-        m_iCountMAvg         = (int)(((count * (1000 - elapsed_ms)) + (count * elapsed_ms)) / 1000);\n-        m_iBytesCountMAvg    = (int)(((bytescount * (1000 - elapsed_ms)) + (bytescount * elapsed_ms)) / 1000);\n-        m_TimespanMAvg       = (int)(((instspan * (1000 - elapsed_ms)) + (instspan * elapsed_ms)) / 1000);\n-        m_tsLastSamplingTime = now;\n-    }\n+    int       bytes       = 0;\n+    int       timespan_ms = 0;\n+    const int pkts        = getCurrBufSize((bytes), (timespan_ms));\n+    m_mavg.update(now, pkts, bytes, timespan_ms);\n }\n \n #endif /* SRT_ENABLE_SNDBUFSZ_MAVG */\n@@ -790,11 +800,6 @@ CRcvBuffer::CRcvBuffer(CUnitQueue* queue, int bufsize_pkts)\n     , m_bTsbPdMode(false)\n     , m_tdTsbPdDelay(0)\n     , m_bTsbPdWrapCheck(false)\n-#ifdef SRT_ENABLE_RCVBUFSZ_MAVG\n-    , m_TimespanMAvg(0)\n-    , m_iCountMAvg(0)\n-    , m_iBytesCountMAvg(0)\n-#endif\n {\n     m_pUnit = new CUnit*[m_iSize];\n     for (int i = 0; i < m_iSize; ++i)\n@@ -1572,68 +1577,24 @@ int CRcvBuffer::debugGetSize() const\n }\n \n #ifdef SRT_ENABLE_RCVBUFSZ_MAVG\n-\n-#define SRT_MAVG_BASE_PERIOD 1000000 // us\n-#define SRT_us2ms 1000\n-\n /* Return moving average of acked data pkts, bytes, and timespan (ms) of the receive buffer */\n int CRcvBuffer::getRcvAvgDataSize(int& bytes, int& timespan)\n {\n-    timespan = m_TimespanMAvg;\n-    bytes    = m_iBytesCountMAvg;\n-    return (m_iCountMAvg);\n+    timespan = m_mavg.timespan_ms();\n+    bytes    = m_mavg.bytes();\n+    return m_mavg.pkts();\n }\n \n /* Update moving average of acked data pkts, bytes, and timespan (ms) of the receive buffer */\n void CRcvBuffer::updRcvAvgDataSize(const steady_clock::time_point& now)\n {\n-    const uint64_t elapsed_ms = count_milliseconds(now - m_tsLastSamplingTime); // ms since last sampling\n-\n-    if (elapsed_ms < (SRT_MAVG_BASE_PERIOD / SRT_MAVG_SAMPLING_RATE) / SRT_us2ms)\n-        return; /* Last sampling too recent, skip */\n-\n-    if (elapsed_ms > SRT_MAVG_BASE_PERIOD / SRT_us2ms)\n-    {\n-        /* No sampling in last 1 sec, initialize/reset moving average */\n-        m_iCountMAvg         = getRcvDataSize(m_iBytesCountMAvg, m_TimespanMAvg);\n-        m_tsLastSamplingTime = now;\n-\n-        HLOGC(dlog.Debug,\n-              log << \"getRcvDataSize: \" << m_iCountMAvg << \" \" << m_iBytesCountMAvg << \" \" << m_TimespanMAvg\n-                  << \" ms elapsed: \" << elapsed_ms << \" ms\");\n-    }\n-    else if (elapsed_ms >= (SRT_MAVG_BASE_PERIOD / SRT_MAVG_SAMPLING_RATE) / SRT_us2ms)\n-    {\n-        int       instspan;\n-        int       bytescount;\n-        const int count = getRcvDataSize(bytescount, instspan);\n-\n-        if (m_iCountMAvg == 0)\n-        {\n-            // This is the first call, so just take the new value\n-            m_iCountMAvg      = count;\n-            m_iBytesCountMAvg = bytescount;\n-            m_TimespanMAvg    = instspan;\n-        }\n-        else\n-        {\n-            /*\n-             * Weight last average value between -1 sec from now and last sampling time (LST)\n-             * and new value between last sampling time and now\n-             *                                      |elapsed|\n-             *   +----------------------------------+-------+\n-             *  -1 sec                             LST      0(now)\n-             */\n-            m_iCountMAvg      = avg_iir_w<1000>(m_iCountMAvg, count, elapsed_ms);\n-            m_iBytesCountMAvg = avg_iir_w<1000>(m_iBytesCountMAvg, bytescount, elapsed_ms);\n-            m_TimespanMAvg    = avg_iir_w<1000>(m_TimespanMAvg, instspan, elapsed_ms);\n-        }\n-        m_tsLastSamplingTime = now;\n+    if (!m_mavg.isTimeToUpdate(now))\n+        return;\n \n-        HLOGC(dlog.Debug,\n-              log << \"getRcvDataSize: \" << count << \" \" << bytescount << \" \" << instspan\n-                  << \" ms elapsed_ms: \" << elapsed_ms << \" ms\");\n-    }\n+    int       bytes       = 0;\n+    int       timespan_ms = 0;\n+    const int pkts        = getRcvDataSize(bytes, timespan_ms);\n+    m_mavg.update(now, pkts, bytes, timespan_ms);\n }\n #endif /* SRT_ENABLE_RCVBUFSZ_MAVG */\n \n--- srtcore/buffer.h\n@@ -72,6 +72,37 @@ modified by\n // a +% b : shift a by b\n // a == b : equality is same as for just numbers\n \n+#if defined(SRT_ENABLE_SNDBUFSZ_MAVG) || defined(SRT_ENABLE_RCVBUFSZ_MAVG)\n+/// The AvgBufSize class is used to calculate moving average of the buffer (RCV or SND)\n+class AvgBufSize\n+{\n+    typedef srt::sync::steady_clock::time_point time_point;\n+\n+public:\n+    AvgBufSize()\n+        : m_iBytesCountMAvg(0)\n+        , m_iCountMAvg(0)\n+        , m_iTimespanMAvg(0)\n+    {\n+    }\n+\n+public:\n+    bool isTimeToUpdate(const time_point& now) const;\n+    void update(const time_point& now, int pkts, int bytes, int timespan_ms);\n+\n+public:\n+    inline int pkts() const { return m_iCountMAvg; }\n+    inline int timespan_ms() const { return m_iTimespanMAvg; }\n+    inline int bytes() const { return m_iBytesCountMAvg; }\n+\n+private:\n+    time_point m_tsLastSamplingTime;\n+    int        m_iBytesCountMAvg;\n+    int        m_iCountMAvg;\n+    int        m_iTimespanMAvg;\n+};\n+#endif // SRT_ENABLE_SNDBUFSZ_MAVG || SRT_ENABLE_RCVBUFSZ_MAVG\n+\n \n class CSndBuffer\n {\n@@ -232,10 +263,7 @@ class CSndBuffer\n    srt::sync::steady_clock::time_point m_tsLastOriginTime;\n \n #ifdef SRT_ENABLE_SNDBUFSZ_MAVG\n-   srt::sync::steady_clock::time_point m_tsLastSamplingTime;\n-   int m_iCountMAvg;\n-   int m_iBytesCountMAvg;\n-   int m_TimespanMAvg;\n+   AvgBufSize m_mavg;\n #endif /* SRT_ENABLE_SNDBUFSZ_MAVG */\n \n    int m_iInRatePktsCount;  // number of payload bytes added since InRateStartTime\n@@ -585,10 +613,7 @@ class CRcvBuffer\n    static const int TSBPD_DRIFT_MAX_SAMPLES = 1000;\n    DriftTracer<TSBPD_DRIFT_MAX_SAMPLES, TSBPD_DRIFT_MAX_VALUE> m_DriftTracer;\n #ifdef SRT_ENABLE_RCVBUFSZ_MAVG\n-   time_point m_tsLastSamplingTime;\n-   int m_TimespanMAvg;\n-   int m_iCountMAvg;\n-   int m_iBytesCountMAvg;\n+   AvgBufSize m_mavg;\n #endif /* SRT_ENABLE_RCVBUFSZ_MAVG */\n #ifdef SRT_DEBUG_TSBPD_DRIFT\n    int m_TsbPdDriftHisto100us[22];              // Histogram of 100us TsbPD drift (-1.0 .. +1.0 ms in 0.1ms increment)"
    ],
    "files_changed": [
      {
        "filename": "srtcore/buffer.cpp",
        "status": "modified",
        "additions": 57,
        "deletions": 96,
        "changes": 153,
        "patch": "@@ -63,6 +63,46 @@ using namespace std;\n using namespace srt_logging;\n using namespace srt::sync;\n \n+bool AvgBufSize::isTimeToUpdate(const time_point& now) const\n+{\n+    const int      usMAvgBasePeriod = 1000000; // us\n+    const int      us2ms            = 1000;\n+    const int      msMAvgPeriod     = (usMAvgBasePeriod / SRT_MAVG_SAMPLING_RATE) / us2ms;\n+    const uint64_t elapsed_ms       = count_milliseconds(now - m_tsLastSamplingTime); // ms since last sampling\n+    return (elapsed_ms >= msMAvgPeriod);\n+}\n+\n+void AvgBufSize::update(const steady_clock::time_point& now, int pkts, int bytes, int timespan_ms)\n+{\n+    const uint64_t elapsed_ms = count_milliseconds(now - m_tsLastSamplingTime); // ms since last sampling\n+    m_tsLastSamplingTime      = now;\n+\n+    HLOGC(dlog.Debug,\n+          log << \"AvgBufSize::update: elapsed \" << elapsed_ms << \" ms, \" << pkts << \" pkts \" << bytes\n+              << \" bytes, timespan \" << timespan_ms << \" ms\");\n+\n+    const uint64_t one_second_in_ms = 1000;\n+    if (elapsed_ms > one_second_in_ms)\n+    {\n+        // No sampling in last 1 sec, initialize average\n+        m_iCountMAvg      = pkts;\n+        m_iBytesCountMAvg = bytes;\n+        m_iTimespanMAvg   = timespan_ms;\n+        return;\n+    }\n+\n+    //\n+    // weight last average value between -1 sec and last sampling time (LST)\n+    // and new value between last sampling time and now\n+    //                                      |elapsed_ms|\n+    //   +----------------------------------+-------+\n+    //  -1                                 LST      0(now)\n+    //\n+    m_iCountMAvg      = avg_iir_w<1000>(m_iCountMAvg, pkts, elapsed_ms);\n+    m_iBytesCountMAvg = avg_iir_w<1000>(m_iBytesCountMAvg, bytes, elapsed_ms);\n+    m_iTimespanMAvg   = avg_iir_w<1000>(m_iTimespanMAvg, timespan_ms, elapsed_ms);\n+}\n+\n CSndBuffer::CSndBuffer(int size, int mss)\n     : m_BufLock()\n     , m_pBlock(NULL)\n@@ -75,11 +115,6 @@ CSndBuffer::CSndBuffer(int size, int mss)\n     , m_iMSS(mss)\n     , m_iCount(0)\n     , m_iBytesCount(0)\n-#ifdef SRT_ENABLE_SNDBUFSZ_MAVG\n-    , m_iCountMAvg(0)\n-    , m_iBytesCountMAvg(0)\n-    , m_TimespanMAvg(0)\n-#endif\n     , m_iInRatePktsCount(0)\n     , m_iInRateBytesCount(0)\n     , m_InRatePeriod(INPUTRATE_FAST_START_US) // 0.5 sec (fast start)\n@@ -582,45 +617,20 @@ int CSndBuffer::getAvgBufSize(int& w_bytes, int& w_tsp)\n     /* update stats in case there was no add/ack activity lately */\n     updAvgBufSize(steady_clock::now());\n \n-    w_bytes = m_iBytesCountMAvg;\n-    w_tsp   = m_TimespanMAvg;\n-    return (m_iCountMAvg);\n+    w_bytes = m_mavg.bytes();\n+    w_tsp   = m_mavg.timespan_ms();\n+    return m_mavg.pkts();\n }\n \n void CSndBuffer::updAvgBufSize(const steady_clock::time_point& now)\n {\n-    const uint64_t elapsed_ms = count_milliseconds(now - m_tsLastSamplingTime); // ms since last sampling\n-\n-    if ((1000000 / SRT_MAVG_SAMPLING_RATE) / 1000 > elapsed_ms)\n+    if (!m_mavg.isTimeToUpdate(now))\n         return;\n \n-    if (1000 < elapsed_ms)\n-    {\n-        /* No sampling in last 1 sec, initialize average */\n-        m_iCountMAvg         = getCurrBufSize((m_iBytesCountMAvg), (m_TimespanMAvg));\n-        m_tsLastSamplingTime = now;\n-    }\n-    else //((1000000 / SRT_MAVG_SAMPLING_RATE) / 1000 <= elapsed_ms)\n-    {\n-        /*\n-         * weight last average value between -1 sec and last sampling time (LST)\n-         * and new value between last sampling time and now\n-         *                                      |elapsed_ms|\n-         *   +----------------------------------+-------+\n-         *  -1                                 LST      0(now)\n-         */\n-        int instspan;\n-        int bytescount;\n-        int count = getCurrBufSize((bytescount), (instspan));\n-\n-        HLOGC(dlog.Debug,\n-              log << \"updAvgBufSize: \" << elapsed_ms << \": \" << count << \" \" << bytescount << \" \" << instspan << \"ms\");\n-\n-        m_iCountMAvg         = (int)(((count * (1000 - elapsed_ms)) + (count * elapsed_ms)) / 1000);\n-        m_iBytesCountMAvg    = (int)(((bytescount * (1000 - elapsed_ms)) + (bytescount * elapsed_ms)) / 1000);\n-        m_TimespanMAvg       = (int)(((instspan * (1000 - elapsed_ms)) + (instspan * elapsed_ms)) / 1000);\n-        m_tsLastSamplingTime = now;\n-    }\n+    int       bytes       = 0;\n+    int       timespan_ms = 0;\n+    const int pkts        = getCurrBufSize((bytes), (timespan_ms));\n+    m_mavg.update(now, pkts, bytes, timespan_ms);\n }\n \n #endif /* SRT_ENABLE_SNDBUFSZ_MAVG */\n@@ -790,11 +800,6 @@ CRcvBuffer::CRcvBuffer(CUnitQueue* queue, int bufsize_pkts)\n     , m_bTsbPdMode(false)\n     , m_tdTsbPdDelay(0)\n     , m_bTsbPdWrapCheck(false)\n-#ifdef SRT_ENABLE_RCVBUFSZ_MAVG\n-    , m_TimespanMAvg(0)\n-    , m_iCountMAvg(0)\n-    , m_iBytesCountMAvg(0)\n-#endif\n {\n     m_pUnit = new CUnit*[m_iSize];\n     for (int i = 0; i < m_iSize; ++i)\n@@ -1572,68 +1577,24 @@ int CRcvBuffer::debugGetSize() const\n }\n \n #ifdef SRT_ENABLE_RCVBUFSZ_MAVG\n-\n-#define SRT_MAVG_BASE_PERIOD 1000000 // us\n-#define SRT_us2ms 1000\n-\n /* Return moving average of acked data pkts, bytes, and timespan (ms) of the receive buffer */\n int CRcvBuffer::getRcvAvgDataSize(int& bytes, int& timespan)\n {\n-    timespan = m_TimespanMAvg;\n-    bytes    = m_iBytesCountMAvg;\n-    return (m_iCountMAvg);\n+    timespan = m_mavg.timespan_ms();\n+    bytes    = m_mavg.bytes();\n+    return m_mavg.pkts();\n }\n \n /* Update moving average of acked data pkts, bytes, and timespan (ms) of the receive buffer */\n void CRcvBuffer::updRcvAvgDataSize(const steady_clock::time_point& now)\n {\n-    const uint64_t elapsed_ms = count_milliseconds(now - m_tsLastSamplingTime); // ms since last sampling\n-\n-    if (elapsed_ms < (SRT_MAVG_BASE_PERIOD / SRT_MAVG_SAMPLING_RATE) / SRT_us2ms)\n-        return; /* Last sampling too recent, skip */\n-\n-    if (elapsed_ms > SRT_MAVG_BASE_PERIOD / SRT_us2ms)\n-    {\n-        /* No sampling in last 1 sec, initialize/reset moving average */\n-        m_iCountMAvg         = getRcvDataSize(m_iBytesCountMAvg, m_TimespanMAvg);\n-        m_tsLastSamplingTime = now;\n-\n-        HLOGC(dlog.Debug,\n-              log << \"getRcvDataSize: \" << m_iCountMAvg << \" \" << m_iBytesCountMAvg << \" \" << m_TimespanMAvg\n-                  << \" ms elapsed: \" << elapsed_ms << \" ms\");\n-    }\n-    else if (elapsed_ms >= (SRT_MAVG_BASE_PERIOD / SRT_MAVG_SAMPLING_RATE) / SRT_us2ms)\n-    {\n-        int       instspan;\n-        int       bytescount;\n-        const int count = getRcvDataSize(bytescount, instspan);\n-\n-        if (m_iCountMAvg == 0)\n-        {\n-            // This is the first call, so just take the new value\n-            m_iCountMAvg      = count;\n-            m_iBytesCountMAvg = bytescount;\n-            m_TimespanMAvg    = instspan;\n-        }\n-        else\n-        {\n-            /*\n-             * Weight last average value between -1 sec from now and last sampling time (LST)\n-             * and new value between last sampling time and now\n-             *                                      |elapsed|\n-             *   +----------------------------------+-------+\n-             *  -1 sec                             LST      0(now)\n-             */\n-            m_iCountMAvg      = avg_iir_w<1000>(m_iCountMAvg, count, elapsed_ms);\n-            m_iBytesCountMAvg = avg_iir_w<1000>(m_iBytesCountMAvg, bytescount, elapsed_ms);\n-            m_TimespanMAvg    = avg_iir_w<1000>(m_TimespanMAvg, instspan, elapsed_ms);\n-        }\n-        m_tsLastSamplingTime = now;\n+    if (!m_mavg.isTimeToUpdate(now))\n+        return;\n \n-        HLOGC(dlog.Debug,\n-              log << \"getRcvDataSize: \" << count << \" \" << bytescount << \" \" << instspan\n-                  << \" ms elapsed_ms: \" << elapsed_ms << \" ms\");\n-    }\n+    int       bytes       = 0;\n+    int       timespan_ms = 0;\n+    const int pkts        = getRcvDataSize(bytes, timespan_ms);\n+    m_mavg.update(now, pkts, bytes, timespan_ms);\n }\n #endif /* SRT_ENABLE_RCVBUFSZ_MAVG */\n "
      },
      {
        "filename": "srtcore/buffer.h",
        "status": "modified",
        "additions": 33,
        "deletions": 8,
        "changes": 41,
        "patch": "@@ -72,6 +72,37 @@ modified by\n // a +% b : shift a by b\n // a == b : equality is same as for just numbers\n \n+#if defined(SRT_ENABLE_SNDBUFSZ_MAVG) || defined(SRT_ENABLE_RCVBUFSZ_MAVG)\n+/// The AvgBufSize class is used to calculate moving average of the buffer (RCV or SND)\n+class AvgBufSize\n+{\n+    typedef srt::sync::steady_clock::time_point time_point;\n+\n+public:\n+    AvgBufSize()\n+        : m_iBytesCountMAvg(0)\n+        , m_iCountMAvg(0)\n+        , m_iTimespanMAvg(0)\n+    {\n+    }\n+\n+public:\n+    bool isTimeToUpdate(const time_point& now) const;\n+    void update(const time_point& now, int pkts, int bytes, int timespan_ms);\n+\n+public:\n+    inline int pkts() const { return m_iCountMAvg; }\n+    inline int timespan_ms() const { return m_iTimespanMAvg; }\n+    inline int bytes() const { return m_iBytesCountMAvg; }\n+\n+private:\n+    time_point m_tsLastSamplingTime;\n+    int        m_iBytesCountMAvg;\n+    int        m_iCountMAvg;\n+    int        m_iTimespanMAvg;\n+};\n+#endif // SRT_ENABLE_SNDBUFSZ_MAVG || SRT_ENABLE_RCVBUFSZ_MAVG\n+\n \n class CSndBuffer\n {\n@@ -232,10 +263,7 @@ class CSndBuffer\n    srt::sync::steady_clock::time_point m_tsLastOriginTime;\n \n #ifdef SRT_ENABLE_SNDBUFSZ_MAVG\n-   srt::sync::steady_clock::time_point m_tsLastSamplingTime;\n-   int m_iCountMAvg;\n-   int m_iBytesCountMAvg;\n-   int m_TimespanMAvg;\n+   AvgBufSize m_mavg;\n #endif /* SRT_ENABLE_SNDBUFSZ_MAVG */\n \n    int m_iInRatePktsCount;  // number of payload bytes added since InRateStartTime\n@@ -585,10 +613,7 @@ class CRcvBuffer\n    static const int TSBPD_DRIFT_MAX_SAMPLES = 1000;\n    DriftTracer<TSBPD_DRIFT_MAX_SAMPLES, TSBPD_DRIFT_MAX_VALUE> m_DriftTracer;\n #ifdef SRT_ENABLE_RCVBUFSZ_MAVG\n-   time_point m_tsLastSamplingTime;\n-   int m_TimespanMAvg;\n-   int m_iCountMAvg;\n-   int m_iBytesCountMAvg;\n+   AvgBufSize m_mavg;\n #endif /* SRT_ENABLE_RCVBUFSZ_MAVG */\n #ifdef SRT_DEBUG_TSBPD_DRIFT\n    int m_TsbPdDriftHisto100us[22];              // Histogram of 100us TsbPD drift (-1.0 .. +1.0 ms in 0.1ms increment)"
      }
    ],
    "lines_added": 90,
    "lines_removed": 104
  },
  "issues": [
    {
      "number": 1272,
      "url": "https://github.com/Haivision/srt/issues/1272",
      "title": "[BUG] Statistics always return instantaneous value for send and recv buffers",
      "body": "Calling srt_bstats or srt_bistats with instantaneous equal to 0 return instantaneous values for msRcvBuf and msSndBuf rather than moving averages as documented by statistics.md\r\n\r\nA moving average value is reported when the value is retrieved by calling `srt_bstats(...)` or `srt_bistats(SRTSOCKET u, SRT_TRACEBSTATS * perf, int clear, int instantaneous)` with instantaneous=false`.\r\n\r\nWhen calculating a moving average, it should be calculated using previous average value and a new sample.  The code in buffer.cpp does calculation of average using only the new sample so it is a instantaneous measurement rather than an average.",
      "created_at": "2020-05-07T17:32:53+00:00"
    }
  ],
  "pull_requests": [],
  "build_info": {
    "old_build_script": "#!/bin/bash\n#!/bin/bash\ncmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DENABLE_UNITTESTS=ON -DENABLE_TESTING=ON",
    "new_build_script": "#!/bin/bash\n#!/bin/bash\ncmake -S /test_workspace/workspace/new -B /test_workspace/workspace/new/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DENABLE_UNITTESTS=ON -DENABLE_TESTING=ON",
    "old_test_script": "#!/bin/bash\ncmake --build /test_workspace/workspace/old/build -- -j 1",
    "new_test_script": "#!/bin/bash\ncmake --build /test_workspace/workspace/new/build -- -j 1",
    "build_system": "cmake"
  },
  "performance_analysis": {
    "is_significant": false,
    "p_value": 1.0,
    "is_pair_significant": false,
    "pair_p_value": 0.9999999999985503,
    "is_binom_significant": false,
    "binom_p_value": 1.0,
    "is_wilcoxon_significant": false,
    "wilcoxon_p_value": 0.9999991333466779,
    "is_mannwhitney_significant": false,
    "mannwhitney_p_value": 0.8125677923522011,
    "relative_improvement": -0.0037866619941789564,
    "absolute_improvement_ms": -129.66666666665105,
    "old_mean_ms": 34243.00000000001,
    "new_mean_ms": 34372.66666666666,
    "old_std_ms": 511.55038178408927,
    "new_std_ms": 548.1312033555054,
    "effect_size_cohens_d": -0.2445819149929859,
    "old_ci95_ms": [
      34051.98394818088,
      34434.01605181913
    ],
    "new_ci95_ms": [
      34167.99111158511,
      34577.34222174821
    ],
    "old_ci99_ms": [
      33985.56487302817,
      34500.43512697185
    ],
    "new_ci99_ms": [
      34096.82242735455,
      34648.51090597877
    ],
    "new_times_s": [
      34.16,
      33.93,
      34.2,
      33.92,
      35.09,
      34.59,
      34.3,
      34.41,
      34.28,
      34.31,
      34.62,
      33.66,
      34.99,
      34.08,
      34.55,
      33.78,
      34.47,
      33.76,
      34.37,
      34.32,
      34.34,
      34.12,
      33.85,
      33.92,
      33.51,
      34.69,
      35.88,
      34.39,
      34.8,
      35.8,
      34.25
    ],
    "old_times_s": [
      34.95,
      35.23,
      34.16,
      34.42,
      33.73,
      34.2,
      33.57,
      33.98,
      33.67,
      33.66,
      35.19,
      34.44,
      33.92,
      33.92,
      34.8,
      35.19,
      34.03,
      34.25,
      34.29,
      33.92,
      34.5,
      34.66,
      34.69,
      34.17,
      34.83,
      33.29,
      34.03,
      34.19,
      34.86,
      33.7,
      33.8
    ]
  },
  "tests": {
    "total_tests": 1,
    "significant_improvements": 0,
    "significant_improvements_tests": [],
    "significant_regressions": 0,
    "significant_regressions_tests": [],
    "significant_pair_improvements": 0,
    "significant_pair_improvements_tests": [],
    "significant_pair_regressions": 0,
    "significant_pair_regressions_tests": [],
    "significant_binom_improvements": 0,
    "significant_binom_improvements_tests": [],
    "significant_binom_regressions": 0,
    "significant_binom_regressions_tests": [],
    "significant_wilcoxon_improvements": 0,
    "significant_wilcoxon_improvements_tests": [],
    "significant_wilcoxon_regressions": 0,
    "significant_wilcoxon_regressions_tests": [],
    "significant_mannwhitney_improvements": 0,
    "significant_mannwhitney_improvements_tests": [],
    "significant_mannwhitney_regressions": 0,
    "significant_mannwhitney_regressions_tests": [],
    "tests": [
      {
        "test_name": "test-srt",
        "is_significant": false,
        "p_value": 1.0,
        "is_pair_significant": false,
        "pair_p_value": 0.9999999999990938,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 1.0,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.8890178784489025,
        "relative_improvement": -0.005242146860760445,
        "absolute_improvement_ms": -179.31034482758434,
        "old_mean_ms": 34205.517241379304,
        "new_mean_ms": 34384.82758620689,
        "old_std_ms": 484.7723044813082,
        "new_std_ms": 551.5019795953024,
        "effect_size_cohens_d": -0.34535207262930706,
        "old_ci95_ms": [
          34021.11971851641,
          34389.914764242196
        ],
        "new_ci95_ms": [
          34175.04745241775,
          34594.60771999603
        ],
        "old_ci99_ms": [
          33956.76847390503,
          34454.26600885358
        ],
        "new_ci99_ms": [
          34101.83815711659,
          34667.81701529719
        ],
        "new_times": [
          34.2,
          33.92,
          35.09,
          34.59,
          34.29,
          34.4,
          34.28,
          34.3,
          34.61,
          33.66,
          34.99,
          34.08,
          34.54,
          33.77,
          34.47,
          33.75,
          34.37,
          34.32,
          34.34,
          34.12,
          33.85,
          33.92,
          33.51,
          34.68,
          35.88,
          34.39,
          34.79,
          35.8,
          34.25
        ],
        "old_times": [
          34.16,
          34.42,
          33.73,
          34.2,
          33.56,
          33.97,
          33.66,
          33.66,
          35.18,
          34.44,
          33.92,
          33.92,
          34.8,
          35.19,
          34.03,
          34.24,
          34.28,
          33.92,
          34.5,
          34.65,
          34.68,
          34.16,
          34.83,
          33.29,
          34.03,
          34.19,
          34.86,
          33.69,
          33.8
        ]
      }
    ]
  },
  "logs": {
    "full_log_path": "/logs/full.log",
    "config_log_path": "/logs/config.log",
    "build_log_path": "/logs/build.log",
    "test_log_path": "/logs/test.log",
    "build_success": true,
    "test_success": true
  },
  "raw_timing_data": {
    "warmup_runs": 1,
    "measurement_runs": 30,
    "min_exec_time_improvement": 0.05,
    "min_p_value": 0.05
  }
}