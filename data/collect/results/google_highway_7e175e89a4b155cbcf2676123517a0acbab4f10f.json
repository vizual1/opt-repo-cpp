{
  "metadata": {
    "collection_date": "2026-01-11T17:46:12.804310",
    "repository": "https://github.com/google/highway",
    "repository_name": "google/highway"
  },
  "commit_info": {
    "old_sha": "7e175e89a4b155cbcf2676123517a0acbab4f10f",
    "new_sha": "7e175e89a4b155cbcf2676123517a0acbab4f10f",
    "commit_message": [
      "1.3-1.5x sort speedup for some low-entropy columns: avoid redundant ScanEqual\n\nPiperOrigin-RevId: 468667943"
    ],
    "commit_date": "2022-08-19T10:55:18+00:00",
    "patch": [
      "--- hwy/contrib/sort/traits128-inl.h\n@@ -130,8 +130,8 @@ struct Key128 : public KeyAny128 {\n   std::string KeyString() const { return \"U128\"; }\n \n   template <class D>\n-  HWY_INLINE Mask<D> EqualKeys(D /*tag*/, Vec<D> a, Vec<D> b) const {\n-    return Eq128(a, b);\n+  HWY_INLINE Mask<D> EqualKeys(D d, Vec<D> a, Vec<D> b) const {\n+    return Eq128(d, a, b);\n   }\n \n   HWY_INLINE bool Equal1(const LaneType* a, const LaneType* b) {\n@@ -234,8 +234,8 @@ struct KeyValue128 : public KeyAny128 {\n   std::string KeyString() const { return \"KV128\"; }\n \n   template <class D>\n-  HWY_INLINE Mask<D> EqualKeys(D /*tag*/, Vec<D> a, Vec<D> b) const {\n-    return Eq128Upper(a, b);\n+  HWY_INLINE Mask<D> EqualKeys(D d, Vec<D> a, Vec<D> b) const {\n+    return Eq128Upper(d, a, b);\n   }\n \n   HWY_INLINE bool Equal1(const LaneType* a, const LaneType* b) {\n--- hwy/contrib/sort/vqsort-inl.h\n@@ -584,8 +584,8 @@ V OrXor(const V o, const V x1, const V x2) {\n // are equal. `num` is const to ensure we don't change it, which would lead to\n // bugs because the caller will check whether we return the original value.\n template <class D, class Traits, typename T>\n-HWY_INLINE size_t ScanEqual(D d, Traits st, const T* HWY_RESTRICT keys,\n-                            const size_t num) {\n+HWY_NOINLINE size_t ScanEqual(D d, Traits st, const T* HWY_RESTRICT keys,\n+                              const size_t num) {\n   using V = Vec<decltype(d)>;\n   const size_t N = Lanes(d);\n   HWY_DASSERT(num >= N);  // See HandleSpecialCases\n@@ -654,20 +654,20 @@ HWY_INLINE size_t ScanEqual(D d, Traits st, const T* HWY_RESTRICT keys,\n   return num;  // all equal\n }\n \n-// Returns key prior to reference in sort order. Starts scanning at index\n-// `start`, which is less than `num`.\n+// Returns false if `reference` is already the first key in sort order.\n+// Otherwise, sets `prev_out` to the key prior to `reference` in sort order.\n+// Starts scanning before index `start`, which is less than `num`.\n template <class D, class Traits, typename T>\n-HWY_INLINE Vec<D> ScanForPrev(D d, Traits st, const T* HWY_RESTRICT keys,\n+HWY_NOINLINE bool ScanForPrev(D d, Traits st, const T* HWY_RESTRICT keys,\n                               size_t num, size_t start, Vec<D> reference,\n+                              Vec<D>* HWY_RESTRICT prev_out,\n                               T* HWY_RESTRICT buf) {\n   const size_t N = Lanes(d);\n   HWY_DASSERT(num >= N);  // See HandleSpecialCases\n   HWY_DASSERT(start < num);\n \n-  Vec<D> prev = st.FirstValue(d);\n-  // We want to reduce a mask but that is currently only supported for vectors,\n-  // so use a vector as a sticky accumulator of mask results.\n-  Vec<D> found_any_lanes = Zero(d);\n+  const Vec<D> first = st.FirstValue(d);\n+  Vec<D> prev = first;\n \n   // The value before the first difference might be the desired prev (if it is\n   // equal to the reference in ScanEqual), so start one vector before.\n@@ -676,32 +676,31 @@ HWY_INLINE Vec<D> ScanForPrev(D d, Traits st, const T* HWY_RESTRICT keys,\n   // Whole vectors, no unrolling\n   for (; i + N <= num; i += N) {\n     const Vec<D> curr = LoadU(d, keys + i);\n-    const Vec<D> is_before = VecFromMask(d, st.Compare(d, curr, reference));\n-    found_any_lanes = Or(found_any_lanes, is_before);\n-    prev = IfVecThenElse(is_before, st.Last(d, prev, curr), prev);\n+    const Mask<D> is_before = st.Compare(d, curr, reference);\n+    prev = IfThenElse(is_before, st.Last(d, prev, curr), prev);\n   }\n   // If there are remainders, re-check the last whole vector.\n   if (HWY_LIKELY(i != num)) {\n     const Vec<D> curr = LoadU(d, keys + num - N);\n-    const Vec<D> is_before = VecFromMask(d, st.Compare(d, curr, reference));\n-    found_any_lanes = Or(found_any_lanes, is_before);\n-    prev = IfVecThenElse(is_before, st.Last(d, prev, curr), prev);\n-  }\n-\n-  const Vec<D> candidate = st.LastOfLanes(d, prev, buf);\n-  // If we didn't find any key less than reference, we're still stuck with\n-  // FirstValue; replace that with reference. (We cannot compare directly to\n-  // FirstValue because that might be the desired value of prev.) The min\n-  // reduction of a signed integer is -1 (true) everywhere if any lane is -1.\n-  const RebindToSigned<D> di;\n-  const Vec<D> found_any =\n-      BitCast(d, MinOfLanes(di, BitCast(di, found_any_lanes)));\n-  return IfVecThenElse(found_any, candidate, reference);\n+    const Mask<D> is_before = st.Compare(d, curr, reference);\n+    prev = IfThenElse(is_before, st.Last(d, prev, curr), prev);\n+  }\n+\n+  prev = st.LastOfLanes(d, prev, buf);\n+  // If prev has not changed, then no `curr` came before `reference`, hence\n+  // `reference` is the first (perhaps even the first possible, i.e. `first`).\n+  if (AllTrue(d, st.EqualKeys(d, prev, first))) {\n+    *prev_out = reference;\n+    return false;\n+  }\n+  *prev_out = prev;\n+  return true;\n }\n \n enum class PivotResult {\n   kNormal,    // use partition\n   kAllEqual,  // already done\n+  kIsFirst,   // can skip left recursion\n };\n \n // Writes samples from `keys[0, num)` into `buf`.\n@@ -812,12 +811,16 @@ HWY_NOINLINE Vec<D> ChoosePivot(D d, Traits st, T* HWY_RESTRICT keys,\n     // with the previous key in sort order. By contrast, selecting the first key\n     // in sort order would guarantee (minimal) progress. We instead do a full\n     // scan to maximize load balance in case there are numerous keys that\n-    // precede the most common key.\n-    result = PivotResult::kNormal;\n+    // precede the most common key. This also tells us whether the pivot is the\n+    // first in sort order; if so, we can skip the left recursion.\n     const V reference = st.SetKey(d, buf);\n-    const V pivot = ScanForPrev(d, st, keys, num, idx_diff, reference, buf);\n+    V pivot;\n+    result = ScanForPrev(d, st, keys, num, idx_diff, reference, &pivot, buf)\n+                 ? PivotResult::kNormal\n+                 : PivotResult::kIsFirst;\n #if VQSORT_PRINT\n     Print(d, \"Using PREV as pivot\", pivot, 0, st.LanesPerKey());\n+    fprintf(stderr, \"IsMin %d\\n\", result == PivotResult::kIsFirst);\n #endif\n     return pivot;\n   }\n@@ -856,7 +859,7 @@ HWY_NOINLINE void Recurse(D d, Traits st, T* HWY_RESTRICT keys,\n   }\n   PivotResult result;\n   Vec<D> pivot = ChoosePivot(d, st, keys + begin, num, buf, rng, result);\n-  if (result == PivotResult::kAllEqual) {\n+  if (HWY_UNLIKELY(result == PivotResult::kAllEqual)) {\n     return;\n   }\n \n@@ -874,7 +877,10 @@ HWY_NOINLINE void Recurse(D d, Traits st, T* HWY_RESTRICT keys,\n   // ChoosePivot ensures pivot != largest key, so the right partition is never\n   // empty; nor is the left, because the pivot is one of the keys.\n   HWY_ASSERT(begin != bound && bound != end);\n-  Recurse(d, st, keys, keys_end, begin, bound, buf, rng, remaining_levels - 1);\n+  if (HWY_LIKELY(result != PivotResult::kIsFirst)) {\n+    Recurse(d, st, keys, keys_end, begin, bound, buf, rng,\n+            remaining_levels - 1);\n+  }\n   Recurse(d, st, keys, keys_end, bound, end, buf, rng, remaining_levels - 1);\n }\n "
    ],
    "files_changed": [
      {
        "filename": "hwy/contrib/sort/traits128-inl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "patch": "@@ -130,8 +130,8 @@ struct Key128 : public KeyAny128 {\n   std::string KeyString() const { return \"U128\"; }\n \n   template <class D>\n-  HWY_INLINE Mask<D> EqualKeys(D /*tag*/, Vec<D> a, Vec<D> b) const {\n-    return Eq128(a, b);\n+  HWY_INLINE Mask<D> EqualKeys(D d, Vec<D> a, Vec<D> b) const {\n+    return Eq128(d, a, b);\n   }\n \n   HWY_INLINE bool Equal1(const LaneType* a, const LaneType* b) {\n@@ -234,8 +234,8 @@ struct KeyValue128 : public KeyAny128 {\n   std::string KeyString() const { return \"KV128\"; }\n \n   template <class D>\n-  HWY_INLINE Mask<D> EqualKeys(D /*tag*/, Vec<D> a, Vec<D> b) const {\n-    return Eq128Upper(a, b);\n+  HWY_INLINE Mask<D> EqualKeys(D d, Vec<D> a, Vec<D> b) const {\n+    return Eq128Upper(d, a, b);\n   }\n \n   HWY_INLINE bool Equal1(const LaneType* a, const LaneType* b) {"
      },
      {
        "filename": "hwy/contrib/sort/vqsort-inl.h",
        "status": "modified",
        "additions": 37,
        "deletions": 31,
        "changes": 68,
        "patch": "@@ -584,8 +584,8 @@ V OrXor(const V o, const V x1, const V x2) {\n // are equal. `num` is const to ensure we don't change it, which would lead to\n // bugs because the caller will check whether we return the original value.\n template <class D, class Traits, typename T>\n-HWY_INLINE size_t ScanEqual(D d, Traits st, const T* HWY_RESTRICT keys,\n-                            const size_t num) {\n+HWY_NOINLINE size_t ScanEqual(D d, Traits st, const T* HWY_RESTRICT keys,\n+                              const size_t num) {\n   using V = Vec<decltype(d)>;\n   const size_t N = Lanes(d);\n   HWY_DASSERT(num >= N);  // See HandleSpecialCases\n@@ -654,20 +654,20 @@ HWY_INLINE size_t ScanEqual(D d, Traits st, const T* HWY_RESTRICT keys,\n   return num;  // all equal\n }\n \n-// Returns key prior to reference in sort order. Starts scanning at index\n-// `start`, which is less than `num`.\n+// Returns false if `reference` is already the first key in sort order.\n+// Otherwise, sets `prev_out` to the key prior to `reference` in sort order.\n+// Starts scanning before index `start`, which is less than `num`.\n template <class D, class Traits, typename T>\n-HWY_INLINE Vec<D> ScanForPrev(D d, Traits st, const T* HWY_RESTRICT keys,\n+HWY_NOINLINE bool ScanForPrev(D d, Traits st, const T* HWY_RESTRICT keys,\n                               size_t num, size_t start, Vec<D> reference,\n+                              Vec<D>* HWY_RESTRICT prev_out,\n                               T* HWY_RESTRICT buf) {\n   const size_t N = Lanes(d);\n   HWY_DASSERT(num >= N);  // See HandleSpecialCases\n   HWY_DASSERT(start < num);\n \n-  Vec<D> prev = st.FirstValue(d);\n-  // We want to reduce a mask but that is currently only supported for vectors,\n-  // so use a vector as a sticky accumulator of mask results.\n-  Vec<D> found_any_lanes = Zero(d);\n+  const Vec<D> first = st.FirstValue(d);\n+  Vec<D> prev = first;\n \n   // The value before the first difference might be the desired prev (if it is\n   // equal to the reference in ScanEqual), so start one vector before.\n@@ -676,32 +676,31 @@ HWY_INLINE Vec<D> ScanForPrev(D d, Traits st, const T* HWY_RESTRICT keys,\n   // Whole vectors, no unrolling\n   for (; i + N <= num; i += N) {\n     const Vec<D> curr = LoadU(d, keys + i);\n-    const Vec<D> is_before = VecFromMask(d, st.Compare(d, curr, reference));\n-    found_any_lanes = Or(found_any_lanes, is_before);\n-    prev = IfVecThenElse(is_before, st.Last(d, prev, curr), prev);\n+    const Mask<D> is_before = st.Compare(d, curr, reference);\n+    prev = IfThenElse(is_before, st.Last(d, prev, curr), prev);\n   }\n   // If there are remainders, re-check the last whole vector.\n   if (HWY_LIKELY(i != num)) {\n     const Vec<D> curr = LoadU(d, keys + num - N);\n-    const Vec<D> is_before = VecFromMask(d, st.Compare(d, curr, reference));\n-    found_any_lanes = Or(found_any_lanes, is_before);\n-    prev = IfVecThenElse(is_before, st.Last(d, prev, curr), prev);\n-  }\n-\n-  const Vec<D> candidate = st.LastOfLanes(d, prev, buf);\n-  // If we didn't find any key less than reference, we're still stuck with\n-  // FirstValue; replace that with reference. (We cannot compare directly to\n-  // FirstValue because that might be the desired value of prev.) The min\n-  // reduction of a signed integer is -1 (true) everywhere if any lane is -1.\n-  const RebindToSigned<D> di;\n-  const Vec<D> found_any =\n-      BitCast(d, MinOfLanes(di, BitCast(di, found_any_lanes)));\n-  return IfVecThenElse(found_any, candidate, reference);\n+    const Mask<D> is_before = st.Compare(d, curr, reference);\n+    prev = IfThenElse(is_before, st.Last(d, prev, curr), prev);\n+  }\n+\n+  prev = st.LastOfLanes(d, prev, buf);\n+  // If prev has not changed, then no `curr` came before `reference`, hence\n+  // `reference` is the first (perhaps even the first possible, i.e. `first`).\n+  if (AllTrue(d, st.EqualKeys(d, prev, first))) {\n+    *prev_out = reference;\n+    return false;\n+  }\n+  *prev_out = prev;\n+  return true;\n }\n \n enum class PivotResult {\n   kNormal,    // use partition\n   kAllEqual,  // already done\n+  kIsFirst,   // can skip left recursion\n };\n \n // Writes samples from `keys[0, num)` into `buf`.\n@@ -812,12 +811,16 @@ HWY_NOINLINE Vec<D> ChoosePivot(D d, Traits st, T* HWY_RESTRICT keys,\n     // with the previous key in sort order. By contrast, selecting the first key\n     // in sort order would guarantee (minimal) progress. We instead do a full\n     // scan to maximize load balance in case there are numerous keys that\n-    // precede the most common key.\n-    result = PivotResult::kNormal;\n+    // precede the most common key. This also tells us whether the pivot is the\n+    // first in sort order; if so, we can skip the left recursion.\n     const V reference = st.SetKey(d, buf);\n-    const V pivot = ScanForPrev(d, st, keys, num, idx_diff, reference, buf);\n+    V pivot;\n+    result = ScanForPrev(d, st, keys, num, idx_diff, reference, &pivot, buf)\n+                 ? PivotResult::kNormal\n+                 : PivotResult::kIsFirst;\n #if VQSORT_PRINT\n     Print(d, \"Using PREV as pivot\", pivot, 0, st.LanesPerKey());\n+    fprintf(stderr, \"IsMin %d\\n\", result == PivotResult::kIsFirst);\n #endif\n     return pivot;\n   }\n@@ -856,7 +859,7 @@ HWY_NOINLINE void Recurse(D d, Traits st, T* HWY_RESTRICT keys,\n   }\n   PivotResult result;\n   Vec<D> pivot = ChoosePivot(d, st, keys + begin, num, buf, rng, result);\n-  if (result == PivotResult::kAllEqual) {\n+  if (HWY_UNLIKELY(result == PivotResult::kAllEqual)) {\n     return;\n   }\n \n@@ -874,7 +877,10 @@ HWY_NOINLINE void Recurse(D d, Traits st, T* HWY_RESTRICT keys,\n   // ChoosePivot ensures pivot != largest key, so the right partition is never\n   // empty; nor is the left, because the pivot is one of the keys.\n   HWY_ASSERT(begin != bound && bound != end);\n-  Recurse(d, st, keys, keys_end, begin, bound, buf, rng, remaining_levels - 1);\n+  if (HWY_LIKELY(result != PivotResult::kIsFirst)) {\n+    Recurse(d, st, keys, keys_end, begin, bound, buf, rng,\n+            remaining_levels - 1);\n+  }\n   Recurse(d, st, keys, keys_end, bound, end, buf, rng, remaining_levels - 1);\n }\n "
      }
    ],
    "lines_added": 41,
    "lines_removed": 35
  },
  "issues": [],
  "pull_requests": [],
  "build_info": {
    "old_build_script": "#!/bin/bash\n#!/bin/bash\ncmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON",
    "new_build_script": "#!/bin/bash\n#!/bin/bash\ncmake -S /test_workspace/workspace/new -B /test_workspace/workspace/new/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON",
    "old_test_script": "#!/bin/bash\ncmake --build /test_workspace/workspace/old/build -- -j 1",
    "new_test_script": "#!/bin/bash\ncmake --build /test_workspace/workspace/new/build -- -j 1",
    "build_system": "cmake"
  },
  "performance_analysis": {
    "is_significant": false,
    "p_value": 1.0,
    "is_pair_significant": false,
    "pair_p_value": 1.0,
    "is_binom_significant": false,
    "binom_p_value": 1.0,
    "is_wilcoxon_significant": false,
    "wilcoxon_p_value": 0.9999991333466779,
    "is_mannwhitney_significant": false,
    "mannwhitney_p_value": 0.2623522299812055,
    "relative_improvement": 0.0015760751787859387,
    "absolute_improvement_ms": 26.666666666660177,
    "old_mean_ms": 16919.666666666664,
    "new_mean_ms": 16893.000000000004,
    "old_std_ms": 188.59705876474487,
    "new_std_ms": 167.93163633680982,
    "effect_size_cohens_d": 0.14933991954063677,
    "old_ci95_ms": [
      16849.24336754938,
      16990.089965783947
    ],
    "new_ci95_ms": [
      16830.29329643601,
      16955.706703563996
    ],
    "old_ci99_ms": [
      16824.756156385567,
      17014.57717694776
    ],
    "new_ci99_ms": [
      16808.489258414433,
      16977.510741585575
    ],
    "new_times_s": [
      16.84,
      16.78,
      16.86,
      16.64,
      16.98,
      16.78,
      16.75,
      16.76,
      16.8,
      16.97,
      16.72,
      16.52,
      16.73,
      16.78,
      16.69,
      16.85,
      17.01,
      16.99,
      16.84,
      16.96,
      17.17,
      16.93,
      17.24,
      16.85,
      16.91,
      16.97,
      16.98,
      17.14,
      16.97,
      17.18,
      17.04
    ],
    "old_times_s": [
      16.97,
      17.03,
      16.83,
      16.9,
      16.9,
      17.31,
      16.62,
      16.84,
      16.87,
      16.7,
      17.09,
      16.82,
      16.75,
      16.54,
      17.06,
      16.83,
      17.17,
      16.97,
      16.86,
      17.01,
      17.08,
      16.87,
      16.75,
      16.97,
      17.31,
      16.58,
      17.09,
      16.84,
      16.92,
      17.0,
      17.08
    ]
  },
  "tests": {
    "total_tests": 1,
    "significant_improvements": 0,
    "significant_improvements_tests": [],
    "significant_regressions": 0,
    "significant_regressions_tests": [],
    "significant_pair_improvements": 0,
    "significant_pair_improvements_tests": [],
    "significant_pair_regressions": 0,
    "significant_pair_regressions_tests": [],
    "significant_binom_improvements": 0,
    "significant_binom_improvements_tests": [],
    "significant_binom_regressions": 0,
    "significant_binom_regressions_tests": [],
    "significant_wilcoxon_improvements": 0,
    "significant_wilcoxon_improvements_tests": [],
    "significant_wilcoxon_regressions": 0,
    "significant_wilcoxon_regressions_tests": [],
    "significant_mannwhitney_improvements": 0,
    "significant_mannwhitney_improvements_tests": [],
    "significant_mannwhitney_regressions": 0,
    "significant_mannwhitney_regressions_tests": [],
    "tests": [
      {
        "test_name": "NanobenchmarkTest.RunAll",
        "is_significant": false,
        "p_value": 0.794692280285012,
        "is_pair_significant": false,
        "pair_p_value": 0.7940859863191676,
        "is_binom_significant": false,
        "binom_p_value": 0.867534551769495,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.7721927672480433,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.42891152381658704,
        "relative_improvement": 0.008975317875841379,
        "absolute_improvement_ms": 4.137931034482678,
        "old_mean_ms": 461.0344827586207,
        "new_mean_ms": 456.896551724138,
        "old_std_ms": 95.06932912302199,
        "new_std_ms": 83.28537207679655,
        "effect_size_cohens_d": 0.04630019654905683,
        "old_ci95_ms": [
          424.8720439631952,
          497.1969215540462
        ],
        "new_ci95_ms": [
          425.21649046711525,
          488.5766129811608
        ],
        "old_ci99_ms": [
          412.2520374222255,
          509.8169280950159
        ],
        "new_ci99_ms": [
          414.16074883022867,
          499.6323546180473
        ],
        "new_times": [
          0.43,
          0.44,
          0.49,
          0.45,
          0.45,
          0.52,
          0.18,
          0.41,
          0.55,
          0.39,
          0.44,
          0.39,
          0.46,
          0.49,
          0.55,
          0.58,
          0.51,
          0.34,
          0.52,
          0.47,
          0.38,
          0.49,
          0.41,
          0.6,
          0.55,
          0.38,
          0.48,
          0.43,
          0.47
        ],
        "old_times": [
          0.49,
          0.43,
          0.56,
          0.54,
          0.51,
          0.2,
          0.54,
          0.43,
          0.56,
          0.5,
          0.42,
          0.41,
          0.57,
          0.42,
          0.41,
          0.62,
          0.48,
          0.43,
          0.63,
          0.41,
          0.45,
          0.23,
          0.41,
          0.48,
          0.53,
          0.41,
          0.46,
          0.4,
          0.44
        ]
      }
    ]
  },
  "logs": {
    "full_log_path": "/logs/full.log",
    "config_log_path": "/logs/config.log",
    "build_log_path": "/logs/build.log",
    "test_log_path": "/logs/test.log",
    "build_success": true,
    "test_success": true
  },
  "raw_timing_data": {
    "warmup_runs": 1,
    "measurement_runs": 30,
    "min_exec_time_improvement": 0.05,
    "min_p_value": 0.05
  }
}