{
    "metadata": {
        "collection_date": "2026-01-14T18:41:00.231097",
        "repository": "https://github.com/google/highway",
        "repository_name": "google/highway"
    },
    "commit_info": {
        "old_sha": "63de5f02b8327502010dab94af8393c0136e41f1",
        "new_sha": "6ed8c6f7acb96f2932530a92500bcb78fa296418",
        "commit_message": [
            "improved SVE codegen: avoid SV_POW2, simpler VecFromMask, tune Lt128\n\nPiperOrigin-RevId: 455352929"
        ],
        "commit_date": "2022-06-16T11:39:23+00:00",
        "patch": [
            "--- hwy/contrib/sort/traits128-inl.h\n@@ -288,30 +288,37 @@ struct OrderDescending128 : public Key128 {\n // Shared code that depends on Order.\n template <class Base>\n class Traits128 : public Base {\n-#if HWY_TARGET <= HWY_AVX2\n+  // Special case for >= 256 bit vectors\n+#if HWY_TARGET <= HWY_AVX2 || HWY_TARGET == HWY_SVE_256\n   // Returns vector with only the top u64 lane valid. Useful when the next step\n   // is to replicate the mask anyway.\n   template <class D>\n   HWY_INLINE HWY_MAYBE_UNUSED Vec<D> CompareTop(D d, Vec<D> a, Vec<D> b) const {\n     const Base* base = static_cast<const Base*>(this);\n-    const Vec<D> eqHL = VecFromMask(d, Eq(a, b));\n+    const Mask<D> eqHL = Eq(a, b);\n     const Vec<D> ltHL = VecFromMask(d, base->CompareLanes(a, b));\n+#if HWY_TARGET == HWY_SVE_256\n+    return IfThenElse(eqHL, DupEven(ltHL), ltHL);\n+#else\n     const Vec<D> ltLX = ShiftLeftLanes<1>(ltHL);\n-    return OrAnd(ltHL, eqHL, ltLX);\n+    return OrAnd(ltHL, VecFromMask(d, eqHL), ltLX);\n+#endif\n   }\n \n   // We want to swap 2 u128, i.e. 4 u64 lanes, based on the 0 or FF..FF mask in\n   // the most-significant of those lanes (the result of CompareTop), so\n   // replicate it 4x. Only called for >= 256-bit vectors.\n   template <class V>\n   HWY_INLINE V ReplicateTop4x(V v) const {\n-#if HWY_TARGET <= HWY_AVX3\n+#if HWY_TARGET == HWY_SVE_256\n+    return svdup_lane_u64(v, 3);\n+#elif HWY_TARGET <= HWY_AVX3\n     return V{_mm512_permutex_epi64(v.raw, _MM_SHUFFLE(3, 3, 3, 3))};\n #else  // AVX2\n     return V{_mm256_permute4x64_epi64(v.raw, _MM_SHUFFLE(3, 3, 3, 3))};\n #endif\n   }\n-#endif  // HWY_TARGET <= HWY_AVX2\n+#endif  // HWY_TARGET\n \n  public:\n   constexpr bool Is128() const { return true; }\n@@ -332,7 +339,7 @@ class Traits128 : public Base {\n     const Base* base = static_cast<const Base*>(this);\n     Vec<D> swapped = base->ReverseKeys2(d, v);\n \n-#if HWY_TARGET <= HWY_AVX2\n+#if HWY_TARGET <= HWY_AVX2 || HWY_TARGET == HWY_SVE_256\n     const Vec<D> select = ReplicateTop4x(CompareTop(d, v, swapped));\n     return IfVecThenElse(select, swapped, v);\n #else\n--- hwy/ops/arm_sve-inl.h\n@@ -206,20 +206,34 @@ HWY_INLINE size_t AllHardwareLanes(hwy::SizeTag<8> /* tag */) {\n   return svcntd_pat(SV_ALL);\n }\n \n+// All-true mask from a macro\n+#define HWY_SVE_ALL_PTRUE(BITS) svptrue_pat_b##BITS(SV_ALL)\n+\n+#if HWY_TARGET == HWY_SVE_256\n+#define HWY_SVE_PTRUE(BITS) HWY_SVE_ALL_PTRUE(BITS)\n+#else\n+#define HWY_SVE_PTRUE(BITS) svptrue_pat_b##BITS(SV_POW2)\n+\n // Returns actual lanes of a hardware vector, rounded down to a power of two.\n-HWY_INLINE size_t HardwareLanes(hwy::SizeTag<1> /* tag */) {\n+template <typename T, HWY_IF_LANE_SIZE(T, 1)>\n+HWY_INLINE size_t HardwareLanes() {\n   return svcntb_pat(SV_POW2);\n }\n-HWY_INLINE size_t HardwareLanes(hwy::SizeTag<2> /* tag */) {\n+template <typename T, HWY_IF_LANE_SIZE(T, 2)>\n+HWY_INLINE size_t HardwareLanes() {\n   return svcnth_pat(SV_POW2);\n }\n-HWY_INLINE size_t HardwareLanes(hwy::SizeTag<4> /* tag */) {\n+template <typename T, HWY_IF_LANE_SIZE(T, 4)>\n+HWY_INLINE size_t HardwareLanes() {\n   return svcntw_pat(SV_POW2);\n }\n-HWY_INLINE size_t HardwareLanes(hwy::SizeTag<8> /* tag */) {\n+template <typename T, HWY_IF_LANE_SIZE(T, 8)>\n+HWY_INLINE size_t HardwareLanes() {\n   return svcntd_pat(SV_POW2);\n }\n \n+#endif  // HWY_TARGET == HWY_SVE_256\n+\n }  // namespace detail\n \n // Returns actual number of lanes after capping by N and shifting. May return 0\n@@ -232,7 +246,7 @@ HWY_API constexpr size_t Lanes(Simd<T, N, kPow2> /* d */) {\n #else\n template <typename T, size_t N, int kPow2>\n HWY_API size_t Lanes(Simd<T, N, kPow2> d) {\n-  const size_t actual = detail::HardwareLanes(hwy::SizeTag<sizeof(T)>());\n+  const size_t actual = detail::HardwareLanes<T>();\n   // Common case of full vectors: avoid any extra instructions.\n   if (detail::IsFull(d)) return actual;\n   return HWY_MIN(detail::ScaleByPower(actual, kPow2), N);\n@@ -255,10 +269,6 @@ HWY_SVE_FOREACH(HWY_SVE_FIRSTN, FirstN, whilelt)\n \n namespace detail {\n \n-// All-true mask from a macro\n-#define HWY_SVE_PTRUE(BITS) svptrue_pat_b##BITS(SV_POW2)\n-#define HWY_SVE_ALL_PTRUE(BITS) svptrue_pat_b##BITS(SV_ALL)\n-\n #define HWY_SVE_WRAP_PTRUE(BASE, CHAR, BITS, HALF, NAME, OP)            \\\n   template <size_t N, int kPow2>                                        \\\n   HWY_API svbool_t NAME(HWY_SVE_D(BASE, BITS, N, kPow2) /* d */) {      \\\n@@ -844,15 +854,21 @@ HWY_API svbool_t MaskFromVec(const V v) {\n \n // ------------------------------ VecFromMask\n \n-template <class D, HWY_IF_NOT_FLOAT_D(D)>\n+template <class D, HWY_IF_LANE_SIZE_D(D, 1)>\n HWY_API VFromD<D> VecFromMask(const D d, svbool_t mask) {\n-  const auto v0 = Zero(RebindToSigned<decltype(d)>());\n-  return BitCast(d, detail::SubN(mask, v0, 1));\n+  return BitCast(d, svdup_n_s8_z(mask, -1));\n }\n-\n-template <class D, HWY_IF_FLOAT_D(D)>\n+template <class D, HWY_IF_LANE_SIZE_D(D, 2)>\n+HWY_API VFromD<D> VecFromMask(const D d, svbool_t mask) {\n+  return BitCast(d, svdup_n_s16_z(mask, -1));\n+}\n+template <class D, HWY_IF_LANE_SIZE_D(D, 4)>\n+HWY_API VFromD<D> VecFromMask(const D d, svbool_t mask) {\n+  return BitCast(d, svdup_n_s32_z(mask, -1));\n+}\n+template <class D, HWY_IF_LANE_SIZE_D(D, 8)>\n HWY_API VFromD<D> VecFromMask(const D d, svbool_t mask) {\n-  return BitCast(d, VecFromMask(RebindToUnsigned<D>(), mask));\n+  return BitCast(d, svdup_n_s64_z(mask, -1));\n }\n \n // ------------------------------ IfVecThenElse (MaskFromVec, IfThenElse)\n@@ -2585,27 +2601,16 @@ HWY_API svuint64_t CLMulUpper(const svuint64_t a, const svuint64_t b) {\n \n // ------------------------------ Lt128\n template <class D>\n-HWY_INLINE svbool_t Lt128(D /* d */, const svuint64_t a, const svuint64_t b) {\n+HWY_INLINE svbool_t Lt128(D d, const svuint64_t a, const svuint64_t b) {\n   static_assert(!IsSigned<TFromD<D>>() && sizeof(TFromD<D>) == 8, \"Use u64\");\n-  // Truth table of Eq and Compare for Hi and Lo u64.\n-  // (removed lines with (=H && cH) or (=L && cL) - cannot both be true)\n-  // =H =L cH cL  | out = cH | (=H & cL) = IfThenElse(=H, cL, cH)\n-  //  0  0  0  0  |  0\n-  //  0  0  0  1  |  0\n-  //  0  0  1  0  |  1\n-  //  0  0  1  1  |  1\n-  //  0  1  0  0  |  0\n-  //  0  1  0  1  |  0\n-  //  0  1  1  0  |  1\n-  //  1  0  0  0  |  0\n-  //  1  0  0  1  |  1\n-  //  1  1  0  0  |  0\n-  const svbool_t eqHL = Eq(a, b);\n-  const svbool_t ltHL = Lt(a, b);\n-  // trn (interleave even/odd) allow us to move and copy masks across lanes.\n-  const svbool_t cmpLL = svtrn1_b64(ltHL, ltHL);\n-  const svbool_t outHx = svsel_b(eqHL, cmpLL, ltHL);  // See truth table above.\n-  return svtrn2_b64(outHx, outHx);                    // replicate to HH\n+  const svbool_t eqHx = Eq(a, b);  // only odd lanes used\n+  // Convert to vector: more pipelines can TRN* for vectors than predicates.\n+  const svuint64_t ltHL = VecFromMask(d, Lt(a, b));\n+  // Move into upper lane: ltL if the upper half is equal, otherwise ltH.\n+  // Requires an extra IfThenElse because INSR, EXT, TRN2 are unpredicated.\n+  const svuint64_t ltHx = IfThenElse(eqHx, DupEven(ltHL), ltHL);\n+  // Duplicate upper lane into lower and convert back to predicate.\n+  return MaskFromVec(DupOdd(ltHx));\n }\n \n // ------------------------------ Min128, Max128 (Lt128)"
        ],
        "files_changed": [
            {
                "filename": "hwy/contrib/sort/traits128-inl.h",
                "status": "modified",
                "additions": 13,
                "deletions": 6,
                "changes": 19,
                "patch": "@@ -288,30 +288,37 @@ struct OrderDescending128 : public Key128 {\n // Shared code that depends on Order.\n template <class Base>\n class Traits128 : public Base {\n-#if HWY_TARGET <= HWY_AVX2\n+  // Special case for >= 256 bit vectors\n+#if HWY_TARGET <= HWY_AVX2 || HWY_TARGET == HWY_SVE_256\n   // Returns vector with only the top u64 lane valid. Useful when the next step\n   // is to replicate the mask anyway.\n   template <class D>\n   HWY_INLINE HWY_MAYBE_UNUSED Vec<D> CompareTop(D d, Vec<D> a, Vec<D> b) const {\n     const Base* base = static_cast<const Base*>(this);\n-    const Vec<D> eqHL = VecFromMask(d, Eq(a, b));\n+    const Mask<D> eqHL = Eq(a, b);\n     const Vec<D> ltHL = VecFromMask(d, base->CompareLanes(a, b));\n+#if HWY_TARGET == HWY_SVE_256\n+    return IfThenElse(eqHL, DupEven(ltHL), ltHL);\n+#else\n     const Vec<D> ltLX = ShiftLeftLanes<1>(ltHL);\n-    return OrAnd(ltHL, eqHL, ltLX);\n+    return OrAnd(ltHL, VecFromMask(d, eqHL), ltLX);\n+#endif\n   }\n \n   // We want to swap 2 u128, i.e. 4 u64 lanes, based on the 0 or FF..FF mask in\n   // the most-significant of those lanes (the result of CompareTop), so\n   // replicate it 4x. Only called for >= 256-bit vectors.\n   template <class V>\n   HWY_INLINE V ReplicateTop4x(V v) const {\n-#if HWY_TARGET <= HWY_AVX3\n+#if HWY_TARGET == HWY_SVE_256\n+    return svdup_lane_u64(v, 3);\n+#elif HWY_TARGET <= HWY_AVX3\n     return V{_mm512_permutex_epi64(v.raw, _MM_SHUFFLE(3, 3, 3, 3))};\n #else  // AVX2\n     return V{_mm256_permute4x64_epi64(v.raw, _MM_SHUFFLE(3, 3, 3, 3))};\n #endif\n   }\n-#endif  // HWY_TARGET <= HWY_AVX2\n+#endif  // HWY_TARGET\n \n  public:\n   constexpr bool Is128() const { return true; }\n@@ -332,7 +339,7 @@ class Traits128 : public Base {\n     const Base* base = static_cast<const Base*>(this);\n     Vec<D> swapped = base->ReverseKeys2(d, v);\n \n-#if HWY_TARGET <= HWY_AVX2\n+#if HWY_TARGET <= HWY_AVX2 || HWY_TARGET == HWY_SVE_256\n     const Vec<D> select = ReplicateTop4x(CompareTop(d, v, swapped));\n     return IfVecThenElse(select, swapped, v);\n #else"
            },
            {
                "filename": "hwy/ops/arm_sve-inl.h",
                "status": "modified",
                "additions": 40,
                "deletions": 35,
                "changes": 75,
                "patch": "@@ -206,20 +206,34 @@ HWY_INLINE size_t AllHardwareLanes(hwy::SizeTag<8> /* tag */) {\n   return svcntd_pat(SV_ALL);\n }\n \n+// All-true mask from a macro\n+#define HWY_SVE_ALL_PTRUE(BITS) svptrue_pat_b##BITS(SV_ALL)\n+\n+#if HWY_TARGET == HWY_SVE_256\n+#define HWY_SVE_PTRUE(BITS) HWY_SVE_ALL_PTRUE(BITS)\n+#else\n+#define HWY_SVE_PTRUE(BITS) svptrue_pat_b##BITS(SV_POW2)\n+\n // Returns actual lanes of a hardware vector, rounded down to a power of two.\n-HWY_INLINE size_t HardwareLanes(hwy::SizeTag<1> /* tag */) {\n+template <typename T, HWY_IF_LANE_SIZE(T, 1)>\n+HWY_INLINE size_t HardwareLanes() {\n   return svcntb_pat(SV_POW2);\n }\n-HWY_INLINE size_t HardwareLanes(hwy::SizeTag<2> /* tag */) {\n+template <typename T, HWY_IF_LANE_SIZE(T, 2)>\n+HWY_INLINE size_t HardwareLanes() {\n   return svcnth_pat(SV_POW2);\n }\n-HWY_INLINE size_t HardwareLanes(hwy::SizeTag<4> /* tag */) {\n+template <typename T, HWY_IF_LANE_SIZE(T, 4)>\n+HWY_INLINE size_t HardwareLanes() {\n   return svcntw_pat(SV_POW2);\n }\n-HWY_INLINE size_t HardwareLanes(hwy::SizeTag<8> /* tag */) {\n+template <typename T, HWY_IF_LANE_SIZE(T, 8)>\n+HWY_INLINE size_t HardwareLanes() {\n   return svcntd_pat(SV_POW2);\n }\n \n+#endif  // HWY_TARGET == HWY_SVE_256\n+\n }  // namespace detail\n \n // Returns actual number of lanes after capping by N and shifting. May return 0\n@@ -232,7 +246,7 @@ HWY_API constexpr size_t Lanes(Simd<T, N, kPow2> /* d */) {\n #else\n template <typename T, size_t N, int kPow2>\n HWY_API size_t Lanes(Simd<T, N, kPow2> d) {\n-  const size_t actual = detail::HardwareLanes(hwy::SizeTag<sizeof(T)>());\n+  const size_t actual = detail::HardwareLanes<T>();\n   // Common case of full vectors: avoid any extra instructions.\n   if (detail::IsFull(d)) return actual;\n   return HWY_MIN(detail::ScaleByPower(actual, kPow2), N);\n@@ -255,10 +269,6 @@ HWY_SVE_FOREACH(HWY_SVE_FIRSTN, FirstN, whilelt)\n \n namespace detail {\n \n-// All-true mask from a macro\n-#define HWY_SVE_PTRUE(BITS) svptrue_pat_b##BITS(SV_POW2)\n-#define HWY_SVE_ALL_PTRUE(BITS) svptrue_pat_b##BITS(SV_ALL)\n-\n #define HWY_SVE_WRAP_PTRUE(BASE, CHAR, BITS, HALF, NAME, OP)            \\\n   template <size_t N, int kPow2>                                        \\\n   HWY_API svbool_t NAME(HWY_SVE_D(BASE, BITS, N, kPow2) /* d */) {      \\\n@@ -844,15 +854,21 @@ HWY_API svbool_t MaskFromVec(const V v) {\n \n // ------------------------------ VecFromMask\n \n-template <class D, HWY_IF_NOT_FLOAT_D(D)>\n+template <class D, HWY_IF_LANE_SIZE_D(D, 1)>\n HWY_API VFromD<D> VecFromMask(const D d, svbool_t mask) {\n-  const auto v0 = Zero(RebindToSigned<decltype(d)>());\n-  return BitCast(d, detail::SubN(mask, v0, 1));\n+  return BitCast(d, svdup_n_s8_z(mask, -1));\n }\n-\n-template <class D, HWY_IF_FLOAT_D(D)>\n+template <class D, HWY_IF_LANE_SIZE_D(D, 2)>\n+HWY_API VFromD<D> VecFromMask(const D d, svbool_t mask) {\n+  return BitCast(d, svdup_n_s16_z(mask, -1));\n+}\n+template <class D, HWY_IF_LANE_SIZE_D(D, 4)>\n+HWY_API VFromD<D> VecFromMask(const D d, svbool_t mask) {\n+  return BitCast(d, svdup_n_s32_z(mask, -1));\n+}\n+template <class D, HWY_IF_LANE_SIZE_D(D, 8)>\n HWY_API VFromD<D> VecFromMask(const D d, svbool_t mask) {\n-  return BitCast(d, VecFromMask(RebindToUnsigned<D>(), mask));\n+  return BitCast(d, svdup_n_s64_z(mask, -1));\n }\n \n // ------------------------------ IfVecThenElse (MaskFromVec, IfThenElse)\n@@ -2585,27 +2601,16 @@ HWY_API svuint64_t CLMulUpper(const svuint64_t a, const svuint64_t b) {\n \n // ------------------------------ Lt128\n template <class D>\n-HWY_INLINE svbool_t Lt128(D /* d */, const svuint64_t a, const svuint64_t b) {\n+HWY_INLINE svbool_t Lt128(D d, const svuint64_t a, const svuint64_t b) {\n   static_assert(!IsSigned<TFromD<D>>() && sizeof(TFromD<D>) == 8, \"Use u64\");\n-  // Truth table of Eq and Compare for Hi and Lo u64.\n-  // (removed lines with (=H && cH) or (=L && cL) - cannot both be true)\n-  // =H =L cH cL  | out = cH | (=H & cL) = IfThenElse(=H, cL, cH)\n-  //  0  0  0  0  |  0\n-  //  0  0  0  1  |  0\n-  //  0  0  1  0  |  1\n-  //  0  0  1  1  |  1\n-  //  0  1  0  0  |  0\n-  //  0  1  0  1  |  0\n-  //  0  1  1  0  |  1\n-  //  1  0  0  0  |  0\n-  //  1  0  0  1  |  1\n-  //  1  1  0  0  |  0\n-  const svbool_t eqHL = Eq(a, b);\n-  const svbool_t ltHL = Lt(a, b);\n-  // trn (interleave even/odd) allow us to move and copy masks across lanes.\n-  const svbool_t cmpLL = svtrn1_b64(ltHL, ltHL);\n-  const svbool_t outHx = svsel_b(eqHL, cmpLL, ltHL);  // See truth table above.\n-  return svtrn2_b64(outHx, outHx);                    // replicate to HH\n+  const svbool_t eqHx = Eq(a, b);  // only odd lanes used\n+  // Convert to vector: more pipelines can TRN* for vectors than predicates.\n+  const svuint64_t ltHL = VecFromMask(d, Lt(a, b));\n+  // Move into upper lane: ltL if the upper half is equal, otherwise ltH.\n+  // Requires an extra IfThenElse because INSR, EXT, TRN2 are unpredicated.\n+  const svuint64_t ltHx = IfThenElse(eqHx, DupEven(ltHL), ltHL);\n+  // Duplicate upper lane into lower and convert back to predicate.\n+  return MaskFromVec(DupOdd(ltHx));\n }\n \n // ------------------------------ Min128, Max128 (Lt128)"
            }
        ],
        "lines_added": 53,
        "lines_removed": 41
    },
    "issues": [],
    "pull_requests": [],
    "build_info": {
        "old_build_script": [
            "apt-get update",
            "cmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON",
            "cmake --build /test_workspace/workspace/old/build -- -j 1"
        ],
        "new_build_script": [
            "apt-get update",
            "cmake -S /test_workspace/workspace/new -B /test_workspace/workspace/new/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON",
            "cmake --build /test_workspace/workspace/new/build -- -j 1"
        ],
        "old_test_script": [
            "cd /test_workspace/workspace/old/build",
            "ctest --output-on-failure"
        ],
        "new_test_script": [
            "cd /test_workspace/workspace/new/build",
            "ctest --output-on-failure"
        ],
        "build_system": "cmake"
    },
    "performance_analysis": {
        "is_significant": false,
        "p_value": 0.9999999999999999,
        "is_pair_significant": false,
        "pair_p_value": 0.99999999999997,
        "is_binom_significant": false,
        "binom_p_value": 1.0,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.9999991360698426,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.2946583261271486,
        "relative_improvement": 0.00240416024250664,
        "absolute_improvement_ms": 30.66666666666329,
        "old_mean_ms": 12755.666666666664,
        "new_mean_ms": 12725.000000000002,
        "old_std_ms": 190.74596454055265,
        "new_std_ms": 222.8769569314749,
        "effect_size_cohens_d": 0.1478378166471616,
        "old_ci95_ms": [
            12684.44095294538,
            12826.89238038795
        ],
        "new_ci95_ms": [
            12641.776376539818,
            12808.223623460184
        ],
        "old_ci99_ms": [
            12659.674730487075,
            12851.658602846255
        ],
        "new_ci99_ms": [
            12612.838305375426,
            12837.161694624576
        ],
        "new_times_s": [
            12.43,
            12.75,
            12.64,
            12.62,
            12.85,
            12.95,
            12.75,
            12.84,
            12.45,
            12.66,
            12.35,
            12.89,
            12.97,
            12.47,
            12.81,
            12.53,
            12.59,
            12.71,
            12.39,
            12.51,
            12.9,
            12.93,
            12.76,
            12.73,
            12.5,
            12.35,
            13.18,
            13.06,
            12.63,
            13.07,
            12.91
        ],
        "old_times_s": [
            12.5,
            12.38,
            12.83,
            12.63,
            12.91,
            12.49,
            12.52,
            12.73,
            12.69,
            12.55,
            12.93,
            12.66,
            12.74,
            12.66,
            12.7,
            12.91,
            12.62,
            12.94,
            12.54,
            12.81,
            12.76,
            12.61,
            12.59,
            12.96,
            12.62,
            12.75,
            13.17,
            12.97,
            12.95,
            13.09,
            12.96
        ]
    },
    "tests": {
        "total_tests": 1,
        "significant_improvements": 0,
        "significant_improvements_tests": [],
        "significant_regressions": 0,
        "significant_regressions_tests": [],
        "significant_pair_improvements": 0,
        "significant_pair_improvements_tests": [],
        "significant_pair_regressions": 0,
        "significant_pair_regressions_tests": [],
        "significant_binom_improvements": 0,
        "significant_binom_improvements_tests": [],
        "significant_binom_regressions": 0,
        "significant_binom_regressions_tests": [],
        "significant_wilcoxon_improvements": 0,
        "significant_wilcoxon_improvements_tests": [],
        "significant_wilcoxon_regressions": 0,
        "significant_wilcoxon_regressions_tests": [],
        "significant_mannwhitney_improvements": 0,
        "significant_mannwhitney_improvements_tests": [],
        "significant_mannwhitney_regressions": 0,
        "significant_mannwhitney_regressions_tests": [],
        "tests": [
            {
                "test_name": "NanobenchmarkTest.RunAll",
                "is_significant": false,
                "p_value": 0.5950777248054546,
                "is_pair_significant": false,
                "pair_p_value": 0.5897890821432499,
                "is_binom_significant": false,
                "binom_p_value": 0.355535551905632,
                "is_wilcoxon_significant": false,
                "wilcoxon_p_value": 0.3687227796090936,
                "is_mannwhitney_significant": false,
                "mannwhitney_p_value": 0.1651301701253879,
                "relative_improvement": 0.0363288718929255,
                "absolute_improvement_ms": 13.103448275862073,
                "old_mean_ms": 360.6896551724138,
                "new_mean_ms": 347.58620689655174,
                "old_std_ms": 70.90894737431934,
                "new_std_ms": 86.7119687081396,
                "effect_size_cohens_d": 0.16543594641285037,
                "old_ci95_ms": [
                    333.717334097615,
                    387.6619762472126
                ],
                "new_ci95_ms": [
                    314.6027379884956,
                    380.5696758046078
                ],
                "old_ci99_ms": [
                    324.30450466111813,
                    397.0748056837094
                ],
                "new_ci99_ms": [
                    303.0921317564792,
                    392.0802820366243
                ],
                "new_times": [
                    0.39,
                    0.4,
                    0.5,
                    0.38,
                    0.39,
                    0.47,
                    0.39,
                    0.26,
                    0.36,
                    0.33,
                    0.19,
                    0.35,
                    0.21,
                    0.34,
                    0.35,
                    0.35,
                    0.36,
                    0.29,
                    0.29,
                    0.58,
                    0.22,
                    0.22,
                    0.43,
                    0.34,
                    0.34,
                    0.33,
                    0.36,
                    0.4,
                    0.26
                ],
                "old_times": [
                    0.45,
                    0.4,
                    0.4,
                    0.44,
                    0.38,
                    0.44,
                    0.49,
                    0.39,
                    0.45,
                    0.38,
                    0.37,
                    0.35,
                    0.32,
                    0.29,
                    0.31,
                    0.36,
                    0.39,
                    0.42,
                    0.37,
                    0.2,
                    0.4,
                    0.33,
                    0.3,
                    0.36,
                    0.3,
                    0.2,
                    0.4,
                    0.25,
                    0.32
                ]
            }
        ]
    },
    "logs": {
        "full_log_path": "/logs/full.log",
        "config_log_path": "/logs/config.log",
        "build_log_path": "/logs/build.log",
        "test_log_path": "/logs/test.log",
        "build_success": true,
        "test_success": true
    },
    "raw_timing_data": {
        "warmup_runs": 1,
        "measurement_runs": 30,
        "min_exec_time_improvement": 0.05,
        "min_p_value": 0.05
    }
}