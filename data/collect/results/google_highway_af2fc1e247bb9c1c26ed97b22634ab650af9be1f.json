{
  "metadata": {
    "collection_date": "2026-01-11T17:46:23.184903",
    "repository": "https://github.com/google/highway",
    "repository_name": "google/highway"
  },
  "commit_info": {
    "old_sha": "af2fc1e247bb9c1c26ed97b22634ab650af9be1f",
    "new_sha": "af2fc1e247bb9c1c26ed97b22634ab650af9be1f",
    "commit_message": [
      "speculative fast 2-valued partition. geomean 1.02x speedup\n\nPiperOrigin-RevId: 477463556"
    ],
    "commit_date": "2022-09-28T15:49:15+00:00",
    "patch": [
      "--- hwy/contrib/sort/vqsort-inl.h\n@@ -233,6 +233,12 @@ HWY_NOINLINE void PartitionToMultipleOfUnroll(D d, Traits st,\n   memcpy(keys + right, buf, bufR * sizeof(T));\n }\n \n+template <class V>\n+V OrXor(const V o, const V x1, const V x2) {\n+  // TODO(janwas): add op so we can benefit from AVX-512 ternlog?\n+  return Or(o, Xor(x1, x2));\n+}\n+\n // Note: we could track the OrXor of v and pivot to see if the entire left\n // partition is equal, but that happens rarely and thus is a net loss.\n template <class D, class Traits, typename T>\n@@ -430,67 +436,133 @@ HWY_NOINLINE size_t Partition(D d, Traits st, T* HWY_RESTRICT keys, size_t left,\n   return writeL;\n }\n \n+// Returns true and partitions if [keys, keys + num) contains only {valueL,\n+// valueR}. Otherwise, keys may have been modified and a regular Partition is\n+// still necessary.\n template <class D, class Traits, typename T>\n-HWY_INLINE void StoreLeftRightTwoValue(D d, Traits st, const Vec<D> v,\n-                                       const Vec<D> pivot, T* HWY_RESTRICT keys,\n-                                       size_t& writeL) {\n-  // We only have two values. Equality comparison is slightly cheaper than\n-  // Compare for 128-bit keys.\n-  const auto eqL = st.EqualKeys(d, pivot, v);\n-\n-  // No need to Compress because we know the only value in the left partition\n-  // (`pivot`). It's fine to store an entire vector because CompressStore has\n-  // the same latitude.\n-  StoreU(v, d, keys + writeL);\n-  writeL += CountTrue(d, eqL);\n-  // To avoid an extra parameter for the R value, and allow writing in\n-  // ascending address order, we write the right partition later.\n-}\n-\n-template <class D, class Traits, typename T>\n-HWY_INLINE void StoreLeftRightTwoValue4(D d, Traits st, const Vec<D> v0,\n-                                        const Vec<D> v1, const Vec<D> v2,\n-                                        const Vec<D> v3, const Vec<D> pivot,\n-                                        T* HWY_RESTRICT keys, size_t& writeL) {\n-  StoreLeftRightTwoValue(d, st, v0, pivot, keys, writeL);\n-  StoreLeftRightTwoValue(d, st, v1, pivot, keys, writeL);\n-  StoreLeftRightTwoValue(d, st, v2, pivot, keys, writeL);\n-  StoreLeftRightTwoValue(d, st, v3, pivot, keys, writeL);\n-}\n-\n-template <class D, class Traits, typename T>\n-HWY_NOINLINE size_t PartitionTwoValue(D d, Traits st, T* HWY_RESTRICT keys,\n-                                      size_t left, size_t right,\n-                                      const Vec<D> pivot, const Vec<D> valueR,\n-                                      T* HWY_RESTRICT buf) {\n-  using V = decltype(Zero(d));\n+HWY_NOINLINE bool MaybePartitionTwoValue(D d, Traits st, T* HWY_RESTRICT keys,\n+                                         size_t num, const Vec<D> valueL,\n+                                         const Vec<D> valueR,\n+                                         T* HWY_RESTRICT buf) {\n   const size_t N = Lanes(d);\n \n-  PartitionToMultipleOfUnroll(d, st, keys, left, right, pivot, buf);\n-  constexpr size_t kUnroll = Constants::kPartitionUnroll;\n+  size_t i = 0;\n+  size_t writeL = 0;\n \n-  const T* HWY_RESTRICT readL = keys + left;\n-  HWY_DASSERT(((right - left) & (kUnroll * N - 1)) == 0);\n+  // As long as all lanes are equal to L or R, we can overwrite with valueL.\n+  // This is faster than first counting, then backtracking to fill L and R.\n+  for (; i + N <= num; i += N) {\n+    const Vec<D> v = LoadU(d, keys + i);\n+    // It is not clear how to apply OrXor here - that can check if *both*\n+    // comparisons are true, but here we want *either*. Comparing the unsigned\n+    // min of differences to zero works, but is expensive for u64 prior to AVX3.\n+    const Mask<D> eqL = Eq(v, valueL);\n+    const Mask<D> eqR = Eq(v, valueR);\n+    // At least one other value present; will require a regular partition.\n+    // On AVX-512, Or + AllTrue are folded into a single kortest.\n+    if (HWY_UNLIKELY(!AllTrue(d, Or(eqL, eqR)))) {\n+      if (VQSORT_PRINT >= 2) {\n+        fprintf(stderr, \"found 3rd value at %zu; writeL %zu\\n\", i, writeL);\n+      }\n+      // 'Undo' what we did by filling the remainder of what we read with R.\n+      for (; writeL + N <= i; writeL += N) {\n+        StoreU(valueR, d, keys + writeL);\n+      }\n+      BlendedStore(valueR, FirstN(d, i - writeL), d, keys + writeL);\n+      return false;\n+    }\n+    StoreU(valueL, d, keys + writeL);\n+    writeL += CountTrue(d, eqL);\n+  }\n \n-  size_t writeL = left;\n+  // Final vector, masked comparison (no effect if i == num)\n+  const size_t remaining = num - i;\n+  SafeCopyN(remaining, d, keys + i, buf);\n+  const Vec<D> v = Load(d, buf);\n+  const Mask<D> valid = FirstN(d, remaining);\n+  const Mask<D> eqL = And(Eq(v, valueL), valid);\n+  const Mask<D> eqR = Eq(v, valueR);\n+  // Invalid lanes are considered equal.\n+  const Mask<D> eq = Or(Or(eqL, eqR), Not(valid));\n+  // At least one other value present; will require a regular partition.\n+  if (HWY_UNLIKELY(!AllTrue(d, eq))) {\n+    if (VQSORT_PRINT >= 2) {\n+      fprintf(stderr, \"found 3rd value at partial %zu; writeL %zu\\n\", i,\n+              writeL);\n+    }\n+    // 'Undo' what we did by filling the remainder of what we read with R.\n+    for (; writeL + N <= i; writeL += N) {\n+      StoreU(valueR, d, keys + writeL);\n+    }\n+    BlendedStore(valueR, FirstN(d, i - writeL), d, keys + writeL);\n+    return false;\n+  }\n+  BlendedStore(valueL, valid, d, keys + writeL);\n+  writeL += CountTrue(d, eqL);\n \n-  while (readL != keys + right) {\n-    V v0 = LoadU(d, readL + 0 * N);\n-    V v1 = LoadU(d, readL + 1 * N);\n-    V v2 = LoadU(d, readL + 2 * N);\n-    V v3 = LoadU(d, readL + 3 * N);\n-    readL += kUnroll * N;\n+  // Fill right side\n+  i = writeL;\n+  for (; i + N <= num; i += N) {\n+    StoreU(valueR, d, keys + i);\n+  }\n+  BlendedStore(valueR, FirstN(d, num - i), d, keys + i);\n \n-    StoreLeftRightTwoValue4(d, st, v0, v1, v2, v3, pivot, keys, writeL);\n+  if (VQSORT_PRINT >= 2) {\n+    fprintf(stderr, \"Successful MaybePartitionTwoValue\\n\");\n   }\n+  return true;\n+}\n \n-  size_t i = writeL;\n-  for (; i + N <= right; i += N) {\n-    StoreU(valueR, d, keys + i);\n+// `idx_second` is `first_mismatch` from `AllEqual` and thus the index of the\n+// second key. This is the first path into `MaybePartitionTwoValue`, called\n+// when all samples are equal.\n+template <class D, class Traits, typename T>\n+HWY_INLINE bool PartitionIfTwoKeys(D d, Traits st, const Vec<D> pivot,\n+                                   T* HWY_RESTRICT keys, size_t num,\n+                                   size_t idx_second, T* HWY_RESTRICT buf) {\n+  const Vec<D> second = st.SetKey(d, keys + idx_second);\n+  // True if second comes before pivot.\n+  const bool is_pivotR = AllFalse(d, st.Compare(d, pivot, second));\n+  if (VQSORT_PRINT >= 1) {\n+    fprintf(stderr, \"Samples all equal, diff at %zu, isPivotR %d\\n\", idx_second,\n+            is_pivotR);\n+#if VQSORT_PRINT >= 2  // Print is only defined #if\n+    Print(d, \"pivot\", pivot, 0, st.LanesPerKey());\n+    Print(d, \"second\", second, 0, st.LanesPerKey());\n+#endif\n   }\n-  BlendedStore(valueR, FirstN(d, right - i), d, keys + i);\n+  HWY_DASSERT(AllFalse(d, st.EqualKeys(d, second, pivot)));\n+\n+  // If pivot is L, we scanned up to idx_second and can leave those in place.\n+  // Otherwise, we'd have to restart from the beginning, and fill most keys\n+  // with L, then overwrite most with R, which is not worthwhile.\n+  if (is_pivotR) return false;\n+  return MaybePartitionTwoValue(d, st, keys + idx_second, num - idx_second,\n+                                pivot, second, buf);\n+}\n \n-  return writeL;\n+// Second path into `MaybePartitionTwoValue`, called when not all samples are\n+// equal. `samples` is sorted.\n+template <class D, class Traits, typename T>\n+HWY_INLINE bool PartitionIfTwoSamples(D d, Traits st, T* HWY_RESTRICT keys,\n+                                      size_t num, T* HWY_RESTRICT samples) {\n+  constexpr size_t kSampleLanes = 3 * 64 / sizeof(T);\n+  constexpr size_t N1 = st.LanesPerKey();\n+  const Vec<D> valueL = st.SetKey(d, samples);\n+  const Vec<D> valueR = st.SetKey(d, samples + kSampleLanes - N1);\n+  HWY_DASSERT(AllTrue(d, st.Compare(d, valueL, valueR)));\n+  HWY_DASSERT(AllFalse(d, st.EqualKeys(d, valueL, valueR)));\n+  const Vec<D> prev = st.PrevValue(d, valueR);\n+  // If the sample has more than two values, then the keys have at least that\n+  // many, and thus this special case is inapplicable.\n+  if (HWY_UNLIKELY(!AllTrue(d, st.EqualKeys(d, valueL, prev)))) {\n+    return false;\n+  }\n+\n+  // Must not overwrite samples because if this returns false, caller wants to\n+  // read the original samples again.\n+  T* HWY_RESTRICT buf = samples + kSampleLanes;\n+  return MaybePartitionTwoValue(d, st, keys, num, valueL, valueR, buf);\n }\n \n // ------------------------------ Pivot sampling\n@@ -624,6 +696,32 @@ HWY_INLINE void DrawSamples(D d, Traits st, T* HWY_RESTRICT keys, size_t num,\n   }\n }\n \n+// For detecting inputs where (almost) all keys are equal.\n+template <class D, class Traits>\n+HWY_INLINE bool UnsortedSampleEqual(D d, Traits st,\n+                                    const TFromD<D>* HWY_RESTRICT samples) {\n+  constexpr size_t kSampleLanes = 3 * 64 / sizeof(TFromD<D>);\n+  const size_t N = Lanes(d);\n+  using V = Vec<D>;\n+\n+  const V first = st.SetKey(d, samples);\n+  // OR of XOR-difference may be faster than comparison.\n+  V diff = Zero(d);\n+  size_t i = 0;\n+  for (; i + N <= kSampleLanes; i += N) {\n+    const V v = Load(d, samples + i);\n+    diff = OrXor(diff, first, v);\n+  }\n+  // Remainder, if any.\n+  const V v = Load(d, samples + i);\n+  const auto valid = FirstN(d, kSampleLanes - i);\n+  diff = IfThenElse(valid, OrXor(diff, first, v), diff);\n+\n+  // Must avoid floating-point comparisons (for -0)\n+  const RebindToUnsigned<D> du;\n+  return AllTrue(du, Eq(BitCast(du, diff), Zero(du)));\n+}\n+\n template <class D, class Traits, typename T>\n HWY_INLINE void SortSamples(D d, Traits st, T* HWY_RESTRICT buf) {\n   // buf contains 192 bytes, so 16 128-bit vectors are necessary and sufficient.\n@@ -722,111 +820,121 @@ HWY_INLINE Vec<D> ChoosePivotByRank(D d, Traits st,\n   return pivot;\n }\n \n-template <class V>\n-V OrXor(const V o, const V x1, const V x2) {\n-  // TODO(janwas): ternlog?\n-  return Or(o, Xor(x1, x2));\n-}\n-\n-// Returns a lower bound on the index of the first mismatch, or `num` if all\n-// are equal. `num` is const to ensure we don't change it, which would lead to\n-// bugs because the caller will check whether we return the original value.\n+// Returns true if all keys equal `pivot`, otherwise returns false and sets\n+// `*first_mismatch' to the index of the first differing key.\n template <class D, class Traits, typename T>\n-HWY_NOINLINE size_t LowerBoundOfMismatch(D d, Traits st,\n-                                         const T* HWY_RESTRICT keys,\n-                                         const size_t num) {\n-  using V = Vec<decltype(d)>;\n+HWY_NOINLINE bool AllEqual(D d, Traits st, const Vec<D> pivot,\n+                           const T* HWY_RESTRICT keys, size_t num,\n+                           size_t* HWY_RESTRICT first_mismatch) {\n   const size_t N = Lanes(d);\n-  HWY_DASSERT(num >= N);  // See HandleSpecialCases\n-  const V reference = st.SetKey(d, keys);\n-  const V zero = Zero(d);\n-\n-  size_t i = 0;\n+  // Ensures we can use overlapping loads for the tail; see HandleSpecialCases.\n+  HWY_DASSERT(num >= N);\n+  const Vec<D> zero = Zero(d);\n \n   // Vector-align keys + i.\n   const size_t misalign =\n       (reinterpret_cast<uintptr_t>(keys) / sizeof(T)) & (N - 1);\n-  if (HWY_LIKELY(misalign != 0)) {\n-    HWY_DASSERT(misalign % st.LanesPerKey() == 0);\n-    const size_t consume = N - misalign;\n-    const auto mask = FirstN(d, consume);\n-    const V v0 = LoadU(d, keys);\n-    // Only check masked lanes; consider others to be equal to the reference.\n-    if (!AllTrue(d, Or(Not(mask), Eq(v0, reference)))) {\n-      return 0;  // not equal\n+  HWY_DASSERT(misalign % st.LanesPerKey() == 0);\n+  const size_t consume = N - misalign;\n+  {\n+    const Vec<D> v = LoadU(d, keys);\n+    // Only check masked lanes; consider others to be equal.\n+    const Mask<D> diff = And(FirstN(d, consume), Ne(v, pivot));\n+    if (HWY_UNLIKELY(!AllFalse(d, diff))) {\n+      const intptr_t lane = FindFirstTrue(d, diff);\n+      HWY_DASSERT(lane >= 0);\n+      *first_mismatch = static_cast<size_t>(lane);\n+      return false;\n     }\n-    i = consume;\n   }\n+  size_t i = consume;\n   HWY_DASSERT(((reinterpret_cast<uintptr_t>(keys + i) / sizeof(T)) & (N - 1)) ==\n               0);\n \n   // Sticky bits registering any difference between `keys` and the first key.\n   // We use vector XOR because it may be cheaper than comparisons, especially\n   // for 128-bit. 2x unrolled for more ILP.\n-  V diff0 = zero;\n-  V diff1 = zero;\n+  Vec<D> diff0 = zero;\n+  Vec<D> diff1 = zero;\n \n-  // We want to stop once a difference has been found, but without slowing down\n-  // the loop by comparing during each iteration. The compromise is to compare\n-  // after a 'group', which consists of kLoops times two vectors.\n-  constexpr size_t kLoops = 4;\n+  // We want to stop once a difference has been found, but without slowing\n+  // down the loop by comparing during each iteration. The compromise is to\n+  // compare after a 'group', which consists of kLoops times two vectors.\n+  constexpr size_t kLoops = 8;\n   const size_t lanes_per_group = kLoops * 2 * N;\n \n   for (; i + lanes_per_group <= num; i += lanes_per_group) {\n     HWY_DEFAULT_UNROLL\n     for (size_t loop = 0; loop < kLoops; ++loop) {\n-      const V v0 = Load(d, keys + i + loop * 2 * N);\n-      const V v1 = Load(d, keys + i + loop * 2 * N + N);\n-      diff0 = OrXor(diff0, v0, reference);\n-      diff1 = OrXor(diff1, v1, reference);\n+      const Vec<D> v0 = Load(d, keys + i + loop * 2 * N);\n+      const Vec<D> v1 = Load(d, keys + i + loop * 2 * N + N);\n+      diff0 = OrXor(diff0, v0, pivot);\n+      diff1 = OrXor(diff1, v1, pivot);\n     }\n     diff0 = Or(diff0, diff1);\n \n-    // Must avoid floating-point comparisons (for -0)\n+    // If there was a difference in the entire group: (use du because we must\n+    // avoid floating-point comparisons for -0)\n     const RebindToUnsigned<D> du;\n-    if (!AllTrue(du, Eq(BitCast(du, diff0), Zero(du)))) {\n-      return i;  // not equal\n+    if (HWY_UNLIKELY(!AllTrue(du, Eq(BitCast(du, diff0), Zero(du))))) {\n+      // .. then loop until the first one, with termination guarantee.\n+      for (;; i += N) {\n+        const Vec<D> v = Load(d, keys + i);\n+        const Mask<D> diff = Ne(v, pivot);\n+        if (HWY_UNLIKELY(!AllFalse(d, diff))) {\n+          const intptr_t lane = FindFirstTrue(d, diff);\n+          HWY_DASSERT(lane >= 0);\n+          *first_mismatch = i + static_cast<size_t>(lane);\n+          return false;\n+        }\n+      }\n     }\n   }\n+\n   // Whole vectors, no unrolling, compare directly\n   for (; i + N <= num; i += N) {\n-    const V v0 = Load(d, keys + i);\n-    if (!AllTrue(d, Eq(v0, reference))) {\n-      return i;  // not equal\n+    const Vec<D> v = Load(d, keys + i);\n+    const Mask<D> diff = Ne(v, pivot);\n+    if (HWY_UNLIKELY(!AllFalse(d, diff))) {\n+      const intptr_t lane = FindFirstTrue(d, diff);\n+      HWY_DASSERT(lane >= 0);\n+      *first_mismatch = i + static_cast<size_t>(lane);\n+      return false;\n     }\n   }\n-  // If there are remainders, re-check the last whole vector.\n-  if (HWY_LIKELY(i != num)) {\n-    const V v0 = LoadU(d, keys + num - N);\n-    if (!AllTrue(d, Eq(v0, reference))) {\n-      return i;  // not equal\n-    }\n+  // Always re-check the last (unaligned) vector to reduce branching.\n+  i = num - N;\n+  const Vec<D> v = LoadU(d, keys + i);\n+  const Mask<D> diff = Ne(v, pivot);\n+  if (HWY_UNLIKELY(!AllFalse(d, diff))) {\n+    const intptr_t lane = FindFirstTrue(d, diff);\n+    HWY_DASSERT(lane >= 0);\n+    *first_mismatch = i + static_cast<size_t>(lane);\n+    return false;\n   }\n \n-  return num;  // all equal\n+  if (VQSORT_PRINT >= 1) {\n+    fprintf(stderr, \"All keys equal\\n\");\n+  }\n+  return true;  // all equal\n }\n \n-// Classifies (and possibly modifies) `pivot` by scanning for the first/last\n-// key from index `idx_diff`, which is less than `num`.\n+// Scans for the first/last key from index `first_mismatch`.\n template <class D, class Traits, typename T>\n HWY_NOINLINE void ScanFirstLast(D d, Traits st, const T* HWY_RESTRICT keys,\n-                                size_t num, size_t idx_diff,\n+                                size_t num, const Vec<D> pivot,\n                                 T* HWY_RESTRICT buf,\n                                 Vec<D>* HWY_RESTRICT out_first,\n                                 Vec<D>* HWY_RESTRICT out_last) {\n   const size_t N = Lanes(d);\n   HWY_DASSERT(num >= N);  // See HandleSpecialCases\n-  HWY_DASSERT(idx_diff < num);\n \n   Vec<D> first = st.LastValue(d);\n   Vec<D> last = st.FirstValue(d);\n \n-  // We know keys[0, idx_diff) are equal, but they might be the first/last, so\n-  // start scanning one vector before.\n-  size_t i = static_cast<size_t>(\n-      HWY_MAX(static_cast<intptr_t>(idx_diff) - static_cast<intptr_t>(N), 0));\n+  size_t i = 0;\n \n-  constexpr size_t kLoops = 4;\n+  constexpr size_t kLoops = 16;\n   const size_t lanes_per_group = kLoops * N;\n \n   // Whole group, unrolled\n@@ -837,6 +945,17 @@ HWY_NOINLINE void ScanFirstLast(D d, Traits st, const T* HWY_RESTRICT keys,\n       first = st.First(d, first, curr);\n       last = st.Last(d, last, curr);\n     }\n+\n+    // We only care whether pivot is the first or last. If neither, i.e. there\n+    // are key(s) before and after pivot, we can stop scanning immediately.\n+    const Mask<D> before = st.Compare(d, first, pivot);\n+    const Mask<D> after = st.Compare(d, pivot, last);\n+    if (HWY_UNLIKELY(!AllFalse(d, And(before, after)))) {\n+      if (VQSORT_PRINT >= 2) {\n+        fprintf(stderr, \"Stopped scanning at %zu\\n\", i + lanes_per_group);\n+      }\n+      goto DONE;\n+    }\n   }\n   // Whole vectors, no unrolling\n   for (; i + N <= num; i += N) {\n@@ -851,21 +970,24 @@ HWY_NOINLINE void ScanFirstLast(D d, Traits st, const T* HWY_RESTRICT keys,\n     last = st.Last(d, last, curr);\n   }\n \n+DONE:\n   *out_first = st.FirstOfLanes(d, first, buf);\n   *out_last = st.LastOfLanes(d, last, buf);\n+\n+#if VQSORT_PRINT >= 2\n+  Print(d, \"first\", *out_first, 0, st.LanesPerKey());\n+  Print(d, \"last\", *out_last, 0, st.LanesPerKey());\n+#endif\n }\n \n // Returns pivot chosen from `keys[0, num)`. It will never be the largest key\n // (thus the right partition will never be empty).\n template <class D, class Traits, typename T>\n HWY_INLINE Vec<D> ChoosePivotForEqualSamples(D d, Traits st,\n                                              T* HWY_RESTRICT keys, size_t num,\n-                                             size_t idx_diff,\n                                              T* HWY_RESTRICT samples,\n                                              PivotResult& result) {\n-  using V = decltype(Zero(d));\n-\n-  V pivot = st.SetKey(d, samples);  // the single unique sample\n+  const Vec<D> pivot = st.SetKey(d, samples);  // the single unique sample\n \n   // Early out for mostly-0 arrays, where pivot is often FirstValue.\n   if (HWY_UNLIKELY(AllTrue(d, st.EqualKeys(d, pivot, st.FirstValue(d))))) {\n@@ -877,20 +999,13 @@ HWY_INLINE Vec<D> ChoosePivotForEqualSamples(D d, Traits st,\n     return st.PrevValue(d, pivot);\n   }\n \n-  V first, last;\n-  ScanFirstLast(d, st, keys, num, idx_diff, /*buf=*/samples, &first, &last);\n+  Vec<D> first, last;\n+  ScanFirstLast(d, st, keys, num, pivot, /*buf=*/samples, &first, &last);\n+\n+  // We only reach here if !AllEqual. Note that first might equal Prev(last)\n+  // because the 2-value special case is conditional and may be skipped.\n+  HWY_DASSERT(AllFalse(d, st.EqualKeys(d, first, last)));\n \n-  const Vec<D> prev_last = st.PrevValue(d, last);\n-  // All keys are in [x, x+1], or [x+1, x] if descending order.\n-  if (HWY_UNLIKELY(AllTrue(d, st.EqualKeys(d, first, prev_last)))) {\n-    (void)PartitionTwoValue(d, st, keys, 0, num, first, last,\n-                            /*buf=*/samples);\n-    result = PivotResult::kDone;\n-    if (VQSORT_PRINT >= 2) {\n-      fprintf(stderr, \"  2val\\n\");\n-    }\n-    return pivot;\n-  }\n   if (AllTrue(d, st.EqualKeys(d, first, pivot))) {\n     // We could consider a special partition mode that only reads from and\n     // writes to the right side, and later fills in the left side, which we know\n@@ -927,7 +1042,7 @@ template <class D, class Traits, typename T>\n HWY_NOINLINE void PrintMinMax(D d, Traits st, const T* HWY_RESTRICT keys,\n                               size_t num, T* HWY_RESTRICT buf) {\n   const size_t N = Lanes(d);\n-  if (num < Lanes(d)) return;\n+  if (num < N) return;\n \n   Vec<D> first = st.LastValue(d);\n   Vec<D> last = st.FirstValue(d);\n@@ -953,32 +1068,6 @@ HWY_NOINLINE void PrintMinMax(D d, Traits st, const T* HWY_RESTRICT keys,\n \n #endif  // VQSORT_PRINT >= 2\n \n-// For detecting inputs where (almost) all keys are equal.\n-template <class D, class Traits>\n-HWY_INLINE bool UnsortedSampleEqual(D d, Traits st,\n-                                    const TFromD<D>* HWY_RESTRICT samples) {\n-  constexpr size_t kSampleLanes = 3 * 64 / sizeof(TFromD<D>);\n-  const size_t N = Lanes(d);\n-  using V = Vec<D>;\n-\n-  const V first = st.SetKey(d, samples);\n-  // OR of XOR-difference may be faster than comparison.\n-  V diff = Zero(d);\n-  size_t i = 0;\n-  for (; i + N <= kSampleLanes; i += N) {\n-    const V v = Load(d, samples + i);\n-    diff = OrXor(diff, first, v);\n-  }\n-  // Remainder, if any.\n-  const V v = Load(d, samples + i);\n-  const auto valid = FirstN(d, kSampleLanes - i);\n-  diff = IfThenElse(valid, OrXor(diff, first, v), diff);\n-\n-  // Must avoid floating-point comparisons (for -0)\n-  const RebindToUnsigned<D> du;\n-  return AllTrue(du, Eq(BitCast(du, diff), Zero(du)));\n-}\n-\n template <class D, class Traits, typename T>\n HWY_NOINLINE void Recurse(D d, Traits st, T* HWY_RESTRICT keys,\n                           T* HWY_RESTRICT keys_end, const size_t begin,\n@@ -1005,27 +1094,28 @@ HWY_NOINLINE void Recurse(D d, Traits st, T* HWY_RESTRICT keys,\n \n   Vec<D> pivot;\n   PivotResult result = PivotResult::kNormal;\n-  size_t idx_diff = 0;\n   if (HWY_UNLIKELY(UnsortedSampleEqual(d, st, buf))) {\n-    idx_diff = LowerBoundOfMismatch(d, st, keys + begin, num);\n-    // All keys are equal; done.\n-    if (HWY_UNLIKELY(idx_diff == num)) {\n-      if (VQSORT_PRINT >= 1) {\n-        fprintf(stderr, \"All keys equal\\n\");\n-      }\n+    pivot = st.SetKey(d, buf);\n+    size_t idx_second = 0;\n+    if (HWY_UNLIKELY(AllEqual(d, st, pivot, keys + begin, num, &idx_second))) {\n       return;\n     }\n \n-    if (VQSORT_PRINT >= 1) {\n-      fprintf(stderr, \"Samples all equal %.0f, diff at %zu\\n\",\n-              static_cast<double>(GetLane(st.SetKey(d, buf))), idx_diff);\n+    if (HWY_UNLIKELY(PartitionIfTwoKeys(d, st, pivot, keys + begin, num,\n+                                        idx_second, buf))) {\n+      return;  // Done, skip recursion because each side has all-equal keys.\n     }\n-    pivot = ChoosePivotForEqualSamples(d, st, keys + begin, num, idx_diff, buf,\n-                                       result);\n-    // TODO(janwas): inline this, move the 2-valued partition here.\n-    if (result == PivotResult::kDone) return;\n+\n+    // We can no longer start scanning from idx_second because\n+    // PartitionIfTwoKeys may have reordered keys.\n+    pivot = ChoosePivotForEqualSamples(d, st, keys + begin, num, buf, result);\n   } else {\n     SortSamples(d, st, buf);\n+\n+    if (HWY_UNLIKELY(PartitionIfTwoSamples(d, st, keys + begin, num, buf))) {\n+      return;\n+    }\n+\n     pivot = ChoosePivotByRank(d, st, buf);\n   }\n "
    ],
    "files_changed": [
      {
        "filename": "hwy/contrib/sort/vqsort-inl.h",
        "status": "modified",
        "additions": 257,
        "deletions": 167,
        "changes": 424,
        "patch": "@@ -233,6 +233,12 @@ HWY_NOINLINE void PartitionToMultipleOfUnroll(D d, Traits st,\n   memcpy(keys + right, buf, bufR * sizeof(T));\n }\n \n+template <class V>\n+V OrXor(const V o, const V x1, const V x2) {\n+  // TODO(janwas): add op so we can benefit from AVX-512 ternlog?\n+  return Or(o, Xor(x1, x2));\n+}\n+\n // Note: we could track the OrXor of v and pivot to see if the entire left\n // partition is equal, but that happens rarely and thus is a net loss.\n template <class D, class Traits, typename T>\n@@ -430,67 +436,133 @@ HWY_NOINLINE size_t Partition(D d, Traits st, T* HWY_RESTRICT keys, size_t left,\n   return writeL;\n }\n \n+// Returns true and partitions if [keys, keys + num) contains only {valueL,\n+// valueR}. Otherwise, keys may have been modified and a regular Partition is\n+// still necessary.\n template <class D, class Traits, typename T>\n-HWY_INLINE void StoreLeftRightTwoValue(D d, Traits st, const Vec<D> v,\n-                                       const Vec<D> pivot, T* HWY_RESTRICT keys,\n-                                       size_t& writeL) {\n-  // We only have two values. Equality comparison is slightly cheaper than\n-  // Compare for 128-bit keys.\n-  const auto eqL = st.EqualKeys(d, pivot, v);\n-\n-  // No need to Compress because we know the only value in the left partition\n-  // (`pivot`). It's fine to store an entire vector because CompressStore has\n-  // the same latitude.\n-  StoreU(v, d, keys + writeL);\n-  writeL += CountTrue(d, eqL);\n-  // To avoid an extra parameter for the R value, and allow writing in\n-  // ascending address order, we write the right partition later.\n-}\n-\n-template <class D, class Traits, typename T>\n-HWY_INLINE void StoreLeftRightTwoValue4(D d, Traits st, const Vec<D> v0,\n-                                        const Vec<D> v1, const Vec<D> v2,\n-                                        const Vec<D> v3, const Vec<D> pivot,\n-                                        T* HWY_RESTRICT keys, size_t& writeL) {\n-  StoreLeftRightTwoValue(d, st, v0, pivot, keys, writeL);\n-  StoreLeftRightTwoValue(d, st, v1, pivot, keys, writeL);\n-  StoreLeftRightTwoValue(d, st, v2, pivot, keys, writeL);\n-  StoreLeftRightTwoValue(d, st, v3, pivot, keys, writeL);\n-}\n-\n-template <class D, class Traits, typename T>\n-HWY_NOINLINE size_t PartitionTwoValue(D d, Traits st, T* HWY_RESTRICT keys,\n-                                      size_t left, size_t right,\n-                                      const Vec<D> pivot, const Vec<D> valueR,\n-                                      T* HWY_RESTRICT buf) {\n-  using V = decltype(Zero(d));\n+HWY_NOINLINE bool MaybePartitionTwoValue(D d, Traits st, T* HWY_RESTRICT keys,\n+                                         size_t num, const Vec<D> valueL,\n+                                         const Vec<D> valueR,\n+                                         T* HWY_RESTRICT buf) {\n   const size_t N = Lanes(d);\n \n-  PartitionToMultipleOfUnroll(d, st, keys, left, right, pivot, buf);\n-  constexpr size_t kUnroll = Constants::kPartitionUnroll;\n+  size_t i = 0;\n+  size_t writeL = 0;\n \n-  const T* HWY_RESTRICT readL = keys + left;\n-  HWY_DASSERT(((right - left) & (kUnroll * N - 1)) == 0);\n+  // As long as all lanes are equal to L or R, we can overwrite with valueL.\n+  // This is faster than first counting, then backtracking to fill L and R.\n+  for (; i + N <= num; i += N) {\n+    const Vec<D> v = LoadU(d, keys + i);\n+    // It is not clear how to apply OrXor here - that can check if *both*\n+    // comparisons are true, but here we want *either*. Comparing the unsigned\n+    // min of differences to zero works, but is expensive for u64 prior to AVX3.\n+    const Mask<D> eqL = Eq(v, valueL);\n+    const Mask<D> eqR = Eq(v, valueR);\n+    // At least one other value present; will require a regular partition.\n+    // On AVX-512, Or + AllTrue are folded into a single kortest.\n+    if (HWY_UNLIKELY(!AllTrue(d, Or(eqL, eqR)))) {\n+      if (VQSORT_PRINT >= 2) {\n+        fprintf(stderr, \"found 3rd value at %zu; writeL %zu\\n\", i, writeL);\n+      }\n+      // 'Undo' what we did by filling the remainder of what we read with R.\n+      for (; writeL + N <= i; writeL += N) {\n+        StoreU(valueR, d, keys + writeL);\n+      }\n+      BlendedStore(valueR, FirstN(d, i - writeL), d, keys + writeL);\n+      return false;\n+    }\n+    StoreU(valueL, d, keys + writeL);\n+    writeL += CountTrue(d, eqL);\n+  }\n \n-  size_t writeL = left;\n+  // Final vector, masked comparison (no effect if i == num)\n+  const size_t remaining = num - i;\n+  SafeCopyN(remaining, d, keys + i, buf);\n+  const Vec<D> v = Load(d, buf);\n+  const Mask<D> valid = FirstN(d, remaining);\n+  const Mask<D> eqL = And(Eq(v, valueL), valid);\n+  const Mask<D> eqR = Eq(v, valueR);\n+  // Invalid lanes are considered equal.\n+  const Mask<D> eq = Or(Or(eqL, eqR), Not(valid));\n+  // At least one other value present; will require a regular partition.\n+  if (HWY_UNLIKELY(!AllTrue(d, eq))) {\n+    if (VQSORT_PRINT >= 2) {\n+      fprintf(stderr, \"found 3rd value at partial %zu; writeL %zu\\n\", i,\n+              writeL);\n+    }\n+    // 'Undo' what we did by filling the remainder of what we read with R.\n+    for (; writeL + N <= i; writeL += N) {\n+      StoreU(valueR, d, keys + writeL);\n+    }\n+    BlendedStore(valueR, FirstN(d, i - writeL), d, keys + writeL);\n+    return false;\n+  }\n+  BlendedStore(valueL, valid, d, keys + writeL);\n+  writeL += CountTrue(d, eqL);\n \n-  while (readL != keys + right) {\n-    V v0 = LoadU(d, readL + 0 * N);\n-    V v1 = LoadU(d, readL + 1 * N);\n-    V v2 = LoadU(d, readL + 2 * N);\n-    V v3 = LoadU(d, readL + 3 * N);\n-    readL += kUnroll * N;\n+  // Fill right side\n+  i = writeL;\n+  for (; i + N <= num; i += N) {\n+    StoreU(valueR, d, keys + i);\n+  }\n+  BlendedStore(valueR, FirstN(d, num - i), d, keys + i);\n \n-    StoreLeftRightTwoValue4(d, st, v0, v1, v2, v3, pivot, keys, writeL);\n+  if (VQSORT_PRINT >= 2) {\n+    fprintf(stderr, \"Successful MaybePartitionTwoValue\\n\");\n   }\n+  return true;\n+}\n \n-  size_t i = writeL;\n-  for (; i + N <= right; i += N) {\n-    StoreU(valueR, d, keys + i);\n+// `idx_second` is `first_mismatch` from `AllEqual` and thus the index of the\n+// second key. This is the first path into `MaybePartitionTwoValue`, called\n+// when all samples are equal.\n+template <class D, class Traits, typename T>\n+HWY_INLINE bool PartitionIfTwoKeys(D d, Traits st, const Vec<D> pivot,\n+                                   T* HWY_RESTRICT keys, size_t num,\n+                                   size_t idx_second, T* HWY_RESTRICT buf) {\n+  const Vec<D> second = st.SetKey(d, keys + idx_second);\n+  // True if second comes before pivot.\n+  const bool is_pivotR = AllFalse(d, st.Compare(d, pivot, second));\n+  if (VQSORT_PRINT >= 1) {\n+    fprintf(stderr, \"Samples all equal, diff at %zu, isPivotR %d\\n\", idx_second,\n+            is_pivotR);\n+#if VQSORT_PRINT >= 2  // Print is only defined #if\n+    Print(d, \"pivot\", pivot, 0, st.LanesPerKey());\n+    Print(d, \"second\", second, 0, st.LanesPerKey());\n+#endif\n   }\n-  BlendedStore(valueR, FirstN(d, right - i), d, keys + i);\n+  HWY_DASSERT(AllFalse(d, st.EqualKeys(d, second, pivot)));\n+\n+  // If pivot is L, we scanned up to idx_second and can leave those in place.\n+  // Otherwise, we'd have to restart from the beginning, and fill most keys\n+  // with L, then overwrite most with R, which is not worthwhile.\n+  if (is_pivotR) return false;\n+  return MaybePartitionTwoValue(d, st, keys + idx_second, num - idx_second,\n+                                pivot, second, buf);\n+}\n \n-  return writeL;\n+// Second path into `MaybePartitionTwoValue`, called when not all samples are\n+// equal. `samples` is sorted.\n+template <class D, class Traits, typename T>\n+HWY_INLINE bool PartitionIfTwoSamples(D d, Traits st, T* HWY_RESTRICT keys,\n+                                      size_t num, T* HWY_RESTRICT samples) {\n+  constexpr size_t kSampleLanes = 3 * 64 / sizeof(T);\n+  constexpr size_t N1 = st.LanesPerKey();\n+  const Vec<D> valueL = st.SetKey(d, samples);\n+  const Vec<D> valueR = st.SetKey(d, samples + kSampleLanes - N1);\n+  HWY_DASSERT(AllTrue(d, st.Compare(d, valueL, valueR)));\n+  HWY_DASSERT(AllFalse(d, st.EqualKeys(d, valueL, valueR)));\n+  const Vec<D> prev = st.PrevValue(d, valueR);\n+  // If the sample has more than two values, then the keys have at least that\n+  // many, and thus this special case is inapplicable.\n+  if (HWY_UNLIKELY(!AllTrue(d, st.EqualKeys(d, valueL, prev)))) {\n+    return false;\n+  }\n+\n+  // Must not overwrite samples because if this returns false, caller wants to\n+  // read the original samples again.\n+  T* HWY_RESTRICT buf = samples + kSampleLanes;\n+  return MaybePartitionTwoValue(d, st, keys, num, valueL, valueR, buf);\n }\n \n // ------------------------------ Pivot sampling\n@@ -624,6 +696,32 @@ HWY_INLINE void DrawSamples(D d, Traits st, T* HWY_RESTRICT keys, size_t num,\n   }\n }\n \n+// For detecting inputs where (almost) all keys are equal.\n+template <class D, class Traits>\n+HWY_INLINE bool UnsortedSampleEqual(D d, Traits st,\n+                                    const TFromD<D>* HWY_RESTRICT samples) {\n+  constexpr size_t kSampleLanes = 3 * 64 / sizeof(TFromD<D>);\n+  const size_t N = Lanes(d);\n+  using V = Vec<D>;\n+\n+  const V first = st.SetKey(d, samples);\n+  // OR of XOR-difference may be faster than comparison.\n+  V diff = Zero(d);\n+  size_t i = 0;\n+  for (; i + N <= kSampleLanes; i += N) {\n+    const V v = Load(d, samples + i);\n+    diff = OrXor(diff, first, v);\n+  }\n+  // Remainder, if any.\n+  const V v = Load(d, samples + i);\n+  const auto valid = FirstN(d, kSampleLanes - i);\n+  diff = IfThenElse(valid, OrXor(diff, first, v), diff);\n+\n+  // Must avoid floating-point comparisons (for -0)\n+  const RebindToUnsigned<D> du;\n+  return AllTrue(du, Eq(BitCast(du, diff), Zero(du)));\n+}\n+\n template <class D, class Traits, typename T>\n HWY_INLINE void SortSamples(D d, Traits st, T* HWY_RESTRICT buf) {\n   // buf contains 192 bytes, so 16 128-bit vectors are necessary and sufficient.\n@@ -722,111 +820,121 @@ HWY_INLINE Vec<D> ChoosePivotByRank(D d, Traits st,\n   return pivot;\n }\n \n-template <class V>\n-V OrXor(const V o, const V x1, const V x2) {\n-  // TODO(janwas): ternlog?\n-  return Or(o, Xor(x1, x2));\n-}\n-\n-// Returns a lower bound on the index of the first mismatch, or `num` if all\n-// are equal. `num` is const to ensure we don't change it, which would lead to\n-// bugs because the caller will check whether we return the original value.\n+// Returns true if all keys equal `pivot`, otherwise returns false and sets\n+// `*first_mismatch' to the index of the first differing key.\n template <class D, class Traits, typename T>\n-HWY_NOINLINE size_t LowerBoundOfMismatch(D d, Traits st,\n-                                         const T* HWY_RESTRICT keys,\n-                                         const size_t num) {\n-  using V = Vec<decltype(d)>;\n+HWY_NOINLINE bool AllEqual(D d, Traits st, const Vec<D> pivot,\n+                           const T* HWY_RESTRICT keys, size_t num,\n+                           size_t* HWY_RESTRICT first_mismatch) {\n   const size_t N = Lanes(d);\n-  HWY_DASSERT(num >= N);  // See HandleSpecialCases\n-  const V reference = st.SetKey(d, keys);\n-  const V zero = Zero(d);\n-\n-  size_t i = 0;\n+  // Ensures we can use overlapping loads for the tail; see HandleSpecialCases.\n+  HWY_DASSERT(num >= N);\n+  const Vec<D> zero = Zero(d);\n \n   // Vector-align keys + i.\n   const size_t misalign =\n       (reinterpret_cast<uintptr_t>(keys) / sizeof(T)) & (N - 1);\n-  if (HWY_LIKELY(misalign != 0)) {\n-    HWY_DASSERT(misalign % st.LanesPerKey() == 0);\n-    const size_t consume = N - misalign;\n-    const auto mask = FirstN(d, consume);\n-    const V v0 = LoadU(d, keys);\n-    // Only check masked lanes; consider others to be equal to the reference.\n-    if (!AllTrue(d, Or(Not(mask), Eq(v0, reference)))) {\n-      return 0;  // not equal\n+  HWY_DASSERT(misalign % st.LanesPerKey() == 0);\n+  const size_t consume = N - misalign;\n+  {\n+    const Vec<D> v = LoadU(d, keys);\n+    // Only check masked lanes; consider others to be equal.\n+    const Mask<D> diff = And(FirstN(d, consume), Ne(v, pivot));\n+    if (HWY_UNLIKELY(!AllFalse(d, diff))) {\n+      const intptr_t lane = FindFirstTrue(d, diff);\n+      HWY_DASSERT(lane >= 0);\n+      *first_mismatch = static_cast<size_t>(lane);\n+      return false;\n     }\n-    i = consume;\n   }\n+  size_t i = consume;\n   HWY_DASSERT(((reinterpret_cast<uintptr_t>(keys + i) / sizeof(T)) & (N - 1)) ==\n               0);\n \n   // Sticky bits registering any difference between `keys` and the first key.\n   // We use vector XOR because it may be cheaper than comparisons, especially\n   // for 128-bit. 2x unrolled for more ILP.\n-  V diff0 = zero;\n-  V diff1 = zero;\n+  Vec<D> diff0 = zero;\n+  Vec<D> diff1 = zero;\n \n-  // We want to stop once a difference has been found, but without slowing down\n-  // the loop by comparing during each iteration. The compromise is to compare\n-  // after a 'group', which consists of kLoops times two vectors.\n-  constexpr size_t kLoops = 4;\n+  // We want to stop once a difference has been found, but without slowing\n+  // down the loop by comparing during each iteration. The compromise is to\n+  // compare after a 'group', which consists of kLoops times two vectors.\n+  constexpr size_t kLoops = 8;\n   const size_t lanes_per_group = kLoops * 2 * N;\n \n   for (; i + lanes_per_group <= num; i += lanes_per_group) {\n     HWY_DEFAULT_UNROLL\n     for (size_t loop = 0; loop < kLoops; ++loop) {\n-      const V v0 = Load(d, keys + i + loop * 2 * N);\n-      const V v1 = Load(d, keys + i + loop * 2 * N + N);\n-      diff0 = OrXor(diff0, v0, reference);\n-      diff1 = OrXor(diff1, v1, reference);\n+      const Vec<D> v0 = Load(d, keys + i + loop * 2 * N);\n+      const Vec<D> v1 = Load(d, keys + i + loop * 2 * N + N);\n+      diff0 = OrXor(diff0, v0, pivot);\n+      diff1 = OrXor(diff1, v1, pivot);\n     }\n     diff0 = Or(diff0, diff1);\n \n-    // Must avoid floating-point comparisons (for -0)\n+    // If there was a difference in the entire group: (use du because we must\n+    // avoid floating-point comparisons for -0)\n     const RebindToUnsigned<D> du;\n-    if (!AllTrue(du, Eq(BitCast(du, diff0), Zero(du)))) {\n-      return i;  // not equal\n+    if (HWY_UNLIKELY(!AllTrue(du, Eq(BitCast(du, diff0), Zero(du))))) {\n+      // .. then loop until the first one, with termination guarantee.\n+      for (;; i += N) {\n+        const Vec<D> v = Load(d, keys + i);\n+        const Mask<D> diff = Ne(v, pivot);\n+        if (HWY_UNLIKELY(!AllFalse(d, diff))) {\n+          const intptr_t lane = FindFirstTrue(d, diff);\n+          HWY_DASSERT(lane >= 0);\n+          *first_mismatch = i + static_cast<size_t>(lane);\n+          return false;\n+        }\n+      }\n     }\n   }\n+\n   // Whole vectors, no unrolling, compare directly\n   for (; i + N <= num; i += N) {\n-    const V v0 = Load(d, keys + i);\n-    if (!AllTrue(d, Eq(v0, reference))) {\n-      return i;  // not equal\n+    const Vec<D> v = Load(d, keys + i);\n+    const Mask<D> diff = Ne(v, pivot);\n+    if (HWY_UNLIKELY(!AllFalse(d, diff))) {\n+      const intptr_t lane = FindFirstTrue(d, diff);\n+      HWY_DASSERT(lane >= 0);\n+      *first_mismatch = i + static_cast<size_t>(lane);\n+      return false;\n     }\n   }\n-  // If there are remainders, re-check the last whole vector.\n-  if (HWY_LIKELY(i != num)) {\n-    const V v0 = LoadU(d, keys + num - N);\n-    if (!AllTrue(d, Eq(v0, reference))) {\n-      return i;  // not equal\n-    }\n+  // Always re-check the last (unaligned) vector to reduce branching.\n+  i = num - N;\n+  const Vec<D> v = LoadU(d, keys + i);\n+  const Mask<D> diff = Ne(v, pivot);\n+  if (HWY_UNLIKELY(!AllFalse(d, diff))) {\n+    const intptr_t lane = FindFirstTrue(d, diff);\n+    HWY_DASSERT(lane >= 0);\n+    *first_mismatch = i + static_cast<size_t>(lane);\n+    return false;\n   }\n \n-  return num;  // all equal\n+  if (VQSORT_PRINT >= 1) {\n+    fprintf(stderr, \"All keys equal\\n\");\n+  }\n+  return true;  // all equal\n }\n \n-// Classifies (and possibly modifies) `pivot` by scanning for the first/last\n-// key from index `idx_diff`, which is less than `num`.\n+// Scans for the first/last key from index `first_mismatch`.\n template <class D, class Traits, typename T>\n HWY_NOINLINE void ScanFirstLast(D d, Traits st, const T* HWY_RESTRICT keys,\n-                                size_t num, size_t idx_diff,\n+                                size_t num, const Vec<D> pivot,\n                                 T* HWY_RESTRICT buf,\n                                 Vec<D>* HWY_RESTRICT out_first,\n                                 Vec<D>* HWY_RESTRICT out_last) {\n   const size_t N = Lanes(d);\n   HWY_DASSERT(num >= N);  // See HandleSpecialCases\n-  HWY_DASSERT(idx_diff < num);\n \n   Vec<D> first = st.LastValue(d);\n   Vec<D> last = st.FirstValue(d);\n \n-  // We know keys[0, idx_diff) are equal, but they might be the first/last, so\n-  // start scanning one vector before.\n-  size_t i = static_cast<size_t>(\n-      HWY_MAX(static_cast<intptr_t>(idx_diff) - static_cast<intptr_t>(N), 0));\n+  size_t i = 0;\n \n-  constexpr size_t kLoops = 4;\n+  constexpr size_t kLoops = 16;\n   const size_t lanes_per_group = kLoops * N;\n \n   // Whole group, unrolled\n@@ -837,6 +945,17 @@ HWY_NOINLINE void ScanFirstLast(D d, Traits st, const T* HWY_RESTRICT keys,\n       first = st.First(d, first, curr);\n       last = st.Last(d, last, curr);\n     }\n+\n+    // We only care whether pivot is the first or last. If neither, i.e. there\n+    // are key(s) before and after pivot, we can stop scanning immediately.\n+    const Mask<D> before = st.Compare(d, first, pivot);\n+    const Mask<D> after = st.Compare(d, pivot, last);\n+    if (HWY_UNLIKELY(!AllFalse(d, And(before, after)))) {\n+      if (VQSORT_PRINT >= 2) {\n+        fprintf(stderr, \"Stopped scanning at %zu\\n\", i + lanes_per_group);\n+      }\n+      goto DONE;\n+    }\n   }\n   // Whole vectors, no unrolling\n   for (; i + N <= num; i += N) {\n@@ -851,21 +970,24 @@ HWY_NOINLINE void ScanFirstLast(D d, Traits st, const T* HWY_RESTRICT keys,\n     last = st.Last(d, last, curr);\n   }\n \n+DONE:\n   *out_first = st.FirstOfLanes(d, first, buf);\n   *out_last = st.LastOfLanes(d, last, buf);\n+\n+#if VQSORT_PRINT >= 2\n+  Print(d, \"first\", *out_first, 0, st.LanesPerKey());\n+  Print(d, \"last\", *out_last, 0, st.LanesPerKey());\n+#endif\n }\n \n // Returns pivot chosen from `keys[0, num)`. It will never be the largest key\n // (thus the right partition will never be empty).\n template <class D, class Traits, typename T>\n HWY_INLINE Vec<D> ChoosePivotForEqualSamples(D d, Traits st,\n                                              T* HWY_RESTRICT keys, size_t num,\n-                                             size_t idx_diff,\n                                              T* HWY_RESTRICT samples,\n                                              PivotResult& result) {\n-  using V = decltype(Zero(d));\n-\n-  V pivot = st.SetKey(d, samples);  // the single unique sample\n+  const Vec<D> pivot = st.SetKey(d, samples);  // the single unique sample\n \n   // Early out for mostly-0 arrays, where pivot is often FirstValue.\n   if (HWY_UNLIKELY(AllTrue(d, st.EqualKeys(d, pivot, st.FirstValue(d))))) {\n@@ -877,20 +999,13 @@ HWY_INLINE Vec<D> ChoosePivotForEqualSamples(D d, Traits st,\n     return st.PrevValue(d, pivot);\n   }\n \n-  V first, last;\n-  ScanFirstLast(d, st, keys, num, idx_diff, /*buf=*/samples, &first, &last);\n+  Vec<D> first, last;\n+  ScanFirstLast(d, st, keys, num, pivot, /*buf=*/samples, &first, &last);\n+\n+  // We only reach here if !AllEqual. Note that first might equal Prev(last)\n+  // because the 2-value special case is conditional and may be skipped.\n+  HWY_DASSERT(AllFalse(d, st.EqualKeys(d, first, last)));\n \n-  const Vec<D> prev_last = st.PrevValue(d, last);\n-  // All keys are in [x, x+1], or [x+1, x] if descending order.\n-  if (HWY_UNLIKELY(AllTrue(d, st.EqualKeys(d, first, prev_last)))) {\n-    (void)PartitionTwoValue(d, st, keys, 0, num, first, last,\n-                            /*buf=*/samples);\n-    result = PivotResult::kDone;\n-    if (VQSORT_PRINT >= 2) {\n-      fprintf(stderr, \"  2val\\n\");\n-    }\n-    return pivot;\n-  }\n   if (AllTrue(d, st.EqualKeys(d, first, pivot))) {\n     // We could consider a special partition mode that only reads from and\n     // writes to the right side, and later fills in the left side, which we know\n@@ -927,7 +1042,7 @@ template <class D, class Traits, typename T>\n HWY_NOINLINE void PrintMinMax(D d, Traits st, const T* HWY_RESTRICT keys,\n                               size_t num, T* HWY_RESTRICT buf) {\n   const size_t N = Lanes(d);\n-  if (num < Lanes(d)) return;\n+  if (num < N) return;\n \n   Vec<D> first = st.LastValue(d);\n   Vec<D> last = st.FirstValue(d);\n@@ -953,32 +1068,6 @@ HWY_NOINLINE void PrintMinMax(D d, Traits st, const T* HWY_RESTRICT keys,\n \n #endif  // VQSORT_PRINT >= 2\n \n-// For detecting inputs where (almost) all keys are equal.\n-template <class D, class Traits>\n-HWY_INLINE bool UnsortedSampleEqual(D d, Traits st,\n-                                    const TFromD<D>* HWY_RESTRICT samples) {\n-  constexpr size_t kSampleLanes = 3 * 64 / sizeof(TFromD<D>);\n-  const size_t N = Lanes(d);\n-  using V = Vec<D>;\n-\n-  const V first = st.SetKey(d, samples);\n-  // OR of XOR-difference may be faster than comparison.\n-  V diff = Zero(d);\n-  size_t i = 0;\n-  for (; i + N <= kSampleLanes; i += N) {\n-    const V v = Load(d, samples + i);\n-    diff = OrXor(diff, first, v);\n-  }\n-  // Remainder, if any.\n-  const V v = Load(d, samples + i);\n-  const auto valid = FirstN(d, kSampleLanes - i);\n-  diff = IfThenElse(valid, OrXor(diff, first, v), diff);\n-\n-  // Must avoid floating-point comparisons (for -0)\n-  const RebindToUnsigned<D> du;\n-  return AllTrue(du, Eq(BitCast(du, diff), Zero(du)));\n-}\n-\n template <class D, class Traits, typename T>\n HWY_NOINLINE void Recurse(D d, Traits st, T* HWY_RESTRICT keys,\n                           T* HWY_RESTRICT keys_end, const size_t begin,\n@@ -1005,27 +1094,28 @@ HWY_NOINLINE void Recurse(D d, Traits st, T* HWY_RESTRICT keys,\n \n   Vec<D> pivot;\n   PivotResult result = PivotResult::kNormal;\n-  size_t idx_diff = 0;\n   if (HWY_UNLIKELY(UnsortedSampleEqual(d, st, buf))) {\n-    idx_diff = LowerBoundOfMismatch(d, st, keys + begin, num);\n-    // All keys are equal; done.\n-    if (HWY_UNLIKELY(idx_diff == num)) {\n-      if (VQSORT_PRINT >= 1) {\n-        fprintf(stderr, \"All keys equal\\n\");\n-      }\n+    pivot = st.SetKey(d, buf);\n+    size_t idx_second = 0;\n+    if (HWY_UNLIKELY(AllEqual(d, st, pivot, keys + begin, num, &idx_second))) {\n       return;\n     }\n \n-    if (VQSORT_PRINT >= 1) {\n-      fprintf(stderr, \"Samples all equal %.0f, diff at %zu\\n\",\n-              static_cast<double>(GetLane(st.SetKey(d, buf))), idx_diff);\n+    if (HWY_UNLIKELY(PartitionIfTwoKeys(d, st, pivot, keys + begin, num,\n+                                        idx_second, buf))) {\n+      return;  // Done, skip recursion because each side has all-equal keys.\n     }\n-    pivot = ChoosePivotForEqualSamples(d, st, keys + begin, num, idx_diff, buf,\n-                                       result);\n-    // TODO(janwas): inline this, move the 2-valued partition here.\n-    if (result == PivotResult::kDone) return;\n+\n+    // We can no longer start scanning from idx_second because\n+    // PartitionIfTwoKeys may have reordered keys.\n+    pivot = ChoosePivotForEqualSamples(d, st, keys + begin, num, buf, result);\n   } else {\n     SortSamples(d, st, buf);\n+\n+    if (HWY_UNLIKELY(PartitionIfTwoSamples(d, st, keys + begin, num, buf))) {\n+      return;\n+    }\n+\n     pivot = ChoosePivotByRank(d, st, buf);\n   }\n "
      }
    ],
    "lines_added": 257,
    "lines_removed": 167
  },
  "issues": [],
  "pull_requests": [],
  "build_info": {
    "old_build_script": "#!/bin/bash\n#!/bin/bash\ncmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON -DHWY_ENABLE_TESTS=ON",
    "new_build_script": "#!/bin/bash\n#!/bin/bash\ncmake -S /test_workspace/workspace/new -B /test_workspace/workspace/new/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON -DHWY_ENABLE_TESTS=ON",
    "old_test_script": "#!/bin/bash\ncmake --build /test_workspace/workspace/old/build -- -j 1",
    "new_test_script": "#!/bin/bash\ncmake --build /test_workspace/workspace/new/build -- -j 1",
    "build_system": "cmake"
  },
  "performance_analysis": {
    "is_significant": false,
    "p_value": 1.0,
    "is_pair_significant": false,
    "pair_p_value": 1.0,
    "is_binom_significant": false,
    "binom_p_value": 1.0,
    "is_wilcoxon_significant": false,
    "wilcoxon_p_value": 0.9999991360698426,
    "is_mannwhitney_significant": false,
    "mannwhitney_p_value": 0.06845653154797762,
    "relative_improvement": 0.0023015922833888283,
    "absolute_improvement_ms": 36.666666666668846,
    "old_mean_ms": 15931.000000000002,
    "new_mean_ms": 15894.333333333334,
    "old_std_ms": 113.39129687456892,
    "new_std_ms": 110.84886677078742,
    "effect_size_cohens_d": 0.32700930602608747,
    "old_ci95_ms": [
      15888.658993892079,
      15973.341006107927
    ],
    "new_ci95_ms": [
      15852.941686228442,
      15935.724980438226
    ],
    "old_ci99_ms": [
      15873.936406759,
      15988.063593241006
    ],
    "new_ci99_ms": [
      15838.549205106709,
      15950.11746155996
    ],
    "new_times_s": [
      15.93,
      15.87,
      15.75,
      15.86,
      15.76,
      15.95,
      15.78,
      15.87,
      15.82,
      15.94,
      15.8,
      15.76,
      15.81,
      15.94,
      15.9,
      16.15,
      16.01,
      15.84,
      15.8,
      15.99,
      15.83,
      15.97,
      16.04,
      15.78,
      16.11,
      16.03,
      16.08,
      15.86,
      15.86,
      15.8,
      15.87
    ],
    "old_times_s": [
      15.86,
      15.78,
      15.88,
      15.84,
      15.77,
      15.95,
      15.91,
      15.72,
      15.95,
      15.94,
      16.1,
      16.01,
      15.7,
      16.1,
      15.91,
      15.78,
      15.89,
      15.86,
      16.07,
      16.03,
      15.91,
      16.11,
      15.98,
      16.0,
      15.87,
      16.03,
      16.11,
      15.95,
      15.98,
      15.87,
      15.93
    ]
  },
  "tests": {
    "total_tests": 1,
    "significant_improvements": 0,
    "significant_improvements_tests": [],
    "significant_regressions": 0,
    "significant_regressions_tests": [],
    "significant_pair_improvements": 0,
    "significant_pair_improvements_tests": [],
    "significant_pair_regressions": 0,
    "significant_pair_regressions_tests": [],
    "significant_binom_improvements": 0,
    "significant_binom_improvements_tests": [],
    "significant_binom_regressions": 0,
    "significant_binom_regressions_tests": [],
    "significant_wilcoxon_improvements": 0,
    "significant_wilcoxon_improvements_tests": [],
    "significant_wilcoxon_regressions": 0,
    "significant_wilcoxon_regressions_tests": [],
    "significant_mannwhitney_improvements": 0,
    "significant_mannwhitney_improvements_tests": [],
    "significant_mannwhitney_regressions": 0,
    "significant_mannwhitney_regressions_tests": [],
    "tests": [
      {
        "test_name": "NanobenchmarkTest.RunAll",
        "is_significant": false,
        "p_value": 0.5399454736989828,
        "is_pair_significant": false,
        "pair_p_value": 0.5386137322623898,
        "is_binom_significant": false,
        "binom_p_value": 0.5,
        "is_wilcoxon_significant": false,
        "wilcoxon_p_value": 0.4355694806213347,
        "is_mannwhitney_significant": false,
        "mannwhitney_p_value": 0.14115194456270058,
        "relative_improvement": 0.046395431834404026,
        "absolute_improvement_ms": 22.41379310344821,
        "old_mean_ms": 483.10344827586204,
        "new_mean_ms": 460.68965517241384,
        "old_std_ms": 77.41831862752703,
        "new_std_ms": 57.0044506083741,
        "effect_size_cohens_d": 0.3297018998862365,
        "old_ci95_ms": [
          453.65509479700347,
          512.5518017547206
        ],
        "new_ci95_ms": [
          439.00632180708993,
          482.37298853773774
        ],
        "old_ci99_ms": [
          443.37817692577306,
          522.8287196259511
        ],
        "new_ci99_ms": [
          431.43924895427585,
          489.9400613905518
        ],
        "new_times": [
          0.44,
          0.46,
          0.4,
          0.49,
          0.41,
          0.49,
          0.42,
          0.54,
          0.46,
          0.42,
          0.46,
          0.46,
          0.54,
          0.58,
          0.44,
          0.49,
          0.36,
          0.4,
          0.47,
          0.44,
          0.54,
          0.38,
          0.55,
          0.52,
          0.5,
          0.39,
          0.49,
          0.41,
          0.41
        ],
        "old_times": [
          0.44,
          0.51,
          0.4,
          0.49,
          0.49,
          0.34,
          0.48,
          0.51,
          0.69,
          0.47,
          0.37,
          0.58,
          0.43,
          0.48,
          0.42,
          0.45,
          0.46,
          0.57,
          0.52,
          0.62,
          0.52,
          0.45,
          0.36,
          0.54,
          0.59,
          0.45,
          0.46,
          0.48,
          0.44
        ]
      }
    ]
  },
  "logs": {
    "full_log_path": "/logs/full.log",
    "config_log_path": "/logs/config.log",
    "build_log_path": "/logs/build.log",
    "test_log_path": "/logs/test.log",
    "build_success": true,
    "test_success": true
  },
  "raw_timing_data": {
    "warmup_runs": 1,
    "measurement_runs": 30,
    "min_exec_time_improvement": 0.05,
    "min_p_value": 0.05
  }
}