{
  "metadata": {
    "collection_date": "2026-01-11T17:52:25.501244",
    "repository": "https://github.com/DescentDevelopers/Descent3",
    "repository_name": "DescentDevelopers/Descent3"
  },
  "commit_info": {
    "old_sha": "7d38dde25d8d8352b4a9bd560f91f09e39a9471b",
    "new_sha": "fbd63509172cac2da8c0e8c36aa39e8f24dff306",
    "commit_message": [
      "more software renderer code removal"
    ],
    "commit_date": "2024-05-09T11:11:49+00:00",
    "patch": [
      "--- 2dlib/surface.cpp\n@@ -266,11 +266,8 @@ void grSurface::load(char *data, int w, int h, char *pal) {\n \n   switch (ddsfObj.bpp) {\n   case BPP_16:\n-    if (Renderer_type == RENDERER_SOFTWARE_8BIT)\n-      xlat8_16(data, w, h, pal);\n-    else\n-      xlat16_16(data, w, h);\n-    break;\n+    // TODO: This is probably software renderer only?\n+    xlat16_16(data, w, h);\n   default:\n     Int3(); // NOT SUPPORTED YET\n   }\n--- Descent3/game.cpp\n@@ -1233,25 +1233,13 @@ void StartFrame(int x, int y, int x2, int y2, bool clear, bool push_on_stack) {\n     last_fov = Render_FOV;\n   }\n \n-  //\tfor software renderers perform frame buffer lock.\n-  if (Renderer_type == RENDERER_SOFTWARE_16BIT) {\n-    int w, h, color_depth, pitch;\n-    ubyte *data;\n-\n-    ddvid_GetVideoProperties(&w, &h, &color_depth);\n-    ddvid_LockFrameBuffer(&data, &pitch);\n-    rend_SetSoftwareParameters(ddvid_GetAspectRatio(), w, h, pitch, data);\n-  }\n-\n   if (push_on_stack) {\n     // push this frame onto the stack\n     FramePush(x, y, x2, y2, clear);\n   }\n \n   rend_StartFrame(x, y, x2, y2);\n-  if (Renderer_type == RENDERER_SOFTWARE_16BIT && clear) {\n-    rend_FillRect(GR_RGB(0, 0, 0), x, y, x2, y2);\n-  }\n+\n   grtext_SetParameters(0, 0, (x2 - x), (y2 - y));\n }\n \n@@ -1273,11 +1261,6 @@ void EndFrame() {\n   //@@Frame_inside = false;\n   rend_EndFrame();\n \n-  //\tfor software renderers perform unlock on frame buffer.\n-  if (Renderer_type == RENDERER_SOFTWARE_16BIT) {\n-    ddvid_UnlockFrameBuffer();\n-  }\n-\n   // pop off frame\n   int x1, x2, y1, y2;\n   bool clear;\n--- Descent3/init.cpp\n@@ -1484,12 +1484,6 @@ void LoadGameSettings() {\n   int len = _MAX_PATH;\n   Database->read(\"Default_pilot\", Default_pilot, &len);\n \n-  // If preferred renderer set to software, force it to be glide\n-  if ((PreferredRenderer == RENDERER_SOFTWARE_8BIT) || (PreferredRenderer == RENDERER_SOFTWARE_16BIT)) {\n-    Int3(); // Warning: rederer was set to Software.  Ok to ignore this.\n-    PreferredRenderer = RENDERER_OPENGL;\n-  }\n-\n   // Now that we have read in all the data, set the detail level if it is a predef setting (custom is ignored in\n   // function)\n \n--- bitmap/tga.cpp\n@@ -322,69 +322,6 @@ int bm_tga_read_outrage_compressed16(CFILE *infile, int n, int num_mips, int typ\n   return 1;\n }\n \n-// Reads a 8bit bitmap into memory\n-// Note: Even if we're are not using an 8bit renderer this routine still needs\n-// to be called due to the fact that we need to 'move' our position in the file\n-// We also need to extract the palette number\n-\n-/*int bm_tga_read_outrage_compressed8 (CFILE *infile,int n)\n-{\n-\n-        ubyte pal_num=tga_read_byte ();\n-        ubyte num_mips=tga_read_byte ();\n-\n-        ASSERT (pal_num>=0 && pal_num<=MAX_BITMAP_PALETTES);\n-        if (num_mips>1)\n-                GameBitmaps[n].mipmapped=1;\n-\n-        GameBitmaps[n].palette_num=pal_num;\n-\n-        for (int m=0;m<num_mips;m++)\n-        {\n-                int width=bm_w(n,m);\n-                int height=bm_h(n,m);\n-\n-                int total=height * width;\n-                int count=0;\n-                ubyte *data;\n-\n-                if (Renderer_type==RENDERER_SOFTWARE_8BIT)\n-                        data=bm_data8 (n,m);\n-                else\n-                        data=NULL;\n-\n-                while (count!=total)\n-                {\n-                        ASSERT (count<total);\n-\n-                        ubyte command=tga_read_byte ();\n-                        if (command==0)\t// next pixel is raw\n-                        {\n-                                ubyte pixel=tga_read_byte ();\n-                                int i=count/width;\n-                                int t=count%width;\n-                                if (Renderer_type==RENDERER_SOFTWARE_8BIT)\n-                                        data[i*256+t]=pixel;\n-                                count++;\n-                        }\n-                        else if (command>=2 && command<=250)\t// next pixel is run of pixels\n-                        {\n-                                ubyte pixel=tga_read_byte ();\n-                                for (int k=0;k<command;k++)\n-                                {\n-                                        int i=count/width;\n-                                        int t=count%width;\n-                                        if (Renderer_type==RENDERER_SOFTWARE_8BIT)\n-                                                data[i*256+t]=pixel;\n-                                        count++;\n-                                }\n-                        }\n-                        else Int3();\t\t// bad compression run\n-                }\n-        }\n-        return 1;\n-}*/\n-\n // Loads a tga or ogf file into a bitmap...returns handle to bm or -1 on error\n int bm_tga_alloc_file(CFILE *infile, char *name, int format) {\n   ubyte image_id_len, color_map_type, image_type, pixsize, descriptor;\n--- dd_vidwin32/ddvidlib.h\n@@ -100,9 +100,6 @@ bool ddvidfs_SetVideoMode(int w, int h, int color_depth, bool paged);\n //\tcloses video mode for fs\n void ddvidfs_CloseVideo();\n \n-//\tretrieves screen information for fullscreen version\n-void ddvidfs_GetVideoProperties(int *w, int *h, int *color_depth);\n-\n //\tflips screen if there's a back buffer\n void ddvidfs_VideoFlip();\n \n@@ -121,9 +118,6 @@ bool ddvidwin_SetVideoMode(int w, int h, int color_depth, bool paged, bool resch\n //\tcloses video mode for fs\n void ddvidwin_CloseVideo();\n \n-//\tretrieves screen information for windowed version\n-void ddvidwin_GetVideoProperties(int *w, int *h, int *color_depth);\n-\n //\tflips screen if there's a back buffer\n void ddvidwin_VideoFlip();\n \n--- dd_vidwin32/vidWin32FS.cpp\n@@ -192,15 +192,6 @@ void ddvidfs_CloseVideo() {\n   }\n }\n \n-//\tretrieves screen information for fullscreen version\n-void ddvidfs_GetVideoProperties(int *w, int *h, int *color_depth) {\n-  ASSERT(DDVideo_info.curmode > -1);\n-\n-  *w = DDVideo_info.DDModes[DDVideo_info.curmode].dwWidth;\n-  *h = DDVideo_info.DDModes[DDVideo_info.curmode].dwHeight;\n-  *color_depth = (int)DDVideo_info.DDModes[DDVideo_info.curmode].ddpfPixelFormat.dwRGBBitCount;\n-}\n-\n //\tflips screen if there's a back buffer\n void ddvidfs_VideoFlip() {\n   if (DDVideo_info.lpDDSBack)\n--- dd_vidwin32/video_win32.cpp\n@@ -188,126 +188,3 @@ bool ddvid_SetVideoMode(int w, int h, int color_depth, bool paged) {\n \n //\tsets screen handle\n void ddvid_SetVideoHandle(unsigned handle) { DDVideo_info.hVidWnd = (HWND)handle; }\n-\n-//\tretrieves screen information\n-void ddvid_GetVideoProperties(int *w, int *h, int *color_depth) {\n-  ASSERT(DDVideo_init);\n-\n-  switch (DDVideo_info.subsystem) {\n-  case VID_GDIF_SUBSYSTEM:\n-  case VID_GDI_SUBSYSTEM:\n-    ddvidwin_GetVideoProperties(w, h, color_depth);\n-    break;\n-  case VID_GDIX_SUBSYSTEM:\n-    ddvidfs_GetVideoProperties(w, h, color_depth);\n-    break;\n-  case VID_DX_SUBSYSTEM:\n-    ddvidfs_GetVideoProperties(w, h, color_depth);\n-    break;\n-  default:\n-    Int3();\n-  }\n-}\n-\n-//\tretrieves screen aspect ratio.\n-float ddvid_GetAspectRatio() {\n-  float aspect_ratio = (float)((3.0 * GetSystemMetrics(SM_CXSCREEN)) / (4.0 * GetSystemMetrics(SM_CYSCREEN)));\n-  return aspect_ratio;\n-}\n-\n-// only available to DD_ACCESS libraries.\n-//\tdd_obj is the DIRECTDRAW OBJECT for the system.\n-//\tdds_obj is the DIRECTDRAWSURFACE OBJECT for the screen\n-void ddvid_GetVideoDDrawProps(uint *dd_obj, uint *dds_obj) {\n-  switch (DDVideo_info.subsystem) {\n-  case VID_GDIX_SUBSYSTEM:\n-    *dd_obj = NULL;\n-    break;\n-  case VID_DX_SUBSYSTEM:\n-    *dd_obj = ddvidfs_GetDirectDrawObject();\n-    break;\n-  }\n-\n-  *dds_obj = NULL;\n-}\n-\n-//\tflips screen if there's a back buffer\n-void ddvid_VideoFlip() {\n-  switch (DDVideo_info.subsystem) {\n-  case VID_GDIF_SUBSYSTEM:\n-  case VID_GDI_SUBSYSTEM:\n-    ddvidwin_VideoFlip();\n-    break;\n-  case VID_GDIX_SUBSYSTEM:\n-    ddvidwin_VideoFlip();\n-    break;\n-  case VID_DX_SUBSYSTEM:\n-    ddvidfs_VideoFlip();\n-    break;\n-  default:\n-    Int3();\n-  }\n-}\n-\n-//\tretreives frame buffer info for a video mode.\n-void ddvid_LockFrameBuffer(ubyte **data, int *pitch) {\n-  //\tlocks a direct draw paged surface or a paged window.  unpaged buffers won't lock.\n-  ASSERT(DDVideo_init);\n-\n-  switch (DDVideo_info.subsystem) {\n-  case VID_GDIF_SUBSYSTEM:\n-  case VID_GDI_SUBSYSTEM: {\n-    *data = (ubyte *)DDVideo_info.gdi.data;\n-    *pitch = DDVideo_info.gdi.pitch;\n-  } break;\n-  case VID_GDIX_SUBSYSTEM: {\n-    *data = (ubyte *)DDVideo_info.gdi.data;\n-    *pitch = DDVideo_info.gdi.pitch;\n-  } break;\n-  case VID_DX_SUBSYSTEM: {\n-    HRESULT hres;\n-    DDSURFACEDESC ddsd;\n-\n-    memset(&ddsd, 0, sizeof(ddsd));\n-    ddsd.dwSize = sizeof(ddsd);\n-\n-    if (DDVideo_info.lpDDSBack) {\n-      hres = DDVideo_info.lpDDSBack->Lock(NULL, &ddsd, DDLOCK_WAIT, NULL);\n-      if (hres != DD_OK) {\n-        Error(\"Unable to set lock DirectDraw surface(%d)\\n\", LOWORD(hres));\n-      }\n-      *pitch = (int)ddsd.lPitch;\n-      *data = (ubyte *)ddsd.lpSurface;\n-      DDVideo_info.surf_data = (char *)(*data);\n-    } else {\n-      *data = NULL;\n-      *pitch = 0;\n-    }\n-  } break;\n-  default:\n-    Int3();\n-  }\n-}\n-\n-void ddvid_UnlockFrameBuffer() {\n-  ASSERT(DDVideo_init);\n-\n-  switch (DDVideo_info.subsystem) {\n-  case VID_GDIF_SUBSYSTEM:\n-  case VID_GDI_SUBSYSTEM:\n-  case VID_GDIX_SUBSYSTEM:\n-    break;\n-  case VID_DX_SUBSYSTEM: {\n-    HRESULT hres;\n-\n-    if (DDVideo_info.lpDDSBack) {\n-      hres = DDVideo_info.lpDDSBack->Unlock(DDVideo_info.surf_data);\n-      if (hres != DD_OK)\n-        Error(\"Unable to unlock DirectDraw surface(%d)\\n\", LOWORD(hres));\n-      DDVideo_info.surf_data = NULL;\n-    }\n-  } break;\n-  default:\n-    Int3();\n-  }\n-}\n--- ddvid_lnx/video_lnx.cpp\n@@ -153,59 +153,3 @@ bool ddvid_SetVideoMode(int w, int h, int color_depth, bool paged) {\n \n //\tsets screen handle\n void ddvid_SetVideoHandle(unsigned handle) {}\n-\n-//\tretrieves screen information\n-void ddvid_GetVideoProperties(int *w, int *h, int *color_depth) {\n-  *w = 640;\n-  *h = 480;\n-  *color_depth = 16;\n-\n-  /*\n-    ASSERT(DDVideo_init);\n-    if(!DDVideo_info.info){\n-      *w = *h = *color_depth = 0;\n-      return;\n-    }\n-    *w = DDVideo_info.info->width;\n-    *h = DDVideo_info.info->height;\n-    *color_depth = DDVideo_info.info->bytesperpixel;\n-  */\n-}\n-\n-//\tretrieves screen aspect ratio.\n-float ddvid_GetAspectRatio() {\n-  /*\n-    float aspect_ratio = (float)((3.0 * vga_getxdim())/(4.0 * vga_getydim()));\n-    return aspect_ratio;\n-  */\n-  return 0.75f;\n-}\n-\n-//\tflips screen if there's a back buffer\n-void ddvid_VideoFlip() {\n-  if (!DDVideo_info.paged)\n-    return;\n-  // vga_flip();\n-}\n-\n-//\tretreives frame buffer info for a video mode.\n-void ddvid_LockFrameBuffer(ubyte **data, int *pitch) {\n-  *data = NULL;\n-  *pitch = 0;\n-\n-  /*\n-    ASSERT(DDVideo_init);\n-    if(!DDVideo_info.info){\n-      *data = NULL;\n-      *pitch = 0;\n-      return;\n-    }\n-\n-    // *data = vga_getgraphmem();\n-    *pitch = DDVideo_info.info->linewidth;\n-  */\n-}\n-\n-void ddvid_UnlockFrameBuffer() {\n-  // ASSERT(DDVideo_init);\n-}\n--- lib/ddvid.h\n@@ -59,29 +59,4 @@ bool ddvid_SetVideoMode(int w, int h, int color_depth, bool paged);\n //\tsets screen handle\n void ddvid_SetVideoHandle(unsigned handle);\n \n-//\tretrieves screen information\n-void ddvid_GetVideoProperties(int *w, int *h, int *color_depth);\n-\n-//\tretrieves screen aspect ratio.\n-float ddvid_GetAspectRatio();\n-\n-//\tretreives frame buffer info for a video mode.\n-void ddvid_LockFrameBuffer(ubyte **data, int *pitch);\n-void ddvid_UnlockFrameBuffer();\n-\n-//\tflips screen if there's a back buffer\n-void ddvid_VideoFlip();\n-\n-// only available to DD_ACCESS libraries.\n-#if defined(DD_ACCESS_RING)\n-#if defined(WIN32)\n-\n-//\tdd_obj is the DIRECTDRAW OBJECT for the system.\n-//\tdds_obj is the DIRECTDRAWSURFACE OBJECT for the screen\n-void ddvid_GetVideoDDrawProps(uint *dd_obj, uint *dds_obj);\n-\n-#endif // WIN32\n-\n-#endif // DD_ACCESS\n-\n #endif\n--- lib/renderer.h\n@@ -316,8 +316,6 @@ extern int Triangles_drawn;\n \n // Is this hardware or software rendered?\n typedef enum {\n-  RENDERER_SOFTWARE_8BIT,\n-  RENDERER_SOFTWARE_16BIT,\n   RENDERER_OPENGL,\n   RENDERER_DIRECT3D,\n   RENDERER_GLIDE,\n--- ui/UIDraw.cpp\n@@ -100,16 +100,6 @@ static int m_UITextFlags = 0;\n //\tDRAWING PRIMATIVE FUNCTIONS\n \n void ui_StartDraw(int left, int top, int right, int bottom) {\n-  //\tfor software renderers perform frame buffer lock.\n-  if (Renderer_type == RENDERER_SOFTWARE_16BIT) {\n-    int w, h, color_depth, pitch;\n-    ubyte *data;\n-\n-    ddvid_GetVideoProperties(&w, &h, &color_depth);\n-    ddvid_LockFrameBuffer(&data, &pitch);\n-    rend_SetSoftwareParameters(ddvid_GetAspectRatio(), w, h, pitch, data);\n-  }\n-\n   m_UIDrawLeft = left;\n   m_UIDrawTop = top;\n   m_UIDrawRight = right;\n@@ -123,11 +113,6 @@ void ui_StartDraw(int left, int top, int right, int bottom) {\n void ui_EndDraw() {\n   grtext_Flush();\n   rend_EndFrame();\n-\n-  //\tfor software renderers perform unlock on frame buffer.\n-  if (Renderer_type == RENDERER_SOFTWARE_16BIT) {\n-    ddvid_UnlockFrameBuffer();\n-  }\n }\n \n //\tsets text clipping within the startdraw region"
    ],
    "files_changed": [
      {
        "filename": "2dlib/surface.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "patch": "@@ -266,11 +266,8 @@ void grSurface::load(char *data, int w, int h, char *pal) {\n \n   switch (ddsfObj.bpp) {\n   case BPP_16:\n-    if (Renderer_type == RENDERER_SOFTWARE_8BIT)\n-      xlat8_16(data, w, h, pal);\n-    else\n-      xlat16_16(data, w, h);\n-    break;\n+    // TODO: This is probably software renderer only?\n+    xlat16_16(data, w, h);\n   default:\n     Int3(); // NOT SUPPORTED YET\n   }"
      },
      {
        "filename": "Descent3/game.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 18,
        "changes": 19,
        "patch": "@@ -1233,25 +1233,13 @@ void StartFrame(int x, int y, int x2, int y2, bool clear, bool push_on_stack) {\n     last_fov = Render_FOV;\n   }\n \n-  //\tfor software renderers perform frame buffer lock.\n-  if (Renderer_type == RENDERER_SOFTWARE_16BIT) {\n-    int w, h, color_depth, pitch;\n-    ubyte *data;\n-\n-    ddvid_GetVideoProperties(&w, &h, &color_depth);\n-    ddvid_LockFrameBuffer(&data, &pitch);\n-    rend_SetSoftwareParameters(ddvid_GetAspectRatio(), w, h, pitch, data);\n-  }\n-\n   if (push_on_stack) {\n     // push this frame onto the stack\n     FramePush(x, y, x2, y2, clear);\n   }\n \n   rend_StartFrame(x, y, x2, y2);\n-  if (Renderer_type == RENDERER_SOFTWARE_16BIT && clear) {\n-    rend_FillRect(GR_RGB(0, 0, 0), x, y, x2, y2);\n-  }\n+\n   grtext_SetParameters(0, 0, (x2 - x), (y2 - y));\n }\n \n@@ -1273,11 +1261,6 @@ void EndFrame() {\n   //@@Frame_inside = false;\n   rend_EndFrame();\n \n-  //\tfor software renderers perform unlock on frame buffer.\n-  if (Renderer_type == RENDERER_SOFTWARE_16BIT) {\n-    ddvid_UnlockFrameBuffer();\n-  }\n-\n   // pop off frame\n   int x1, x2, y1, y2;\n   bool clear;"
      },
      {
        "filename": "Descent3/init.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "patch": "@@ -1484,12 +1484,6 @@ void LoadGameSettings() {\n   int len = _MAX_PATH;\n   Database->read(\"Default_pilot\", Default_pilot, &len);\n \n-  // If preferred renderer set to software, force it to be glide\n-  if ((PreferredRenderer == RENDERER_SOFTWARE_8BIT) || (PreferredRenderer == RENDERER_SOFTWARE_16BIT)) {\n-    Int3(); // Warning: rederer was set to Software.  Ok to ignore this.\n-    PreferredRenderer = RENDERER_OPENGL;\n-  }\n-\n   // Now that we have read in all the data, set the detail level if it is a predef setting (custom is ignored in\n   // function)\n "
      },
      {
        "filename": "bitmap/tga.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 63,
        "changes": 63,
        "patch": "@@ -322,69 +322,6 @@ int bm_tga_read_outrage_compressed16(CFILE *infile, int n, int num_mips, int typ\n   return 1;\n }\n \n-// Reads a 8bit bitmap into memory\n-// Note: Even if we're are not using an 8bit renderer this routine still needs\n-// to be called due to the fact that we need to 'move' our position in the file\n-// We also need to extract the palette number\n-\n-/*int bm_tga_read_outrage_compressed8 (CFILE *infile,int n)\n-{\n-\n-        ubyte pal_num=tga_read_byte ();\n-        ubyte num_mips=tga_read_byte ();\n-\n-        ASSERT (pal_num>=0 && pal_num<=MAX_BITMAP_PALETTES);\n-        if (num_mips>1)\n-                GameBitmaps[n].mipmapped=1;\n-\n-        GameBitmaps[n].palette_num=pal_num;\n-\n-        for (int m=0;m<num_mips;m++)\n-        {\n-                int width=bm_w(n,m);\n-                int height=bm_h(n,m);\n-\n-                int total=height * width;\n-                int count=0;\n-                ubyte *data;\n-\n-                if (Renderer_type==RENDERER_SOFTWARE_8BIT)\n-                        data=bm_data8 (n,m);\n-                else\n-                        data=NULL;\n-\n-                while (count!=total)\n-                {\n-                        ASSERT (count<total);\n-\n-                        ubyte command=tga_read_byte ();\n-                        if (command==0)\t// next pixel is raw\n-                        {\n-                                ubyte pixel=tga_read_byte ();\n-                                int i=count/width;\n-                                int t=count%width;\n-                                if (Renderer_type==RENDERER_SOFTWARE_8BIT)\n-                                        data[i*256+t]=pixel;\n-                                count++;\n-                        }\n-                        else if (command>=2 && command<=250)\t// next pixel is run of pixels\n-                        {\n-                                ubyte pixel=tga_read_byte ();\n-                                for (int k=0;k<command;k++)\n-                                {\n-                                        int i=count/width;\n-                                        int t=count%width;\n-                                        if (Renderer_type==RENDERER_SOFTWARE_8BIT)\n-                                                data[i*256+t]=pixel;\n-                                        count++;\n-                                }\n-                        }\n-                        else Int3();\t\t// bad compression run\n-                }\n-        }\n-        return 1;\n-}*/\n-\n // Loads a tga or ogf file into a bitmap...returns handle to bm or -1 on error\n int bm_tga_alloc_file(CFILE *infile, char *name, int format) {\n   ubyte image_id_len, color_map_type, image_type, pixsize, descriptor;"
      },
      {
        "filename": "dd_vidwin32/ddvidlib.h",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "patch": "@@ -100,9 +100,6 @@ bool ddvidfs_SetVideoMode(int w, int h, int color_depth, bool paged);\n //\tcloses video mode for fs\n void ddvidfs_CloseVideo();\n \n-//\tretrieves screen information for fullscreen version\n-void ddvidfs_GetVideoProperties(int *w, int *h, int *color_depth);\n-\n //\tflips screen if there's a back buffer\n void ddvidfs_VideoFlip();\n \n@@ -121,9 +118,6 @@ bool ddvidwin_SetVideoMode(int w, int h, int color_depth, bool paged, bool resch\n //\tcloses video mode for fs\n void ddvidwin_CloseVideo();\n \n-//\tretrieves screen information for windowed version\n-void ddvidwin_GetVideoProperties(int *w, int *h, int *color_depth);\n-\n //\tflips screen if there's a back buffer\n void ddvidwin_VideoFlip();\n "
      },
      {
        "filename": "dd_vidwin32/vidWin32FS.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 9,
        "changes": 9,
        "patch": "@@ -192,15 +192,6 @@ void ddvidfs_CloseVideo() {\n   }\n }\n \n-//\tretrieves screen information for fullscreen version\n-void ddvidfs_GetVideoProperties(int *w, int *h, int *color_depth) {\n-  ASSERT(DDVideo_info.curmode > -1);\n-\n-  *w = DDVideo_info.DDModes[DDVideo_info.curmode].dwWidth;\n-  *h = DDVideo_info.DDModes[DDVideo_info.curmode].dwHeight;\n-  *color_depth = (int)DDVideo_info.DDModes[DDVideo_info.curmode].ddpfPixelFormat.dwRGBBitCount;\n-}\n-\n //\tflips screen if there's a back buffer\n void ddvidfs_VideoFlip() {\n   if (DDVideo_info.lpDDSBack)"
      },
      {
        "filename": "dd_vidwin32/video_win32.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 123,
        "changes": 123,
        "patch": "@@ -188,126 +188,3 @@ bool ddvid_SetVideoMode(int w, int h, int color_depth, bool paged) {\n \n //\tsets screen handle\n void ddvid_SetVideoHandle(unsigned handle) { DDVideo_info.hVidWnd = (HWND)handle; }\n-\n-//\tretrieves screen information\n-void ddvid_GetVideoProperties(int *w, int *h, int *color_depth) {\n-  ASSERT(DDVideo_init);\n-\n-  switch (DDVideo_info.subsystem) {\n-  case VID_GDIF_SUBSYSTEM:\n-  case VID_GDI_SUBSYSTEM:\n-    ddvidwin_GetVideoProperties(w, h, color_depth);\n-    break;\n-  case VID_GDIX_SUBSYSTEM:\n-    ddvidfs_GetVideoProperties(w, h, color_depth);\n-    break;\n-  case VID_DX_SUBSYSTEM:\n-    ddvidfs_GetVideoProperties(w, h, color_depth);\n-    break;\n-  default:\n-    Int3();\n-  }\n-}\n-\n-//\tretrieves screen aspect ratio.\n-float ddvid_GetAspectRatio() {\n-  float aspect_ratio = (float)((3.0 * GetSystemMetrics(SM_CXSCREEN)) / (4.0 * GetSystemMetrics(SM_CYSCREEN)));\n-  return aspect_ratio;\n-}\n-\n-// only available to DD_ACCESS libraries.\n-//\tdd_obj is the DIRECTDRAW OBJECT for the system.\n-//\tdds_obj is the DIRECTDRAWSURFACE OBJECT for the screen\n-void ddvid_GetVideoDDrawProps(uint *dd_obj, uint *dds_obj) {\n-  switch (DDVideo_info.subsystem) {\n-  case VID_GDIX_SUBSYSTEM:\n-    *dd_obj = NULL;\n-    break;\n-  case VID_DX_SUBSYSTEM:\n-    *dd_obj = ddvidfs_GetDirectDrawObject();\n-    break;\n-  }\n-\n-  *dds_obj = NULL;\n-}\n-\n-//\tflips screen if there's a back buffer\n-void ddvid_VideoFlip() {\n-  switch (DDVideo_info.subsystem) {\n-  case VID_GDIF_SUBSYSTEM:\n-  case VID_GDI_SUBSYSTEM:\n-    ddvidwin_VideoFlip();\n-    break;\n-  case VID_GDIX_SUBSYSTEM:\n-    ddvidwin_VideoFlip();\n-    break;\n-  case VID_DX_SUBSYSTEM:\n-    ddvidfs_VideoFlip();\n-    break;\n-  default:\n-    Int3();\n-  }\n-}\n-\n-//\tretreives frame buffer info for a video mode.\n-void ddvid_LockFrameBuffer(ubyte **data, int *pitch) {\n-  //\tlocks a direct draw paged surface or a paged window.  unpaged buffers won't lock.\n-  ASSERT(DDVideo_init);\n-\n-  switch (DDVideo_info.subsystem) {\n-  case VID_GDIF_SUBSYSTEM:\n-  case VID_GDI_SUBSYSTEM: {\n-    *data = (ubyte *)DDVideo_info.gdi.data;\n-    *pitch = DDVideo_info.gdi.pitch;\n-  } break;\n-  case VID_GDIX_SUBSYSTEM: {\n-    *data = (ubyte *)DDVideo_info.gdi.data;\n-    *pitch = DDVideo_info.gdi.pitch;\n-  } break;\n-  case VID_DX_SUBSYSTEM: {\n-    HRESULT hres;\n-    DDSURFACEDESC ddsd;\n-\n-    memset(&ddsd, 0, sizeof(ddsd));\n-    ddsd.dwSize = sizeof(ddsd);\n-\n-    if (DDVideo_info.lpDDSBack) {\n-      hres = DDVideo_info.lpDDSBack->Lock(NULL, &ddsd, DDLOCK_WAIT, NULL);\n-      if (hres != DD_OK) {\n-        Error(\"Unable to set lock DirectDraw surface(%d)\\n\", LOWORD(hres));\n-      }\n-      *pitch = (int)ddsd.lPitch;\n-      *data = (ubyte *)ddsd.lpSurface;\n-      DDVideo_info.surf_data = (char *)(*data);\n-    } else {\n-      *data = NULL;\n-      *pitch = 0;\n-    }\n-  } break;\n-  default:\n-    Int3();\n-  }\n-}\n-\n-void ddvid_UnlockFrameBuffer() {\n-  ASSERT(DDVideo_init);\n-\n-  switch (DDVideo_info.subsystem) {\n-  case VID_GDIF_SUBSYSTEM:\n-  case VID_GDI_SUBSYSTEM:\n-  case VID_GDIX_SUBSYSTEM:\n-    break;\n-  case VID_DX_SUBSYSTEM: {\n-    HRESULT hres;\n-\n-    if (DDVideo_info.lpDDSBack) {\n-      hres = DDVideo_info.lpDDSBack->Unlock(DDVideo_info.surf_data);\n-      if (hres != DD_OK)\n-        Error(\"Unable to unlock DirectDraw surface(%d)\\n\", LOWORD(hres));\n-      DDVideo_info.surf_data = NULL;\n-    }\n-  } break;\n-  default:\n-    Int3();\n-  }\n-}"
      },
      {
        "filename": "ddvid_lnx/video_lnx.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 56,
        "changes": 56,
        "patch": "@@ -153,59 +153,3 @@ bool ddvid_SetVideoMode(int w, int h, int color_depth, bool paged) {\n \n //\tsets screen handle\n void ddvid_SetVideoHandle(unsigned handle) {}\n-\n-//\tretrieves screen information\n-void ddvid_GetVideoProperties(int *w, int *h, int *color_depth) {\n-  *w = 640;\n-  *h = 480;\n-  *color_depth = 16;\n-\n-  /*\n-    ASSERT(DDVideo_init);\n-    if(!DDVideo_info.info){\n-      *w = *h = *color_depth = 0;\n-      return;\n-    }\n-    *w = DDVideo_info.info->width;\n-    *h = DDVideo_info.info->height;\n-    *color_depth = DDVideo_info.info->bytesperpixel;\n-  */\n-}\n-\n-//\tretrieves screen aspect ratio.\n-float ddvid_GetAspectRatio() {\n-  /*\n-    float aspect_ratio = (float)((3.0 * vga_getxdim())/(4.0 * vga_getydim()));\n-    return aspect_ratio;\n-  */\n-  return 0.75f;\n-}\n-\n-//\tflips screen if there's a back buffer\n-void ddvid_VideoFlip() {\n-  if (!DDVideo_info.paged)\n-    return;\n-  // vga_flip();\n-}\n-\n-//\tretreives frame buffer info for a video mode.\n-void ddvid_LockFrameBuffer(ubyte **data, int *pitch) {\n-  *data = NULL;\n-  *pitch = 0;\n-\n-  /*\n-    ASSERT(DDVideo_init);\n-    if(!DDVideo_info.info){\n-      *data = NULL;\n-      *pitch = 0;\n-      return;\n-    }\n-\n-    // *data = vga_getgraphmem();\n-    *pitch = DDVideo_info.info->linewidth;\n-  */\n-}\n-\n-void ddvid_UnlockFrameBuffer() {\n-  // ASSERT(DDVideo_init);\n-}"
      },
      {
        "filename": "lib/ddvid.h",
        "status": "modified",
        "additions": 0,
        "deletions": 25,
        "changes": 25,
        "patch": "@@ -59,29 +59,4 @@ bool ddvid_SetVideoMode(int w, int h, int color_depth, bool paged);\n //\tsets screen handle\n void ddvid_SetVideoHandle(unsigned handle);\n \n-//\tretrieves screen information\n-void ddvid_GetVideoProperties(int *w, int *h, int *color_depth);\n-\n-//\tretrieves screen aspect ratio.\n-float ddvid_GetAspectRatio();\n-\n-//\tretreives frame buffer info for a video mode.\n-void ddvid_LockFrameBuffer(ubyte **data, int *pitch);\n-void ddvid_UnlockFrameBuffer();\n-\n-//\tflips screen if there's a back buffer\n-void ddvid_VideoFlip();\n-\n-// only available to DD_ACCESS libraries.\n-#if defined(DD_ACCESS_RING)\n-#if defined(WIN32)\n-\n-//\tdd_obj is the DIRECTDRAW OBJECT for the system.\n-//\tdds_obj is the DIRECTDRAWSURFACE OBJECT for the screen\n-void ddvid_GetVideoDDrawProps(uint *dd_obj, uint *dds_obj);\n-\n-#endif // WIN32\n-\n-#endif // DD_ACCESS\n-\n #endif"
      },
      {
        "filename": "lib/renderer.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "patch": "@@ -316,8 +316,6 @@ extern int Triangles_drawn;\n \n // Is this hardware or software rendered?\n typedef enum {\n-  RENDERER_SOFTWARE_8BIT,\n-  RENDERER_SOFTWARE_16BIT,\n   RENDERER_OPENGL,\n   RENDERER_DIRECT3D,\n   RENDERER_GLIDE,"
      },
      {
        "filename": "ui/UIDraw.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 15,
        "changes": 15,
        "patch": "@@ -100,16 +100,6 @@ static int m_UITextFlags = 0;\n //\tDRAWING PRIMATIVE FUNCTIONS\n \n void ui_StartDraw(int left, int top, int right, int bottom) {\n-  //\tfor software renderers perform frame buffer lock.\n-  if (Renderer_type == RENDERER_SOFTWARE_16BIT) {\n-    int w, h, color_depth, pitch;\n-    ubyte *data;\n-\n-    ddvid_GetVideoProperties(&w, &h, &color_depth);\n-    ddvid_LockFrameBuffer(&data, &pitch);\n-    rend_SetSoftwareParameters(ddvid_GetAspectRatio(), w, h, pitch, data);\n-  }\n-\n   m_UIDrawLeft = left;\n   m_UIDrawTop = top;\n   m_UIDrawRight = right;\n@@ -123,11 +113,6 @@ void ui_StartDraw(int left, int top, int right, int bottom) {\n void ui_EndDraw() {\n   grtext_Flush();\n   rend_EndFrame();\n-\n-  //\tfor software renderers perform unlock on frame buffer.\n-  if (Renderer_type == RENDERER_SOFTWARE_16BIT) {\n-    ddvid_UnlockFrameBuffer();\n-  }\n }\n \n //\tsets text clipping within the startdraw region"
      }
    ],
    "lines_added": 3,
    "lines_removed": 328
  },
  "issues": [],
  "pull_requests": [],
  "build_info": {
    "old_build_script": "#!/bin/bash\n#!/bin/bash\ncmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON",
    "new_build_script": "#!/bin/bash\n#!/bin/bash\ncmake -S /test_workspace/workspace/old -B /test_workspace/workspace/old/build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DBUILD_TESTING=ON",
    "old_test_script": "#!/bin/bash\ncmake --build /test_workspace/workspace/old/build -- -j 1",
    "new_test_script": "#!/bin/bash\ncmake --build /test_workspace/workspace/old/build -- -j 1",
    "build_system": "cmake"
  },
  "performance_analysis": {
    "is_significant": false,
    "p_value": 0.9803231017051379,
    "is_pair_significant": false,
    "pair_p_value": 0.9752489115485791,
    "is_binom_significant": false,
    "binom_p_value": 0.9999999990686774,
    "is_wilcoxon_significant": false,
    "wilcoxon_p_value": 0.999998699808437,
    "is_mannwhitney_significant": false,
    "mannwhitney_p_value": 0.16685534787178302,
    "relative_improvement": 0.016393442622950834,
    "absolute_improvement_ms": 0.3333333333333313,
    "old_mean_ms": 20.333333333333336,
    "new_mean_ms": 20.000000000000004,
    "old_std_ms": 1.8257418583505538,
    "new_std_ms": 3.5287580338023136e-15,
    "effect_size_cohens_d": 0.25819888974715954,
    "old_ci95_ms": [
      19.6515901192891,
      21.01507654737757
    ],
    "new_ci95_ms": [
      20.000000000000004,
      20.000000000000004
    ],
    "old_ci99_ms": [
      19.41453803210989,
      21.25212863455678
    ],
    "new_ci99_ms": [
      20.0,
      20.000000000000007
    ],
    "new_times_s": [
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02
    ],
    "old_times_s": [
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.02,
      0.03,
      0.02,
      0.02,
      0.02
    ]
  },
  "tests": {
    "total_tests": 0,
    "significant_improvements": 0,
    "significant_improvements_tests": [],
    "significant_regressions": 0,
    "significant_regressions_tests": [],
    "significant_pair_improvements": 0,
    "significant_pair_improvements_tests": [],
    "significant_pair_regressions": 0,
    "significant_pair_regressions_tests": [],
    "significant_binom_improvements": 0,
    "significant_binom_improvements_tests": [],
    "significant_binom_regressions": 0,
    "significant_binom_regressions_tests": [],
    "significant_wilcoxon_improvements": 0,
    "significant_wilcoxon_improvements_tests": [],
    "significant_wilcoxon_regressions": 0,
    "significant_wilcoxon_regressions_tests": [],
    "significant_mannwhitney_improvements": 0,
    "significant_mannwhitney_improvements_tests": [],
    "significant_mannwhitney_regressions": 0,
    "significant_mannwhitney_regressions_tests": [],
    "tests": []
  },
  "logs": {
    "full_log_path": "/logs/full.log",
    "config_log_path": "/logs/config.log",
    "build_log_path": "/logs/build.log",
    "test_log_path": "/logs/test.log",
    "build_success": true,
    "test_success": true
  },
  "raw_timing_data": {
    "warmup_runs": 1,
    "measurement_runs": 30,
    "min_exec_time_improvement": 0.05,
    "min_p_value": 0.05
  }
}