diff --git a/hwy/ops/arm_neon-inl.h b/hwy/ops/arm_neon-inl.h
index e0737552..be2044b0 100644
--- a/hwy/ops/arm_neon-inl.h
+++ b/hwy/ops/arm_neon-inl.h
@@ -7217,6 +7217,93 @@ HWY_API Vec32<uint32_t> RearrangeToOddPlusEven(Vec32<uint32_t> sum0,
 
 // ------------------------------ WidenMulPairwiseAdd
 
+// ------------------------------ SumOfMulQuadAccumulate (NEON dotprod)
+
+#if defined(__ARM_FEATURE_DOTPROD) || HWY_TARGET == HWY_NEON_BF16
+
+#ifdef HWY_NATIVE_I8_I8_SUMOFMULQUADACCUMULATE
+#undef HWY_NATIVE_I8_I8_SUMOFMULQUADACCUMULATE
+#else
+#define HWY_NATIVE_I8_I8_SUMOFMULQUADACCUMULATE
+#endif
+
+// int8 x int8 -> int32 accumulation using NEON DOT
+template <class DI32, HWY_IF_I32_D(DI32), HWY_IF_V_SIZE_D(DI32, 16)>
+HWY_API VFromD<DI32> SumOfMulQuadAccumulate(
+    DI32 /*di32*/, VFromD<Repartition<int8_t, DI32>> a,
+    VFromD<Repartition<int8_t, DI32>> b, VFromD<DI32> sum) {
+  return VFromD<DI32>(vdotq_s32(sum.raw, a.raw, b.raw));
+}
+
+template <class DI32, HWY_IF_I32_D(DI32), HWY_IF_V_SIZE_LE_D(DI32, 8)>
+HWY_API VFromD<DI32> SumOfMulQuadAccumulate(
+    DI32 /*di32*/, VFromD<Repartition<int8_t, DI32>> a,
+    VFromD<Repartition<int8_t, DI32>> b, VFromD<DI32> sum) {
+  return VFromD<DI32>(vdot_s32(sum.raw, a.raw, b.raw));
+}
+
+#ifdef HWY_NATIVE_U8_U8_SUMOFMULQUADACCUMULATE
+#undef HWY_NATIVE_U8_U8_SUMOFMULQUADACCUMULATE
+#else
+#define HWY_NATIVE_U8_U8_SUMOFMULQUADACCUMULATE
+#endif
+
+// uint8 x uint8 -> uint32 accumulation using NEON DOT
+template <class DU32, HWY_IF_U32_D(DU32), HWY_IF_V_SIZE_D(DU32, 16)>
+HWY_API VFromD<DU32> SumOfMulQuadAccumulate(
+    DU32 /*du32*/, VFromD<Repartition<uint8_t, DU32>> a,
+    VFromD<Repartition<uint8_t, DU32>> b, VFromD<DU32> sum) {
+  return VFromD<DU32>(vdotq_u32(sum.raw, a.raw, b.raw));
+}
+
+template <class DU32, HWY_IF_U32_D(DU32), HWY_IF_V_SIZE_LE_D(DU32, 8)>
+HWY_API VFromD<DU32> SumOfMulQuadAccumulate(
+    DU32 /*du32*/, VFromD<Repartition<uint8_t, DU32>> a,
+    VFromD<Repartition<uint8_t, DU32>> b, VFromD<DU32> sum) {
+  return VFromD<DU32>(vdot_u32(sum.raw, a.raw, b.raw));
+}
+
+#ifdef HWY_NATIVE_U8_I8_SUMOFMULQUADACCUMULATE
+#undef HWY_NATIVE_U8_I8_SUMOFMULQUADACCUMULATE
+#else
+#define HWY_NATIVE_U8_I8_SUMOFMULQUADACCUMULATE
+#endif
+
+// uint8 x int8 -> int32 accumulation (mixed signedness) using NEON DOT with
+// decomposition similar to SVE implementation.
+template <class DI32, HWY_IF_I32_D(DI32)>
+HWY_API VFromD<DI32> SumOfMulQuadAccumulate(
+    DI32 di32, VFromD<Repartition<uint8_t, DI32>> a_u,
+    VFromD<Repartition<int8_t, DI32>> b_i, VFromD<DI32> sum) {
+  const Repartition<uint8_t, decltype(di32)> du8;
+  const RebindToUnsigned<decltype(di32)> du32;
+  const RebindToSigned<decltype(du8)> di8;
+
+  const auto b_u = BitCast(du8, b_i);
+
+  // Full vector
+  if constexpr (decltype(di32)::MaxLanes() == 4) {
+    const auto result_sum0 = VFromD<decltype(du32)>(
+        vdotq_u32(BitCast(du32, sum).raw, a_u.raw, b_u.raw));
+    const auto shifted_b = ShiftRight<7>(b_u);
+    const auto result_sum1 = ShiftLeft<8>(
+        VFromD<decltype(du32)>(vdotq_u32(Zero(du32).raw, a_u.raw, shifted_b.raw)));
+    return BitCast(di32, Sub(result_sum0, result_sum1));
+  } else {
+    // 64-bit or smaller vector lanes
+    const auto result_sum0 = VFromD<decltype(du32)>(
+        vdot_u32(BitCast(du32, sum).raw, a_u.raw, b_u.raw));
+    const auto shifted_b = ShiftRight<7>(b_u);
+    const auto result_sum1 = ShiftLeft<8>(
+        VFromD<decltype(du32)>(vdot_u32(Zero(du32).raw, a_u.raw, shifted_b.raw)));
+    return BitCast(di32, Sub(result_sum0, result_sum1));
+  }
+}
+
+#endif  // defined(__ARM_FEATURE_DOTPROD) || HWY_TARGET == HWY_NEON_BF16
+
+// ------------------------------ WidenMulPairwiseAdd
+
 #if HWY_NEON_HAVE_F32_TO_BF16C
 
 template <class DF, HWY_IF_V_SIZE_D(DF, 16)>
