diff --git a/core/src/HybridBinarizer.cpp b/core/src/HybridBinarizer.cpp
index faa4cd4e..6a124039 100644
--- a/core/src/HybridBinarizer.cpp
+++ b/core/src/HybridBinarizer.cpp
@@ -31,7 +31,7 @@ HybridBinarizer::~HybridBinarizer() = default;
 * See the following thread for a discussion of this algorithm:
 *  http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0
 */
-static Matrix<int> CalculateBlackPoints(const uint8_t* luminances, int subWidth, int subHeight, int width, int height, int rowStride)
+static Matrix<int> CalculateBlackPoints(const uint8_t* __restrict luminances, int subWidth, int subHeight, int width, int height, int rowStride)
 {
 	Matrix<int>	blackPoints(subWidth, subHeight);
 
@@ -98,14 +98,14 @@ static Matrix<int> CalculateBlackPoints(const uint8_t* luminances, int subWidth,
 /**
 * Applies a single threshold to a block of pixels.
 */
-static void ThresholdBlock(const uint8_t* luminances, int xoffset, int yoffset, int threshold, int rowStride, BitMatrix& matrix)
+static void ThresholdBlock(const uint8_t* __restrict luminances, int xoffset, int yoffset, int threshold, int rowStride, BitMatrix& matrix)
 {
 	for (int y = yoffset; y < yoffset + BLOCK_SIZE; ++y) {
-		auto* src = luminances + y * rowStride + xoffset;
-		auto* const dstBegin = matrix.row(y).begin() + xoffset;
+		const uint8_t* __restrict src = luminances + y * rowStride + xoffset;
+		auto* __restrict dstBegin = matrix.row(y).begin() + xoffset;
 		// TODO: fix pixelStride > 1 case
-		for (auto* dst = dstBegin; dst < dstBegin + BLOCK_SIZE; ++dst, ++src)
-			*dst = (*src <= threshold) * BitMatrix::SET_V;
+		for (int i = 0; i < BLOCK_SIZE; ++i)
+			dstBegin[i] = (src[i] <= threshold) * BitMatrix::SET_V;
 	}
 }
 
@@ -114,7 +114,7 @@ static void ThresholdBlock(const uint8_t* luminances, int xoffset, int yoffset,
 * of the blocks around it. Also handles the corner cases (fractional blocks are computed based
 * on the last pixels in the row/column which are also used in the previous block).
 */
-static std::shared_ptr<BitMatrix> CalculateMatrix(const uint8_t* luminances, int subWidth, int subHeight, int width,
+static std::shared_ptr<BitMatrix> CalculateMatrix(const uint8_t* __restrict luminances, int subWidth, int subHeight, int width,
 												  int height, int rowStride, const Matrix<int>& blackPoints)
 {
 	auto matrix = std::make_shared<BitMatrix>(width, height);
@@ -142,7 +142,7 @@ static std::shared_ptr<BitMatrix> CalculateMatrix(const uint8_t* luminances, int
 std::shared_ptr<const BitMatrix> HybridBinarizer::getBlackMatrix() const
 {
 	if (width() >= MINIMUM_DIMENSION && height() >= MINIMUM_DIMENSION) {
-		const uint8_t* luminances = _buffer.data(0, 0);
+		const uint8_t* __restrict luminances = _buffer.data(0, 0);
 		int subWidth = (width() + BLOCK_SIZE - 1) / BLOCK_SIZE; // ceil(width/BS)
 		int subHeight = (height() + BLOCK_SIZE - 1) / BLOCK_SIZE; // ceil(height/BS)
 		auto blackPoints =
