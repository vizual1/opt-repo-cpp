diff --git a/include/svs/core/distance/cosine.h b/include/svs/core/distance/cosine.h
index c8e41e7..46238cc 100644
--- a/include/svs/core/distance/cosine.h
+++ b/include/svs/core/distance/cosine.h
@@ -164,7 +164,10 @@ float generic_cosine_similarity(
         accum += bi_float * bi_float;
         result += static_cast<float>(a[i]) * bi_float;
     }
-    return result / (a_norm * std::sqrt(accum));
+    // Compute reciprocal once to avoid multiple divisions and use float sqrt for performance
+    float norm_sqrt = std::sqrtf(accum);
+    float inv = 1.0f / (a_norm * norm_sqrt);
+    return result * inv;
 };
 
 template <size_t N, typename Ea, typename Eb> struct CosineSimilarityImpl {
diff --git a/include/svs/index/inverted/common.h b/include/svs/index/inverted/common.h
index 88c6625..95aa014 100644
--- a/include/svs/index/inverted/common.h
+++ b/include/svs/index/inverted/common.h
@@ -42,7 +42,9 @@ template <typename T> inline T bound_with(T nearest, T epsilon, svs::DistanceL2)
 template <typename T> inline T bound_with(T nearest, T epsilon, svs::DistanceIP) {
     // TODO: What do we do if the best match is simply bad?
     assert(nearest > 0.0f);
-    return nearest / (1 + epsilon);
+    // Compute reciprocal once and multiply to avoid a division.
+    T inv = static_cast<T>(1) / (static_cast<T>(1) + epsilon);
+    return nearest * inv;
 }
 
 } // namespace svs::index::inverted
