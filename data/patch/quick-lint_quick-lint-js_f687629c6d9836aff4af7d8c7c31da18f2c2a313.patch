diff --git a/src/lsp-location.cpp b/src/lsp-location.cpp
index cb4f54f5..db52319e 100644
--- a/src/lsp-location.cpp
+++ b/src/lsp-location.cpp
@@ -27,6 +27,29 @@ void insert_back_transform(InputIt input_begin, InputIt input_end,
   output_it = std::transform(input_begin, input_end, output_it, transformer);
   QLJS_ASSERT(output_it == output.end());
 }
+
+// Count the number of line terminators (\n or \r, treating CRLF as one)
+// in the range [begin, end). Used to pre-reserve vectors to avoid repeated
+// reallocations when computing offsets of lines.
+inline std::size_t count_line_terminators(const char8 *begin, const char8 *end) {
+  std::size_t count = 0;
+  for (const char8 *c = begin; c != end;) {
+    if (*c == u8'\r') {
+      ++count;
+      if (c + 1 != end && c[1] == u8'\n') {
+        c += 2;
+      } else {
+        c += 1;
+      }
+    } else if (*c == u8'\n') {
+      ++count;
+      c += 1;
+    } else {
+      c += 1;
+    }
+  }
+  return count;
+}
 }
 
 bool operator==(const lsp_position &lhs, const lsp_position &rhs) noexcept {
@@ -208,6 +231,13 @@ void lsp_locator::compute_offsets_of_lines(const char8 *begin, const char8 *end,
     flags = 0;
   };
 
+  // Reserve space for offsets/flags to avoid repeated reallocations. We count
+  // terminators and add one for the final line which may not end with a
+  // terminator.
+  std::size_t terminators = count_line_terminators(begin, end);
+  this->offset_of_lines_.reserve(this->offset_of_lines_.size() + terminators + 1);
+  this->line_is_ascii_.reserve(this->line_is_ascii_.size() + terminators + 1);
+
   for (const char8 *c = begin; c != end;) {
     flags |= static_cast<std::uint8_t>(*c);
     if (*c == u8'\n' || *c == u8'\r') {
