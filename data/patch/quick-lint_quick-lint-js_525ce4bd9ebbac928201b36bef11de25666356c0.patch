diff --git a/src/lex.cpp b/src/lex.cpp
index 430b4c34..6af5321e 100644
--- a/src/lex.cpp
+++ b/src/lex.cpp
@@ -1049,13 +1049,25 @@ next:
 }
 
 lexer_transaction lexer::begin_transaction() {
+  // If this is the outermost transaction, we must prepare the temporary
+  // allocator so it can be rewound later. Increment the transaction depth so
+  // nested transactions don't release or reset the temporary allocator.
+  std::optional<monotonic_allocator::rewind_state> maybe_rewind;
+  if (this->temporary_allocator_transaction_depth_ == 0) {
+    // Save the state so the outermost transaction can rewind the temporary
+    // allocator when it completes.
+    maybe_rewind = this->temporary_allocator_.prepare_for_rewind();
+  }
+  ++this->temporary_allocator_transaction_depth_;
+
   return lexer_transaction(
       /*old_last_token=*/this->last_token_,
       /*old_last_last_token_end=*/this->last_last_token_end_,
       /*old_input=*/this->input_,
       /*error_reporter_pointer=*/
       &this->error_reporter_,
-      /*memory=*/&this->temporary_allocator_);
+      /*memory=*/&this->temporary_allocator_,
+      /*maybe_temporary_allocator_rewind_state=*/std::move(maybe_rewind));
 }
 
 void lexer::commit_transaction(lexer_transaction&& transaction) {
@@ -1064,6 +1076,20 @@ void lexer::commit_transaction(lexer_transaction&& transaction) {
   buffered_errors->move_into(transaction.old_error_reporter);
 
   this->error_reporter_ = transaction.old_error_reporter;
+
+  // Decrement the transaction depth and, if this was the outermost
+  // transaction, release memory held by the temporary allocator by rewinding to
+  // its previous state.
+  QLJS_ASSERT(this->temporary_allocator_transaction_depth_ > 0);
+  --this->temporary_allocator_transaction_depth_;
+  if (this->temporary_allocator_transaction_depth_ == 0) {
+    if (transaction.temporary_allocator_rewind_state) {
+      this->temporary_allocator_.rewind(
+          std::move(*transaction.temporary_allocator_rewind_state));
+    } else {
+      this->temporary_allocator_.release();
+    }
+  }
 }
 
 void lexer::roll_back_transaction(lexer_transaction&& transaction) {
@@ -1071,6 +1097,20 @@ void lexer::roll_back_transaction(lexer_transaction&& transaction) {
   this->last_last_token_end_ = transaction.old_last_last_token_end;
   this->input_ = transaction.old_input;
   this->error_reporter_ = transaction.old_error_reporter;
+
+  // Decrement the transaction depth and, if this was the outermost
+  // transaction, release memory held by the temporary allocator by rewinding to
+  // its previous state.
+  QLJS_ASSERT(this->temporary_allocator_transaction_depth_ > 0);
+  --this->temporary_allocator_transaction_depth_;
+  if (this->temporary_allocator_transaction_depth_ == 0) {
+    if (transaction.temporary_allocator_rewind_state) {
+      this->temporary_allocator_.rewind(
+          std::move(*transaction.temporary_allocator_rewind_state));
+    } else {
+      this->temporary_allocator_.release();
+    }
+  }
 }
 
 bool lexer::transaction_has_lex_errors(const lexer_transaction&) const
diff --git a/src/quick-lint-js/lex.h b/src/quick-lint-js/lex.h
index ef985aab..48ca961d 100644
--- a/src/quick-lint-js/lex.h
+++ b/src/quick-lint-js/lex.h
@@ -5,10 +5,10 @@
 #define QUICK_LINT_JS_LEX_H
 
 #include <boost/container/pmr/memory_resource.hpp>
-#include <boost/container/pmr/unsynchronized_pool_resource.hpp>
 #include <cstddef>
 #include <cstdint>
 #include <optional>
+#include <utility>
 #include <quick-lint-js/buffering-error-reporter.h>
 #include <quick-lint-js/char8.h>
 #include <quick-lint-js/identifier.h>
@@ -296,7 +296,12 @@ class lexer {
   padded_string_view original_input_;
 
   monotonic_allocator allocator_;
-  boost::container::pmr::unsynchronized_pool_resource temporary_allocator_;
+  monotonic_allocator temporary_allocator_;
+
+  // The number of active lexer transactions. When this reaches zero we can
+  // release memory held by temporary_allocator_. This prevents peak memory from
+  // growing across nested transactions.
+  std::size_t temporary_allocator_transaction_depth_ = 0;
 };
 
 struct lexer_transaction {
@@ -306,13 +311,17 @@ struct lexer_transaction {
                              const char8* old_last_last_token_end,
                              const char8* old_input,
                              error_reporter** error_reporter_pointer,
-                             boost::container::pmr::memory_resource* memory)
+                             boost::container::pmr::memory_resource* memory,
+                             std::optional<monotonic_allocator::rewind_state>
+                                 maybe_temporary_allocator_rewind_state)
       : old_last_token(old_last_token),
         old_last_last_token_end(old_last_last_token_end),
         old_input(old_input),
         reporter(memory),
         old_error_reporter(
-            std::exchange(*error_reporter_pointer, &this->reporter)) {}
+            std::exchange(*error_reporter_pointer, &this->reporter)),
+        temporary_allocator_rewind_state(
+            std::move(maybe_temporary_allocator_rewind_state)) {}
 
   // Don't allow copying a transaction. lexer::error_reporter_ might point to
   // lexer_transaction::error_reporter.
@@ -324,6 +333,11 @@ struct lexer_transaction {
   const char8* old_input;
   buffering_error_reporter reporter;
   error_reporter* old_error_reporter;
+
+  // If set, this rewind_state should be used to rewind temporary_allocator_
+  // when the outermost transaction completes.
+  std::optional<monotonic_allocator::rewind_state>
+      temporary_allocator_rewind_state;
 };
 }
 
