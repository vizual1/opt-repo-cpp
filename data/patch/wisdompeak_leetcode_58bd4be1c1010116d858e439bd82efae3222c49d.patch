diff --git a/Bit_Manipulation/1774.Closest-Dessert-Cost/1774.Closest-Dessert-Cost.cpp b/Bit_Manipulation/1774.Closest-Dessert-Cost/1774.Closest-Dessert-Cost.cpp
index b8590d08..4cfc22cb 100644
--- a/Bit_Manipulation/1774.Closest-Dessert-Cost/1774.Closest-Dessert-Cost.cpp
+++ b/Bit_Manipulation/1774.Closest-Dessert-Cost/1774.Closest-Dessert-Cost.cpp
@@ -1,30 +1,55 @@
+#include <vector>
+#include <algorithm>
+#include <climits>
+#include <cstdlib>
+#include <functional>
+
+using namespace std;
+
 class Solution {
 public:
     int closestCost(vector<int>& baseCosts, vector<int>& toppingCosts, int target) 
     {
-        int cost;
-        int diff = INT_MAX;
         int m = toppingCosts.size();
-        
-        for (int baseCost: baseCosts)
-        {            
-            for (int state = 0; state < (1<<(2*m)); state++)
-            {
-                int sum = baseCost;
-                for (int i=0; i<m; i++)
-                {
-                    if ((state>>(i*2))&1)
-                        sum += toppingCosts[i];
-                    if ((state>>(i*2+1))&1)
-                        sum += toppingCosts[i];
+        vector<int> toppingSums;
+        toppingSums.reserve(1);
+
+        // generate all possible topping sums (each topping can be used 0,1,2 times)
+        function<void(int,int)> dfs = [&](int idx, int sum){
+            if (idx == m) {
+                toppingSums.push_back(sum);
+                return;
+            }
+            // 0 of this topping
+            dfs(idx+1, sum);
+            // 1 of this topping
+            dfs(idx+1, sum + toppingCosts[idx]);
+            // 2 of this topping
+            dfs(idx+1, sum + 2 * toppingCosts[idx]);
+        };
+        dfs(0, 0);
+
+        sort(toppingSums.begin(), toppingSums.end());
+        toppingSums.erase(unique(toppingSums.begin(), toppingSums.end()), toppingSums.end());
+
+        int best = INT_MAX;
+        int bestDiff = INT_MAX;
+
+        for (int base : baseCosts) {
+            int rem = target - base;
+            auto it = lower_bound(toppingSums.begin(), toppingSums.end(), rem);
+            auto consider = [&](int toppingSum){
+                int total = base + toppingSum;
+                int d = abs(total - target);
+                if (d < bestDiff || (d == bestDiff && total < best)) {
+                    bestDiff = d;
+                    best = total;
                 }
-                if (abs(sum-target)<diff || abs(sum-target)==diff && sum<cost)
-                {
-                    diff = abs(sum-target);
-                    cost = sum;
-                }
-            }            
-        }        
-        return cost;        
+            };
+            if (it != toppingSums.end()) consider(*it);
+            if (it != toppingSums.begin()) { --it; consider(*it); }
+        }
+
+        return best;
     }
 };
