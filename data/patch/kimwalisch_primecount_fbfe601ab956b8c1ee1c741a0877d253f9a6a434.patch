diff --git a/include/Sieve.hpp b/include/Sieve.hpp
index cae039c9..0c4aa603 100644
--- a/include/Sieve.hpp
+++ b/include/Sieve.hpp
@@ -145,11 +145,11 @@ public:
     uint64_t m1 = unset_smaller[start % 240];
     uint64_t m2 = unset_larger[stop % 240];
 
-    // Branchfree bitmask calculation:
-    // m1 = (start_idx != stop_idx) ? m1 : m1 & m2;
-    m1 = (m1 * (start_idx != stop_idx)) | ((m1 & m2) * (start_idx == stop_idx));
-    // m2 = (start_idx != stop_idx) ? m2 : 0;
-    m2 *= (start_idx != stop_idx);
+    // Branchfree bitmask calculation simplified using a mask
+    // mask = all 1s if start_idx == stop_idx else 0
+    uint64_t mask = -(uint64_t)(start_idx == stop_idx);
+    m1 = (m1 & ~mask) | ((m1 & m2) & mask);
+    m2 &= ~mask;
 
     const uint64_t* sieve64 = (const uint64_t*) sieve_.data();
     uint64_t start_bits = sieve64[start_idx] & m1;
@@ -226,11 +226,11 @@ public:
     uint64_t m1 = unset_smaller[start % 240];
     uint64_t m2 = unset_larger[stop % 240];
 
-    // Branchfree bitmask calculation:
-    // m1 = (start_idx != stop_idx) ? m1 : m1 & m2;
-    m1 = (m1 * (start_idx != stop_idx)) | ((m1 & m2) * (start_idx == stop_idx));
-    // m2 = (start_idx != stop_idx) ? m2 : 0;
-    m2 *= (start_idx != stop_idx);
+    // Branchfree bitmask calculation simplified using a mask
+    // mask = all 1s if start_idx == stop_idx else 0
+    uint64_t mask = -(uint64_t)(start_idx == stop_idx);
+    m1 = (m1 & ~mask) | ((m1 & m2) & mask);
+    m2 &= ~mask;
 
     const uint64_t* sieve64 = (const uint64_t*) sieve_.data();
     uint64_t start_bits = sieve64[start_idx] & m1;
@@ -305,11 +305,11 @@ private:
     uint64_t m1 = unset_smaller[start % 240];
     uint64_t m2 = unset_larger[stop % 240];
 
-    // Branchfree bitmask calculation:
-    // m1 = (start_idx != stop_idx) ? m1 : m1 & m2;
-    m1 = (m1 * (start_idx != stop_idx)) | ((m1 & m2) * (start_idx == stop_idx));
-    // m2 = (start_idx != stop_idx) ? m2 : 0;
-    m2 *= (start_idx != stop_idx);
+    // Branchfree bitmask calculation simplified using a mask
+    // mask = all 1s if start_idx == stop_idx else 0
+    uint64_t mask = -(uint64_t)(start_idx == stop_idx);
+    m1 = (m1 & ~mask) | ((m1 & m2) & mask);
+    m2 &= ~mask;
 
     const uint64_t* sieve64 = (const uint64_t*) sieve_.data();
     uint64_t start_bits = sieve64[start_idx] & m1;
diff --git a/src/Sieve.cpp b/src/Sieve.cpp
index 027ecacc..731dbec6 100644
--- a/src/Sieve.cpp
+++ b/src/Sieve.cpp
@@ -447,11 +447,11 @@ uint64_t Sieve::count_popcnt64(uint64_t start, uint64_t stop) const
   uint64_t m1 = unset_smaller[start % 240];
   uint64_t m2 = unset_larger[stop % 240];
 
-  // Branchfree bitmask calculation:
-  // m1 = (start_idx != stop_idx) ? m1 : m1 & m2;
-  m1 = (m1 * (start_idx != stop_idx)) | ((m1 & m2) * (start_idx == stop_idx));
-  // m2 = (start_idx != stop_idx) ? m2 : 0;
-  m2 *= (start_idx != stop_idx);
+  // Branchfree bitmask calculation simplified using a mask
+  // mask = all 1s if start_idx == stop_idx else 0
+  uint64_t mask = -(uint64_t)(start_idx == stop_idx);
+  m1 = (m1 & ~mask) | ((m1 & m2) & mask);
+  m2 &= ~mask;
 
   const uint64_t* sieve64 = (const uint64_t*) sieve_.data();
   uint64_t start_bits = sieve64[start_idx] & m1;
@@ -489,11 +489,11 @@ uint64_t Sieve::count_avx512(uint64_t start, uint64_t stop) const
   uint64_t m1 = unset_smaller[start % 240];
   uint64_t m2 = unset_larger[stop % 240];
 
-  // Branchfree bitmask calculation:
-  // m1 = (start_idx != stop_idx) ? m1 : m1 & m2;
-  m1 = (m1 * (start_idx != stop_idx)) | ((m1 & m2) * (start_idx == stop_idx));
-  // m2 = (start_idx != stop_idx) ? m2 : 0;
-  m2 *= (start_idx != stop_idx);
+  // Branchfree bitmask calculation simplified using a mask
+  // mask = all 1s if start_idx == stop_idx else 0
+  uint64_t mask = -(uint64_t)(start_idx == stop_idx);
+  m1 = (m1 & ~mask) | ((m1 & m2) & mask);
+  m2 &= ~mask;
 
   const uint64_t* sieve64 = (const uint64_t*) sieve_.data();
   uint64_t start_bits = sieve64[start_idx] & m1;
@@ -542,11 +542,11 @@ uint64_t Sieve::count_arm_sve(uint64_t start, uint64_t stop) const
   uint64_t m1 = unset_smaller[start % 240];
   uint64_t m2 = unset_larger[stop % 240];
 
-  // Branchfree bitmask calculation:
-  // m1 = (start_idx != stop_idx) ? m1 : m1 & m2;
-  m1 = (m1 * (start_idx != stop_idx)) | ((m1 & m2) * (start_idx == stop_idx));
-  // m2 = (start_idx != stop_idx) ? m2 : 0;
-  m2 *= (start_idx != stop_idx);
+  // Branchfree bitmask calculation simplified using a mask
+  // mask = all 1s if start_idx == stop_idx else 0
+  uint64_t mask = -(uint64_t)(start_idx == stop_idx);
+  m1 = (m1 & ~mask) | ((m1 & m2) & mask);
+  m2 &= ~mask;
 
   const uint64_t* sieve64 = (const uint64_t*) sieve_.data();
   uint64_t start_bits = sieve64[start_idx] & m1;
