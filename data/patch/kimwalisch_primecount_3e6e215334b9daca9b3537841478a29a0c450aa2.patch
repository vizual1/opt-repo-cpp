diff --git a/include/popcnt.hpp b/include/popcnt.hpp
index 22a24e68..9425cd27 100644
--- a/include/popcnt.hpp
+++ b/include/popcnt.hpp
@@ -55,7 +55,7 @@ ALWAYS_INLINE uint64_t popcnt64(uint64_t x)
 {
   // On my AMD EPYC 7642 CPU using GCC 12 this runtime
   // check incurs an overall overhead of about 1%.
-  if (cpu_supports_popcnt)
+  if_likely(cpu_supports_popcnt)
   {
     __asm__("popcnt %1, %0" : "=r"(x) : "r"(x));
     return x;
@@ -78,7 +78,7 @@ namespace {
 
 ALWAYS_INLINE uint64_t popcnt64(uint64_t x)
 {
-  if (cpu_supports_popcnt)
+  if_likely(cpu_supports_popcnt)
   {
     uint32_t x0 = uint32_t(x);
     uint32_t x1 = uint32_t(x >> 32);
@@ -135,7 +135,7 @@ ALWAYS_INLINE uint64_t popcnt64(uint64_t x)
 #if defined(HAS_POPCNT)
   return __popcnt64(x);
 #elif defined(ENABLE_CPUID_POPCNT)
-  if (cpu_supports_popcnt)
+  if_likely(cpu_supports_popcnt)
     return __popcnt64(x);
   else
     return popcnt64_bitwise(x);
@@ -160,7 +160,7 @@ ALWAYS_INLINE uint64_t popcnt64(uint64_t x)
   return __popcnt(uint32_t(x)) +
          __popcnt(uint32_t(x >> 32));
 #elif defined(ENABLE_CPUID_POPCNT)
-  if (cpu_supports_popcnt)
+  if_likely(cpu_supports_popcnt)
     return __popcnt(uint32_t(x)) +
            __popcnt(uint32_t(x >> 32));
   else
