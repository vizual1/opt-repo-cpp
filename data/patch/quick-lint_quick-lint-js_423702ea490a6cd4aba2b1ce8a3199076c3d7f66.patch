diff --git a/src/quick-lint-js/debug/debug-server.cpp b/src/quick-lint-js/debug/debug-server.cpp
index b475ea2e..80b91917 100644
--- a/src/quick-lint-js/debug/debug-server.cpp
+++ b/src/quick-lint-js/debug/debug-server.cpp
@@ -333,10 +333,19 @@ void write_vector_profiler_stats(byte_buffer &out_json) {
   out_json.append_copy(u8R"--({"maxSizeHistogramByOwner":{)--"_sv);
 
 #if QLJS_FEATURE_VECTOR_PROFILING
-  vector_max_size_histogram_by_owner max_size_histogram;
-  max_size_histogram.add_entries(vector_instrumentation::instance.entries());
+  // Keep a cached histogram and only add new entries since the last
+  // request. This avoids rebuilding the entire histogram for every HTTP
+  // request which can be expensive for long-running sessions.
+  static vector_max_size_histogram_by_owner cached_histogram;
+  // take_entries() is thread-safe and returns only new entries since the
+  // last call, clearing them from the global instrumentation.
+  std::vector<vector_instrumentation::entry> new_entries =
+      vector_instrumentation::instance.take_entries();
+  if (!new_entries.empty()) {
+    cached_histogram.add_entries(new_entries);
+  }
   bool need_comma = false;
-  for (auto &[owner, histogram] : max_size_histogram.histogram()) {
+  for (auto &[owner, histogram] : cached_histogram.histogram()) {
     if (need_comma) {
       out_json.append_copy(u8',');
     }
diff --git a/src/quick-lint-js/debug/debug-server.h b/src/quick-lint-js/debug/debug-server.h
index 04ca2217..ced99a7c 100644
--- a/src/quick-lint-js/debug/debug-server.h
+++ b/src/quick-lint-js/debug/debug-server.h
@@ -15,6 +15,8 @@
 #include <quick-lint-js/container/result.h>
 #include <quick-lint-js/port/thread.h>
 #include <string>
+#include <quick-lint-js/container/vector-profiler.h>
+
 
 namespace quick_lint_js {
 class trace_flusher;
