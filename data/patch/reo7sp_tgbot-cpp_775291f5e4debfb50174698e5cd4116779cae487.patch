diff --git a/include/tgbot/net/CurlHttpClient.h b/include/tgbot/net/CurlHttpClient.h
index 0f93937f..e89b6bf0 100644
--- a/include/tgbot/net/CurlHttpClient.h
+++ b/include/tgbot/net/CurlHttpClient.h
@@ -12,6 +12,9 @@
 
 #include <string>
 #include <vector>
+#include <unordered_map>
+#include <thread>
+#include <mutex>
 
 namespace TgBot {
 
@@ -41,6 +44,13 @@ public:
 
 private:
     const HttpParser _httpParser;
+
+    // Per-thread curl handles to allow connection reuse. Mutable so makeRequest can be const.
+    mutable std::unordered_map<std::thread::id, CURL*> curlHandles;
+    mutable std::mutex curlHandlesMutex;
+
+    // Get or create a CURL* handle for the current thread.
+    CURL* getOrCreateCurlHandle() const;
 };
 
 }
diff --git a/src/net/CurlHttpClient.cpp b/src/net/CurlHttpClient.cpp
index 02619a38..64fe8974 100644
--- a/src/net/CurlHttpClient.cpp
+++ b/src/net/CurlHttpClient.cpp
@@ -4,29 +4,67 @@
 
 #include <cstddef>
 #include <string>
+#include <mutex>
+#include <thread>
+#include <unordered_map>
 
 namespace TgBot {
 
 CurlHttpClient::CurlHttpClient() : _httpParser() {
     curlSettings = curl_easy_init();
-    
+
     curl_easy_setopt(curlSettings, CURLOPT_CONNECTTIMEOUT, 20);
     curl_easy_setopt(curlSettings, CURLOPT_TIMEOUT, _timeout);
 }
 
 CurlHttpClient::~CurlHttpClient() {
+    // Clean up per-thread handles
+    std::lock_guard<std::mutex> lock(curlHandlesMutex);
+    for (auto &p : curlHandles) {
+        if (p.second) {
+            curl_easy_cleanup(p.second);
+        }
+    }
+    curlHandles.clear();
+
     curl_easy_cleanup(curlSettings);
 }
 
+// Get or create a CURL* handle for the current thread.
+CURL* CurlHttpClient::getOrCreateCurlHandle() const {
+    std::thread::id tid = std::this_thread::get_id();
+    {
+        std::lock_guard<std::mutex> lock(curlHandlesMutex);
+        auto it = curlHandles.find(tid);
+        if (it != curlHandles.end()) {
+            return it->second;
+        }
+    }
+
+    // Create a new handle based on curlSettings
+    CURL* newHandle = curl_easy_duphandle(curlSettings);
+    // Keep redirects and timeouts from base settings; other per-request
+    // options will be set in makeRequest.
+    std::lock_guard<std::mutex> lock(curlHandlesMutex);
+    curlHandles[tid] = newHandle;
+    return newHandle;
+}
+
 static std::size_t curlWriteString(char* ptr, std::size_t size, std::size_t nmemb, void* userdata) {
     static_cast<std::string*>(userdata)->append(ptr, size * nmemb);
     return size * nmemb;
 }
 
 std::string CurlHttpClient::makeRequest(const Url& url, const std::vector<HttpReqArg>& args) const {
-    // Copy settings for each call because we change CURLOPT_URL and other stuff.
-    // This also protects multithreaded case.
-    auto curl = curl_easy_duphandle(curlSettings);
+    // Use per-thread handle to allow connection reuse and avoid repeated
+    // connect()/close() cycles.
+    CURL* curl = getOrCreateCurlHandle();
+
+    // We duplicate the handle here only for options that shouldn't persist
+    // across requests (like headers and MIME). But keep the main handle to
+    // preserve connection reuse.
+    // Note: curl_easy_duphandle may be used for thread-safety; here we rely
+    // on per-thread handles so dup is unnecessary.
 
     std::string u = url.protocol + "://" + url.host + url.path;
     if (args.empty()) {
@@ -34,15 +72,13 @@ std::string CurlHttpClient::makeRequest(const Url& url, const std::vector<HttpRe
     }
     curl_easy_setopt(curl, CURLOPT_URL, u.c_str());
 
-    // disable keep-alive
+    // enable keep-alive (remove Connection: close)
     struct curl_slist* headers = nullptr;
-    headers = curl_slist_append(headers, "Connection: close");
-    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
 
-    curl_mime* mime;
-    curl_mimepart* part;
-    mime = curl_mime_init(curl);
+    curl_mime* mime = nullptr;
+    curl_mimepart* part = nullptr;
     if (!args.empty()) {
+        mime = curl_mime_init(curl);
         for (const HttpReqArg& a : args) {
             part = curl_mime_addpart(mime);
 
@@ -54,6 +90,9 @@ std::string CurlHttpClient::makeRequest(const Url& url, const std::vector<HttpRe
             }
         }
         curl_easy_setopt(curl, CURLOPT_MIMEPOST, mime);
+    } else {
+        // Clear any previous MIME on the handle
+        curl_easy_setopt(curl, CURLOPT_MIMEPOST, nullptr);
     }
 
     std::string response;
@@ -64,9 +103,12 @@ std::string CurlHttpClient::makeRequest(const Url& url, const std::vector<HttpRe
     curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, errbuf);
 
     auto res = curl_easy_perform(curl);
-    curl_slist_free_all(headers);
-    curl_easy_cleanup(curl);
-    curl_mime_free(mime);
+    if (headers) curl_slist_free_all(headers);
+    if (mime) {
+        // Detach mime from the persistent handle before freeing it.
+        curl_easy_setopt(curl, CURLOPT_MIMEPOST, nullptr);
+        curl_mime_free(mime);
+    }
 
     // If the request did not complete correctly, show the error
     // information. If no detailed error information was written to errbuf
